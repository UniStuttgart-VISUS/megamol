#
# configure.ps1 [!output CURRENT_DATE]
#
# Copyright (C) 2011 by Christoph Müller. Alle Rechte vorbehalten.
# Copyright (C) 2007 by Visualisierungsinstitut der Universität Stuttgart.
# Alle Rechte vorbehalten.
# Copyright (C) 2007-2010 by Christoph Müller. Alle Rechte vorbehalten.
#
#
# THIS FILE HAS BEEN GENERATED BY THE [!output WIZARD_DIALOG_TITLE] WIZARD!
#

<#
.SYNOPSIS 
Creates a Visual Studio 2010 Property Sheet configuring the use of VISlib.

.DESCRIPTION
Todo

.PARAMETER TemplatePath
Specifies the path of the template file containing the framework of the 
property sheet. If no template file is specified (or cached), the script
will use a default template that inserts all VISLibs.

.PARAMETER DestinationPath
Specifies the path of the output file.

.PARAMETER Replacements
Specifies the default values for the marker replacements.

.PARAMETER CopyCacheFrom
Forces the script to load the default parameters from the cache of the 
given script location rather than of the current location.

.PARAMETER ClearCache
Clears all cached configuration values that are stored for the current script
location. This parameter is exclusive, i. e. if it is used, no other operations
will be performed.

.INPUTS
None. You cannot pipline objects to this script.

.OUTPUTS
None. This script does not generate any pipeline outputs.

.EXAMPLE
C:\PS> .\configure.ps1
#>

param([string] $TemplatePath[!if PROPS_TEMPLATE] = '[!output PROPS_TEMPLATE_FILENAME]'[!endif],
      [string] $DestinationPath,
      [hashtable] $Replacements = @{},
      [string] $CopyCacheFrom,
      [switch] $ClearCache
     )
     

# Absolute base path of the script settings in the registry.   
$RegistryBasePath = 'HKCU:\SOFTWARE\VISUS\configure.ps1'

# Relative registry path of the settings for the current invocation. This path
# is derived from the location of the script in the file system.
$RegistryInvocationName = (Split-Path(Resolve-Path $MyInvocation.MyCommand.Definition) -Parent) -replace '\\', '_'

# Absolute registry path of the invocation settings in the registry.
$RegistryInvocationPath = "$RegistryBasePath\$RegistryInvocationName"


################################################################################
# BEGIN OF UTILITY FUNCTION DEFINITIONS                                        #
################################################################################

# Sets the specified registry value to the specified value. If the value does
# not exist, it is created as the specified type.
function CreateOrSet-RegistryValue([string] $key, [string] $name, 
        [string] $value, [Microsoft.Win32.RegistryValueKind] $type) { 
    Get-ItemProperty -Path $key -Name $name -ErrorAction SilentlyContinue | Out-Null
    if ($?) {
        Set-ItemProperty -Path $key -Name $name -Value "$value"
    } else {
        New-ItemProperty -Path $key -Name $name -Value "$value" -type $type | Out-Null
    }
}


# Creates the registry cahce for the specified application key $key or for
# the application if $key is not set. If the specified path already exists,
# nothing is changed, i. e. existing values are not erased or re-created.
function Create-Registry-Cache([string] $key) {
    if ($key) {
        $path = "$RegistryBasePath\$key"
    } else {
        $path = "$RegistryBasePath"
    }
    
    if (-not (Test-Path $path)) {
        Write-Host "Creating cache store at `"$path`" ..."
        ni $path -force | Out-Null
        echo "$path\Replacements"
        ni "$path\Replacements" -force | Out-Null
    }
}    


# Recursively removes all settings for the specified application key $key or
# removes all settings of the script if $key is not set.
function Delete-Registry-Cache([string] $key) {
    if ($key) {
        $path = "$RegistryBasePath\$key"
    } else {
        $path = "$RegistryBasePath"
    }
    
    if (Test-Path $path) {
        Write-Host "Deleting `"$path`" ..."    
        Remove-Item $path -recurse
    }
}


################################################################################
# BEGIN OF MAIN SCRIPT BODY                                                    #
################################################################################

# If requested, clear the cache before doing anything and exit. Clearing the 
# cache is an exclusive operation.
if ($ClearCache) {
    Delete-Registry-Cache $RegistryInvocationName
    exit
}

# Set the registry to own path or to $CopyCacheFrom in case the user wants
# to copy the defaults.
if ($CopyCacheFrom) {
    $CopyCacheFrom = $CopyCacheFrom -replace '\\', '_'
    $RegPath = "$RegistryBasePath\$CopyCacheFrom"
    #echo "Copying cached values from `"$RegPath`"."
} else {
    $RegPath = $RegistryInvocationPath
}

# Get cached input values if (i) there are any in the registry and (ii) the
# respective variable is not set via the command line
Create-Registry-Cache $RegistryInvocationName
if (-not $TemplatePath) {
    $TemplatePath = (gp $RegPath -ErrorAction SilentlyContinue).TemplatePath
}
if (-not $DestinationPath) {
    $DestinationPath = (gp $RegPath -ErrorAction SilentlyContinue).DestinationPath
}
foreach ($r in (gi "$RegPath\Replacements" -ErrorAction SilentlyContinue).GetValueNames()) {
    $Replacements[$r] = (gp "$RegPath\Replacements").$r
}

# If we still do not have values from the parameters now, assign standard 
# values for all missing parameters.
if ($TemplatePath) {
    $Template = gc -Path $TemplatePath
} else {
    $Template = '<?xml version="1.0" encoding="Windows-1252"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup Label="UserMacros">
        <VISlibDir>###VISLIB###</VISlibDir>
    </PropertyGroup>
    <PropertyGroup>
        <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
    </PropertyGroup>
    <ItemDefinitionGroup>
        <ClCompile>
            <AdditionalIncludeDirectories>&quot;$(VISlibDir)\base\include&quot;[!if VISLIB_CLUSTER]; &quot;$(VISlibDir)\cluster\include&quot;[!endif][!if VISLIB_D3D]; &quot;$(VISlibDir)\d3d\include&quot;[!endif][!if VISLIB_GL]; &quot;$(VISlibDir)\gl\include&quot;[!endif][!if VISLIB_GRAPHICS]; &quot;$(VISlibDir)\graphics\include&quot;[!endif][!if VISLIB_MATH]; &quot;$(VISlibDir)\math\include&quot;[!endif][!if VISLIB_NET]; &quot;$(VISlibDir)\net\include&quot;[!endif][!if VISLIB_SYS]; &quot;$(VISlibDir)\sys\include&quot;[!endif]; %(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
        </ClCompile>
        <Link>
            <AdditionalDependencies>vislibbase$(BitsD).lib[!if VISLIB_CLUSTER]; vislibcluster$(BitsD).lib[!endif][!if VISLIB_D3D]; vislibd3d$(BitsD).lib[!endif][!if VISLIB_GL]; vislibgl$(BitsD).lib[!endif][!if VISLIB_GRAPHICS]; vislibgraphics$(BitsD).lib[!endif][!if VISLIB_MATH]; vislibmath$(BitsD).lib[!endif][!if VISLIB_NET]; vislibnet$(BitsD).lib[!endif][!if VISLIB_SYS]; vislibsys$(BitsD).lib[!endif]; [!output ADDITIONAL_LIBRARIES] %(AdditionalDependencies)</AdditionalDependencies>
            <AdditionalLibraryDirectories>$(VISlibDir)\lib; %(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
        </Link>
    </ItemDefinitionGroup>
    <ItemGroup>
        <BuildMacro Include="VISlibDir">
            <Value>$(VISlibDir)</Value>
        </BuildMacro>
    </ItemGroup>    
</Project>'
}
#echo $Template

if (-not $DestinationPath) {
    $DestinationPath = "[!output PROPS_FILENAME]"
}
if (-not $Replacements) {
    $Replacements = @{};
}

# Initialisation of VISlib loction from wizard.
if (-not ($Replacements.Contains('###VISLIB###'))) {
    $Replacements['###VISLIB###'] = '[!output VISLIB_DIR]';
}

# Get all markers from the template and add it to the replacement list if
# the list does not yet contain the respective key
[regex]::matches($Template, '###[^#]+###') | %{
    if (-not ($Replacements.ContainsKey($_.Value))) {
        $Replacements[$_.Value] = ""
    }
}

# Ask the user to fill all replacement entries.
$Keys = ($Replacements.Keys | sort)
foreach ($k in $Keys) {
    $d = $Replacements[$k]
    $n = $k -replace '###', ''
    $i = Read-Host -prompt "Specify path for $n [`"$d`"]"
    if ($i) {
        $Replacements[$k] = $i
    }
}

#echo $Replacements

# Create the property sheet
foreach ($r in $Replacements.Keys) {
    $Template = [regex]::Replace($Template, $r, $Replacements[$r]);
}

#echo $Template

# Write property sheet
#ni . -name [!output PROPS_FILENAME] -force -type "file" -value ($Template | out-string) >> $null 
ni -Path $DestinationPath -Force -Type "file" -Value ($Template | out-string) >> $null 


# Cache all inputs in the registry for this path.
CreateOrSet-RegistryValue $RegistryInvocationPath 'TemplatePath' $TemplatePath 'String'
CreateOrSet-RegistryValue $RegistryInvocationPath 'DestinationPath' $DestinationPath 'String'
foreach ($r in $Replacements.Keys) {
    CreateOrSet-RegistryValue "$RegistryInvocationPath\Replacements" $r $Replacements[$r] 'String'    
}