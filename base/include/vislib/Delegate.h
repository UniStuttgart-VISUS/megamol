/*
 * Delegate.h
 *
 * Copyright (C) 2006 - 2011 by Visualisierungsinstitut Universitaet Stuttgart. 
 * Alle Rechte vorbehalten.
 */

#ifndef VISLIB_DELEGATE_H_INCLUDED
#define VISLIB_DELEGATE_H_INCLUDED
#if (defined(_MSC_VER) && (_MSC_VER > 1000))
#pragma once
#endif /* (defined(_MSC_VER) && (_MSC_VER > 1000)) */
#if defined(_WIN32) && defined(_MANAGED)
#pragma managed(push, off)
#endif /* defined(_WIN32) && defined(_MANAGED) */

#include "vislib/assert.h"
#include "vislib/IllegalStateException.h"
#include "vislib/memutils.h"


/*
 * This file is generated by 'implementDelegate.pl'
 */


namespace vislib {


    /**
     * Class representing a single callback target, which can either be a
     * function (c or static member) or a member-object pair, both with an
     * optional context object (usually a pointer).
     *
     * The first template parameter specifies the return value.
     * The other template parameters define the parameter list of the
     * callback, while void is used to (implicitly) terminate the list.
     * The parameter list may only have a maximum of 10 elements.
     */
    template<class Rv = void, class P1 = void, class P2 = void, class P3 = void, class P4 = void, class P5 = void, class P6 = void, class P7 = void, class P8 = void, class P9 = void, class P10 = void>
    class Delegate {
    public:

        /**
         * Ctor
         */
        Delegate(void) : callee(NULL) {
            // intentionally empty
        }

        /**
         * Copy ctor
         *
         * @param src The object to clone from
         */
        Delegate(const Delegate& src) : callee(NULL) {
            (*this) = src;
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         */
        Delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10))
                : callee((funcPtr == NULL)
                    ? NULL
                    : new FunctionCallee(funcPtr)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        Delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, CT1), CT2 ctxt)
                : callee((funcPtr == NULL)
                    ? NULL
                    : new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10))
                : callee(new MethodCallee<C>(obj, methPtr)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, CT1), CT2 ctxt)
                : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
            // intentionally empty
        }

        /**
         * Dtor
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        ~Delegate(void) {
            SAFE_DELETE(this->callee);
        }

        /**
         * Answer whether the target for this delegate is set
         *
         * @return True if the target for this delegate is set
         */
        inline bool IsTargetSet(void) const {
            return this->callee != NULL;
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         */
        void Set(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10)) {
            SAFE_DELETE(this->callee);
            if (funcPtr != NULL) {
                this->callee = new FunctionCallee(funcPtr);
            }
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        void Set(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            if (funcPtr != NULL) {
                this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
            }
        }

        /**
         * Sets the target for this delegate
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10)) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodCallee<C>(obj, methPtr);
        }

        /**
         * Sets the target for this delegate
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
        }

        /**
         * Unsets the target for this delegate
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        void Unset(void) {
            SAFE_DELETE(this->callee);
        }

        /**
         * Calls the delegate's target
         *
         * Parameter and return value depend on the template arguments of the delegate
         */
        Rv operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10) {
            if (this->callee == NULL) {
                throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
            }
            return this->callee->Call(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        bool operator==(const Delegate& rhs) const {
            if (this->callee == NULL) {
                return (rhs.callee == NULL);
            }
            return this->callee->Equals(*rhs.callee);
        }

        /**
         * Assignment operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        Delegate& operator=(const Delegate& rhs) {
            SAFE_DELETE(this->callee);
            if (rhs.callee != NULL) {
                this->callee = rhs.callee->Clone();
            }
            return *this;
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         *
         * @return A reference to this object
         */
        Delegate& operator=(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10)) {
            this->Set(funcPtr);
            return *this;
        }

    private:

        /**
         * abstract base class for callee implementations
         */
        class AbstractCallee {
        public:

            /** Ctor */
            AbstractCallee(void) {
                // intentionally empty
            }

            /** Dtor */
            virtual ~AbstractCallee(void) {
                // intentionally empty
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10) = 0;

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) = 0;

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) = 0;

        };

        /**
         * Callee implementation for functions
         */
        class FunctionCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             */
            FunctionCallee(Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10)) : AbstractCallee(), func(func) {
                ASSERT(this->func != NULL);
            }

            /** Dtor */
            virtual ~FunctionCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10) {
                return this->func(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new FunctionCallee(this->func);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionCallee *r= dynamic_cast<const FunctionCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10);

        };

        /**
         * Callee implementation for functions with user data context
         */
        template<class CT1>
        class FunctionContextCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             * @param ctxt The user data context
             */
            FunctionContextCallee(Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, CT1), CT1 ctxt) : AbstractCallee(), func(func), ctxt(ctxt) {
                ASSERT(this->func != NULL);
            }

            /** Dtor */
            virtual ~FunctionContextCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10) {
                return this->func(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, this->ctxt);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new FunctionContextCallee<CT1>(this->func, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionContextCallee *r= dynamic_cast<const FunctionContextCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /**
         * Callee implementation for methods
         */
        template<class C>
        class MethodCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            MethodCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10)) : AbstractCallee(), obj(obj), meth(meth) {
                ASSERT(this->meth != NULL);
            }

            /** Dtor */
            virtual ~MethodCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10) {
                return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new MethodCallee<C>(this->obj, this->meth);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodCallee *r= dynamic_cast<const MethodCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10);

        };

        /**
         * Callee implementation for methods with user data context
         */
        template<class C, class CT1>
        class MethodContextCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param obj The object
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            MethodContextCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, CT1), CT1 ctxt) : AbstractCallee(), obj(obj), meth(meth), ctxt(ctxt) {
                ASSERT(this->meth != NULL);
            }

            /** Dtor */
            virtual ~MethodContextCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10) {
                return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, this->ctxt);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new MethodContextCallee<C, CT1>(this->obj, this->meth, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodContextCallee *r= dynamic_cast<const MethodContextCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /** The callee target */
        AbstractCallee *callee;

    };


    /**
     * Template specialication for delegate functions with 9 parameters
     */
    template<class Rv, class P1, class P2, class P3, class P4, class P5, class P6, class P7, class P8, class P9>
    class Delegate<Rv, P1, P2, P3, P4, P5, P6, P7, P8, P9, void> {
    public:

        /**
         * Ctor
         */
        Delegate(void) : callee(NULL) {
            // intentionally empty
        }

        /**
         * Copy ctor
         *
         * @param src The object to clone from
         */
        Delegate(const Delegate& src) : callee(NULL) {
            (*this) = src;
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         */
        Delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9))
                : callee((funcPtr == NULL)
                    ? NULL
                    : new FunctionCallee(funcPtr)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        Delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, CT1), CT2 ctxt)
                : callee((funcPtr == NULL)
                    ? NULL
                    : new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9))
                : callee(new MethodCallee<C>(obj, methPtr)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, CT1), CT2 ctxt)
                : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
            // intentionally empty
        }

        /**
         * Dtor
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        ~Delegate(void) {
            SAFE_DELETE(this->callee);
        }

        /**
         * Answer whether the target for this delegate is set
         *
         * @return True if the target for this delegate is set
         */
        inline bool IsTargetSet(void) const {
            return this->callee != NULL;
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         */
        void Set(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9)) {
            SAFE_DELETE(this->callee);
            if (funcPtr != NULL) {
                this->callee = new FunctionCallee(funcPtr);
            }
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        void Set(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            if (funcPtr != NULL) {
                this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
            }
        }

        /**
         * Sets the target for this delegate
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9)) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodCallee<C>(obj, methPtr);
        }

        /**
         * Sets the target for this delegate
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
        }

        /**
         * Unsets the target for this delegate
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        void Unset(void) {
            SAFE_DELETE(this->callee);
        }

        /**
         * Calls the delegate's target
         *
         * Parameter and return value depend on the template arguments of the delegate
         */
        Rv operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
            if (this->callee == NULL) {
                throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
            }
            return this->callee->Call(p1, p2, p3, p4, p5, p6, p7, p8, p9);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        bool operator==(const Delegate& rhs) const {
            if (this->callee == NULL) {
                return (rhs.callee == NULL);
            }
            return this->callee->Equals(*rhs.callee);
        }

        /**
         * Assignment operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        Delegate& operator=(const Delegate& rhs) {
            SAFE_DELETE(this->callee);
            if (rhs.callee != NULL) {
                this->callee = rhs.callee->Clone();
            }
            return *this;
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         *
         * @return A reference to this object
         */
        Delegate& operator=(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9)) {
            this->Set(funcPtr);
            return *this;
        }

    private:

        /**
         * abstract base class for callee implementations
         */
        class AbstractCallee {
        public:

            /** Ctor */
            AbstractCallee(void) {
                // intentionally empty
            }

            /** Dtor */
            virtual ~AbstractCallee(void) {
                // intentionally empty
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) = 0;

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) = 0;

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) = 0;

        };

        /**
         * Callee implementation for functions
         */
        class FunctionCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             */
            FunctionCallee(Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, P9)) : AbstractCallee(), func(func) {
                ASSERT(this->func != NULL);
            }

            /** Dtor */
            virtual ~FunctionCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
                return this->func(p1, p2, p3, p4, p5, p6, p7, p8, p9);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new FunctionCallee(this->func);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionCallee *r= dynamic_cast<const FunctionCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, P9);

        };

        /**
         * Callee implementation for functions with user data context
         */
        template<class CT1>
        class FunctionContextCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             * @param ctxt The user data context
             */
            FunctionContextCallee(Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, P9, CT1), CT1 ctxt) : AbstractCallee(), func(func), ctxt(ctxt) {
                ASSERT(this->func != NULL);
            }

            /** Dtor */
            virtual ~FunctionContextCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
                return this->func(p1, p2, p3, p4, p5, p6, p7, p8, p9, this->ctxt);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new FunctionContextCallee<CT1>(this->func, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionContextCallee *r= dynamic_cast<const FunctionContextCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, P9, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /**
         * Callee implementation for methods
         */
        template<class C>
        class MethodCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            MethodCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, P9)) : AbstractCallee(), obj(obj), meth(meth) {
                ASSERT(this->meth != NULL);
            }

            /** Dtor */
            virtual ~MethodCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
                return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, p7, p8, p9);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new MethodCallee<C>(this->obj, this->meth);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodCallee *r= dynamic_cast<const MethodCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, P9);

        };

        /**
         * Callee implementation for methods with user data context
         */
        template<class C, class CT1>
        class MethodContextCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param obj The object
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            MethodContextCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, P9, CT1), CT1 ctxt) : AbstractCallee(), obj(obj), meth(meth), ctxt(ctxt) {
                ASSERT(this->meth != NULL);
            }

            /** Dtor */
            virtual ~MethodContextCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
                return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, p7, p8, p9, this->ctxt);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new MethodContextCallee<C, CT1>(this->obj, this->meth, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodContextCallee *r= dynamic_cast<const MethodContextCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, P9, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /** The callee target */
        AbstractCallee *callee;

    };


    /**
     * Template specialication for delegate functions with 8 parameters
     */
    template<class Rv, class P1, class P2, class P3, class P4, class P5, class P6, class P7, class P8>
    class Delegate<Rv, P1, P2, P3, P4, P5, P6, P7, P8, void, void> {
    public:

        /**
         * Ctor
         */
        Delegate(void) : callee(NULL) {
            // intentionally empty
        }

        /**
         * Copy ctor
         *
         * @param src The object to clone from
         */
        Delegate(const Delegate& src) : callee(NULL) {
            (*this) = src;
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         */
        Delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8))
                : callee((funcPtr == NULL)
                    ? NULL
                    : new FunctionCallee(funcPtr)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        Delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, CT1), CT2 ctxt)
                : callee((funcPtr == NULL)
                    ? NULL
                    : new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8))
                : callee(new MethodCallee<C>(obj, methPtr)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8, CT1), CT2 ctxt)
                : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
            // intentionally empty
        }

        /**
         * Dtor
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        ~Delegate(void) {
            SAFE_DELETE(this->callee);
        }

        /**
         * Answer whether the target for this delegate is set
         *
         * @return True if the target for this delegate is set
         */
        inline bool IsTargetSet(void) const {
            return this->callee != NULL;
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         */
        void Set(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8)) {
            SAFE_DELETE(this->callee);
            if (funcPtr != NULL) {
                this->callee = new FunctionCallee(funcPtr);
            }
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        void Set(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            if (funcPtr != NULL) {
                this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
            }
        }

        /**
         * Sets the target for this delegate
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8)) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodCallee<C>(obj, methPtr);
        }

        /**
         * Sets the target for this delegate
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8, CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
        }

        /**
         * Unsets the target for this delegate
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        void Unset(void) {
            SAFE_DELETE(this->callee);
        }

        /**
         * Calls the delegate's target
         *
         * Parameter and return value depend on the template arguments of the delegate
         */
        Rv operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
            if (this->callee == NULL) {
                throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
            }
            return this->callee->Call(p1, p2, p3, p4, p5, p6, p7, p8);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        bool operator==(const Delegate& rhs) const {
            if (this->callee == NULL) {
                return (rhs.callee == NULL);
            }
            return this->callee->Equals(*rhs.callee);
        }

        /**
         * Assignment operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        Delegate& operator=(const Delegate& rhs) {
            SAFE_DELETE(this->callee);
            if (rhs.callee != NULL) {
                this->callee = rhs.callee->Clone();
            }
            return *this;
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         *
         * @return A reference to this object
         */
        Delegate& operator=(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8)) {
            this->Set(funcPtr);
            return *this;
        }

    private:

        /**
         * abstract base class for callee implementations
         */
        class AbstractCallee {
        public:

            /** Ctor */
            AbstractCallee(void) {
                // intentionally empty
            }

            /** Dtor */
            virtual ~AbstractCallee(void) {
                // intentionally empty
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) = 0;

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) = 0;

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) = 0;

        };

        /**
         * Callee implementation for functions
         */
        class FunctionCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             */
            FunctionCallee(Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8)) : AbstractCallee(), func(func) {
                ASSERT(this->func != NULL);
            }

            /** Dtor */
            virtual ~FunctionCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
                return this->func(p1, p2, p3, p4, p5, p6, p7, p8);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new FunctionCallee(this->func);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionCallee *r= dynamic_cast<const FunctionCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8);

        };

        /**
         * Callee implementation for functions with user data context
         */
        template<class CT1>
        class FunctionContextCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             * @param ctxt The user data context
             */
            FunctionContextCallee(Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, CT1), CT1 ctxt) : AbstractCallee(), func(func), ctxt(ctxt) {
                ASSERT(this->func != NULL);
            }

            /** Dtor */
            virtual ~FunctionContextCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
                return this->func(p1, p2, p3, p4, p5, p6, p7, p8, this->ctxt);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new FunctionContextCallee<CT1>(this->func, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionContextCallee *r= dynamic_cast<const FunctionContextCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /**
         * Callee implementation for methods
         */
        template<class C>
        class MethodCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            MethodCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8)) : AbstractCallee(), obj(obj), meth(meth) {
                ASSERT(this->meth != NULL);
            }

            /** Dtor */
            virtual ~MethodCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
                return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, p7, p8);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new MethodCallee<C>(this->obj, this->meth);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodCallee *r= dynamic_cast<const MethodCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8);

        };

        /**
         * Callee implementation for methods with user data context
         */
        template<class C, class CT1>
        class MethodContextCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param obj The object
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            MethodContextCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, CT1), CT1 ctxt) : AbstractCallee(), obj(obj), meth(meth), ctxt(ctxt) {
                ASSERT(this->meth != NULL);
            }

            /** Dtor */
            virtual ~MethodContextCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
                return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, p7, p8, this->ctxt);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new MethodContextCallee<C, CT1>(this->obj, this->meth, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodContextCallee *r= dynamic_cast<const MethodContextCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /** The callee target */
        AbstractCallee *callee;

    };


    /**
     * Template specialication for delegate functions with 7 parameters
     */
    template<class Rv, class P1, class P2, class P3, class P4, class P5, class P6, class P7>
    class Delegate<Rv, P1, P2, P3, P4, P5, P6, P7, void, void, void> {
    public:

        /**
         * Ctor
         */
        Delegate(void) : callee(NULL) {
            // intentionally empty
        }

        /**
         * Copy ctor
         *
         * @param src The object to clone from
         */
        Delegate(const Delegate& src) : callee(NULL) {
            (*this) = src;
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         */
        Delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7))
                : callee((funcPtr == NULL)
                    ? NULL
                    : new FunctionCallee(funcPtr)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        Delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, CT1), CT2 ctxt)
                : callee((funcPtr == NULL)
                    ? NULL
                    : new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7))
                : callee(new MethodCallee<C>(obj, methPtr)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, CT1), CT2 ctxt)
                : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
            // intentionally empty
        }

        /**
         * Dtor
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        ~Delegate(void) {
            SAFE_DELETE(this->callee);
        }

        /**
         * Answer whether the target for this delegate is set
         *
         * @return True if the target for this delegate is set
         */
        inline bool IsTargetSet(void) const {
            return this->callee != NULL;
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         */
        void Set(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7)) {
            SAFE_DELETE(this->callee);
            if (funcPtr != NULL) {
                this->callee = new FunctionCallee(funcPtr);
            }
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        void Set(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            if (funcPtr != NULL) {
                this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
            }
        }

        /**
         * Sets the target for this delegate
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7)) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodCallee<C>(obj, methPtr);
        }

        /**
         * Sets the target for this delegate
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
        }

        /**
         * Unsets the target for this delegate
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        void Unset(void) {
            SAFE_DELETE(this->callee);
        }

        /**
         * Calls the delegate's target
         *
         * Parameter and return value depend on the template arguments of the delegate
         */
        Rv operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
            if (this->callee == NULL) {
                throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
            }
            return this->callee->Call(p1, p2, p3, p4, p5, p6, p7);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        bool operator==(const Delegate& rhs) const {
            if (this->callee == NULL) {
                return (rhs.callee == NULL);
            }
            return this->callee->Equals(*rhs.callee);
        }

        /**
         * Assignment operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        Delegate& operator=(const Delegate& rhs) {
            SAFE_DELETE(this->callee);
            if (rhs.callee != NULL) {
                this->callee = rhs.callee->Clone();
            }
            return *this;
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         *
         * @return A reference to this object
         */
        Delegate& operator=(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7)) {
            this->Set(funcPtr);
            return *this;
        }

    private:

        /**
         * abstract base class for callee implementations
         */
        class AbstractCallee {
        public:

            /** Ctor */
            AbstractCallee(void) {
                // intentionally empty
            }

            /** Dtor */
            virtual ~AbstractCallee(void) {
                // intentionally empty
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) = 0;

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) = 0;

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) = 0;

        };

        /**
         * Callee implementation for functions
         */
        class FunctionCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             */
            FunctionCallee(Rv (*func)(P1, P2, P3, P4, P5, P6, P7)) : AbstractCallee(), func(func) {
                ASSERT(this->func != NULL);
            }

            /** Dtor */
            virtual ~FunctionCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
                return this->func(p1, p2, p3, p4, p5, p6, p7);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new FunctionCallee(this->func);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionCallee *r= dynamic_cast<const FunctionCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, P5, P6, P7);

        };

        /**
         * Callee implementation for functions with user data context
         */
        template<class CT1>
        class FunctionContextCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             * @param ctxt The user data context
             */
            FunctionContextCallee(Rv (*func)(P1, P2, P3, P4, P5, P6, P7, CT1), CT1 ctxt) : AbstractCallee(), func(func), ctxt(ctxt) {
                ASSERT(this->func != NULL);
            }

            /** Dtor */
            virtual ~FunctionContextCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
                return this->func(p1, p2, p3, p4, p5, p6, p7, this->ctxt);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new FunctionContextCallee<CT1>(this->func, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionContextCallee *r= dynamic_cast<const FunctionContextCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, P5, P6, P7, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /**
         * Callee implementation for methods
         */
        template<class C>
        class MethodCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            MethodCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7)) : AbstractCallee(), obj(obj), meth(meth) {
                ASSERT(this->meth != NULL);
            }

            /** Dtor */
            virtual ~MethodCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
                return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, p7);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new MethodCallee<C>(this->obj, this->meth);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodCallee *r= dynamic_cast<const MethodCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7);

        };

        /**
         * Callee implementation for methods with user data context
         */
        template<class C, class CT1>
        class MethodContextCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param obj The object
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            MethodContextCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, CT1), CT1 ctxt) : AbstractCallee(), obj(obj), meth(meth), ctxt(ctxt) {
                ASSERT(this->meth != NULL);
            }

            /** Dtor */
            virtual ~MethodContextCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
                return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, p7, this->ctxt);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new MethodContextCallee<C, CT1>(this->obj, this->meth, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodContextCallee *r= dynamic_cast<const MethodContextCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /** The callee target */
        AbstractCallee *callee;

    };


    /**
     * Template specialication for delegate functions with 6 parameters
     */
    template<class Rv, class P1, class P2, class P3, class P4, class P5, class P6>
    class Delegate<Rv, P1, P2, P3, P4, P5, P6, void, void, void, void> {
    public:

        /**
         * Ctor
         */
        Delegate(void) : callee(NULL) {
            // intentionally empty
        }

        /**
         * Copy ctor
         *
         * @param src The object to clone from
         */
        Delegate(const Delegate& src) : callee(NULL) {
            (*this) = src;
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         */
        Delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6))
                : callee((funcPtr == NULL)
                    ? NULL
                    : new FunctionCallee(funcPtr)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        Delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, CT1), CT2 ctxt)
                : callee((funcPtr == NULL)
                    ? NULL
                    : new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6))
                : callee(new MethodCallee<C>(obj, methPtr)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, CT1), CT2 ctxt)
                : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
            // intentionally empty
        }

        /**
         * Dtor
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        ~Delegate(void) {
            SAFE_DELETE(this->callee);
        }

        /**
         * Answer whether the target for this delegate is set
         *
         * @return True if the target for this delegate is set
         */
        inline bool IsTargetSet(void) const {
            return this->callee != NULL;
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         */
        void Set(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6)) {
            SAFE_DELETE(this->callee);
            if (funcPtr != NULL) {
                this->callee = new FunctionCallee(funcPtr);
            }
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        void Set(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            if (funcPtr != NULL) {
                this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
            }
        }

        /**
         * Sets the target for this delegate
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6)) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodCallee<C>(obj, methPtr);
        }

        /**
         * Sets the target for this delegate
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
        }

        /**
         * Unsets the target for this delegate
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        void Unset(void) {
            SAFE_DELETE(this->callee);
        }

        /**
         * Calls the delegate's target
         *
         * Parameter and return value depend on the template arguments of the delegate
         */
        Rv operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
            if (this->callee == NULL) {
                throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
            }
            return this->callee->Call(p1, p2, p3, p4, p5, p6);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        bool operator==(const Delegate& rhs) const {
            if (this->callee == NULL) {
                return (rhs.callee == NULL);
            }
            return this->callee->Equals(*rhs.callee);
        }

        /**
         * Assignment operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        Delegate& operator=(const Delegate& rhs) {
            SAFE_DELETE(this->callee);
            if (rhs.callee != NULL) {
                this->callee = rhs.callee->Clone();
            }
            return *this;
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         *
         * @return A reference to this object
         */
        Delegate& operator=(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6)) {
            this->Set(funcPtr);
            return *this;
        }

    private:

        /**
         * abstract base class for callee implementations
         */
        class AbstractCallee {
        public:

            /** Ctor */
            AbstractCallee(void) {
                // intentionally empty
            }

            /** Dtor */
            virtual ~AbstractCallee(void) {
                // intentionally empty
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) = 0;

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) = 0;

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) = 0;

        };

        /**
         * Callee implementation for functions
         */
        class FunctionCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             */
            FunctionCallee(Rv (*func)(P1, P2, P3, P4, P5, P6)) : AbstractCallee(), func(func) {
                ASSERT(this->func != NULL);
            }

            /** Dtor */
            virtual ~FunctionCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
                return this->func(p1, p2, p3, p4, p5, p6);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new FunctionCallee(this->func);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionCallee *r= dynamic_cast<const FunctionCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, P5, P6);

        };

        /**
         * Callee implementation for functions with user data context
         */
        template<class CT1>
        class FunctionContextCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             * @param ctxt The user data context
             */
            FunctionContextCallee(Rv (*func)(P1, P2, P3, P4, P5, P6, CT1), CT1 ctxt) : AbstractCallee(), func(func), ctxt(ctxt) {
                ASSERT(this->func != NULL);
            }

            /** Dtor */
            virtual ~FunctionContextCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
                return this->func(p1, p2, p3, p4, p5, p6, this->ctxt);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new FunctionContextCallee<CT1>(this->func, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionContextCallee *r= dynamic_cast<const FunctionContextCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, P5, P6, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /**
         * Callee implementation for methods
         */
        template<class C>
        class MethodCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            MethodCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6)) : AbstractCallee(), obj(obj), meth(meth) {
                ASSERT(this->meth != NULL);
            }

            /** Dtor */
            virtual ~MethodCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
                return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new MethodCallee<C>(this->obj, this->meth);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodCallee *r= dynamic_cast<const MethodCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, P5, P6);

        };

        /**
         * Callee implementation for methods with user data context
         */
        template<class C, class CT1>
        class MethodContextCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param obj The object
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            MethodContextCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, CT1), CT1 ctxt) : AbstractCallee(), obj(obj), meth(meth), ctxt(ctxt) {
                ASSERT(this->meth != NULL);
            }

            /** Dtor */
            virtual ~MethodContextCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
                return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, this->ctxt);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new MethodContextCallee<C, CT1>(this->obj, this->meth, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodContextCallee *r= dynamic_cast<const MethodContextCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, P5, P6, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /** The callee target */
        AbstractCallee *callee;

    };


    /**
     * Template specialication for delegate functions with 5 parameters
     */
    template<class Rv, class P1, class P2, class P3, class P4, class P5>
    class Delegate<Rv, P1, P2, P3, P4, P5, void, void, void, void, void> {
    public:

        /**
         * Ctor
         */
        Delegate(void) : callee(NULL) {
            // intentionally empty
        }

        /**
         * Copy ctor
         *
         * @param src The object to clone from
         */
        Delegate(const Delegate& src) : callee(NULL) {
            (*this) = src;
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         */
        Delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5))
                : callee((funcPtr == NULL)
                    ? NULL
                    : new FunctionCallee(funcPtr)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        Delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, CT1), CT2 ctxt)
                : callee((funcPtr == NULL)
                    ? NULL
                    : new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5))
                : callee(new MethodCallee<C>(obj, methPtr)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, CT1), CT2 ctxt)
                : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
            // intentionally empty
        }

        /**
         * Dtor
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        ~Delegate(void) {
            SAFE_DELETE(this->callee);
        }

        /**
         * Answer whether the target for this delegate is set
         *
         * @return True if the target for this delegate is set
         */
        inline bool IsTargetSet(void) const {
            return this->callee != NULL;
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         */
        void Set(Rv (*funcPtr)(P1, P2, P3, P4, P5)) {
            SAFE_DELETE(this->callee);
            if (funcPtr != NULL) {
                this->callee = new FunctionCallee(funcPtr);
            }
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        void Set(Rv (*funcPtr)(P1, P2, P3, P4, P5, CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            if (funcPtr != NULL) {
                this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
            }
        }

        /**
         * Sets the target for this delegate
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5)) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodCallee<C>(obj, methPtr);
        }

        /**
         * Sets the target for this delegate
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
        }

        /**
         * Unsets the target for this delegate
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        void Unset(void) {
            SAFE_DELETE(this->callee);
        }

        /**
         * Calls the delegate's target
         *
         * Parameter and return value depend on the template arguments of the delegate
         */
        Rv operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
            if (this->callee == NULL) {
                throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
            }
            return this->callee->Call(p1, p2, p3, p4, p5);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        bool operator==(const Delegate& rhs) const {
            if (this->callee == NULL) {
                return (rhs.callee == NULL);
            }
            return this->callee->Equals(*rhs.callee);
        }

        /**
         * Assignment operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        Delegate& operator=(const Delegate& rhs) {
            SAFE_DELETE(this->callee);
            if (rhs.callee != NULL) {
                this->callee = rhs.callee->Clone();
            }
            return *this;
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         *
         * @return A reference to this object
         */
        Delegate& operator=(Rv (*funcPtr)(P1, P2, P3, P4, P5)) {
            this->Set(funcPtr);
            return *this;
        }

    private:

        /**
         * abstract base class for callee implementations
         */
        class AbstractCallee {
        public:

            /** Ctor */
            AbstractCallee(void) {
                // intentionally empty
            }

            /** Dtor */
            virtual ~AbstractCallee(void) {
                // intentionally empty
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) = 0;

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) = 0;

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) = 0;

        };

        /**
         * Callee implementation for functions
         */
        class FunctionCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             */
            FunctionCallee(Rv (*func)(P1, P2, P3, P4, P5)) : AbstractCallee(), func(func) {
                ASSERT(this->func != NULL);
            }

            /** Dtor */
            virtual ~FunctionCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
                return this->func(p1, p2, p3, p4, p5);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new FunctionCallee(this->func);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionCallee *r= dynamic_cast<const FunctionCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, P5);

        };

        /**
         * Callee implementation for functions with user data context
         */
        template<class CT1>
        class FunctionContextCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             * @param ctxt The user data context
             */
            FunctionContextCallee(Rv (*func)(P1, P2, P3, P4, P5, CT1), CT1 ctxt) : AbstractCallee(), func(func), ctxt(ctxt) {
                ASSERT(this->func != NULL);
            }

            /** Dtor */
            virtual ~FunctionContextCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
                return this->func(p1, p2, p3, p4, p5, this->ctxt);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new FunctionContextCallee<CT1>(this->func, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionContextCallee *r= dynamic_cast<const FunctionContextCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, P5, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /**
         * Callee implementation for methods
         */
        template<class C>
        class MethodCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            MethodCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5)) : AbstractCallee(), obj(obj), meth(meth) {
                ASSERT(this->meth != NULL);
            }

            /** Dtor */
            virtual ~MethodCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
                return (this->obj.*this->meth)(p1, p2, p3, p4, p5);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new MethodCallee<C>(this->obj, this->meth);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodCallee *r= dynamic_cast<const MethodCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, P5);

        };

        /**
         * Callee implementation for methods with user data context
         */
        template<class C, class CT1>
        class MethodContextCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param obj The object
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            MethodContextCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, CT1), CT1 ctxt) : AbstractCallee(), obj(obj), meth(meth), ctxt(ctxt) {
                ASSERT(this->meth != NULL);
            }

            /** Dtor */
            virtual ~MethodContextCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
                return (this->obj.*this->meth)(p1, p2, p3, p4, p5, this->ctxt);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new MethodContextCallee<C, CT1>(this->obj, this->meth, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodContextCallee *r= dynamic_cast<const MethodContextCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, P5, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /** The callee target */
        AbstractCallee *callee;

    };


    /**
     * Template specialication for delegate functions with 4 parameters
     */
    template<class Rv, class P1, class P2, class P3, class P4>
    class Delegate<Rv, P1, P2, P3, P4, void, void, void, void, void, void> {
    public:

        /**
         * Ctor
         */
        Delegate(void) : callee(NULL) {
            // intentionally empty
        }

        /**
         * Copy ctor
         *
         * @param src The object to clone from
         */
        Delegate(const Delegate& src) : callee(NULL) {
            (*this) = src;
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         */
        Delegate(Rv (*funcPtr)(P1, P2, P3, P4))
                : callee((funcPtr == NULL)
                    ? NULL
                    : new FunctionCallee(funcPtr)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        Delegate(Rv (*funcPtr)(P1, P2, P3, P4, CT1), CT2 ctxt)
                : callee((funcPtr == NULL)
                    ? NULL
                    : new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4))
                : callee(new MethodCallee<C>(obj, methPtr)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, CT1), CT2 ctxt)
                : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
            // intentionally empty
        }

        /**
         * Dtor
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        ~Delegate(void) {
            SAFE_DELETE(this->callee);
        }

        /**
         * Answer whether the target for this delegate is set
         *
         * @return True if the target for this delegate is set
         */
        inline bool IsTargetSet(void) const {
            return this->callee != NULL;
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         */
        void Set(Rv (*funcPtr)(P1, P2, P3, P4)) {
            SAFE_DELETE(this->callee);
            if (funcPtr != NULL) {
                this->callee = new FunctionCallee(funcPtr);
            }
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        void Set(Rv (*funcPtr)(P1, P2, P3, P4, CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            if (funcPtr != NULL) {
                this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
            }
        }

        /**
         * Sets the target for this delegate
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4)) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodCallee<C>(obj, methPtr);
        }

        /**
         * Sets the target for this delegate
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
        }

        /**
         * Unsets the target for this delegate
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        void Unset(void) {
            SAFE_DELETE(this->callee);
        }

        /**
         * Calls the delegate's target
         *
         * Parameter and return value depend on the template arguments of the delegate
         */
        Rv operator()(P1 p1, P2 p2, P3 p3, P4 p4) {
            if (this->callee == NULL) {
                throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
            }
            return this->callee->Call(p1, p2, p3, p4);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        bool operator==(const Delegate& rhs) const {
            if (this->callee == NULL) {
                return (rhs.callee == NULL);
            }
            return this->callee->Equals(*rhs.callee);
        }

        /**
         * Assignment operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        Delegate& operator=(const Delegate& rhs) {
            SAFE_DELETE(this->callee);
            if (rhs.callee != NULL) {
                this->callee = rhs.callee->Clone();
            }
            return *this;
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         *
         * @return A reference to this object
         */
        Delegate& operator=(Rv (*funcPtr)(P1, P2, P3, P4)) {
            this->Set(funcPtr);
            return *this;
        }

    private:

        /**
         * abstract base class for callee implementations
         */
        class AbstractCallee {
        public:

            /** Ctor */
            AbstractCallee(void) {
                // intentionally empty
            }

            /** Dtor */
            virtual ~AbstractCallee(void) {
                // intentionally empty
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4) = 0;

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) = 0;

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) = 0;

        };

        /**
         * Callee implementation for functions
         */
        class FunctionCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             */
            FunctionCallee(Rv (*func)(P1, P2, P3, P4)) : AbstractCallee(), func(func) {
                ASSERT(this->func != NULL);
            }

            /** Dtor */
            virtual ~FunctionCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4) {
                return this->func(p1, p2, p3, p4);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new FunctionCallee(this->func);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionCallee *r= dynamic_cast<const FunctionCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4);

        };

        /**
         * Callee implementation for functions with user data context
         */
        template<class CT1>
        class FunctionContextCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             * @param ctxt The user data context
             */
            FunctionContextCallee(Rv (*func)(P1, P2, P3, P4, CT1), CT1 ctxt) : AbstractCallee(), func(func), ctxt(ctxt) {
                ASSERT(this->func != NULL);
            }

            /** Dtor */
            virtual ~FunctionContextCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4) {
                return this->func(p1, p2, p3, p4, this->ctxt);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new FunctionContextCallee<CT1>(this->func, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionContextCallee *r= dynamic_cast<const FunctionContextCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /**
         * Callee implementation for methods
         */
        template<class C>
        class MethodCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            MethodCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4)) : AbstractCallee(), obj(obj), meth(meth) {
                ASSERT(this->meth != NULL);
            }

            /** Dtor */
            virtual ~MethodCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4) {
                return (this->obj.*this->meth)(p1, p2, p3, p4);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new MethodCallee<C>(this->obj, this->meth);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodCallee *r= dynamic_cast<const MethodCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4);

        };

        /**
         * Callee implementation for methods with user data context
         */
        template<class C, class CT1>
        class MethodContextCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param obj The object
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            MethodContextCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, CT1), CT1 ctxt) : AbstractCallee(), obj(obj), meth(meth), ctxt(ctxt) {
                ASSERT(this->meth != NULL);
            }

            /** Dtor */
            virtual ~MethodContextCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4) {
                return (this->obj.*this->meth)(p1, p2, p3, p4, this->ctxt);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new MethodContextCallee<C, CT1>(this->obj, this->meth, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodContextCallee *r= dynamic_cast<const MethodContextCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /** The callee target */
        AbstractCallee *callee;

    };


    /**
     * Template specialication for delegate functions with 3 parameters
     */
    template<class Rv, class P1, class P2, class P3>
    class Delegate<Rv, P1, P2, P3, void, void, void, void, void, void, void> {
    public:

        /**
         * Ctor
         */
        Delegate(void) : callee(NULL) {
            // intentionally empty
        }

        /**
         * Copy ctor
         *
         * @param src The object to clone from
         */
        Delegate(const Delegate& src) : callee(NULL) {
            (*this) = src;
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         */
        Delegate(Rv (*funcPtr)(P1, P2, P3))
                : callee((funcPtr == NULL)
                    ? NULL
                    : new FunctionCallee(funcPtr)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        Delegate(Rv (*funcPtr)(P1, P2, P3, CT1), CT2 ctxt)
                : callee((funcPtr == NULL)
                    ? NULL
                    : new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3))
                : callee(new MethodCallee<C>(obj, methPtr)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, CT1), CT2 ctxt)
                : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
            // intentionally empty
        }

        /**
         * Dtor
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        ~Delegate(void) {
            SAFE_DELETE(this->callee);
        }

        /**
         * Answer whether the target for this delegate is set
         *
         * @return True if the target for this delegate is set
         */
        inline bool IsTargetSet(void) const {
            return this->callee != NULL;
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         */
        void Set(Rv (*funcPtr)(P1, P2, P3)) {
            SAFE_DELETE(this->callee);
            if (funcPtr != NULL) {
                this->callee = new FunctionCallee(funcPtr);
            }
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        void Set(Rv (*funcPtr)(P1, P2, P3, CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            if (funcPtr != NULL) {
                this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
            }
        }

        /**
         * Sets the target for this delegate
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3)) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodCallee<C>(obj, methPtr);
        }

        /**
         * Sets the target for this delegate
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
        }

        /**
         * Unsets the target for this delegate
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        void Unset(void) {
            SAFE_DELETE(this->callee);
        }

        /**
         * Calls the delegate's target
         *
         * Parameter and return value depend on the template arguments of the delegate
         */
        Rv operator()(P1 p1, P2 p2, P3 p3) {
            if (this->callee == NULL) {
                throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
            }
            return this->callee->Call(p1, p2, p3);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        bool operator==(const Delegate& rhs) const {
            if (this->callee == NULL) {
                return (rhs.callee == NULL);
            }
            return this->callee->Equals(*rhs.callee);
        }

        /**
         * Assignment operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        Delegate& operator=(const Delegate& rhs) {
            SAFE_DELETE(this->callee);
            if (rhs.callee != NULL) {
                this->callee = rhs.callee->Clone();
            }
            return *this;
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         *
         * @return A reference to this object
         */
        Delegate& operator=(Rv (*funcPtr)(P1, P2, P3)) {
            this->Set(funcPtr);
            return *this;
        }

    private:

        /**
         * abstract base class for callee implementations
         */
        class AbstractCallee {
        public:

            /** Ctor */
            AbstractCallee(void) {
                // intentionally empty
            }

            /** Dtor */
            virtual ~AbstractCallee(void) {
                // intentionally empty
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3) = 0;

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) = 0;

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) = 0;

        };

        /**
         * Callee implementation for functions
         */
        class FunctionCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             */
            FunctionCallee(Rv (*func)(P1, P2, P3)) : AbstractCallee(), func(func) {
                ASSERT(this->func != NULL);
            }

            /** Dtor */
            virtual ~FunctionCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3) {
                return this->func(p1, p2, p3);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new FunctionCallee(this->func);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionCallee *r= dynamic_cast<const FunctionCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3);

        };

        /**
         * Callee implementation for functions with user data context
         */
        template<class CT1>
        class FunctionContextCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             * @param ctxt The user data context
             */
            FunctionContextCallee(Rv (*func)(P1, P2, P3, CT1), CT1 ctxt) : AbstractCallee(), func(func), ctxt(ctxt) {
                ASSERT(this->func != NULL);
            }

            /** Dtor */
            virtual ~FunctionContextCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3) {
                return this->func(p1, p2, p3, this->ctxt);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new FunctionContextCallee<CT1>(this->func, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionContextCallee *r= dynamic_cast<const FunctionContextCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /**
         * Callee implementation for methods
         */
        template<class C>
        class MethodCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            MethodCallee(C& obj, Rv (C::*meth)(P1, P2, P3)) : AbstractCallee(), obj(obj), meth(meth) {
                ASSERT(this->meth != NULL);
            }

            /** Dtor */
            virtual ~MethodCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3) {
                return (this->obj.*this->meth)(p1, p2, p3);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new MethodCallee<C>(this->obj, this->meth);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodCallee *r= dynamic_cast<const MethodCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3);

        };

        /**
         * Callee implementation for methods with user data context
         */
        template<class C, class CT1>
        class MethodContextCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param obj The object
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            MethodContextCallee(C& obj, Rv (C::*meth)(P1, P2, P3, CT1), CT1 ctxt) : AbstractCallee(), obj(obj), meth(meth), ctxt(ctxt) {
                ASSERT(this->meth != NULL);
            }

            /** Dtor */
            virtual ~MethodContextCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2, P3 p3) {
                return (this->obj.*this->meth)(p1, p2, p3, this->ctxt);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new MethodContextCallee<C, CT1>(this->obj, this->meth, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodContextCallee *r= dynamic_cast<const MethodContextCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /** The callee target */
        AbstractCallee *callee;

    };


    /**
     * Template specialication for delegate functions with 2 parameters
     */
    template<class Rv, class P1, class P2>
    class Delegate<Rv, P1, P2, void, void, void, void, void, void, void, void> {
    public:

        /**
         * Ctor
         */
        Delegate(void) : callee(NULL) {
            // intentionally empty
        }

        /**
         * Copy ctor
         *
         * @param src The object to clone from
         */
        Delegate(const Delegate& src) : callee(NULL) {
            (*this) = src;
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         */
        Delegate(Rv (*funcPtr)(P1, P2))
                : callee((funcPtr == NULL)
                    ? NULL
                    : new FunctionCallee(funcPtr)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        Delegate(Rv (*funcPtr)(P1, P2, CT1), CT2 ctxt)
                : callee((funcPtr == NULL)
                    ? NULL
                    : new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        Delegate(C& obj, Rv (C::*methPtr)(P1, P2))
                : callee(new MethodCallee<C>(obj, methPtr)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        Delegate(C& obj, Rv (C::*methPtr)(P1, P2, CT1), CT2 ctxt)
                : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
            // intentionally empty
        }

        /**
         * Dtor
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        ~Delegate(void) {
            SAFE_DELETE(this->callee);
        }

        /**
         * Answer whether the target for this delegate is set
         *
         * @return True if the target for this delegate is set
         */
        inline bool IsTargetSet(void) const {
            return this->callee != NULL;
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         */
        void Set(Rv (*funcPtr)(P1, P2)) {
            SAFE_DELETE(this->callee);
            if (funcPtr != NULL) {
                this->callee = new FunctionCallee(funcPtr);
            }
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        void Set(Rv (*funcPtr)(P1, P2, CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            if (funcPtr != NULL) {
                this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
            }
        }

        /**
         * Sets the target for this delegate
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        void Set(C& obj, Rv (C::*methPtr)(P1, P2)) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodCallee<C>(obj, methPtr);
        }

        /**
         * Sets the target for this delegate
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        void Set(C& obj, Rv (C::*methPtr)(P1, P2, CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
        }

        /**
         * Unsets the target for this delegate
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        void Unset(void) {
            SAFE_DELETE(this->callee);
        }

        /**
         * Calls the delegate's target
         *
         * Parameter and return value depend on the template arguments of the delegate
         */
        Rv operator()(P1 p1, P2 p2) {
            if (this->callee == NULL) {
                throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
            }
            return this->callee->Call(p1, p2);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        bool operator==(const Delegate& rhs) const {
            if (this->callee == NULL) {
                return (rhs.callee == NULL);
            }
            return this->callee->Equals(*rhs.callee);
        }

        /**
         * Assignment operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        Delegate& operator=(const Delegate& rhs) {
            SAFE_DELETE(this->callee);
            if (rhs.callee != NULL) {
                this->callee = rhs.callee->Clone();
            }
            return *this;
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         *
         * @return A reference to this object
         */
        Delegate& operator=(Rv (*funcPtr)(P1, P2)) {
            this->Set(funcPtr);
            return *this;
        }

    private:

        /**
         * abstract base class for callee implementations
         */
        class AbstractCallee {
        public:

            /** Ctor */
            AbstractCallee(void) {
                // intentionally empty
            }

            /** Dtor */
            virtual ~AbstractCallee(void) {
                // intentionally empty
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2) = 0;

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) = 0;

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) = 0;

        };

        /**
         * Callee implementation for functions
         */
        class FunctionCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             */
            FunctionCallee(Rv (*func)(P1, P2)) : AbstractCallee(), func(func) {
                ASSERT(this->func != NULL);
            }

            /** Dtor */
            virtual ~FunctionCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2) {
                return this->func(p1, p2);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new FunctionCallee(this->func);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionCallee *r= dynamic_cast<const FunctionCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2);

        };

        /**
         * Callee implementation for functions with user data context
         */
        template<class CT1>
        class FunctionContextCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             * @param ctxt The user data context
             */
            FunctionContextCallee(Rv (*func)(P1, P2, CT1), CT1 ctxt) : AbstractCallee(), func(func), ctxt(ctxt) {
                ASSERT(this->func != NULL);
            }

            /** Dtor */
            virtual ~FunctionContextCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2) {
                return this->func(p1, p2, this->ctxt);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new FunctionContextCallee<CT1>(this->func, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionContextCallee *r= dynamic_cast<const FunctionContextCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /**
         * Callee implementation for methods
         */
        template<class C>
        class MethodCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            MethodCallee(C& obj, Rv (C::*meth)(P1, P2)) : AbstractCallee(), obj(obj), meth(meth) {
                ASSERT(this->meth != NULL);
            }

            /** Dtor */
            virtual ~MethodCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2) {
                return (this->obj.*this->meth)(p1, p2);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new MethodCallee<C>(this->obj, this->meth);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodCallee *r= dynamic_cast<const MethodCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2);

        };

        /**
         * Callee implementation for methods with user data context
         */
        template<class C, class CT1>
        class MethodContextCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param obj The object
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            MethodContextCallee(C& obj, Rv (C::*meth)(P1, P2, CT1), CT1 ctxt) : AbstractCallee(), obj(obj), meth(meth), ctxt(ctxt) {
                ASSERT(this->meth != NULL);
            }

            /** Dtor */
            virtual ~MethodContextCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1, P2 p2) {
                return (this->obj.*this->meth)(p1, p2, this->ctxt);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new MethodContextCallee<C, CT1>(this->obj, this->meth, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodContextCallee *r= dynamic_cast<const MethodContextCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /** The callee target */
        AbstractCallee *callee;

    };


    /**
     * Template specialication for delegate functions with 1 parameters
     */
    template<class Rv, class P1>
    class Delegate<Rv, P1, void, void, void, void, void, void, void, void, void> {
    public:

        /**
         * Ctor
         */
        Delegate(void) : callee(NULL) {
            // intentionally empty
        }

        /**
         * Copy ctor
         *
         * @param src The object to clone from
         */
        Delegate(const Delegate& src) : callee(NULL) {
            (*this) = src;
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         */
        Delegate(Rv (*funcPtr)(P1))
                : callee((funcPtr == NULL)
                    ? NULL
                    : new FunctionCallee(funcPtr)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        Delegate(Rv (*funcPtr)(P1, CT1), CT2 ctxt)
                : callee((funcPtr == NULL)
                    ? NULL
                    : new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        Delegate(C& obj, Rv (C::*methPtr)(P1))
                : callee(new MethodCallee<C>(obj, methPtr)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        Delegate(C& obj, Rv (C::*methPtr)(P1, CT1), CT2 ctxt)
                : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
            // intentionally empty
        }

        /**
         * Dtor
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        ~Delegate(void) {
            SAFE_DELETE(this->callee);
        }

        /**
         * Answer whether the target for this delegate is set
         *
         * @return True if the target for this delegate is set
         */
        inline bool IsTargetSet(void) const {
            return this->callee != NULL;
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         */
        void Set(Rv (*funcPtr)(P1)) {
            SAFE_DELETE(this->callee);
            if (funcPtr != NULL) {
                this->callee = new FunctionCallee(funcPtr);
            }
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        void Set(Rv (*funcPtr)(P1, CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            if (funcPtr != NULL) {
                this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
            }
        }

        /**
         * Sets the target for this delegate
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        void Set(C& obj, Rv (C::*methPtr)(P1)) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodCallee<C>(obj, methPtr);
        }

        /**
         * Sets the target for this delegate
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        void Set(C& obj, Rv (C::*methPtr)(P1, CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
        }

        /**
         * Unsets the target for this delegate
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        void Unset(void) {
            SAFE_DELETE(this->callee);
        }

        /**
         * Calls the delegate's target
         *
         * Parameter and return value depend on the template arguments of the delegate
         */
        Rv operator()(P1 p1) {
            if (this->callee == NULL) {
                throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
            }
            return this->callee->Call(p1);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        bool operator==(const Delegate& rhs) const {
            if (this->callee == NULL) {
                return (rhs.callee == NULL);
            }
            return this->callee->Equals(*rhs.callee);
        }

        /**
         * Assignment operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        Delegate& operator=(const Delegate& rhs) {
            SAFE_DELETE(this->callee);
            if (rhs.callee != NULL) {
                this->callee = rhs.callee->Clone();
            }
            return *this;
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         *
         * @return A reference to this object
         */
        Delegate& operator=(Rv (*funcPtr)(P1)) {
            this->Set(funcPtr);
            return *this;
        }

    private:

        /**
         * abstract base class for callee implementations
         */
        class AbstractCallee {
        public:

            /** Ctor */
            AbstractCallee(void) {
                // intentionally empty
            }

            /** Dtor */
            virtual ~AbstractCallee(void) {
                // intentionally empty
            }

            /** Call */
            virtual Rv Call(P1 p1) = 0;

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) = 0;

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) = 0;

        };

        /**
         * Callee implementation for functions
         */
        class FunctionCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             */
            FunctionCallee(Rv (*func)(P1)) : AbstractCallee(), func(func) {
                ASSERT(this->func != NULL);
            }

            /** Dtor */
            virtual ~FunctionCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1) {
                return this->func(p1);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new FunctionCallee(this->func);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionCallee *r= dynamic_cast<const FunctionCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1);

        };

        /**
         * Callee implementation for functions with user data context
         */
        template<class CT1>
        class FunctionContextCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             * @param ctxt The user data context
             */
            FunctionContextCallee(Rv (*func)(P1, CT1), CT1 ctxt) : AbstractCallee(), func(func), ctxt(ctxt) {
                ASSERT(this->func != NULL);
            }

            /** Dtor */
            virtual ~FunctionContextCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1) {
                return this->func(p1, this->ctxt);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new FunctionContextCallee<CT1>(this->func, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionContextCallee *r= dynamic_cast<const FunctionContextCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /**
         * Callee implementation for methods
         */
        template<class C>
        class MethodCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            MethodCallee(C& obj, Rv (C::*meth)(P1)) : AbstractCallee(), obj(obj), meth(meth) {
                ASSERT(this->meth != NULL);
            }

            /** Dtor */
            virtual ~MethodCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1) {
                return (this->obj.*this->meth)(p1);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new MethodCallee<C>(this->obj, this->meth);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodCallee *r= dynamic_cast<const MethodCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1);

        };

        /**
         * Callee implementation for methods with user data context
         */
        template<class C, class CT1>
        class MethodContextCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param obj The object
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            MethodContextCallee(C& obj, Rv (C::*meth)(P1, CT1), CT1 ctxt) : AbstractCallee(), obj(obj), meth(meth), ctxt(ctxt) {
                ASSERT(this->meth != NULL);
            }

            /** Dtor */
            virtual ~MethodContextCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(P1 p1) {
                return (this->obj.*this->meth)(p1, this->ctxt);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new MethodContextCallee<C, CT1>(this->obj, this->meth, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodContextCallee *r= dynamic_cast<const MethodContextCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /** The callee target */
        AbstractCallee *callee;

    };


    /**
     * Template specialication for delegate functions with 0 parameters
     */
    template<class Rv>
    class Delegate<Rv, void, void, void, void, void, void, void, void, void, void> {
    public:

        /**
         * Ctor
         */
        Delegate(void) : callee(NULL) {
            // intentionally empty
        }

        /**
         * Copy ctor
         *
         * @param src The object to clone from
         */
        Delegate(const Delegate& src) : callee(NULL) {
            (*this) = src;
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         */
        Delegate(Rv (*funcPtr)(void))
                : callee((funcPtr == NULL)
                    ? NULL
                    : new FunctionCallee(funcPtr)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        Delegate(Rv (*funcPtr)(CT1), CT2 ctxt)
                : callee((funcPtr == NULL)
                    ? NULL
                    : new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        Delegate(C& obj, Rv (C::*methPtr)(void))
                : callee(new MethodCallee<C>(obj, methPtr)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        Delegate(C& obj, Rv (C::*methPtr)(CT1), CT2 ctxt)
                : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
            // intentionally empty
        }

        /**
         * Dtor
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        ~Delegate(void) {
            SAFE_DELETE(this->callee);
        }

        /**
         * Answer whether the target for this delegate is set
         *
         * @return True if the target for this delegate is set
         */
        inline bool IsTargetSet(void) const {
            return this->callee != NULL;
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         */
        void Set(Rv (*funcPtr)(void)) {
            SAFE_DELETE(this->callee);
            if (funcPtr != NULL) {
                this->callee = new FunctionCallee(funcPtr);
            }
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        void Set(Rv (*funcPtr)(CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            if (funcPtr != NULL) {
                this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
            }
        }

        /**
         * Sets the target for this delegate
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        void Set(C& obj, Rv (C::*methPtr)(void)) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodCallee<C>(obj, methPtr);
        }

        /**
         * Sets the target for this delegate
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        void Set(C& obj, Rv (C::*methPtr)(CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
        }

        /**
         * Unsets the target for this delegate
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        void Unset(void) {
            SAFE_DELETE(this->callee);
        }

        /**
         * Calls the delegate's target
         *
         * Parameter and return value depend on the template arguments of the delegate
         */
        Rv operator()(void) {
            if (this->callee == NULL) {
                throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
            }
            return this->callee->Call();
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        bool operator==(const Delegate& rhs) const {
            if (this->callee == NULL) {
                return (rhs.callee == NULL);
            }
            return this->callee->Equals(*rhs.callee);
        }

        /**
         * Assignment operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        Delegate& operator=(const Delegate& rhs) {
            SAFE_DELETE(this->callee);
            if (rhs.callee != NULL) {
                this->callee = rhs.callee->Clone();
            }
            return *this;
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         *
         * @return A reference to this object
         */
        Delegate& operator=(Rv (*funcPtr)(void)) {
            this->Set(funcPtr);
            return *this;
        }

    private:

        /**
         * abstract base class for callee implementations
         */
        class AbstractCallee {
        public:

            /** Ctor */
            AbstractCallee(void) {
                // intentionally empty
            }

            /** Dtor */
            virtual ~AbstractCallee(void) {
                // intentionally empty
            }

            /** Call */
            virtual Rv Call(void) = 0;

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) = 0;

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) = 0;

        };

        /**
         * Callee implementation for functions
         */
        class FunctionCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             */
            FunctionCallee(Rv (*func)(void)) : AbstractCallee(), func(func) {
                ASSERT(this->func != NULL);
            }

            /** Dtor */
            virtual ~FunctionCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(void) {
                return this->func();
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new FunctionCallee(this->func);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionCallee *r= dynamic_cast<const FunctionCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func);
            }

        private:

            /** The function pointer */
            Rv (*func)(void);

        };

        /**
         * Callee implementation for functions with user data context
         */
        template<class CT1>
        class FunctionContextCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             * @param ctxt The user data context
             */
            FunctionContextCallee(Rv (*func)(CT1), CT1 ctxt) : AbstractCallee(), func(func), ctxt(ctxt) {
                ASSERT(this->func != NULL);
            }

            /** Dtor */
            virtual ~FunctionContextCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(void) {
                return this->func(this->ctxt);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new FunctionContextCallee<CT1>(this->func, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionContextCallee *r= dynamic_cast<const FunctionContextCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The function pointer */
            Rv (*func)(CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /**
         * Callee implementation for methods
         */
        template<class C>
        class MethodCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            MethodCallee(C& obj, Rv (C::*meth)(void)) : AbstractCallee(), obj(obj), meth(meth) {
                ASSERT(this->meth != NULL);
            }

            /** Dtor */
            virtual ~MethodCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(void) {
                return (this->obj.*this->meth)();
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new MethodCallee<C>(this->obj, this->meth);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodCallee *r= dynamic_cast<const MethodCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(void);

        };

        /**
         * Callee implementation for methods with user data context
         */
        template<class C, class CT1>
        class MethodContextCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param obj The object
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            MethodContextCallee(C& obj, Rv (C::*meth)(CT1), CT1 ctxt) : AbstractCallee(), obj(obj), meth(meth), ctxt(ctxt) {
                ASSERT(this->meth != NULL);
            }

            /** Dtor */
            virtual ~MethodContextCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual Rv Call(void) {
                return (this->obj.*this->meth)(this->ctxt);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new MethodContextCallee<C, CT1>(this->obj, this->meth, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodContextCallee *r= dynamic_cast<const MethodContextCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /** The callee target */
        AbstractCallee *callee;

    };


    /**
     * Template specialication for delegate functions without parameters and
     * without return value.
     */
    template<>
    class Delegate<void, void, void, void, void, void, void, void, void, void, void> {
    public:

        /**
         * Ctor
         */
        Delegate(void) : callee(NULL) {
            // intentionally empty
        }

        /**
         * Copy ctor
         *
         * @param src The object to clone from
         */
        Delegate(const Delegate& src) : callee(NULL) {
            (*this) = src;
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         */
        Delegate(void (*funcPtr)(void))
                : callee((funcPtr == NULL)
                    ? NULL
                    : new FunctionCallee(funcPtr)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        Delegate(void (*funcPtr)(CT1), CT2 ctxt)
                : callee((funcPtr == NULL)
                    ? NULL
                    : new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        Delegate(C& obj, void (C::*methPtr)(void))
                : callee(new MethodCallee<C>(obj, methPtr)) {
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        Delegate(C& obj, void (C::*methPtr)(CT1), CT2 ctxt)
                : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
            // intentionally empty
        }

        /**
         * Dtor
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        ~Delegate(void) {
            SAFE_DELETE(this->callee);
        }

        /**
         * Answer whether the target for this delegate is set
         *
         * @return True if the target for this delegate is set
         */
        inline bool IsTargetSet(void) const {
            return this->callee != NULL;
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         */
        void Set(void (*funcPtr)(void)) {
            SAFE_DELETE(this->callee);
            if (funcPtr != NULL) {
                this->callee = new FunctionCallee(funcPtr);
            }
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        void Set(void (*funcPtr)(CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            if (funcPtr != NULL) {
                this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
            }
        }

        /**
         * Sets the target for this delegate
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        void Set(C& obj, void (C::*methPtr)(void)) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodCallee<C>(obj, methPtr);
        }

        /**
         * Sets the target for this delegate
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        void Set(C& obj, void (C::*methPtr)(CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
        }

        /**
         * Unsets the target for this delegate
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        void Unset(void) {
            SAFE_DELETE(this->callee);
        }

        /**
         * Calls the delegate's target
         *
         * Parameter and return value depend on the template arguments of the delegate
         */
        void operator()(void) {
            if (this->callee == NULL) {
                throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
            }
            this->callee->Call();
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        bool operator==(const Delegate& rhs) const {
            if (this->callee == NULL) {
                return (rhs.callee == NULL);
            }
            return this->callee->Equals(*rhs.callee);
        }

        /**
         * Assignment operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        Delegate& operator=(const Delegate& rhs) {
            SAFE_DELETE(this->callee);
            if (rhs.callee != NULL) {
                this->callee = rhs.callee->Clone();
            }
            return *this;
        }

        /**
         * Sets the target for this delegate
         *
         * @param funcPtr Function pointer to be set
         *
         * @return A reference to this object
         */
        Delegate& operator=(void (*funcPtr)(void)) {
            this->Set(funcPtr);
            return *this;
        }

    private:

        /**
         * abstract base class for callee implementations
         */
        class AbstractCallee {
        public:

            /** Ctor */
            AbstractCallee(void) {
                // intentionally empty
            }

            /** Dtor */
            virtual ~AbstractCallee(void) {
                // intentionally empty
            }

            /** Call */
            virtual void Call(void) = 0;

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) = 0;

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) = 0;

        };

        /**
         * Callee implementation for functions
         */
        class FunctionCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             */
            FunctionCallee(void (*func)(void)) : AbstractCallee(), func(func) {
                ASSERT(this->func != NULL);
            }

            /** Dtor */
            virtual ~FunctionCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual void Call(void) {
                this->func();
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new FunctionCallee(this->func);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionCallee *r= dynamic_cast<const FunctionCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func);
            }

        private:

            /** The function pointer */
            void (*func)(void);

        };

        /**
         * Callee implementation for functions with user data context
         */
        template<class CT1>
        class FunctionContextCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             * @param ctxt The user data context
             */
            FunctionContextCallee(void (*func)(CT1), CT1 ctxt) : AbstractCallee(), func(func), ctxt(ctxt) {
                ASSERT(this->func != NULL);
            }

            /** Dtor */
            virtual ~FunctionContextCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual void Call(void) {
                this->func(this->ctxt);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new FunctionContextCallee<CT1>(this->func, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionContextCallee *r= dynamic_cast<const FunctionContextCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The function pointer */
            void (*func)(CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /**
         * Callee implementation for methods
         */
        template<class C>
        class MethodCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            MethodCallee(C& obj, void (C::*meth)(void)) : AbstractCallee(), obj(obj), meth(meth) {
                ASSERT(this->meth != NULL);
            }

            /** Dtor */
            virtual ~MethodCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual void Call(void) {
                (this->obj.*this->meth)();
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new MethodCallee<C>(this->obj, this->meth);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodCallee *r= dynamic_cast<const MethodCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            void (C::*meth)(void);

        };

        /**
         * Callee implementation for methods with user data context
         */
        template<class C, class CT1>
        class MethodContextCallee : public AbstractCallee {
        public:

            /**
             * Ctor
             *
             * @param obj The object
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            MethodContextCallee(C& obj, void (C::*meth)(CT1), CT1 ctxt) : AbstractCallee(), obj(obj), meth(meth), ctxt(ctxt) {
                ASSERT(this->meth != NULL);
            }

            /** Dtor */
            virtual ~MethodContextCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }

            /** Call */
            virtual void Call(void) {
                (this->obj.*this->meth)(this->ctxt);
            }

            /**
             * Clones this object
             *
             * @return A clone
             */
            virtual AbstractCallee * Clone(void) {
                return new MethodContextCallee<C, CT1>(this->obj, this->meth, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodContextCallee *r= dynamic_cast<const MethodContextCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            void (C::*meth)(CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /** The callee target */
        AbstractCallee *callee;

    };

} /* end namespace vislib */

#if defined(_WIN32) && defined(_MANAGED)
#pragma managed(pop)
#endif /* defined(_WIN32) && defined(_MANAGED) */
#endif /* VISLIB_DELEGATE_H_INCLUDED */
