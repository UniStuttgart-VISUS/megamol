diff --git a/.gitignore b/.gitignore
index 842cfc9c4..af782591d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -27,4 +27,9 @@ utils/MMPLD/test*.mmpld
 utils/MMPLD/test*.lua
 utils/MMPLD/test*.png
 utils/MMPLD/SphereTest.bat
-examples/
\ No newline at end of file
+/.vs
+/astroschulz.mmprj
+examples/
+/astroschulz2.mmprj
+solution/**/*
+deploy/**/*
diff --git a/.travis.yml b/.travis.yml
index 0a89596ae..91af51694 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -18,6 +18,17 @@ matrix:
       env:
         - CC=gcc-7
         - CXX=g++-7
+    - os: linux
+      dist: xenial
+      addons:
+        apt:
+          sources:
+            - ubuntu-toolchain-r-test
+          packages:
+            - g++-9
+      env:
+        - CC=gcc-9
+        - CXX=g++-9
 
 before_install:
   - . travis/install-cuda-xenial.sh
@@ -33,7 +44,7 @@ before_install:
   - sudo apt-get install -y libcgal-qt5-dev
   - sudo apt-get install -y libcgal-dev
   - mkdir build && cd build
-  - cmake ../ -DCMAKE_CXX_FLAGS=-Wno-deprecated-declarations -DENABLE_CUDA=ON -DSUPPRESS_CUDA_WARNINGS=TRUE -DBUILD_PROTEIN_CUDA_PLUGIN=ON
+  - cmake ../ -DCMAKE_CXX_FLAGS=-w -DENABLE_CUDA=ON -DSUPPRESS_CUDA_WARNINGS=TRUE -DBUILD_PROTEIN_CUDA_PLUGIN=ON
 
 install:
   - make install
diff --git a/core/Shaders/arrow.btf b/core/Shaders/arrow.btf
index b0797e818..dd43413f4 100644
--- a/core/Shaders/arrow.btf
+++ b/core/Shaders/arrow.btf
@@ -78,7 +78,7 @@ void main(void) {
     vec3 fromPos = gl_Vertex.xyz + (dir * 0.5) * lengthScale;
     vec3 toPos = gl_Vertex.xyz - (dir * 0.5) * lengthScale;
 
-    inPos = vec4((fromPos + toPos) * vec3(0.5), 1.0);
+    inPos = vec4(gl_Vertex.xyz, 1.0);
 
     rad.y = rad.x * rad.x;
     //rad.z = 1.0; // half cylinder length
@@ -233,16 +233,18 @@ void main(void) {
 
     if (bitflag_test(flags, FLAG_SELECTED, FLAG_SELECTED)) {
         gl_FrontColor = vec4(1.0, 0.0, 0.0, 1.0);
-    } else {
     }
-    if (bitflag_test(flags, FLAG_FILTERED, FLAG_FILTERED)) {
-    } else {
+    
     gl_Position = vec4(
       (minP + maxP) * 0.5,
       0.5, 
       ( CYL_HALF_LEN < lengthFilter * 0.5) ? 0.0 : 1.0
       );
+    
+    if (bitflag_test(flags, FLAG_FILTERED, FLAG_FILTERED)) {
+        gl_Position.w = 0.0;
     }
+    
     maxP = (maxP - minP) * 0.5 * winHalf;
     gl_PointSize = max(maxP.x, maxP.y) + 0.5;
 
diff --git a/core/Shaders/phong.glsl b/core/Shaders/phong.glsl
new file mode 100644
index 000000000..ea634f22b
--- /dev/null
+++ b/core/Shaders/phong.glsl
@@ -0,0 +1,21 @@
+uniform float ka;
+uniform float kd;
+uniform float ks;
+uniform float shininess;
+
+uniform vec3 light;
+
+uniform vec3 ambient_col;
+uniform vec3 specular_col;
+uniform vec3 light_col;
+
+vec3 phong(vec3 color, vec3 normal, vec3 eye, vec3 light) {
+    eye = normalize(eye);
+    light = normalize(light);
+
+    vec3 ambient = ka * ambient_col * color;
+    vec3 diffuse = kd * light_col * color * max(0, dot(normal, light));
+    vec3 specular = ks * light_col * specular_col * pow(max(0, dot(normal, normalize(light + eye))), shininess);
+
+    return clamp(ambient + diffuse + specular, vec3(0), vec3(1));
+}
diff --git a/core/Shaders/sphere/simple_frag_mainstart.glsl b/core/Shaders/sphere/simple_frag_mainstart.glsl
index ce783e1c5..4eba60c74 100644
--- a/core/Shaders/sphere/simple_frag_mainstart.glsl
+++ b/core/Shaders/sphere/simple_frag_mainstart.glsl
@@ -1,7 +1,6 @@
-#extension GL_ARB_explicit_attrib_location : require   // glsl version 130
-#extension GL_ARB_conservative_depth       : require   // glsl version 130
-layout (depth_greater) out float gl_FragDepth; 
-
+#extension GL_ARB_explicit_attrib_location : require // glsl version 130
+//#extension GL_ARB_conservative_depth       : require   // glsl version 130
+// layout (depth_greater) out float gl_FragDepth;
 
 #ifdef BACKSIDE_ENABLED
 uniform float hitsideFlag;
@@ -19,6 +18,8 @@ uniform vec4 viewAttr;
 uniform mat4 MVPinv;
 uniform mat4 MVPtransp;
 
+uniform float outlinesize = 2.0;
+
 FLACH in vec4 objPos;
 FLACH in vec4 camPos;
 FLACH in vec4 lightPos;
@@ -87,13 +88,13 @@ void main(void) {
     vec3 sphereintersection = lambda * ray + camPos.xyz;    // intersection point
     vec3 normal = sphereintersection / rad;
 
-
+    float d, dist1, dist2;
     if (any(notEqual(clipDat.xyz, vec3(0, 0, 0)))) {
         vec3 planeNormal = normalize(clipDat.xyz);
         vec3 clipPlaneBase = planeNormal * clipDat.w;
-        float d = -dot(planeNormal, clipPlaneBase - objPos.xyz);
-        float dist1 = dot(sphereintersection, planeNormal) + d;
-        float dist2 = d;
+        d = -dot(planeNormal, clipPlaneBase - objPos.xyz);
+        dist1 = dot(sphereintersection, planeNormal) + d;
+        dist2 = d;
         float t = -(dot(planeNormal, camPos.xyz) + d) / dot(planeNormal, ray);
         vec3 planeintersect = camPos.xyz + t * ray;
         if (dist1 > 0.0) {
diff --git a/core/Shaders/sphere/simple_frag_out-nolighting.glsl b/core/Shaders/sphere/simple_frag_out-nolighting.glsl
new file mode 100644
index 000000000..0b1604656
--- /dev/null
+++ b/core/Shaders/sphere/simple_frag_out-nolighting.glsl
@@ -0,0 +1,3 @@
+    // phong lighting with directional light
+    //outColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color.rgb), color.a);
+    outColor = color;
diff --git a/core/Shaders/sphere/simple_frag_outline-cutout.glsl b/core/Shaders/sphere/simple_frag_outline-cutout.glsl
new file mode 100644
index 000000000..b4df5ac98
--- /dev/null
+++ b/core/Shaders/sphere/simple_frag_outline-cutout.glsl
@@ -0,0 +1,24 @@
+//float m_pi = 3.14159265358;
+//float wid = m_pi / 64;
+//float azimuth = atan(normal.y, normal.x);
+//azimuth = azimuth + m_pi; // scale up to range (0,2pi)
+//float inclination = acos(normal.z);
+//
+//bool throwaway = false;
+//float divisions = 8.0;
+//for (int i = 0; i < int(divisions + 0.5); i++) {
+//    float curazi = float(i) * (2.0 * m_pi / divisions);
+//    float nextazi = float(i + 1) * (2.0 * m_pi / divisions);
+//    if (azimuth > curazi + wid && azimuth < nextazi - wid) {
+//        throwaway = true;
+//    }
+//}
+//
+//float wf = 4.0f;
+//if (inclination < wf * wid || inclination > m_pi - wf * wid) throwaway = false;
+//if (inclination > (m_pi / 2.0) - wid && inclination < (m_pi / 2.0) + wid) throwaway = false;
+//
+//if (throwaway) discard;
+
+if (radicand > outlinesize) discard;
+// TODO make this independent of the sphere radius
\ No newline at end of file
diff --git a/core/Shaders/sphere_outline.btf b/core/Shaders/sphere_outline.btf
new file mode 100644
index 000000000..5e2bd9eb2
--- /dev/null
+++ b/core/Shaders/sphere_outline.btf
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?>
+<btf type="MegaMolGLSLShader" version="1.0" namespace="sphere_outline">
+    <include file="common"/>
+
+    <shader name="vertex">
+        <snippet type="version">130</snippet>
+        <snippet name="CommonDefines"    type="file">commondefines.glsl</snippet>
+        <snippet name="Attributes"       type="file">sphere/simple_vert_attributes.glsl</snippet>
+        <snippet name="MainStart"        type="file">sphere/simple_vert_mainstart.glsl</snippet>
+        <snippet name="PosTrans"         type="file">sphere/simple_vert_postrans.glsl</snippet>
+        <snippet name="ClippingPlane"    type="file">sphere/simple_vert_clipping.glsl</snippet>
+        <snippet name="SphereTouchPlane" type="file">sphere/simple_vert_spheretouchplane.glsl</snippet>
+        <snippet name="PosOutput"        type="file">sphere/simple_vert_posout.glsl</snippet>
+        <snippet name="MainEnd"          type="file">sphere/simple_vert_mainend.glsl</snippet>
+    </shader>
+
+    <shader name="fragment">
+        <snippet type="version">130</snippet>
+        <snippet name="CommonDefines"    type="file">commondefines.glsl</snippet>
+        <snippet name="MainStart"        type="file">sphere/simple_frag_mainstart.glsl</snippet>
+        <snippet name="OutlineCutout"    type="file">sphere/simple_frag_outline-cutout.glsl</snippet>
+        <snippet name="OutLighting"      type="file">sphere/simple_frag_out-nolighting.glsl</snippet>
+        <snippet name="OutDepth"         type="file">sphere/simple_frag_out-depth.glsl</snippet>
+        <snippet name="MainEnd"          type="file">sphere/simple_frag_mainend.glsl</snippet>
+
+        <snippet name="LightDirectional" type="file">lightdirectional.glsl</snippet>
+    </shader>
+
+</btf>
diff --git a/core/include/mmcore/moldyn/ArrowRenderer.h b/core/include/mmcore/moldyn/ArrowRenderer.h
index 4f29b040f..59e7c6f0b 100644
--- a/core/include/mmcore/moldyn/ArrowRenderer.h
+++ b/core/include/mmcore/moldyn/ArrowRenderer.h
@@ -100,6 +100,9 @@ namespace moldyn {
         /** The arrow shader */
         vislib::graphics::gl::GLSLShader arrowShader;
 
+        /** The call for a chained renderer */
+        CallerSlot getRenderSlot;
+
         /** The call for data */
         CallerSlot getDataSlot;
 
diff --git a/core/include/mmcore/moldyn/SphereOutlineRenderer.h b/core/include/mmcore/moldyn/SphereOutlineRenderer.h
index 73e24ea94..7646f54b0 100644
--- a/core/include/mmcore/moldyn/SphereOutlineRenderer.h
+++ b/core/include/mmcore/moldyn/SphereOutlineRenderer.h
@@ -1,7 +1,7 @@
 /*
  * SphereOutlineRenderer.h
  *
- * Copyright (C) 2009 by VISUS (Universitaet Stuttgart)
+ * Copyright (C) 2009 - 2019 by VISUS (Universitaet Stuttgart)
  * Alle Rechte vorbehalten.
  */
 
@@ -114,6 +114,9 @@ namespace moldyn {
         /** The distance of the additional outlines as angles in radians */
         param::ParamSlot multiOutLineDistSlot;
 
+        /** A user-defined scaling factor applied on the radius. */
+        param::ParamSlot paramScaling;
+
         /** The sphere quadric */
         void *sphereQuadric;
 
diff --git a/core/include/mmcore/moldyn/SphereRenderer.h b/core/include/mmcore/moldyn/SphereRenderer.h
index 4aba3db56..f1a584f7a 100644
--- a/core/include/mmcore/moldyn/SphereRenderer.h
+++ b/core/include/mmcore/moldyn/SphereRenderer.h
@@ -234,7 +234,8 @@ namespace moldyn {
             SSBO_STREAM       = 3,
             BUFFER_ARRAY      = 4,
             SPLAT             = 5,
-            AMBIENT_OCCLUSION = 6 
+            AMBIENT_OCCLUSION = 6,
+            OUTLINE = 7
         };
 
         typedef std::map <std::tuple<int, int, bool>, std::shared_ptr<GLSLShader> > shaderMap;
@@ -344,6 +345,8 @@ namespace moldyn {
         megamol::core::param::ParamSlot aoConeLengthSlot;
         // High precision textures slot
         megamol::core::param::ParamSlot useHPTexturesSlot;
+        // size of the outline
+        megamol::core::param::ParamSlot outlineSizeSlot;
 
 
         /*********************************************************************/
@@ -388,6 +391,7 @@ namespace moldyn {
         bool renderSplat(view::CallRender3D* cr3d, MultiParticleDataCall* mpdc);
         bool renderBufferArray(view::CallRender3D* cr3d, MultiParticleDataCall* mpdc);
         bool renderAmbientOcclusion(view::CallRender3D* cr3d, MultiParticleDataCall* mpdc);
+        bool renderOutline(view::CallRender3D* cr3d, MultiParticleDataCall* mpdc);
 
         /**
          * Set pointers to vertex and color buffers and corresponding shader variables.
diff --git a/core/include/mmcore/thecam/utility/types.h b/core/include/mmcore/thecam/utility/types.h
index 20dc49ccd..12479cd81 100644
--- a/core/include/mmcore/thecam/utility/types.h
+++ b/core/include/mmcore/thecam/utility/types.h
@@ -42,6 +42,7 @@
 #    pragma managed(push, off)
 #endif /* defined(_WIN32) && defined(_MANAGED) */
 
+#include "mmcore/api/MegaMolCore.std.h"
 #include "mmcore/thecam/utility/config.h"
 
 #if defined(THE_WINDOWS)
@@ -79,13 +80,13 @@ typedef int do_not_initialise_t;
  * A constant that can be passed to some methods (eg megamol::core::thecam::ring_buffer::pop)
  * for omitting return values.
  */
-extern const discard_return_t discard_return;
+extern const discard_return_t MEGAMOLCORE_API discard_return;
 
 /**
  * A constant that can be passed to some constructors (eg of
  * megamol::core::thecam::math::vector) for omitting initialisation.
  */
-extern const do_not_initialise_t do_not_initialise;
+extern const do_not_initialise_t MEGAMOLCORE_API do_not_initialise;
 
 } /* end namespace utility */
 } /* end namespace thecam */
diff --git a/core/include/mmcore/view/AbstractView.h b/core/include/mmcore/view/AbstractView.h
index a7538a37c..b03065dfd 100644
--- a/core/include/mmcore/view/AbstractView.h
+++ b/core/include/mmcore/view/AbstractView.h
@@ -180,6 +180,16 @@ public:
      */
     virtual bool OnRenderView(Call& call);
 
+
+    /** 
+     * Callback requesting the extents of this view
+     *
+     * @param call The calling call
+     *
+     * @return The return value
+     */
+    virtual bool GetExtents(Call& call);
+
     /**
      * Callback requesting a rendering of this view
      *
@@ -287,8 +297,6 @@ private:
      */
     bool onResetView(Call& call);
 
-	bool GetExtentsCallback(Call& call);
-
     bool OnKeyCallback(Call& call);
 
     bool OnCharCallback(Call& call);
diff --git a/core/include/mmcore/view/CallRenderView.h b/core/include/mmcore/view/CallRenderView.h
index 72420c0bc..1551726c5 100644
--- a/core/include/mmcore/view/CallRenderView.h
+++ b/core/include/mmcore/view/CallRenderView.h
@@ -55,6 +55,9 @@ namespace view {
 		/** Function index of 'render' */
         static const unsigned int CALL_RENDER = AbstractCallRender::FnRender;
 
+        /** Function index of 'getExtents' */
+        static const unsigned int CALL_EXTENTS = AbstractCallRender::FnGetExtents;
+
         /** Function index of 'freeze' */
         static const unsigned int CALL_FREEZE = 7;
 
diff --git a/core/include/mmcore/view/SplitView.h b/core/include/mmcore/view/SplitView.h
index 25409147d..ebbb55dcc 100644
--- a/core/include/mmcore/view/SplitView.h
+++ b/core/include/mmcore/view/SplitView.h
@@ -12,10 +12,11 @@
 #endif /* (defined(_MSC_VER) && (_MSC_VER > 1000)) */
 
 #include "mmcore/CallerSlot.h"
+#include "mmcore/param/ColorParam.h"
 #include "mmcore/param/ParamSlot.h"
 #include "mmcore/view/AbstractView.h"
 #include "mmcore/view/CallRenderView.h"
-
+#include "mmcore/view/TimeControl.h"
 #include "vislib/graphics/gl/FramebufferObject.h"
 
 namespace megamol {
@@ -166,6 +167,9 @@ protected:
      */
     void unpackMouseCoordinates(float& x, float& y) override;
 
+    /** Override of GetExtents */
+    virtual bool GetExtents(core::Call& call) override;
+
 private:
     /**
      * Answer the renderer 1 call
@@ -233,6 +237,15 @@ private:
     /** The splitter colour slot */
     param::ParamSlot splitColourSlot;
 
+    /** Slot enabling time synchronization */
+    param::ParamSlot enableTimeSyncSlot;
+
+    /** Option for forwarding mouse and keyboard events to both child views */
+    param::ParamSlot inputToBothSlot;
+
+    /** The parameter storage for time control */
+    TimeControl timeCtrl;
+
     /** The override call */
     CallRenderView* overrideCall;
 
@@ -246,7 +259,7 @@ private:
 
     vislib::graphics::gl::FramebufferObject fbo2;
 
-    int focus;
+	int focus;
 
     float mouseX;
 
diff --git a/core/include/mmcore/view/View2D.h b/core/include/mmcore/view/View2D.h
index de4d32768..b720035d0 100644
--- a/core/include/mmcore/view/View2D.h
+++ b/core/include/mmcore/view/View2D.h
@@ -129,6 +129,8 @@ namespace view {
          */
         virtual bool OnRenderView(Call& call);
 
+        virtual bool GetExtents(Call& call) override;
+
         /**
          * Freezes, updates, or unfreezes the view onto the scene (not the
          * rendering, but camera settings, timing, etc).
diff --git a/core/include/mmcore/view/View3D.h b/core/include/mmcore/view/View3D.h
index 609ef47d6..3ee4b0d7e 100644
--- a/core/include/mmcore/view/View3D.h
+++ b/core/include/mmcore/view/View3D.h
@@ -145,6 +145,8 @@ namespace view {
          */
         virtual bool OnRenderView(Call& call);
 
+        virtual bool GetExtents(Call & call) override;
+
         /**
          * Freezes, updates, or unfreezes the view onto the scene (not the
          * rendering, but camera settings, timing, etc).
diff --git a/core/src/moldyn/ArrowRenderer.cpp b/core/src/moldyn/ArrowRenderer.cpp
index 7dcbda4fd..5a4597eb3 100644
--- a/core/src/moldyn/ArrowRenderer.cpp
+++ b/core/src/moldyn/ArrowRenderer.cpp
@@ -6,16 +6,17 @@
  */
 
 #include "stdafx.h"
-#include "vislib/graphics/gl/IncludeAllGL.h"
 #include "mmcore/moldyn/ArrowRenderer.h"
-#include "mmcore/moldyn/MultiParticleDataCall.h"
 #include "mmcore/CoreInstance.h"
+#include "mmcore/FlagCall.h"
+#include "mmcore/moldyn/MultiParticleDataCall.h"
 #include "mmcore/param/FloatParam.h"
+#include "mmcore/utility/ScaledBoundingBoxes.h"
 #include "mmcore/view/CallClipPlane.h"
 #include "mmcore/view/CallGetTransferFunction.h"
 #include "mmcore/view/CallRender3D.h"
-#include "mmcore/FlagCall.h"
 #include "vislib/assert.h"
+#include "vislib/graphics/gl/IncludeAllGL.h"
 
 using namespace megamol::core;
 
@@ -23,13 +24,21 @@ using namespace megamol::core;
 /*
  * moldyn::ArrowRenderer::ArrowRenderer
  */
-moldyn::ArrowRenderer::ArrowRenderer(void) : Renderer3DModule(),
-        arrowShader(), getDataSlot("getdata", "Connects to the data source"),
-        getTFSlot("gettransferfunction", "Connects to the transfer function module"),
-        getFlagsSlot("getflags", "connects to a FlagStorage"),
-        //getClipPlaneSlot("getclipplane", "Connects to a clipping plane module"),
-        greyTF(0),
-        lengthScaleSlot("lengthScale", ""), lengthFilterSlot("lengthFilter", "Filters the arrows by length") {
+moldyn::ArrowRenderer::ArrowRenderer(void)
+    : Renderer3DModule()
+    , arrowShader()
+    , getRenderSlot("getrenderer", "Input renderer slot for chaining")
+    , getDataSlot("getdata", "Connects to the data source")
+    , getTFSlot("gettransferfunction", "Connects to the transfer function module")
+    , getFlagsSlot("getflags", "connects to a FlagStorage")
+    ,
+    // getClipPlaneSlot("getclipplane", "Connects to a clipping plane module"),
+    greyTF(0)
+    , lengthScaleSlot("lengthScale", "")
+    , lengthFilterSlot("lengthFilter", "Filters the arrows by length") {
+
+    this->getRenderSlot.SetCompatibleCall<view::CallRender3DDescription>();
+    this->MakeSlotAvailable(&this->getRenderSlot);
 
     this->getDataSlot.SetCompatibleCall<moldyn::MultiParticleDataCallDescription>();
     this->MakeSlotAvailable(&this->getDataSlot);
@@ -40,13 +49,13 @@ moldyn::ArrowRenderer::ArrowRenderer(void) : Renderer3DModule(),
     this->getFlagsSlot.SetCompatibleCall<FlagCallDescription>();
     this->MakeSlotAvailable(&this->getFlagsSlot);
 
-    //this->getClipPlaneSlot.SetCompatibleCall<view::CallClipPlaneDescription>();
-    //this->MakeSlotAvailable(&this->getClipPlaneSlot);
-    
+    // this->getClipPlaneSlot.SetCompatibleCall<view::CallClipPlaneDescription>();
+    // this->MakeSlotAvailable(&this->getClipPlaneSlot);
+
     this->lengthScaleSlot << new param::FloatParam(1.0f);
     this->MakeSlotAvailable(&this->lengthScaleSlot);
-    
-    this->lengthFilterSlot << new param::FloatParam( 0.0f, 0.0);
+
+    this->lengthFilterSlot << new param::FloatParam(0.0f, 0.0);
     this->MakeSlotAvailable(&this->lengthFilterSlot);
 }
 
@@ -54,9 +63,7 @@ moldyn::ArrowRenderer::ArrowRenderer(void) : Renderer3DModule(),
 /*
  * moldyn::ArrowRenderer::~ArrowRenderer
  */
-moldyn::ArrowRenderer::~ArrowRenderer(void) {
-    this->Release();
-}
+moldyn::ArrowRenderer::~ArrowRenderer(void) { this->Release(); }
 
 
 /*
@@ -78,32 +85,30 @@ bool moldyn::ArrowRenderer::create(void) {
 
     try {
         if (!this->arrowShader.Create(vert.Code(), vert.Count(), frag.Code(), frag.Count())) {
-            vislib::sys::Log::DefaultLog.WriteMsg(vislib::sys::Log::LEVEL_ERROR,
-                "Unable to compile arrow shader: Unknown error\n");
+            vislib::sys::Log::DefaultLog.WriteMsg(
+                vislib::sys::Log::LEVEL_ERROR, "Unable to compile arrow shader: Unknown error\n");
             return false;
         }
 
-    } catch(vislib::graphics::gl::AbstractOpenGLShader::CompileException ce) {
+    } catch (vislib::graphics::gl::AbstractOpenGLShader::CompileException ce) {
         vislib::sys::Log::DefaultLog.WriteMsg(vislib::sys::Log::LEVEL_ERROR,
-            "Unable to compile arrow shader (@%s): %s\n", 
-            vislib::graphics::gl::AbstractOpenGLShader::CompileException::CompileActionName(
-            ce.FailedAction()) ,ce.GetMsgA());
+            "Unable to compile arrow shader (@%s): %s\n",
+            vislib::graphics::gl::AbstractOpenGLShader::CompileException::CompileActionName(ce.FailedAction()),
+            ce.GetMsgA());
         return false;
-    } catch(vislib::Exception e) {
-        vislib::sys::Log::DefaultLog.WriteMsg(vislib::sys::Log::LEVEL_ERROR,
-            "Unable to compile arrow shader: %s\n", e.GetMsgA());
+    } catch (vislib::Exception e) {
+        vislib::sys::Log::DefaultLog.WriteMsg(
+            vislib::sys::Log::LEVEL_ERROR, "Unable to compile arrow shader: %s\n", e.GetMsgA());
         return false;
-    } catch(...) {
-        vislib::sys::Log::DefaultLog.WriteMsg(vislib::sys::Log::LEVEL_ERROR,
-            "Unable to compile arrow shader: Unknown exception\n");
+    } catch (...) {
+        vislib::sys::Log::DefaultLog.WriteMsg(
+            vislib::sys::Log::LEVEL_ERROR, "Unable to compile arrow shader: Unknown exception\n");
         return false;
     }
 
     glEnable(GL_TEXTURE_1D);
     glGenTextures(1, &this->greyTF);
-    unsigned char tex[6] = {
-        0, 0, 0,  255, 255, 255
-    };
+    unsigned char tex[6] = {0, 0, 0, 255, 255, 255};
     glBindTexture(GL_TEXTURE_1D, this->greyTF);
     glTexImage1D(GL_TEXTURE_1D, 0, GL_RGBA, 2, 0, GL_RGB, GL_UNSIGNED_BYTE, tex);
     glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
@@ -120,27 +125,26 @@ bool moldyn::ArrowRenderer::create(void) {
  * moldyn::ArrowRenderer::GetExtents
  */
 bool moldyn::ArrowRenderer::GetExtents(Call& call) {
-    view::CallRender3D *cr = dynamic_cast<view::CallRender3D*>(&call);
+    view::CallRender3D* cr = dynamic_cast<view::CallRender3D*>(&call);
     if (cr == NULL) return false;
 
     MultiParticleDataCall* c2 = this->getDataSlot.CallAs<MultiParticleDataCall>();
     if ((c2 != NULL) && ((*c2)(1))) {
         cr->SetTimeFramesCount(c2->FrameCount());
-        cr->AccessBoundingBoxes() = c2->AccessBoundingBoxes();
-
-        float scaling = cr->AccessBoundingBoxes().ObjectSpaceBBox().LongestEdge();
-        if (scaling > 0.0000001) {
-            scaling = 10.0f / scaling;
-        } else {
-            scaling = 1.0f;
-        }
-        cr->AccessBoundingBoxes().MakeScaledWorld(scaling);
+        cr->AccessBoundingBoxes() = core::utility::magicScaleBoundingBoxes(c2->AccessBoundingBoxes());
 
     } else {
         cr->SetTimeFramesCount(1);
         cr->AccessBoundingBoxes().Clear();
     }
 
+    auto chainedRenderer = this->getRenderSlot.CallAs<view::CallRender3D>();
+    if (chainedRenderer != nullptr) {
+        *chainedRenderer = *cr;
+        (*chainedRenderer)(view::CallRender3D::FnGetExtents);
+        *cr = *chainedRenderer;
+    }
+
     return true;
 }
 
@@ -158,23 +162,21 @@ void moldyn::ArrowRenderer::release(void) {
  * moldyn::ArrowRenderer::Render
  */
 bool moldyn::ArrowRenderer::Render(Call& call) {
-    view::CallRender3D *cr = dynamic_cast<view::CallRender3D*>(&call);
+    view::CallRender3D* cr = dynamic_cast<view::CallRender3D*>(&call);
     if (cr == NULL) return false;
 
-    MultiParticleDataCall *c2 = this->getDataSlot.CallAs<MultiParticleDataCall>();
-    float scaling = 1.0f;
+    auto chainedRenderer = this->getRenderSlot.CallAs<view::CallRender3D>();
+    if (chainedRenderer != nullptr) {
+        *chainedRenderer = *cr;
+        (*chainedRenderer)(view::CallRender3D::FnRender);
+        *cr = *chainedRenderer;
+    }
+
+    MultiParticleDataCall* c2 = this->getDataSlot.CallAs<MultiParticleDataCall>();
     if (c2 != NULL) {
         c2->SetFrameID(static_cast<unsigned int>(cr->Time()));
         if (!(*c2)(1)) return false;
 
-        // calculate scaling
-        scaling = c2->AccessBoundingBoxes().ObjectSpaceBBox().LongestEdge();
-        if (scaling > 0.0000001) {
-            scaling = 10.0f / scaling;
-        } else {
-            scaling = 1.0f;
-        }
-
         c2->SetFrameID(static_cast<unsigned int>(cr->Time()));
         if (!(*c2)(0)) return false;
     } else {
@@ -182,14 +184,14 @@ bool moldyn::ArrowRenderer::Render(Call& call) {
     }
 
     auto* cflags = this->getFlagsSlot.CallAs<FlagCall>();
-  
+
     float lengthScale = this->lengthScaleSlot.Param<param::FloatParam>()->Value();
     float lengthFilter = this->lengthFilterSlot.Param<param::FloatParam>()->Value();
 
-    //view::CallClipPlane *ccp = this->getClipPlaneSlot.CallAs<view::CallClipPlane>();
-    //float clipDat[4];
-    //float clipCol[3];
-    //if ((ccp != NULL) && (*ccp)()) {
+    // view::CallClipPlane *ccp = this->getClipPlaneSlot.CallAs<view::CallClipPlane>();
+    // float clipDat[4];
+    // float clipCol[3];
+    // if ((ccp != NULL) && (*ccp)()) {
     //    clipDat[0] = ccp->GetPlane().Normal().X();
     //    clipDat[1] = ccp->GetPlane().Normal().Y();
     //    clipDat[2] = ccp->GetPlane().Normal().Z();
@@ -220,15 +222,17 @@ bool moldyn::ArrowRenderer::Render(Call& call) {
 
     glUniform4fv(this->arrowShader.ParameterLocation("viewAttr"), 1, viewportStuff);
     glUniform3fv(this->arrowShader.ParameterLocation("camIn"), 1, cr->GetCameraParameters()->Front().PeekComponents());
-    glUniform3fv(this->arrowShader.ParameterLocation("camRight"), 1, cr->GetCameraParameters()->Right().PeekComponents());
+    glUniform3fv(
+        this->arrowShader.ParameterLocation("camRight"), 1, cr->GetCameraParameters()->Right().PeekComponents());
     glUniform3fv(this->arrowShader.ParameterLocation("camUp"), 1, cr->GetCameraParameters()->Up().PeekComponents());
     this->arrowShader.SetParameter("lengthScale", lengthScale);
     this->arrowShader.SetParameter("lengthFilter", lengthFilter);
 
-    //glUniform4fvARB(this->arrowShader.ParameterLocation("clipDat"), 1, clipDat);
-    //glUniform3fvARB(this->arrowShader.ParameterLocation("clipCol"), 1, clipCol);
+    // glUniform4fvARB(this->arrowShader.ParameterLocation("clipDat"), 1, clipDat);
+    // glUniform3fvARB(this->arrowShader.ParameterLocation("clipCol"), 1, clipCol);
 
-    glScalef(scaling, scaling, scaling);
+    core::utility::glMagicScale scaling;
+    scaling.apply(cr->GetBoundingBoxes());
 
     if (c2 != NULL) {
         unsigned int cial = glGetAttribLocationARB(this->arrowShader, "colIdx");
@@ -245,95 +249,96 @@ bool moldyn::ArrowRenderer::Render(Call& call) {
         }
 
         for (unsigned int i = 0; i < c2->GetParticleListCount(); i++) {
-            MultiParticleDataCall::Particles &parts = c2->AccessParticles(i);
+            MultiParticleDataCall::Particles& parts = c2->AccessParticles(i);
             float minC = 0.0f, maxC = 0.0f;
             unsigned int colTabSize = 0;
 
             // colour
             switch (parts.GetColourDataType()) {
-                case MultiParticleDataCall::Particles::COLDATA_NONE:
-                    glColor3ubv(parts.GetGlobalColour());
-                    break;
-                case MultiParticleDataCall::Particles::COLDATA_UINT8_RGB:
-                    glEnableClientState(GL_COLOR_ARRAY);
-                    glColorPointer(3, GL_UNSIGNED_BYTE, parts.GetColourDataStride(), parts.GetColourData());
-                    break;
-                case MultiParticleDataCall::Particles::COLDATA_UINT8_RGBA:
-                    glEnableClientState(GL_COLOR_ARRAY);
-                    glColorPointer(4, GL_UNSIGNED_BYTE, parts.GetColourDataStride(), parts.GetColourData());
-                    break;
-                case MultiParticleDataCall::Particles::COLDATA_FLOAT_RGB:
-                    glEnableClientState(GL_COLOR_ARRAY);
-                    glColorPointer(3, GL_FLOAT, parts.GetColourDataStride(), parts.GetColourData());
-                    break;
-                case MultiParticleDataCall::Particles::COLDATA_FLOAT_RGBA:
-                    glEnableClientState(GL_COLOR_ARRAY);
-                    glColorPointer(4, GL_FLOAT, parts.GetColourDataStride(), parts.GetColourData());
-                    break;
-                case MultiParticleDataCall::Particles::COLDATA_DOUBLE_I:
-                case MultiParticleDataCall::Particles::COLDATA_FLOAT_I: {
-                    glEnableVertexAttribArrayARB(cial);
-                    if (parts.GetColourDataType() == MultiParticleDataCall::Particles::COLDATA_FLOAT_I) {
-                        glVertexAttribPointerARB(
-                            cial, 1, GL_FLOAT, GL_FALSE, parts.GetColourDataStride(), parts.GetColourData());
-                    } else {
-                        glVertexAttribPointerARB(
-                            cial, 1, GL_DOUBLE, GL_FALSE, parts.GetColourDataStride(), parts.GetColourData());
-                    }
-
-                    glEnable(GL_TEXTURE_1D);
-                    view::CallGetTransferFunction *cgtf = this->getTFSlot.CallAs<view::CallGetTransferFunction>();
-                    if ((cgtf != NULL) && ((*cgtf)())) {
-                        glBindTexture(GL_TEXTURE_1D, cgtf->OpenGLTexture());
-                        colTabSize = cgtf->TextureSize();
-                    } else {
-                        glBindTexture(GL_TEXTURE_1D, this->greyTF);
-                        colTabSize = 2;
-                    }
-
-                    glUniform1i(this->arrowShader.ParameterLocation("colTab"), 0);
-                    minC = parts.GetMinColourIndexValue();
-                    maxC = parts.GetMaxColourIndexValue();
-                    glColor3ub(127, 127, 127);
-                } break;
-                default:
-                    glColor3ub(127, 127, 127);
-                    break;
+            case MultiParticleDataCall::Particles::COLDATA_NONE:
+                glColor3ubv(parts.GetGlobalColour());
+                break;
+            case MultiParticleDataCall::Particles::COLDATA_UINT8_RGB:
+                glEnableClientState(GL_COLOR_ARRAY);
+                glColorPointer(3, GL_UNSIGNED_BYTE, parts.GetColourDataStride(), parts.GetColourData());
+                break;
+            case MultiParticleDataCall::Particles::COLDATA_UINT8_RGBA:
+                glEnableClientState(GL_COLOR_ARRAY);
+                glColorPointer(4, GL_UNSIGNED_BYTE, parts.GetColourDataStride(), parts.GetColourData());
+                break;
+            case MultiParticleDataCall::Particles::COLDATA_FLOAT_RGB:
+                glEnableClientState(GL_COLOR_ARRAY);
+                glColorPointer(3, GL_FLOAT, parts.GetColourDataStride(), parts.GetColourData());
+                break;
+            case MultiParticleDataCall::Particles::COLDATA_FLOAT_RGBA:
+                glEnableClientState(GL_COLOR_ARRAY);
+                glColorPointer(4, GL_FLOAT, parts.GetColourDataStride(), parts.GetColourData());
+                break;
+            case MultiParticleDataCall::Particles::COLDATA_DOUBLE_I:
+            case MultiParticleDataCall::Particles::COLDATA_FLOAT_I: {
+                glEnableVertexAttribArrayARB(cial);
+                if (parts.GetColourDataType() == MultiParticleDataCall::Particles::COLDATA_FLOAT_I) {
+                    glVertexAttribPointerARB(
+                        cial, 1, GL_FLOAT, GL_FALSE, parts.GetColourDataStride(), parts.GetColourData());
+                } else {
+                    glVertexAttribPointerARB(
+                        cial, 1, GL_DOUBLE, GL_FALSE, parts.GetColourDataStride(), parts.GetColourData());
+                }
+
+                glEnable(GL_TEXTURE_1D);
+                view::CallGetTransferFunction* cgtf = this->getTFSlot.CallAs<view::CallGetTransferFunction>();
+                if ((cgtf != NULL) && ((*cgtf)())) {
+                    glBindTexture(GL_TEXTURE_1D, cgtf->OpenGLTexture());
+                    colTabSize = cgtf->TextureSize();
+                } else {
+                    glBindTexture(GL_TEXTURE_1D, this->greyTF);
+                    colTabSize = 2;
+                }
+
+                glUniform1i(this->arrowShader.ParameterLocation("colTab"), 0);
+                minC = parts.GetMinColourIndexValue();
+                maxC = parts.GetMaxColourIndexValue();
+                glColor3ub(127, 127, 127);
+            } break;
+            default:
+                glColor3ub(127, 127, 127);
+                break;
             }
 
             // radius and position
             switch (parts.GetVertexDataType()) {
-                case MultiParticleDataCall::Particles::VERTDATA_NONE:
-                    continue;
-                case MultiParticleDataCall::Particles::VERTDATA_FLOAT_XYZ:
-                    glEnableClientState(GL_VERTEX_ARRAY);
-                    glUniform4f(this->arrowShader.ParameterLocation("inConsts1"), parts.GetGlobalRadius(), minC, maxC, float(colTabSize));
-                    glVertexPointer(3, GL_FLOAT, parts.GetVertexDataStride(), parts.GetVertexData());
-                    break;
-                case MultiParticleDataCall::Particles::VERTDATA_FLOAT_XYZR:
-                    glEnableClientState(GL_VERTEX_ARRAY);
-                    glUniform4f(this->arrowShader.ParameterLocation("inConsts1"), -1.0f, minC, maxC, float(colTabSize));
-                    glVertexPointer(4, GL_FLOAT, parts.GetVertexDataStride(), parts.GetVertexData());
-                    break;
-                case MultiParticleDataCall::Particles::VERTDATA_DOUBLE_XYZ:
-                    glEnableClientState(GL_VERTEX_ARRAY);
-                    glUniform4f(this->arrowShader.ParameterLocation("inConsts1"), -1.0f, minC, maxC, float(colTabSize));
-                    glVertexPointer(3, GL_DOUBLE, parts.GetVertexDataStride(), parts.GetVertexData());
-                default:
-                    continue;
+            case MultiParticleDataCall::Particles::VERTDATA_NONE:
+                continue;
+            case MultiParticleDataCall::Particles::VERTDATA_FLOAT_XYZ:
+                glEnableClientState(GL_VERTEX_ARRAY);
+                glUniform4f(this->arrowShader.ParameterLocation("inConsts1"), parts.GetGlobalRadius(), minC, maxC,
+                    float(colTabSize));
+                glVertexPointer(3, GL_FLOAT, parts.GetVertexDataStride(), parts.GetVertexData());
+                break;
+            case MultiParticleDataCall::Particles::VERTDATA_FLOAT_XYZR:
+                glEnableClientState(GL_VERTEX_ARRAY);
+                glUniform4f(this->arrowShader.ParameterLocation("inConsts1"), -1.0f, minC, maxC, float(colTabSize));
+                glVertexPointer(4, GL_FLOAT, parts.GetVertexDataStride(), parts.GetVertexData());
+                break;
+            case MultiParticleDataCall::Particles::VERTDATA_DOUBLE_XYZ:
+                glEnableClientState(GL_VERTEX_ARRAY);
+                glUniform4f(this->arrowShader.ParameterLocation("inConsts1"), -1.0f, minC, maxC, float(colTabSize));
+                glVertexPointer(3, GL_DOUBLE, parts.GetVertexDataStride(), parts.GetVertexData());
+            default:
+                continue;
             }
 
             // direction
             switch (parts.GetDirDataType()) {
-                case MultiParticleDataCall::Particles::DIRDATA_FLOAT_XYZ:
-                    ::glEnableVertexAttribArrayARB(tpal);
-                    ::glVertexAttribPointerARB(tpal, 3, GL_FLOAT, GL_FALSE, parts.GetDirDataStride(), parts.GetDirData());
-                    break;
-                default:
-                    vislib::sys::Log::DefaultLog.WriteWarn(
-                        "ArrowRenderer: cannot render arrows without directional data!");
-                    continue;
+            case MultiParticleDataCall::Particles::DIRDATA_FLOAT_XYZ:
+                ::glEnableVertexAttribArrayARB(tpal);
+                ::glVertexAttribPointerARB(tpal, 3, GL_FLOAT, GL_FALSE, parts.GetDirDataStride(), parts.GetDirData());
+                break;
+            default:
+                vislib::sys::Log::DefaultLog.WriteWarn("ArrowRenderer: cannot render arrows without directional data!");
+                continue;
             }
+
             std::shared_ptr<FlagStorage::FlagVectorType> flags;
             unsigned int fal = 0;
             if (useFlags) {
@@ -342,16 +347,15 @@ bool moldyn::ArrowRenderer::Render(Call& call) {
                 flags = cflags->GetFlags();
                 fal = glGetAttribLocationARB(this->arrowShader, "flags");
                 ::glEnableVertexAttribArrayARB(fal);
-                ::glVertexAttribIPointer(
-                    fal, 1, GL_UNSIGNED_INT, sizeof(FlagStorage::FlagItemType), flags.get()->data());
+                ::glVertexAttribIPointer(fal, 1, GL_UNSIGNED_INT, 0, flags->data());
             }
 
             glDrawArrays(GL_POINTS, 0, static_cast<GLsizei>(parts.GetCount()));
 
             if (useFlags) {
+                glDisableVertexAttribArrayARB(fal);
                 cflags->SetFlags(flags);
                 (*cflags)(core::FlagCall::CallUnmapFlags);
-                glDisableVertexAttribArrayARB(fal);
             }
 
             glDisableClientState(GL_COLOR_ARRAY);
@@ -365,7 +369,6 @@ bool moldyn::ArrowRenderer::Render(Call& call) {
         }
 
         c2->Unlock();
-
     }
 
     this->arrowShader.Disable();
diff --git a/core/src/moldyn/SphereOutlineRenderer.cpp b/core/src/moldyn/SphereOutlineRenderer.cpp
index 507c03937..59b9983e7 100644
--- a/core/src/moldyn/SphereOutlineRenderer.cpp
+++ b/core/src/moldyn/SphereOutlineRenderer.cpp
@@ -16,6 +16,7 @@
 #include "mmcore/param/IntParam.h"
 #include "mmcore/param/FloatParam.h"
 #include "mmcore/view/CallRender3D.h"
+#include "mmcore/utility/ScaledBoundingBoxes.h"
 #include <GL/glu.h>
 #include "vislib/assert.h"
 #include "vislib/math/mathfunctions.h"
@@ -39,6 +40,7 @@ moldyn::SphereOutlineRenderer::SphereOutlineRenderer(void) : Renderer3DModule(),
         circleSegSlot("seg", "The number of line segments to construct the circle"),
         multiOutlineCntSlot("multiOutline::count", "The (half) number of additional outlines"),
         multiOutLineDistSlot("multiOutline::dist", "The distance of the additional outlines as angles in radians"),
+        paramScaling("scaling", "A scaling factor for the radius"),
         sphereQuadric(NULL) {
 
     this->getDataSlot.SetCompatibleCall<moldyn::MultiParticleDataCallDescription>();
@@ -62,6 +64,9 @@ moldyn::SphereOutlineRenderer::SphereOutlineRenderer(void) : Renderer3DModule(),
     this->multiOutLineDistSlot << new param::FloatParam(0.1f, 0.0f);
     this->MakeSlotAvailable(&this->multiOutLineDistSlot);
 
+    this->paramScaling << new param::FloatParam(1.0f, (std::numeric_limits<float>::min)());
+    this->MakeSlotAvailable(&this->paramScaling);
+
 }
 
 
@@ -149,6 +154,11 @@ bool moldyn::SphereOutlineRenderer::Render(Call& call) {
         return false;
     }
 
+    ::glEnable(GL_DEPTH_TEST);  // Der Oberhass
+    ::glDisable(GL_TEXTURE_1D); // Der Turbohass!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+    ::glDisable(GL_TEXTURE_2D); // Der Turbohass!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+    ::glDisable(GL_TEXTURE_3D); // Der Turbohass!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+    ::glPushMatrix();       // Der HASS!
     glScalef(scaling, scaling, scaling); // ... unklar ob problematisch, aber eigentlich nicht
 
     const int rep = this->repSlot.Param<param::EnumParam>()->Value();
@@ -207,6 +217,9 @@ bool moldyn::SphereOutlineRenderer::Render(Call& call) {
                     vislib::math::Point<float, 3> posP(const_cast<float*>(posData));
                     posP.Set(posP.X() * scaling, posP.Y() * scaling, posP.Z() * scaling);
 
+                    // Apply user-defined scaling.
+                    rad *= this->paramScaling.Param<param::FloatParam>()->Value();
+
                     // Calculate outline angles
                     float d = cr->GetCameraParameters()->EyePosition().Distance(posP);
                     float p = (rad * rad * scaling * scaling) / d;
@@ -263,6 +276,8 @@ bool moldyn::SphereOutlineRenderer::Render(Call& call) {
         ::gluQuadricDrawStyle(static_cast<GLUquadric*>(this->sphereQuadric), GLU_FILL);
         ::glEnable(GL_CULL_FACE);
 
+        ::glDisable(GL_LIGHTING);   // Der Hass!!!
+
         for (unsigned int i = 0; i < c2->GetParticleListCount(); i++) {
             MultiParticleDataCall::Particles &parts = c2->AccessParticles(i);
             float rad = parts.GetGlobalRadius();
@@ -277,6 +292,9 @@ bool moldyn::SphereOutlineRenderer::Render(Call& call) {
                 if (loadRad) rad = posData[3];
                 vislib::math::Point<float, 3> posP(const_cast<float*>(posData));
 
+                // Apply user-defined scaling.
+                rad *= this->paramScaling.Param<param::FloatParam>()->Value();
+
                 ::glPushMatrix();
                 ::glTranslatef(posP.X(), posP.Y(), posP.Z());
                 ::glScalef(rad, rad, rad);
@@ -299,5 +317,7 @@ bool moldyn::SphereOutlineRenderer::Render(Call& call) {
 
     }
 
+    ::glPopMatrix();    // Der Hass!
+
     return true;
 }
diff --git a/core/src/moldyn/SphereRenderer.cpp b/core/src/moldyn/SphereRenderer.cpp
index 8ec3e658c..eb566c87f 100644
--- a/core/src/moldyn/SphereRenderer.cpp
+++ b/core/src/moldyn/SphereRenderer.cpp
@@ -95,7 +95,8 @@ moldyn::SphereRenderer::SphereRenderer(void)
     , aoOffsetSlot("ao::offset", "Ambient Occlusion: Offset from Surface")
     , aoStrengthSlot("ao::strength", "Ambient Occlusion: Strength")
     , aoConeLengthSlot("ao::conelen", "Ambient Occlusion: Cone length")
-    , useHPTexturesSlot("ao::high_prec_tex", "Ambient Occlusion: Use high precision textures") {
+    , useHPTexturesSlot("ao::high_prec_tex", "Ambient Occlusion: Use high precision textures")
+    , outlineSizeSlot("outline::width", "Width of the outline") {
 
     this->radiusScalingParam << new core::param::FloatParam(1.0f);
     this->MakeSlotAvailable(&this->radiusScalingParam);
@@ -136,6 +137,9 @@ moldyn::SphereRenderer::SphereRenderer(void)
     this->useHPTexturesSlot << (new core::param::BoolParam(false));
     this->MakeSlotAvailable(&this->useHPTexturesSlot);
 
+    this->outlineSizeSlot << (new core::param::FloatParam(2.0f, 0.0f));
+    this->MakeSlotAvailable(&this->outlineSizeSlot);
+
     // Initialising enum param with all possible modes (needed for configurator) 
     // (Removing not available render modes later in create function)
     param::EnumParam* rmp = new param::EnumParam(this->renderMode);
@@ -146,6 +150,7 @@ moldyn::SphereRenderer::SphereRenderer(void)
     rmp->SetTypePair(RenderMode::BUFFER_ARRAY,      "Buffer_Array"); 
     rmp->SetTypePair(RenderMode::SPLAT,             "Splat");   
     rmp->SetTypePair(RenderMode::AMBIENT_OCCLUSION, "Ambient_Occlusion"); 
+    rmp->SetTypePair(RenderMode::OUTLINE, "Outline");
     this->renderModeParam << rmp;
     this->MakeSlotAvailable(&this->renderModeParam);
 
@@ -193,6 +198,9 @@ bool moldyn::SphereRenderer::create(void) {
     if (this->isRenderModeAvailable(RenderMode::AMBIENT_OCCLUSION)) {
         this->renderModeParam.Param<param::EnumParam>()->SetTypePair(RenderMode::AMBIENT_OCCLUSION, "Ambient_Occlusion");
     }
+    if (this->isRenderModeAvailable(RenderMode::OUTLINE)) {
+        this->renderModeParam.Param<param::EnumParam>()->SetTypePair(RenderMode::OUTLINE, "Outline");
+    }
     this->MakeSlotAvailable(&this->renderModeParam);
 
     // Check initial render mode
@@ -465,6 +473,23 @@ bool moldyn::SphereRenderer::createResources() {
             this->triggerRebuildGBuffer = true;
         } break;
 
+        case RenderMode::OUTLINE: {
+            vertShaderName = "sphere_outline::vertex";
+            fragShaderName = "sphere_outline::fragment";
+            if (!instance()->ShaderSourceFactory().MakeShaderSource(vertShaderName.PeekBuffer(), *this->vertShader)) {
+                return false;
+            }
+            if (!instance()->ShaderSourceFactory().MakeShaderSource(fragShaderName.PeekBuffer(), *this->fragShader)) {
+                return false;
+            }
+            if (!this->sphereShader.Create(this->vertShader->Code(), this->vertShader->Count(),
+                    this->fragShader->Code(), this->fragShader->Count())) {
+                vislib::sys::Log::DefaultLog.WriteMsg(
+                    vislib::sys::Log::LEVEL_ERROR, "Unable to compile sphere shader: Unknown error\n");
+                return false;
+            }
+        } break;
+
         default:
             return false;
         }
@@ -568,6 +593,11 @@ bool moldyn::SphereRenderer::isRenderModeAvailable(RenderMode rm, bool silent) {
             errorstr += "[SphereRenderer] Render Mode 'AMBIENT_OCCLUSION' is not available. Extension GL_ARB_gpu_shader_fp64 is not available. \n";
         }
         break;
+    case (RenderMode::OUTLINE):
+        if (ogl_IsVersionGEQ(1, 4) == 0) { // TODO change to needed openGL version
+            errorstr += "[SphereRenderer] Render Mode 'OUTLINE' is not available. Minimum OpenGL version is 1.4 \n";
+        }
+        break;
     default:
         errorstr += "[SphereRenderer] BUG: Unknown render mode ... \n";
         break;
@@ -607,6 +637,9 @@ std::string moldyn::SphereRenderer::getRenderModeString(RenderMode rm) {
     case (RenderMode::AMBIENT_OCCLUSION):
         mode = "AMBIENT OCCLUSION";
         break;
+    case (RenderMode::OUTLINE):
+        mode = "OUTLINE";
+        break;
     default:
         mode = "unknown";
         break;
@@ -711,6 +744,8 @@ bool moldyn::SphereRenderer::Render(view::CallRender3D& call) {
     case (RenderMode::AMBIENT_OCCLUSION):
         retval = this->renderAmbientOcclusion(cr3d, mpdc); 
         break;
+    case (RenderMode::OUTLINE):
+        retval = this->renderOutline(cr3d, mpdc); break;
     default:
         break;
     }
@@ -1174,6 +1209,75 @@ bool moldyn::SphereRenderer::renderSplat(view::CallRender3D* cr3d, MultiParticle
     return true;
 }
 
+bool moldyn::SphereRenderer::renderOutline(view::CallRender3D* cr3d, MultiParticleDataCall* mpdc) {
+
+    this->sphereShader.Enable();
+
+    GLuint vertAttribLoc = glGetAttribLocationARB(this->sphereShader, "inVertex");
+    GLuint colAttribLoc = glGetAttribLocationARB(this->sphereShader, "inColor");
+    GLuint colIdxAttribLoc = glGetAttribLocationARB(this->sphereShader, "colIdx");
+
+    glUniform4fv(this->sphereShader.ParameterLocation("viewAttr"), 1, this->curViewAttrib);
+    glUniform3fv(
+        this->sphereShader.ParameterLocation("camIn"), 1, cr3d->GetCameraParameters()->Front().PeekComponents());
+    glUniform3fv(
+        this->sphereShader.ParameterLocation("camRight"), 1, cr3d->GetCameraParameters()->Right().PeekComponents());
+    glUniform3fv(this->sphereShader.ParameterLocation("camUp"), 1, cr3d->GetCameraParameters()->Up().PeekComponents());
+    glUniform1f(
+        this->sphereShader.ParameterLocation("scaling"), this->radiusScalingParam.Param<param::FloatParam>()->Value());
+    glUniform1f(
+        this->sphereShader.ParameterLocation("outlinesize"), this->outlineSizeSlot.Param<param::FloatParam>()->Value());
+    glUniform4fv(this->sphereShader.ParameterLocation("clipDat"), 1, this->curClipDat);
+    glUniform4fv(this->sphereShader.ParameterLocation("clipCol"), 1, this->curClipCol);
+    glUniform4fv(this->sphereShader.ParameterLocation("lpos"), 1, this->curLightPos);
+    glUniformMatrix4fv(this->sphereShader.ParameterLocation("MVinv"), 1, GL_FALSE, this->curMVinv.PeekComponents());
+    glUniformMatrix4fv(this->sphereShader.ParameterLocation("MVP"), 1, GL_FALSE, this->curMVP.PeekComponents());
+    glUniformMatrix4fv(this->sphereShader.ParameterLocation("MVPinv"), 1, GL_FALSE, this->curMVPinv.PeekComponents());
+    glUniformMatrix4fv(
+        this->sphereShader.ParameterLocation("MVPtransp"), 1, GL_FALSE, this->curMVPtransp.PeekComponents());
+
+    for (unsigned int i = 0; i < mpdc->GetParticleListCount(); i++) {
+        MultiParticleDataCall::Particles& parts = mpdc->AccessParticles(i);
+
+        GLuint vao, vb, cb;
+        if (this->renderMode == RenderMode::SIMPLE_CLUSTERED) {
+            parts.GetVAOs(vao, vb, cb);
+            if (parts.IsVAO()) {
+                glBindVertexArray(vao);
+                this->setPointers<GLSLShader>(parts, this->sphereShader, vb, parts.GetVertexData(), vertAttribLoc, cb,
+                    parts.GetColourData(), colAttribLoc, colIdxAttribLoc);
+            }
+        }
+        if ((this->renderMode == RenderMode::SIMPLE) || (!parts.IsVAO())) {
+            this->setPointers<GLSLShader>(parts, this->sphereShader, 0, parts.GetVertexData(), vertAttribLoc, 0,
+                parts.GetColourData(), colAttribLoc, colIdxAttribLoc);
+        }
+
+        glDrawArrays(GL_POINTS, 0, static_cast<GLsizei>(parts.GetCount()));
+
+        if (this->renderMode == RenderMode::SIMPLE_CLUSTERED) {
+            if (parts.IsVAO()) {
+                glBindVertexArray(0); // vao
+            }
+        }
+
+        // Reset states set in setPointers()
+        glBindBuffer(GL_ARRAY_BUFFER, 0);
+        glDisableVertexAttribArrayARB(vertAttribLoc);
+        glDisableVertexAttribArrayARB(colAttribLoc);
+        glDisableVertexAttribArrayARB(colIdxAttribLoc);
+        glDisable(GL_TEXTURE_1D);
+    }
+
+    mpdc->Unlock();
+
+    this->sphereShader.Disable();
+
+    return true;
+
+    return true;
+}
+
 
 bool moldyn::SphereRenderer::renderBufferArray(view::CallRender3D* cr3d, MultiParticleDataCall* mpdc) {
 
@@ -2130,8 +2234,12 @@ void moldyn::SphereRenderer::renderDeferredPass(megamol::core::view::CallRender3
             "inBoundsSize", 1, cr3d->AccessBoundingBoxes().ObjectSpaceClipBox().GetSize().PeekDimension());
     }
 
-    glBegin(GL_POINTS);
-    glVertex2f(0.0f, 0.0f);
+    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+    glBegin(GL_QUADS);
+    glVertex2f(-1.0f, 1.0f);
+    glVertex2f(-1.0f, -1.0f);
+    glVertex2f(1.0f, -1.0f);
+    glVertex2f(1.0f, 1.0f);
     glEnd();
 
     glBindTexture(GL_TEXTURE_2D, 0);
diff --git a/core/src/view/AbstractView.cpp b/core/src/view/AbstractView.cpp
index 784379402..f39294af3 100644
--- a/core/src/view/AbstractView.cpp
+++ b/core/src/view/AbstractView.cpp
@@ -1,7 +1,7 @@
 /*
  * AbstractView.cpp
  *
- * Copyright (C) 2008 by Universitaet Stuttgart (VIS). 
+ * Copyright (C) 2008 by Universitaet Stuttgart (VIS).
  * Alle Rechte vorbehalten.
  */
 
@@ -12,11 +12,11 @@
 #include "mmcore/CoreInstance.h"
 #include "mmcore/param/AbstractParam.h"
 #include "mmcore/param/ParamSlot.h"
-#include "mmcore/view/CallRenderView.h"
 #include "mmcore/view/AbstractCallRender.h"
+#include "mmcore/view/CallRenderView.h"
 #include "vislib/Array.h"
-#include "vislib/assert.h"
 #include "vislib/UnsupportedOperationException.h"
+#include "vislib/assert.h"
 
 using namespace megamol::core;
 using vislib::sys::Log;
@@ -25,9 +25,8 @@ using vislib::sys::Log;
 /*
  * view::AbstractView::AbstractView
  */
-view::AbstractView::AbstractView(void) : Module(),
-        renderSlot("render", "Connects modules requesting renderings"),
-        hooks() {
+view::AbstractView::AbstractView(void)
+    : Module(), renderSlot("render", "Connects modules requesting renderings"), hooks() {
     // InputCall
     this->renderSlot.SetCallback(
         view::CallRenderView::ClassName(), InputCall::FunctionName(InputCall::FnOnKey), &AbstractView::OnKeyCallback);
@@ -43,7 +42,7 @@ view::AbstractView::AbstractView(void) : Module(),
     this->renderSlot.SetCallback(view::CallRenderView::ClassName(),
         AbstractCallRender::FunctionName(AbstractCallRender::FnRender), &AbstractView::OnRenderView);
     this->renderSlot.SetCallback(view::CallRenderView::ClassName(),
-        AbstractCallRender::FunctionName(AbstractCallRender::FnGetExtents), &AbstractView::GetExtentsCallback);
+        AbstractCallRender::FunctionName(AbstractCallRender::FnGetExtents), &AbstractView::GetExtents);
     // CallRenderView
     this->renderSlot.SetCallback(view::CallRenderView::ClassName(),
         view::CallRenderView::FunctionName(view::CallRenderView::CALL_FREEZE), &AbstractView::OnFreezeView);
@@ -66,8 +65,7 @@ view::AbstractView::~AbstractView(void) {
 /*
  * view::AbstractView::IsParamRelevant
  */
-bool view::AbstractView::IsParamRelevant(
-        const vislib::SmartPtr<param::AbstractParam>& param) const {
+bool view::AbstractView::IsParamRelevant(const vislib::SmartPtr<param::AbstractParam>& param) const {
     const AbstractNamedObject* ano = dynamic_cast<const AbstractNamedObject*>(this);
     if (ano == NULL) return false;
     if (param.IsNull()) return false;
@@ -80,26 +78,24 @@ bool view::AbstractView::IsParamRelevant(
 /*
  * view::AbstractView::DesiredWindowPosition
  */
-bool view::AbstractView::DesiredWindowPosition(int *x, int *y, int *w,
-        int *h, bool *nd) {
-    Module *tm = dynamic_cast<Module*>(this);
+bool view::AbstractView::DesiredWindowPosition(int* x, int* y, int* w, int* h, bool* nd) {
+    Module* tm = dynamic_cast<Module*>(this);
     if (tm != NULL) {
 
         // this is not working properly if the main module/view is placed at top namespace root
-        //vislib::StringA name(tm->Name());
-        //if (tm->Parent() != NULL) name = tm->Parent()->Name();
+        // vislib::StringA name(tm->Name());
+        // if (tm->Parent() != NULL) name = tm->Parent()->Name();
         vislib::StringA name(tm->GetDemiRootName());
 
         if (name.IsEmpty()) {
-            vislib::sys::Log::DefaultLog.WriteMsg(vislib::sys::Log::LEVEL_INFO + 1200,
-                "View does not seem to have a name. Odd.");
+            vislib::sys::Log::DefaultLog.WriteMsg(
+                vislib::sys::Log::LEVEL_INFO + 1200, "View does not seem to have a name. Odd.");
         } else {
             name.Append("-Window");
 
             if (tm->GetCoreInstance()->Configuration().IsConfigValueSet(name)) {
                 if (this->desiredWindowPosition(
-                        tm->GetCoreInstance()->Configuration().ConfigValue(name),
-                        x, y, w, h, nd)) {
+                        tm->GetCoreInstance()->Configuration().ConfigValue(name), x, y, w, h, nd)) {
                     vislib::sys::Log::DefaultLog.WriteMsg(vislib::sys::Log::LEVEL_INFO + 200,
                         "Loaded desired window geometry from \"%s\"", name.PeekBuffer());
                     return true;
@@ -116,9 +112,7 @@ bool view::AbstractView::DesiredWindowPosition(int *x, int *y, int *w,
         name = "*-Window";
 
         if (tm->GetCoreInstance()->Configuration().IsConfigValueSet(name)) {
-            if (this->desiredWindowPosition(
-                    tm->GetCoreInstance()->Configuration().ConfigValue(name),
-                    x, y, w, h, nd)) {
+            if (this->desiredWindowPosition(tm->GetCoreInstance()->Configuration().ConfigValue(name), x, y, w, h, nd)) {
                 vislib::sys::Log::DefaultLog.WriteMsg(vislib::sys::Log::LEVEL_INFO + 200,
                     "Loaded desired window geometry from \"%s\"", name.PeekBuffer());
                 return true;
@@ -140,24 +134,32 @@ bool view::AbstractView::DesiredWindowPosition(int *x, int *y, int *w,
  * view::AbstractView::OnRenderView
  */
 bool view::AbstractView::OnRenderView(Call& call) {
-    throw vislib::UnsupportedOperationException(
-        "AbstractView::OnRenderView", __FILE__, __LINE__);
+    throw vislib::UnsupportedOperationException("AbstractView::OnRenderView", __FILE__, __LINE__);
 }
 
 /*
  * view::AbstractView::desiredWindowPosition
  */
-bool view::AbstractView::desiredWindowPosition(const vislib::StringW& str,
-        int *x, int *y, int *w, int *h, bool *nd) {
+bool view::AbstractView::desiredWindowPosition(const vislib::StringW& str, int* x, int* y, int* w, int* h, bool* nd) {
     vislib::StringW v = str;
     int vi = -1;
     v.TrimSpaces();
 
-    if (x != NULL) { *x = INT_MIN; }
-    if (y != NULL) { *y = INT_MIN; }
-    if (w != NULL) { *w = INT_MIN; }
-    if (h != NULL) { *h = INT_MIN; }
-    if (nd != NULL) { *nd = false; }
+    if (x != NULL) {
+        *x = INT_MIN;
+    }
+    if (y != NULL) {
+        *y = INT_MIN;
+    }
+    if (w != NULL) {
+        *w = INT_MIN;
+    }
+    if (h != NULL) {
+        *h = INT_MIN;
+    }
+    if (nd != NULL) {
+        *nd = false;
+    }
 
     while (!v.IsEmpty()) {
         if ((v[0] == L'X') || (v[0] == L'x')) {
@@ -176,8 +178,7 @@ bool view::AbstractView::desiredWindowPosition(const vislib::StringW& str,
             }
             vi = 4;
         } else {
-            Log::DefaultLog.WriteMsg(
-                vislib::sys::Log::LEVEL_WARN,
+            Log::DefaultLog.WriteMsg(vislib::sys::Log::LEVEL_WARN,
                 "Unexpected character %s in window position definition.\n",
                 vislib::StringA(vislib::StringA(v)[0], 1).PeekBuffer());
             break;
@@ -191,46 +192,59 @@ bool view::AbstractView::desiredWindowPosition(const vislib::StringW& str,
             // now we want to parse a double :-/
             int cp = 0;
             int len = v.Length();
-            while ((cp < len) && (((v[cp] >= L'0') && (v[cp] <= L'9'))
-                    || (v[cp] == L'+') /*|| (v[cp] == L'.')
-                    || (v[cp] == L',') */|| (v[cp] == L'-')
-                    /*|| (v[cp] == L'e') || (v[cp] == L'E')*/)) {
+            while ((cp < len) && (((v[cp] >= L'0') && (v[cp] <= L'9')) || (v[cp] == L'+') /*|| (v[cp] == L'.')
+                                                                       || (v[cp] == L',') */
+                                     || (v[cp] == L'-')
+                                     /*|| (v[cp] == L'e') || (v[cp] == L'E')*/)) {
                 cp++;
             }
 
             try {
                 int i = vislib::CharTraitsW::ParseInt(v.Substring(0, cp));
                 switch (vi) {
-                    case 0 :
-                        if (x != NULL) { *x = i; }
-                        break;
-                    case 1 :
-                        if (y != NULL) { *y = i; }
-                        break;
-                    case 2 :
-                        if (w != NULL) { *w = i; }
-                        break;
-                    case 3 :
-                        if (h != NULL) { *h = i; }
-                        break;
+                case 0:
+                    if (x != NULL) {
+                        *x = i;
+                    }
+                    break;
+                case 1:
+                    if (y != NULL) {
+                        *y = i;
+                    }
+                    break;
+                case 2:
+                    if (w != NULL) {
+                        *w = i;
+                    }
+                    break;
+                case 3:
+                    if (h != NULL) {
+                        *h = i;
+                    }
+                    break;
                 }
-            } catch(...) {
-                const char *str = "unknown";
+            } catch (...) {
+                const char* str = "unknown";
                 switch (vi) {
-                    case 0 : str = "X"; break;
-                    case 1 : str = "Y"; break;
-                    case 2 : str = "W"; break;
-                    case 3 : str = "H"; break;
+                case 0:
+                    str = "X";
+                    break;
+                case 1:
+                    str = "Y";
+                    break;
+                case 2:
+                    str = "W";
+                    break;
+                case 3:
+                    str = "H";
+                    break;
                 }
                 vi = -1;
-                Log::DefaultLog.WriteMsg(
-                    vislib::sys::Log::LEVEL_WARN,
-                    "Unable to parse value for %s.\n", str);
+                Log::DefaultLog.WriteMsg(vislib::sys::Log::LEVEL_WARN, "Unable to parse value for %s.\n", str);
             }
 
             v = v.Substring(cp);
         }
-
     }
 
     return true;
@@ -240,7 +254,7 @@ bool view::AbstractView::desiredWindowPosition(const vislib::StringW& str,
 /*
  * view::AbstractView::unpackMouseCoordinates
  */
-void view::AbstractView::unpackMouseCoordinates(float &x, float &y) {
+void view::AbstractView::unpackMouseCoordinates(float& x, float& y) {
     // intentionally empty
     // do something smart in the derived classes
 }
@@ -254,9 +268,9 @@ bool view::AbstractView::onResetView(Call& call) {
 }
 
 
-bool view::AbstractView::GetExtentsCallback(Call& call) {
-	// NOP, because thats the way it was before.
-	return false; 
+bool view::AbstractView::GetExtents(Call& call) {
+    throw vislib::UnsupportedOperationException("AbstractView::GetExtents", __FILE__, __LINE__);
+    return false;
 }
 
 bool view::AbstractView::OnKeyCallback(Call& call) {
diff --git a/core/src/view/SplitView.cpp b/core/src/view/SplitView.cpp
index 88b0420b3..3b46dc1d7 100644
--- a/core/src/view/SplitView.cpp
+++ b/core/src/view/SplitView.cpp
@@ -6,6 +6,7 @@
  */
 #include "stdafx.h"
 #include "mmcore/view/SplitView.h"
+#include "mmcore/param/BoolParam.h"
 #include "mmcore/param/ColorParam.h"
 #include "mmcore/param/EnumParam.h"
 #include "mmcore/param/FloatParam.h"
@@ -30,6 +31,9 @@ view::SplitView::SplitView()
     , splitPositionSlot("split.pos", "Splitter position")
     , splitWidthSlot("split.width", "Splitter width")
     , splitColourSlot("split.colour", "Splitter colour")
+    , enableTimeSyncSlot("timeLord",
+          "Enables time synchronization between the connected views. The time of this view is then used instead")
+    , inputToBothSlot("inputToBoth", "Forward input to both child views")
     , overrideCall(nullptr)
     , clientArea()
     , clientArea1()
@@ -60,15 +64,22 @@ view::SplitView::SplitView()
 
     this->splitColourSlot << new param::ColorParam(0.75f, 0.75f, 0.75f, 1.0f);
     this->MakeSlotAvailable(&this->splitColourSlot);
-}
 
-view::SplitView::~SplitView() { this->Release(); }
+    this->enableTimeSyncSlot << new param::BoolParam(false);
+    this->MakeSlotAvailable(&this->enableTimeSyncSlot);
+
+    this->inputToBothSlot << new param::BoolParam(false);
+    this->MakeSlotAvailable(&this->inputToBothSlot);
 
-float view::SplitView::DefaultTime(double instTime) const {
-    // This view does not do any time control
-    return 0.0f;
+    for (unsigned int i = 0; this->timeCtrl.GetSlot(i) != nullptr; i++) {
+        this->MakeSlotAvailable(this->timeCtrl.GetSlot(i));
+    }
 }
 
+view::SplitView::~SplitView(void) { this->Release(); }
+
+float view::SplitView::DefaultTime(double instTime) const { return this->timeCtrl.Time(instTime); }
+
 unsigned int view::SplitView::GetCameraSyncNumber() const {
     Log::DefaultLog.WriteWarn("SplitView::GetCameraSyncNumber unsupported");
     return 0u;
@@ -85,6 +96,8 @@ void view::SplitView::DeserialiseCamera(vislib::Serialiser& serialiser) {
 void view::SplitView::Render(const mmcRenderViewContext& context) {
     // TODO: Affinity
 
+	 float time = static_cast<float>(context.Time);
+
     if (this->doHookCode()) {
         this->doBeforeRenderHook();
     }
@@ -102,17 +115,61 @@ void view::SplitView::Render(const mmcRenderViewContext& context) {
         vph = this->overrideCall->ViewportHeight();
     }
 
+    if (this->enableTimeSyncSlot.Param<param::BoolParam>()->Value()) {
+        auto cr = this->render1();
+        (*cr)(CallRenderView::CALL_EXTENTS);
+        auto fcount = cr->TimeFramesCount();
+        auto insitu = cr->IsInSituTime();
+        cr = this->render2();
+        (*cr)(CallRenderView::CALL_EXTENTS);
+        fcount = std::min(fcount, cr->TimeFramesCount());
+        insitu = insitu && cr->IsInSituTime();
+
+        this->timeCtrl.SetTimeExtend(fcount, insitu);
+        if (time > static_cast<float>(fcount)) {
+            time = static_cast<float>(fcount);
+        }
+    }
+
+    //float sp = this->splitPositionSlot.Param<param::FloatParam>()->Value();
+    //float shw = this->splitWidthSlot.Param<param::FloatParam>()->Value() * 0.5f;
+    //auto so = static_cast<Orientation>(this->splitOrientationSlot.Param<param::EnumParam>()->Value());
+    //if (so == HORIZONTAL) {
+    //    auto oc = this->overrideCall;
+    //    float splitpos = oc->VirtualWidth() * sp;
+
+    //    auto left1 = oc->TileX();
+    //    auto right1 = std::max(std::min(oc->TileX() + oc->TileWidth(), splitpos), oc->TileX());
+    //    if (left1 == right1) {
+    //        // skip client 1
+    //        // draw no handle at all
+    //    }
+    //    // or the other way round?
+    //    auto top1 = oc->TileY();
+    //    auto bottom1 = oc->TileY() + oc->TileHeight();
+
+    //    auto left2 = std::min(std::max(oc->TileX(), splitpos), oc->TileX() + oc->TileWidth());
+    //    auto right2 = oc->TileX() + oc->TileWidth();
+    //    if (left2 == right2) {
+    //        // skip client 2
+    //        // draw no handle at all
+    //    }
+    //    auto top2 = top1;
+    //    auto bottom2 = bottom1;
+    //} else {
+    //}
+
     if (this->splitPositionSlot.IsDirty() || this->splitOrientationSlot.IsDirty() || this->splitWidthSlot.IsDirty() ||
         !this->fbo1.IsValid() || !this->fbo2.IsValid() ||
         !vislib::math::IsEqual(this->clientArea.Width(), static_cast<float>(vpw)) ||
         !vislib::math::IsEqual(this->clientArea.Height(), static_cast<float>(vph))) {
-
         this->updateSize(vpw, vph);
 
         if (this->overrideCall != nullptr) {
             this->overrideCall->EnableOutputBuffer();
         }
     }
+
     auto renderAndBlit = [&](vislib::graphics::gl::FramebufferObject& fbo, CallRenderView* crv,
                              const vislib::math::Rectangle<float>& ca) {
         if (crv == nullptr) {
@@ -122,6 +179,10 @@ void view::SplitView::Render(const mmcRenderViewContext& context) {
         crv->SetInstanceTime(context.InstanceTime);
         crv->SetTime(-1.0f);
 
+        if (this->enableTimeSyncSlot.Param<param::BoolParam>()->Value()) {
+            crv->SetTime(static_cast<float>(time));
+        }
+
 #if defined(DEBUG) || defined(_DEBUG)
         unsigned int otl = vislib::Trace::GetInstance().GetLevel();
         vislib::Trace::GetInstance().SetLevel(0);
@@ -163,6 +224,25 @@ void view::SplitView::Render(const mmcRenderViewContext& context) {
     renderAndBlit(this->fbo2, this->render2(), this->clientArea2);
 }
 
+bool view::SplitView::GetExtents(core::Call& call) {
+    if (this->enableTimeSyncSlot.Param<param::BoolParam>()->Value()) {
+        auto cr = this->render1();
+        if (!(*cr)(CallRenderView::CALL_EXTENTS)) return false;
+        auto time = cr->TimeFramesCount();
+        auto insitu = cr->IsInSituTime();
+        cr = this->render2();
+        if (!(*cr)(CallRenderView::CALL_EXTENTS)) return false;
+        time = std::min(time, cr->TimeFramesCount());
+        insitu = insitu && cr->IsInSituTime();
+
+        CallRenderView* crv = dynamic_cast<CallRenderView*>(&call);
+        if (crv == nullptr) return false;
+        crv->SetTimeFramesCount(time);
+        crv->SetIsInSituTime(insitu);
+    }
+    return true;
+}
+
 void view::SplitView::ResetView() {
     for (auto crv : {this->render1(), this->render2()}) {
         if (crv != nullptr) (*crv)(CallRenderView::CALL_RESETVIEW);
@@ -185,6 +265,9 @@ bool view::SplitView::OnRenderView(Call& call) {
     mmcRenderViewContext context;
     ::ZeroMemory(&context, sizeof(context));
     context.Time = crv->Time();
+    if (this->enableTimeSyncSlot.Param<param::BoolParam>()->Value() && context.Time < 0.0) {
+        context.Time = this->DefaultTime(crv->InstanceTime());
+    }
     context.InstanceTime = crv->InstanceTime();
     this->Render(context);
 
@@ -200,37 +283,59 @@ void view::SplitView::UpdateFreeze(bool freeze) {
 }
 
 bool view::SplitView::OnKey(Key key, KeyAction action, Modifiers mods) {
-    bool consumed = false;
+    auto* crv = this->renderHovered();
+    auto* crv1 = this->render1();
+    auto* crv2 = this->render2();
 
-    for (auto crv : {this->render1(), this->render2()}) {
-        if (crv != nullptr) {
-            InputEvent evt;
-            evt.tag = InputEvent::Tag::Key;
-            evt.keyData.key = key;
-            evt.keyData.action = action;
-            evt.keyData.mods = mods;
+    if (crv != nullptr) {
+        InputEvent evt;
+        evt.tag = InputEvent::Tag::Key;
+        evt.keyData.key = key;
+        evt.keyData.action = action;
+        evt.keyData.mods = mods;
+
+        if (this->inputToBothSlot.Param<param::BoolParam>()->Value()) {
+            crv1->SetInputEvent(evt);
+            auto consumed = (*crv1)(view::CallRenderView::FnOnKey);
+
+            crv2->SetInputEvent(evt);
+            consumed |= (*crv2)(view::CallRenderView::FnOnKey);
+
+            return consumed;
+        } else {
             crv->SetInputEvent(evt);
-            if ((*crv)(view::CallRenderView::FnOnKey)) consumed = true;
+            if (!(*crv)(view::CallRenderView::FnOnKey)) return false;
         }
     }
 
-    return consumed;
+    return false;
 }
 
 bool view::SplitView::OnChar(unsigned int codePoint) {
-    bool consumed = false;
+    auto* crv = this->renderHovered();
+    auto* crv1 = this->render1();
+    auto* crv2 = this->render2();
 
-    for (auto crv : {this->render1(), this->render2()}) {
-        if (crv != nullptr) {
-            InputEvent evt;
-            evt.tag = InputEvent::Tag::Char;
-            evt.charData.codePoint = codePoint;
+    if (crv != nullptr) {
+        InputEvent evt;
+        evt.tag = InputEvent::Tag::Char;
+        evt.charData.codePoint = codePoint;
+
+        if (this->inputToBothSlot.Param<param::BoolParam>()->Value()) {
+            crv1->SetInputEvent(evt);
+            auto consumed = (*crv1)(view::CallRenderView::FnOnChar);
+
+            crv2->SetInputEvent(evt);
+            consumed |= (*crv2)(view::CallRenderView::FnOnChar);
+
+            return consumed;
+        } else {
             crv->SetInputEvent(evt);
-            if ((*crv)(view::CallRenderView::FnOnChar)) consumed = true;
+            if (!(*crv)(view::CallRenderView::FnOnChar)) return false;
         }
     }
 
-    return consumed;
+    return false;
 }
 
 bool view::SplitView::OnMouseButton(MouseButton button, MouseButtonAction action, Modifiers mods) {
@@ -240,28 +345,33 @@ bool view::SplitView::OnMouseButton(MouseButton button, MouseButtonAction action
 
     this->dragSplitter = false;
 
-    if (action == MouseButtonAction::PRESS) {
-        if (crv == crv1) {
-            this->focus = 1;
-        } else if (crv == crv2) {
-            this->focus = 2;
-        } else {
-            this->focus = 0;
-            this->dragSplitter = true;
-        }
+    auto down = (action == MouseButtonAction::PRESS);
+    if (down && crv != crv1 && crv != crv2) {
+        this->dragSplitter = true;
     }
 
-    if (crv) {
+    if (crv != nullptr) {
         InputEvent evt;
         evt.tag = InputEvent::Tag::MouseButton;
         evt.mouseButtonData.button = button;
         evt.mouseButtonData.action = action;
         evt.mouseButtonData.mods = mods;
-        crv->SetInputEvent(evt);
-        if (!(*crv)(view::CallRenderView::FnOnMouseButton)) return false;
+
+        if (this->inputToBothSlot.Param<param::BoolParam>()->Value()) {
+            crv1->SetInputEvent(evt);
+            auto consumed = (*crv1)(view::CallRenderView::FnOnMouseButton);
+
+            crv2->SetInputEvent(evt);
+            consumed |= (*crv2)(view::CallRenderView::FnOnMouseButton);
+
+            return consumed;
+        } else {
+            crv->SetInputEvent(evt);
+            if (!(*crv)(view::CallRenderView::FnOnMouseButton)) return false;
+        }
     }
 
-    return true;
+    return false;
 }
 
 
@@ -300,26 +410,51 @@ bool view::SplitView::OnMouseMove(double x, double y) {
         evt.tag = InputEvent::Tag::MouseMove;
         evt.mouseMoveData.x = mx;
         evt.mouseMoveData.y = my;
-        crv->SetInputEvent(evt);
-        if (!(*crv)(view::CallRenderView::FnOnMouseMove)) return false;
+
+        if (this->inputToBothSlot.Param<param::BoolParam>()->Value()) {
+            crv1->SetInputEvent(evt);
+            auto consumed = (*crv1)(view::CallRenderView::FnOnMouseMove);
+
+            crv2->SetInputEvent(evt);
+            consumed |= (*crv2)(view::CallRenderView::FnOnMouseMove);
+
+            return consumed;
+        } else {
+            crv->SetInputEvent(evt);
+            if (!(*crv)(view::CallRenderView::FnOnMouseMove)) return false;
+        }
     }
 
-    return true;
+    return false;
 }
 
 
 bool view::SplitView::OnMouseScroll(double dx, double dy) {
     auto* crv = this->renderHovered();
-    if (crv == nullptr) return false;
+    auto* crv1 = this->render1();
+    auto* crv2 = this->render2();
 
-    InputEvent evt;
-    evt.tag = InputEvent::Tag::MouseScroll;
-    evt.mouseScrollData.dx = dx;
-    evt.mouseScrollData.dy = dy;
-    crv->SetInputEvent(evt);
-    if (!(*crv)(view::CallRenderView::FnOnMouseScroll)) return false;
+    if (crv != nullptr) {
+        InputEvent evt;
+        evt.tag = InputEvent::Tag::MouseScroll;
+        evt.mouseScrollData.dx = dx;
+        evt.mouseScrollData.dy = dy;
 
-    return true;
+        if (this->inputToBothSlot.Param<param::BoolParam>()->Value()) {
+            crv1->SetInputEvent(evt);
+            auto consumed = (*crv1)(view::CallRenderView::FnOnMouseScroll);
+
+            crv2->SetInputEvent(evt);
+            consumed |= (*crv2)(view::CallRenderView::FnOnMouseScroll);
+
+            return consumed;
+        } else {
+            crv->SetInputEvent(evt);
+            if (!(*crv)(view::CallRenderView::FnOnMouseScroll)) return false;
+        }
+    }
+
+    return false;
 }
 
 bool view::SplitView::create() {
diff --git a/core/src/view/View2D.cpp b/core/src/view/View2D.cpp
index 6f05462c0..b343bc3a5 100644
--- a/core/src/view/View2D.cpp
+++ b/core/src/view/View2D.cpp
@@ -40,7 +40,7 @@ view::View2D::View2D(void) : view::AbstractRenderingView(),
     this->rendererSlot.SetCompatibleCall<CallRender2DDescription>();
     this->MakeSlotAvailable(&this->rendererSlot);
 
-    this->resetViewSlot << new param::ButtonParam(core::view::Key::KEY_HOME);
+    this->resetViewSlot << new param::ButtonParam();
     this->resetViewSlot.SetUpdateCallback(&View2D::onResetView);
     this->MakeSlotAvailable(&this->resetViewSlot);
 
@@ -375,6 +375,10 @@ bool view::View2D::OnKey(Key key, KeyAction action, Modifiers mods) {
     auto* cr = this->rendererSlot.CallAs<view::CallRender2D>();
     if (cr == NULL) return false;
 
+    if (key == Key::KEY_HOME) {
+        onResetView(this->resetViewSlot);
+    }
+
     InputEvent evt;
     evt.tag = InputEvent::Tag::Key;
     evt.keyData.key = key;
@@ -532,3 +536,20 @@ bool view::View2D::onResetView(param::ParamSlot& p) {
     this->ResetView();
     return true;
 }
+
+/*
+ * view::View2D::GetExtents
+ */
+bool view::View2D::GetExtents(Call& call) { 
+    view::CallRenderView* crv = dynamic_cast<view::CallRenderView*>(&call);
+    if (crv == nullptr) return false;
+
+    CallRender2D* cr2d = this->rendererSlot.CallAs<CallRender2D>();
+    if (cr2d == nullptr) return false;
+
+    if (!(*cr2d)(CallRender2D::FnGetExtents)) return false;
+
+    crv->SetTimeFramesCount(cr2d->TimeFramesCount());
+    crv->SetIsInSituTime(cr2d->IsInSituTime());
+    return true; 
+}
diff --git a/core/src/view/View3D.cpp b/core/src/view/View3D.cpp
index 8a431a3e6..dcea6ff09 100644
--- a/core/src/view/View3D.cpp
+++ b/core/src/view/View3D.cpp
@@ -133,7 +133,7 @@ view::View3D::View3D(void)
     this->restoreCameraSettingsSlot.SetUpdateCallback(&View3D::onRestoreCamera);
     this->MakeSlotAvailable(&this->restoreCameraSettingsSlot);
 
-    this->resetViewSlot << new param::ButtonParam(view::Key::KEY_HOME);
+    this->resetViewSlot << new param::ButtonParam();
     this->resetViewSlot.SetUpdateCallback(&View3D::onResetView);
     this->MakeSlotAvailable(&this->resetViewSlot);
 
@@ -709,6 +709,10 @@ bool view::View3D::OnKey(Key key, KeyAction action, Modifiers mods) {
     auto* cr = this->rendererSlot.CallAs<view::CallRender3D>();
     if (cr == NULL) return false;
 
+    if (key == Key::KEY_HOME) {
+        onResetView(this->resetViewSlot);
+    }
+
     running = mods.test(Modifier::SHIFT);
     bool down = (action == KeyAction::PRESS || action == KeyAction::REPEAT) && (action != KeyAction::RELEASE);
     bool ret = true;
@@ -1571,3 +1575,20 @@ void view::View3D::renderViewCube(void) {
     glLineWidth(1.0f);
     glDisable(GL_CULL_FACE);
 }
+
+/*
+ * view::View3D::GetExtents
+ */
+bool view::View3D::GetExtents(Call& call) { 
+    view::CallRenderView* crv = dynamic_cast<view::CallRenderView*>(&call);
+    if (crv == nullptr) return false;
+
+    CallRender3D* cr3d = this->rendererSlot.CallAs<CallRender3D>();
+    if (cr3d == nullptr) return false;
+
+    if (!(*cr3d)(CallRender3D::FnGetExtents)) return false;
+
+    crv->SetTimeFramesCount(cr3d->TimeFramesCount());
+    crv->SetIsInSituTime(cr3d->IsInSituTime());
+    return true; 
+}
diff --git a/core/src/view/special/ScreenShooter.cpp b/core/src/view/special/ScreenShooter.cpp
index 7161205c8..e4ff65f41 100644
--- a/core/src/view/special/ScreenShooter.cpp
+++ b/core/src/view/special/ScreenShooter.cpp
@@ -7,9 +7,12 @@
 
 #include "stdafx.h"
 #include "mmcore/view/special/ScreenShooter.h"
+
 #include <climits>
+#include <limits>
 #include <map>
 #include <sstream>
+
 #include "mmcore/AbstractNamedObject.h"
 #include "mmcore/AbstractNamedObjectContainer.h"
 #include "mmcore/CoreInstance.h"
@@ -939,11 +942,12 @@ bool view::special::ScreenShooter::triggerButtonClicked(param::ParamSlot& slot)
             if (this->makeAnimSlot.Param<param::BoolParam>()->Value()) {
                 param::ParamSlot* timeSlot = this->findTimeParam(vi->View());
                 if (timeSlot != nullptr) {
-                    timeSlot->Param<param::FloatParam>()->SetValue(
-                        static_cast<float>(this->animFromSlot.Param<param::IntParam>()->Value()));
-                    this->animLastFrameTime = (float)UINT_MAX;
+                    auto startTime = static_cast<float>(this->animFromSlot.Param<param::IntParam>()->Value());
+                    Log::DefaultLog.WriteInfo("Starting animation of screen shots at %f.", time);
+                    timeSlot->Param<param::FloatParam>()->SetValue(startTime);
+                    this->animLastFrameTime = std::numeric_limits<decltype(animLastFrameTime)>::lowest();
                 } else {
-                    Log::DefaultLog.WriteError("Unable to make animation screen shots");
+                    Log::DefaultLog.WriteError("Unable to make animation screen shots.");
                     this->makeAnimSlot.Param<param::BoolParam>()->SetValue(false);
                 }
                 // this is not a good idea because the animation module interferes with the "anim::time" parameter in
diff --git a/plugins/infovis/src/ScatterplotMatrixRenderer2D.cpp b/plugins/infovis/src/ScatterplotMatrixRenderer2D.cpp
index f52ba2747..4fbb167db 100644
--- a/plugins/infovis/src/ScatterplotMatrixRenderer2D.cpp
+++ b/plugins/infovis/src/ScatterplotMatrixRenderer2D.cpp
@@ -114,7 +114,7 @@ ScatterplotMatrixRenderer2D::ScatterplotMatrixRenderer2D()
     , axisFont("Evolventa-SansSerif", core::utility::SDFFont::RenderType::RENDERTYPE_FILL)
     , textFont("Evolventa-SansSerif", core::utility::SDFFont::RenderType::RENDERTYPE_FILL)
     , textValid(false)
-    , dataTime(0)
+    , dataTime((std::numeric_limits<unsigned int>::max)())
     , flagsBufferVersion(0) {
     this->floatTableInSlot.SetCompatibleCall<table::TableDataCallDescription>();
     this->MakeSlotAvailable(&this->floatTableInSlot);
@@ -361,9 +361,11 @@ bool ScatterplotMatrixRenderer2D::validate(core::view::CallRender2D& call, bool
     this->floatTable = this->floatTableInSlot.CallAs<table::TableDataCall>();
 
     if (this->floatTable == nullptr || !(*this->floatTable)(1)) return false;
-    auto ts = this->floatTable->GetFrameCount();
-    call.SetTimeFramesCount(ts);
-    this->floatTable->SetFrameID(static_cast<unsigned int>(call.Time()));
+    const auto cntFrames = this->floatTable->GetFrameCount();
+    call.SetTimeFramesCount(cntFrames);    // Tell view about the data set size.
+
+    const auto now = static_cast<unsigned int>(call.Time());    // 
+    this->floatTable->SetFrameID(now);
 
     if (this->floatTable == nullptr || !(*(this->floatTable))(0)) return false;
     if (this->floatTable->GetColumnsCount() == 0) return false;
@@ -389,7 +391,7 @@ bool ScatterplotMatrixRenderer2D::validate(core::view::CallRender2D& call, bool
         this->transferFunction->ResetDirty();
     }
 
-    if (this->dataHash == this->floatTable->DataHash() && ts == this->dataTime && !hasDirtyData()) return true;
+    if (this->dataHash == this->floatTable->DataHash() && now == this->dataTime && !hasDirtyData()) return true;
 
     auto columnInfos = this->floatTable->GetColumnsInfos();
     const size_t colCount = this->floatTable->GetColumnsCount();
@@ -416,7 +418,7 @@ bool ScatterplotMatrixRenderer2D::validate(core::view::CallRender2D& call, bool
     this->updateColumns();
 
     this->dataHash = this->floatTable->DataHash();
-    this->dataTime = ts;
+    this->dataTime = now;
     this->resetDirtyData();
 
     return true;
diff --git a/plugins/infovis/src/ScatterplotMatrixRenderer2D.h b/plugins/infovis/src/ScatterplotMatrixRenderer2D.h
index 569193665..c74368022 100644
--- a/plugins/infovis/src/ScatterplotMatrixRenderer2D.h
+++ b/plugins/infovis/src/ScatterplotMatrixRenderer2D.h
@@ -117,10 +117,9 @@ private:
 
     struct SPLOMPoints {
         SPLOMPoints(const std::vector<PlotInfo>& plots, const stdplugin::datatools::table::TableDataCall* floatTable)
-            : plots(plots)
-            , floatTable(floatTable){}
+            : plots(plots), floatTable(floatTable) {}
 
-                  [[nodiscard]] inline size_t idx_to_row(size_t idx) const {
+        [[nodiscard]] inline size_t idx_to_row(size_t idx) const {
             const size_t rowCount = floatTable->GetRowsCount();
             return idx % rowCount;
         }
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Aggr.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Aggr.glsl
new file mode 100644
index 000000000..6544616b3
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Aggr.glsl
@@ -0,0 +1,59 @@
+/* opacity threshold for integration */
+uniform float opacityThreshold;
+
+/* texture containing transfer function */
+uniform highp sampler1D tf_tx1D;
+
+/* texture containing a depth buffer */
+uniform highp sampler2D color_tx2D;
+uniform highp sampler2D depth_tx2D;
+uniform int use_depth_tx;
+
+/* main function for computation */
+void compute(float t, const float tfar, const Ray ray, const float rayStep, const ivec2 pixel_coords) {
+    // Get pixel texture coordinates and depth value at original position
+    vec2 pixel_tex_coords = vec2(pixel_coords.x / rt_resolution.x, pixel_coords.y / rt_resolution.y);
+    const float input_depth = texture(depth_tx2D, pixel_tex_coords).x;
+
+    // Initialize results
+    vec4 result = vec4(0.0f);
+
+    float att = 0.0f;
+
+    while (t < tfar) {
+        vec3 pos = ray.o + t * ray.d;
+
+        // Compute volume tex coordinates in [0,1] range.
+        vec3 texCoords = (pos - boxMin) / (boxMax - boxMin);
+        texCoords *= 1.0 - 2.0 * halfVoxelSize;
+        texCoords += halfVoxelSize;
+
+        if (use_depth_tx != 0) {
+            // Compare depth values and decide to abort
+            const float depth = calculate_depth(pos);
+
+            if (depth > input_depth) {
+                const vec4 color = texture(color_tx2D, pixel_tex_coords);
+
+                result = color;
+
+                break;
+            }
+        }
+
+        // Get sample
+        att += (texture(volume_tx3D, texCoords).x - valRange.x) / (valRange.y - valRange.x);
+
+        t += rayStep;
+    }
+
+    // Write results
+    result = result.w * result + background * (1.0f - result.w);
+
+    imageStore(render_target_tx2D, pixel_coords, vec4(result.xyz, att));
+}
+
+/* function for storing default output values */
+void storeDefaults(const ivec2 pixel_coords) {
+    imageStore(render_target_tx2D, pixel_coords, vec4(0.0f));
+}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-DVR.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-DVR.glsl
new file mode 100644
index 000000000..19d7c8fc1
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-DVR.glsl
@@ -0,0 +1,68 @@
+/* opacity threshold for integration */
+uniform float opacityThreshold;
+
+/* texture containing transfer function */
+uniform highp sampler1D tf_tx1D;
+
+/* texture containing a depth buffer */
+uniform highp sampler2D color_tx2D;
+uniform highp sampler2D depth_tx2D;
+uniform int use_depth_tx;
+
+/* main function for computation */
+void compute(float t, const float tfar, const Ray ray, const float rayStep, const ivec2 pixel_coords) {
+    // Get pixel texture coordinates and depth value at original position
+    vec2 pixel_tex_coords = vec2(pixel_coords.x / rt_resolution.x, pixel_coords.y / rt_resolution.y);
+    const float input_depth = texture(depth_tx2D, pixel_tex_coords).x;
+
+    // Initialize results
+    vec4 result = vec4(0.0f);
+
+    while (t < tfar && result.w < opacityThreshold) {
+        vec3 pos = ray.o + t * ray.d;
+
+        // Compute volume tex coordinates in [0,1] range.
+        vec3 texCoords = (pos - boxMin) / (boxMax - boxMin);
+        texCoords *= 1.0 - 2.0 * halfVoxelSize;
+        texCoords += halfVoxelSize;
+
+        if (use_depth_tx != 0) {
+            // Compare depth values and decide to abort
+            const float depth = calculate_depth(pos);
+
+            if (depth > input_depth) {
+                const vec4 color = texture(color_tx2D, pixel_tex_coords);
+
+                result += (1.0f - result.w) * color;
+
+                break;
+            }
+        }
+
+        // Get sample
+        vec4 vol_sample = texture(tf_tx1D, (texture(volume_tx3D, texCoords).x - valRange.x) / (valRange.y-valRange.x));
+
+        // Calculate lighting
+        if (use_lighting) {
+            vol_sample.xyz = phong(vol_sample.xyz, calculate_normal(texCoords), -ray.d, light - pos);
+        }
+
+        // Opacity correction.
+        vol_sample.w = (1.0f - pow(1.0f - vol_sample.w, rayStepRatio));
+        vol_sample.xyz *= vol_sample.w;
+
+        result += (1.0f - result.w) * vol_sample;
+
+        t += rayStep;
+    }
+
+    // Write results
+    result = result.w * result + background * (1.0f - result.w);
+
+    imageStore(render_target_tx2D, pixel_coords, result);
+}
+
+/* function for storing default output values */
+void storeDefaults(const ivec2 pixel_coords) {
+    imageStore(render_target_tx2D, pixel_coords, vec4(0.0f));
+}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Functions.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Functions.glsl
new file mode 100644
index 000000000..9394f3e9c
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Functions.glsl
@@ -0,0 +1,89 @@
+struct Ray {
+    vec3 o;
+    vec3 d;
+};
+
+Ray generateRay(ivec2 pixel_coords) {
+    Ray ray;
+
+    // Transform pixel to clip coordinates
+    vec2 clip_space_pixel_coords =
+        vec2((pixel_coords.x / rt_resolution.x) * 2.0f - 1.0f, (pixel_coords.y / rt_resolution.y) * 2.0f - 1.0f);
+
+    // Unproject a point on the near plane and use as an origin
+    mat4 inv_view_proj_mx = inverse(proj_mx * view_mx);
+    vec4 unproj = inv_view_proj_mx * vec4(clip_space_pixel_coords, -1.0f, 1.0f);
+
+    ray.o = unproj.xyz / unproj.w;
+
+    // Unproject a point at the same pixel, but further away from the near plane
+    // to compute a ray direction in world space
+    unproj = inv_view_proj_mx * vec4(clip_space_pixel_coords, 0.0f, 1.0f);
+
+    ray.d = normalize((unproj.xyz / unproj.w) - ray.o);
+
+    return ray;
+}
+
+bool intersectBox(Ray r, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar) {
+    vec3 invR = vec3(1.0f) / r.d;
+    vec3 tbot = invR * (boxmin - r.o);
+    vec3 ttop = invR * (boxmax - r.o);
+
+    // Special case for a ray lying in a bounding plane.
+    if (r.d.x == 0.0f && r.o.x == boxmax.x) {
+        ttop.x = -FLT_MAX;
+        tbot.x = FLT_MAX;
+    }
+    if (r.d.y == 0.0f && r.o.y == boxmax.y) {
+        ttop.y = -FLT_MAX;
+        tbot.y = FLT_MAX;
+    }
+    if (r.d.z == 0.0f && r.o.z == boxmax.z) {
+        ttop.z = -FLT_MAX;
+        tbot.z = FLT_MAX;
+    }
+
+    vec3 tmin = min(ttop, tbot);
+    vec3 tmax = max(ttop, tbot);
+
+    float largest_tmin = max(max(tmin.x, tmin.y), max(tmin.x, tmin.z));
+    float smallest_tmax = min(min(tmax.x, tmax.y), min(tmax.x, tmax.z));
+
+    tnear = largest_tmin;
+    tfar = smallest_tmax;
+
+    return smallest_tmax > largest_tmin;
+}
+
+float wang_hash(uint seed) {
+    seed = (seed ^ 61) ^ (seed >> 16);
+    seed *= 9;
+    seed = seed ^ (seed >> 4);
+    seed *= 0x27d4eb2d;
+    seed = seed ^ (seed >> 15);
+
+    return float(seed) / 4294967296.0;
+}
+
+float calculate_depth(vec3 pos) {
+    vec4 clip_pos = proj_mx * view_mx * vec4(pos, 1.0f);
+
+    return ((clip_pos.z / clip_pos.w) + 1.0f) / 2.0f;
+}
+
+vec3 calculate_normal(vec3 texCoords) {
+    const float left = textureOffset(volume_tx3D, texCoords, ivec3(-1, 0, 0)).x;
+    const float right = textureOffset(volume_tx3D, texCoords, ivec3(1, 0, 0)).x;
+
+    const float bottom = textureOffset(volume_tx3D, texCoords, ivec3(0, -1, 0)).x;
+    const float top = textureOffset(volume_tx3D, texCoords, ivec3(0, 1, 0)).x;
+
+    const float front = textureOffset(volume_tx3D, texCoords, ivec3(0, 0, -1)).x;
+    const float back = textureOffset(volume_tx3D, texCoords, ivec3(0, 0, 1)).x;
+
+    return normalize(vec3(
+        (left - right) / halfVoxelSize.x,
+        (bottom - top) / halfVoxelSize.y,
+        (front - back) / halfVoxelSize.z));
+}
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Input.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Input.glsl
new file mode 100644
index 000000000..0e2ebba40
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Input.glsl
@@ -0,0 +1,35 @@
+#extension GL_ARB_compute_shader: enable
+#define FLT_MAX 3.402823466e+38
+#define FLT_MIN 1.175494351e-38
+#define PI      3.14159265
+
+/* matrices */
+uniform mat4 view_mx;
+uniform mat4 proj_mx;
+
+/* render targete resolution*/
+uniform vec2 rt_resolution;
+
+/* bounding box size */
+uniform vec3 boxMin;
+uniform vec3 boxMax;
+
+/* voxel size */
+uniform float voxelSize;
+uniform vec3 halfVoxelSize;
+
+/* sampling frequency */
+uniform float rayStepRatio;
+
+/* value range */
+uniform vec2 valRange;
+
+/* background color */
+uniform vec4 background;
+
+/* lighting */
+uniform bool use_lighting;
+uniform vec3 material_col;
+
+/* texture that houses the volume data */
+uniform highp sampler3D volume_tx3D;
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Iso.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Iso.glsl
new file mode 100644
index 000000000..108eae488
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Iso.glsl
@@ -0,0 +1,82 @@
+/* isovalue used for isosurface reconstruction */
+uniform float isoValue;
+
+/* opacity */
+uniform float opacity;
+
+/* output normal */
+layout(rgba32f, binding = 1) writeonly uniform highp image2D normal_target_tx2D;
+
+/* output depth */
+layout(r32f, binding = 2) writeonly uniform highp image2D depth_target_tx2D;
+
+/* main function for computation */
+void compute(float t, const float tfar, const Ray ray, const float rayStep, const ivec2 pixel_coords) {
+    // Initialize results
+    vec4 result = vec4(0.0f);
+
+    // Initialize output depth and normal value
+    float depth = FLT_MAX;
+    vec3 normal = vec3(0.0f);
+
+    // Store value and position from previous step
+    vec3 old_pos = ray.o + t * ray.d;
+    float old_value = 0.0f;
+
+    while (t < tfar) {
+        vec3 pos = ray.o + t * ray.d;
+
+        // Compute volume tex coordinates in [0,1] range.
+        vec3 texCoords = (pos - boxMin) / (boxMax - boxMin);
+        texCoords *= 1.0 - 2.0 * halfVoxelSize;
+        texCoords += halfVoxelSize;
+
+        // Get volume sample
+        float vol_sample = texture(volume_tx3D, texCoords).x;
+
+        if (vol_sample > isoValue) {
+            // Compute relative position between sample positions
+            const vec3 direction = pos - old_pos;
+            const float distance = (isoValue - old_value) / (vol_sample - old_value);
+
+            const vec3 surface_pos = old_pos + distance * direction;
+
+            depth = calculate_depth(surface_pos);
+
+            // Compute normal
+            normal = calculate_normal(texCoords);
+
+            // Compute illumination from fixed light
+            if (use_lighting) {
+                result = vec4(phong(material_col, normal, -ray.d, light - surface_pos), opacity);
+            } else {
+                result = vec4(material_col, opacity);
+            }
+
+            break;
+        }
+
+        // Store value and position for new "previous" step
+        old_pos = pos;
+        old_value = vol_sample;
+
+        // Adaptive step size
+        if (vol_sample / isoValue < 0.5f) {
+            t += rayStep;
+        } else {
+            t += rayStep * (1.0f + (rayStep / 10.0f) - vol_sample / isoValue);
+        }
+    }
+
+    // Write results
+    imageStore(render_target_tx2D, pixel_coords, result);
+    imageStore(normal_target_tx2D, pixel_coords, vec4(normal, 1.0f));
+    imageStore(depth_target_tx2D, pixel_coords, vec4(depth));
+}
+
+/* function for storing default output values */
+void storeDefaults(const ivec2 pixel_coords) {
+    imageStore(render_target_tx2D, pixel_coords, vec4(0.0f));
+    imageStore(normal_target_tx2D, pixel_coords, vec4(0.0f));
+    imageStore(depth_target_tx2D, pixel_coords, vec4(FLT_MAX));
+}
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Output.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Output.glsl
new file mode 100644
index 000000000..402e9f949
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Output.glsl
@@ -0,0 +1,2 @@
+/* output image */
+layout(rgba32f, binding = 0) writeonly uniform highp image2D render_target_tx2D;
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute.glsl
new file mode 100644
index 000000000..1a380996d
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute.glsl
@@ -0,0 +1,31 @@
+/* main routine */
+layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
+
+void main() {
+    // Get pixel coordinates
+    vec3 gID = gl_GlobalInvocationID.xyz;
+    if (gID.x >= rt_resolution.x || gID.y >= rt_resolution.y) return;
+
+    ivec2 pixel_coords = ivec2(gID.xy);
+
+    // Generate ray
+    Ray ray = generateRay(pixel_coords);
+    float rayStep = voxelSize * rayStepRatio;
+    float rayOffset = wang_hash(pixel_coords.x + pixel_coords.y * uint(rt_resolution.x)) * rayStep;
+
+    // Require tnear or tfar to be positive, so that we can renderer from inside the box,
+    // but do not render if the box is completely behind the camera.
+    float tnear, tfar;
+
+    if (intersectBox(ray, boxMin, boxMax, tnear, tfar) && (tnear > 0.0f || tfar > 0.0f)) {
+        // Initialize ray start and randomly offset it to prevent ringing artifacts
+        float t = tnear >= 0.0f ? tnear : 0.0f;
+        t += rayOffset;
+
+        // Start computation by calling the function from the specialized shader
+        compute(t, tfar, ray, rayStep, pixel_coords);
+    } else {
+        // Store default values by calling the function from the specialized shader
+        storeDefaults(pixel_coords);
+    }
+}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Fragment-Aggr.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Fragment-Aggr.glsl
new file mode 100644
index 000000000..de953c336
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Fragment-Aggr.glsl
@@ -0,0 +1,22 @@
+uniform sampler2D src_tx2D;
+uniform sampler2D normal_tx2D;
+uniform sampler2D depth_tx2D;
+uniform sampler1D tf_tx1D;
+
+uniform vec2 valRange;
+
+in vec2 uv_coord;
+
+layout (location = 0) out vec4 frag_out;
+layout (location = 1) out vec4 normal_out;
+
+void main()
+{
+    frag_out = texture(src_tx2D, uv_coord);
+    vec4 vol_sample = texture(tf_tx1D, (frag_out.w - valRange.x) / (valRange.y - valRange.x));
+    frag_out = vec4(frag_out.xyz * (1.0f - vol_sample.w) + vol_sample.xyz * vol_sample.w, 1.0f);
+
+    normal_out = texture(normal_tx2D, uv_coord);
+
+    gl_FragDepth = texture(depth_tx2D, uv_coord).x;
+}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Fragment.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Fragment.glsl
new file mode 100644
index 000000000..7cde99f50
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Fragment.glsl
@@ -0,0 +1,16 @@
+uniform sampler2D src_tx2D;
+uniform sampler2D normal_tx2D;
+uniform sampler2D depth_tx2D;
+
+in vec2 uv_coord;
+
+layout (location = 0) out vec4 frag_out;
+layout (location = 1) out vec4 normal_out;
+
+void main()
+{
+    frag_out = texture(src_tx2D, uv_coord);
+    normal_out = texture(normal_tx2D, uv_coord);
+
+    gl_FragDepth = texture(depth_tx2D, uv_coord).x;
+}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Vertex.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Vertex.glsl
new file mode 100644
index 000000000..946885b57
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Vertex.glsl
@@ -0,0 +1,17 @@
+out vec2 uv_coord;
+
+void main()
+{
+    const vec4 vertices[6] = vec4[6](
+        vec4(-1.0, -1.0, 0.0, 0.0),
+        vec4( 1.0,  1.0, 1.0, 1.0),
+        vec4(-1.0,  1.0, 0.0, 1.0),
+        vec4( 1.0,  1.0, 1.0, 1.0),
+        vec4(-1.0, -1.0, 0.0, 0.0),
+        vec4( 1.0, -1.0, 1.0, 0.0));
+
+    const vec4 vertex = vertices[gl_VertexID];
+
+    uv_coord = vertex.zw;
+    gl_Position =  vec4(vertex.xy, -1.0, 1.0);
+}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer.btf b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer.btf
index 101b27261..eae925923 100644
--- a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer.btf
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer.btf
@@ -1,20 +1,48 @@
 <?xml version="1.0" encoding="utf-8"?>
 <btf type="MegaMolGLSLShader" version="1.0" namespace="RaycastVolumeRenderer">
-    <include file="common"/>
 
     <shader name="compute">
         <snippet type="version">430</snippet>
-        <snippet name="body" type="file">raycast_volume/raycast_volume_c.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Input.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Output.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Functions.glsl</snippet>
+        <snippet type="file">phong.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-DVR.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute.glsl</snippet>
+    </shader>
+
+    <shader name="compute_aggr">
+        <snippet type="version">430</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Input.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Output.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Functions.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Aggr.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute.glsl</snippet>
+    </shader>
+
+    <shader name="compute_iso">
+        <snippet type="version">430</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Input.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Output.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Functions.glsl</snippet>
+        <snippet type="file">phong.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Iso.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute.glsl</snippet>
     </shader>
 
     <shader name="vert">
         <snippet type="version">430</snippet>
-        <snippet name="body" type="file">raycast_volume/render_to_framebuffer_v.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Vertex.glsl</snippet>
     </shader>
 
     <shader name="frag">
         <snippet type="version">430</snippet>
-        <snippet name="body" type="file">raycast_volume/render_to_framebuffer_f.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Fragment.glsl</snippet>
+    </shader>
+
+    <shader name="frag_aggr">
+        <snippet type="version">430</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Fragment-Aggr.glsl</snippet>
     </shader>
 
 </btf>
diff --git a/plugins/mmstd_volume/Shaders/raycast_volume/raycast_volume_c.glsl b/plugins/mmstd_volume/Shaders/raycast_volume/raycast_volume_c.glsl
deleted file mode 100644
index ee82f5907..000000000
--- a/plugins/mmstd_volume/Shaders/raycast_volume/raycast_volume_c.glsl
+++ /dev/null
@@ -1,183 +0,0 @@
-#extension GL_ARB_compute_shader: enable
-#define FLT_MAX 3.402823466e+38
-#define FLT_MIN 1.175494351e-38
-
-/* matrix that transforms a set of coordinates from world space to volume texture space */
-uniform mat4 volume_model_mx;
-/* camera inverse view projection matrix */
-//uniform mat4 camera_inv_view_proj_mx;
-
-uniform mat4 view_mx;
-uniform mat4 proj_mx;
-
-/* render targete resolution*/
-uniform vec2 rt_resolution;
-/**/
-uniform vec3 boxMin;
-/**/
-uniform vec3 boxMax;
-/**/
-uniform float voxelSize;
-/**/
-uniform vec3 halfVoxelSize;
-uniform float rayStepRatio;
-/**/
-uniform float opacityThreshold;
-
-uniform vec2 valRange;
-
-/*	texture that houses the volume data */
-uniform highp sampler3D volume_tx3D;
-/* texture containing scene depth */
-uniform highp sampler2D depth_tx2D;
-/* texture containing transfer function */
-//uniform highp sampler2D transfer_function_tx2D;
-uniform highp sampler1D tf_tx1D;
-
-layout(rgba32f, binding = 0) writeonly uniform highp image2D render_target_tx2D;
-
-struct Ray {
-    vec3 o;
-    vec3 d;
-};
-
-bool intersectBox(Ray r, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar) {
-    vec3 invR = vec3(1.0f) / r.d;
-    vec3 tbot = invR * (boxmin - r.o);
-    vec3 ttop = invR * (boxmax - r.o);
-
-    // Special case for a ray lying in a bounding plane.
-    if (r.d.x == 0.0f && r.o.x == boxmax.x) {
-        ttop.x = -FLT_MAX;
-        tbot.x = FLT_MAX;
-    }
-    if (r.d.y == 0.0f && r.o.y == boxmax.y) {
-        ttop.y = -FLT_MAX;
-        tbot.y = FLT_MAX;
-    }
-    if (r.d.z == 0.0f && r.o.z == boxmax.z) {
-        ttop.z = -FLT_MAX;
-        tbot.z = FLT_MAX;
-    }
-
-    vec3 tmin = min(ttop, tbot);
-    vec3 tmax = max(ttop, tbot);
-
-    float largest_tmin = max(max(tmin.x, tmin.y), max(tmin.x, tmin.z));
-    float smallest_tmax = min(min(tmax.x, tmax.y), min(tmax.x, tmax.z));
-
-    tnear = largest_tmin;
-    tfar = smallest_tmax;
-
-    return smallest_tmax > largest_tmin;
-}
-
-/////////////////////////////// Random Number Generator
-float wang_hash(uint seed) {
-    seed = (seed ^ 61) ^ (seed >> 16);
-    seed *= 9;
-    seed = seed ^ (seed >> 4);
-    seed *= 0x27d4eb2d;
-    seed = seed ^ (seed >> 15);
-
-    return float(seed) / 4294967296.0;
-}
-/////////////////////////////// End - Random Number Generator
-
-layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
-
-void main() {
-    vec3 gID = gl_GlobalInvocationID.xyz;
-
-    if (gID.x >= rt_resolution.x || gID.y >= rt_resolution.y) return;
-
-    ivec2 pixel_coords = ivec2(gID.xy);
-
-    vec2 clip_space_pixel_coords =
-        vec2((gID.x / rt_resolution.x) * 2.0f - 1.0f, (gID.y / rt_resolution.y) * 2.0f - 1.0f);
-
-    Ray ray;
-    // Unproject a point on the near plane and use as an origin.
-    mat4 inv_view_proj_mx = inverse(proj_mx * view_mx);
-    vec4 unproj = inv_view_proj_mx * vec4(clip_space_pixel_coords, -1.0f, 1.0f);
-    ray.o = unproj.xyz / unproj.w;
-    // Unproject a point at the same pixel, but further away from the near plane
-    // to compute a ray direction in world space.
-    unproj = inv_view_proj_mx * vec4(clip_space_pixel_coords, 0.0f, 1.0f);
-    ray.d = normalize((unproj.xyz / unproj.w) - ray.o);
-
-    // Just for safety.
-    // Box diagonal is sqrt(3) times longer.
-    float rayStep = voxelSize * rayStepRatio;
-    vec3 box_range = boxMax - boxMin;
-    float max_bbox_length = max(max(box_range.x, box_range.y), box_range.z);
-    //int maxSteps = int((1.0f / rayStep) * 1.74f * 2.0f * max_bbox_length); // todo
-
-    // Generate a random value in [0, 1] range.
-    // float randomTemp = sin(dot(vec2(pixel_coords.y * rt_resolution.x + pixel_coords.x), vec2(12.9898f, 78.233f))) *
-    // 43758.5453f; float random = abs(randomTemp - floor(randomTemp));
-    float random = wang_hash(pixel_coords.x + pixel_coords.y * uint(rt_resolution.x));
-
-    float tnear, tfar;
-
-    // Require tnear or tfar to be positive, so that we can renderer from inside the box,
-    // but do not render if the box is completely behind the camera.
-    if (intersectBox(ray, boxMin, boxMax, tnear, tfar) && (tnear > 0.0f || tfar > 0.0f)) {
-        float t = tnear >= 0.0f ? tnear : 0.0f;
-        t += random * rayStep; // Randomly offset the ray origin to prevent ringing artifacts
-        vec4 result = vec4(0.0f);
-        int steps = 0;
-
-        while (t < tfar && result.w < opacityThreshold /*&& steps < maxSteps*/) {
-            vec3 pos = ray.o + t * ray.d;
-            // Compute volume tex coordinates in [0,1] range.
-            vec3 texCoords = (pos - boxMin) / (boxMax - boxMin);
-            texCoords *= 1.0 - 2.0 * halfVoxelSize;
-            texCoords += halfVoxelSize;
-
-            //vec4 vol_sample = texture(transfer_function_tx2D, vec2(texture(volume_tx3D, texCoords).x, 1));
-            vec4 vol_sample = texture(tf_tx1D, (texture(volume_tx3D, texCoords).x - valRange.x)/valRange.y);
-            
-            // vec4 vol_sample = texture(volume_tx3D,texCoords);
-            // vol_sample.w = vol_sample.x;
-
-            // Opacity correction.
-            vol_sample.w = (1.0f - pow(1.0f - vol_sample.w, rayStepRatio));
-            // TF "Brightness". Make sure to not over-saturate the opacity.
-            // (Which will lead to color oversaturation.)
-            // vol_sample.w = min(vol_sample.w * cSeriesDesc.BrightnessPerSeries[series], 1.0f)
-            vol_sample.xyz *= vol_sample.w;
-            // if (useLighting)
-            //{
-            //    vec3 gradient = fetchGradientEstimate(cVolumesToRender.List[series],
-            //                                            cSeriesDesc.ComponentsPerSeries[series],
-            //                                            cTfs.List[series],
-            // texCoords,
-                //                                            rayStep * 8.0f);
-                //    float3 normal = normalize(-gradient);
-                //    float3 lightDir = normalize(cLightDesc.Pos - pos);
-                //    float lambert = max(0.0f, dot(normal, lightDir));
-                //    float3 lightColorContribution = cLightDesc.Color * cLightDesc.Intensity * lambert;
-                //    float3 surfaceColor = make_float3(mappedSample)
-                //    mappedSample += make_float4(surfaceColor * lightColorContribution, 0.0f);
-                //}
-
-                result += (1.0f - result.w) * vol_sample;
-
-            steps++;
-            t += rayStep;
-        }
-
-        // Blend with white background. (Helps to make the renderings look more consistent.)
-        // todo Is this correct? What if bg was transparent? The result would change with this formula.
-        // result = (result.w) * result + vec4(1.0f,0.0,0.0,0.0) * (1.0f - result.w);
-        // result.w = 1.0f;
-        imageStore(render_target_tx2D, pixel_coords, result);
-
-        // debug
-        // imageStore(render_target_tx2D,pixel_coords,vec4(1.0));
-    } else {
-        // Always write out to make sure that data from the previous frame is overwritten.
-        imageStore(render_target_tx2D, pixel_coords, vec4(0.0));
-    }
-}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/Shaders/raycast_volume/render_to_framebuffer_f.glsl b/plugins/mmstd_volume/Shaders/raycast_volume/render_to_framebuffer_f.glsl
deleted file mode 100644
index 65a761c90..000000000
--- a/plugins/mmstd_volume/Shaders/raycast_volume/render_to_framebuffer_f.glsl
+++ /dev/null
@@ -1,10 +0,0 @@
-uniform sampler2D src_tx2D;
-
-in vec2 uv_coord;
-
-out vec4 frag_out;
-
-void main()
-{
-    frag_out = texture(src_tx2D,uv_coord);
-}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/Shaders/raycast_volume/render_to_framebuffer_v.glsl b/plugins/mmstd_volume/Shaders/raycast_volume/render_to_framebuffer_v.glsl
deleted file mode 100644
index e036f7b3a..000000000
--- a/plugins/mmstd_volume/Shaders/raycast_volume/render_to_framebuffer_v.glsl
+++ /dev/null
@@ -1,16 +0,0 @@
-out vec2 uv_coord;
-
-void main()
-{
-	const vec4 vertices[6] = vec4[6]( vec4( -1.0,-1.0,0.0,0.0 ),
-									vec4( 1.0,1.0,1.0,1.0 ),
-									vec4( -1.0,1.0,0.0,1.0 ),
-									vec4( 1.0,1.0,1.0,1.0 ),
-									vec4( -1.0,-1.0,0.0,0.0 ),
-                                	vec4( 1.0,-1.0,1.0,0.0 ) );
-
-	vec4 vertex = vertices[gl_VertexID];
-	
-	uv_coord = vertex.zw;
-	gl_Position =  vec4(vertex.xy, -1.0, 1.0);
-}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/src/DifferenceVolume.cpp b/plugins/mmstd_volume/src/DifferenceVolume.cpp
new file mode 100644
index 000000000..8247d8a7f
--- /dev/null
+++ b/plugins/mmstd_volume/src/DifferenceVolume.cpp
@@ -0,0 +1,514 @@
+/*
+ * DifferenceVolume.cpp
+ *
+ * Copyright (C) 2019 by Visualisierungsinstitut der Universitt Stuttgart.
+ * Alle rechte vorbehalten.
+ */
+
+#include "stdafx.h"
+#include "DifferenceVolume.h"
+
+#include <limits>
+
+#include "mmcore/param/BoolParam.h"
+
+#include "vislib/sys/Log.h"
+
+
+/*
+ * megamol::stdplugin::volume::DifferenceVolume::DifferenceVolume
+ */
+megamol::stdplugin::volume::DifferenceVolume::DifferenceVolume(void)
+        : frameID((std::numeric_limits<unsigned int>::max)()),
+        frameIdx(0),
+        hashData((std::numeric_limits<std::size_t>::max)()),
+        hashState((std::numeric_limits<std::size_t>::max)()),
+        paramIgnoreInputHash("ignoreInputHash", "Instructs the module not to honour the input hash when checking for updates."),
+        slotIn("in", "The input slot providing the volume data."),
+        slotOut("out", "The output slot receiving the difference.") {
+    using core::misc::VolumetricDataCall;
+
+    this->slotIn.SetCompatibleCall<
+        core::factories::CallAutoDescription<VolumetricDataCall>>();
+    this->MakeSlotAvailable(&this->slotIn);
+
+    this->slotOut.SetCallback(VolumetricDataCall::ClassName(),
+        VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_DATA),
+        &DifferenceVolume::onGetData);
+    this->slotOut.SetCallback(VolumetricDataCall::ClassName(),
+        VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_EXTENTS),
+        &DifferenceVolume::onGetExtents);
+    this->slotOut.SetCallback(VolumetricDataCall::ClassName(),
+        VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_METADATA),
+        &DifferenceVolume::onGetMetadata);
+    this->slotOut.SetCallback(VolumetricDataCall::ClassName(),
+        VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_START_ASYNC),
+        &DifferenceVolume::onUnsupported);
+    this->slotOut.SetCallback(VolumetricDataCall::ClassName(),
+        VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_STOP_ASYNC),
+        &DifferenceVolume::onUnsupported);
+    this->slotOut.SetCallback(VolumetricDataCall::ClassName(),
+        VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_TRY_GET_DATA),
+        &DifferenceVolume::onUnsupported);
+    this->MakeSlotAvailable(&this->slotOut);
+
+    this->paramIgnoreInputHash << new core::param::BoolParam(false);
+    this->MakeSlotAvailable(&this->paramIgnoreInputHash);
+}
+
+
+/*
+ * megamol::stdplugin::volume::DifferenceVolume::~DifferenceVolume
+ */
+megamol::stdplugin::volume::DifferenceVolume::~DifferenceVolume(void) {
+    this->Release();
+}
+
+
+/*
+ * megamol::stdplugin::volume::DifferenceVolume::getFrameSize
+ */
+std::size_t megamol::stdplugin::volume::DifferenceVolume::getFrameSize(
+        const core::misc::VolumetricMetadata_t& md) {
+    auto retval = md.Resolution[0] * md.Resolution[1] * md.Resolution[2];
+    retval *= md.ScalarLength;
+    retval *= md.Components;
+    return retval;
+}
+
+
+/*
+ * megamol::stdplugin::volume::DifferenceVolume::getDifferenceType
+ */
+megamol::core::misc::ScalarType_t
+megamol::stdplugin::volume::DifferenceVolume::getDifferenceType(
+        const core::misc::VolumetricMetadata_t& md) {
+    switch (md.ScalarType) {
+        case core::misc::SIGNED_INTEGER:
+        case core::misc::FLOATING_POINT:
+            // Can be used as it is.
+            return md.ScalarType;
+
+        case core::misc::UNSIGNED_INTEGER:
+            // unsigned must become signed.
+            return core::misc::SIGNED_INTEGER;
+
+        default:
+            // Anything else is unsupported.
+            return core::misc::UNKNOWN;
+    }
+}
+
+
+/*
+ * megamol::stdplugin::volume::DifferenceVolume::checkCompatibility
+ */
+bool megamol::stdplugin::volume::DifferenceVolume::checkCompatibility(
+        const core::misc::VolumetricMetadata_t& md) const {
+    using vislib::sys::Log;
+    auto reqType = getDifferenceType(md);
+
+    if (getFrameSize(this->metadata) != getFrameSize(md)) {
+        Log::DefaultLog.WriteError(L"The volume resolution must not change "
+            "over time in order for %hs to work.",
+            DifferenceVolume::ClassName());
+        return false;
+    }
+
+    if ((this->metadata.ScalarLength != md.ScalarLength)
+            && (md.ScalarType == reqType)) {
+        Log::DefaultLog.WriteError(L"The scalar size must not change over time "
+            "in order for %hs to work.",
+            DifferenceVolume::ClassName());
+        return false;
+    }
+
+    if (this->metadata.ScalarType != reqType) {
+        Log::DefaultLog.WriteError(L"The scalar type must not change over time "
+            "in order for %hs to work.",
+            DifferenceVolume::ClassName());
+        return false;
+    }
+
+    return true;
+}
+
+
+/*
+ * megamol::stdplugin::volume::DifferenceVolume::create
+ */
+bool megamol::stdplugin::volume::DifferenceVolume::create(void) {
+    return true;
+}
+
+
+/*
+ * megamol::stdplugin::volume::DifferenceVolume::onGetData
+ */
+bool megamol::stdplugin::volume::DifferenceVolume::onGetData(core::Call& call) {
+    using core::misc::VolumetricDataCall;
+    using core::param::BoolParam;
+    using vislib::sys::Log;
+
+    auto dst = dynamic_cast<VolumetricDataCall *>(&call);
+    auto src = this->slotIn.CallAs<VolumetricDataCall>();
+    const auto localUpdate = this->paramIgnoreInputHash.IsDirty();
+    const auto ignoreHash = this->paramIgnoreInputHash.Param<BoolParam>()->Value();
+
+    /* Sanity checks. */
+    if (dst == nullptr) {
+        Log::DefaultLog.WriteError(L"Call %hs of %hs received a wrong request.",
+            VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_DATA),
+            DifferenceVolume::ClassName());
+        return false;
+    }
+
+    if (src == nullptr) {
+        Log::DefaultLog.WriteError(L"Call %hs of %hs has a wrong source.",
+            VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_DATA),
+            DifferenceVolume::ClassName());
+        return false;
+    }
+
+    /* Retrieve info about incoming data and pass it on to the caller. */
+    *src = *dst;
+    src->SetFrameID(dst->FrameID(), true);  // Use the force!
+    assert(src->IsFrameForced());
+    if (!VolumetricDataCall::GetMetadata(*src)) {
+        return false;
+    }
+    *dst = *src;
+
+    /* Establish what acceptable data are if the source changed. */
+    if (localUpdate || (!ignoreHash && (this->hashData != src->DataHash()))) {
+        Log::DefaultLog.WriteInfo(L"Volume data or local configuration have "
+            L"changed, resetting reference for difference computation.");
+
+        /* Check for compatibility of the incoming data. */
+        if (src->GetMetadata()->GridType != core::misc::CARTESIAN) {
+            Log::DefaultLog.WriteError(L"%hs is only supported for Cartesian "
+                L"grids.", DifferenceVolume::ClassName());
+            return false;
+        }
+
+        switch (src->GetMetadata()->ScalarType) {
+            case core::misc::SIGNED_INTEGER:
+            case core::misc::UNSIGNED_INTEGER:
+            case core::misc::FLOATING_POINT:
+                break;
+
+            default:
+                Log::DefaultLog.WriteError(L"%hs is not supported for scalar "
+                    "type %u.", DifferenceVolume::ClassName(),
+                    src->GetMetadata()->ScalarType);
+                return false;
+        }
+
+        /* Everything is OK at this point, save the reference data. */
+        this->metadata = *src->GetMetadata();
+
+        /* Reset the caching state. */
+        this->frameID = (std::numeric_limits<unsigned int>::max)();
+        this->frameIdx = 0;
+        this->hashData = src->DataHash();
+
+        /* Mark local state as unchanged. */
+        if (localUpdate) {
+            this->paramIgnoreInputHash.ResetDirty();
+        }
+    }
+
+    /* If the data we have need an update, compute it. */
+    if (this->frameID != src->FrameID()) {
+        Log::DefaultLog.WriteInfo(L"%hs is rebuilding the volume.",
+            DifferenceVolume::ClassName());
+
+        if (!VolumetricDataCall::GetMetadata(*src)) {
+            return false;
+        }
+
+        /* Check that the format is the same. */
+        if (!this->checkCompatibility(*src->GetMetadata())) {
+            return false;
+        }
+
+        if (!(*src)(VolumetricDataCall::IDX_GET_DATA)) {
+            Log::DefaultLog.WriteError(L"%hs failed to call %hs.",
+                DifferenceVolume::ClassName(),
+                VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_DATA));
+            return false;
+        }
+
+        /* Prepare a cache location for the current frame. */
+        auto& cur = this->cache[this->frameIdx];
+        cur.resize(src->GetFrameSize());
+        ::memcpy(cur.data(), src->GetData(), src->GetFrameSize());
+
+        /* Select the potential previous frame. */
+        auto& prev = this->cache[increment(this->frameIdx)];
+
+        /* Prepare the data storage. */
+        this->data.resize(cur.size());
+
+        if (src->FrameID() < 1) {
+            /* There is no predecessor, so the frame is the difference. */
+            Log::DefaultLog.WriteInfo(L"The data provided to %hs do not have a "
+                L"predecessor. The previous volume is considered to be zero.",
+                DifferenceVolume::ClassName());
+            auto& prev = this->cache[increment(this->frameIdx)];
+            prev.resize(cur.size());
+            ::memset(prev.data(), 0, prev.size());
+
+        } else if (src->FrameID() - 1 != this->frameID) {
+            /* We do not have the previous frame cached, so get it. */
+            Log::DefaultLog.WriteInfo(L"Load previous frame %u to compute the "
+                L"difference to the current one.", src->FrameID() - 1);
+            src->SetFrameID(src->FrameID() - 1, true);
+            if (!VolumetricDataCall::GetMetadata(*src)) {
+                return false;
+            }
+
+            /* Check that the format is the same. */
+            if (!this->checkCompatibility(*src->GetMetadata())) {
+                return false;
+            }
+
+            assert(src->IsFrameForced());
+            if (!(*src)(VolumetricDataCall::IDX_GET_DATA)) {
+                Log::DefaultLog.WriteError(L"%hs failed to call %hs.",
+                    DifferenceVolume::ClassName(),
+                    VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_DATA));
+                    return false;
+            }
+
+            prev.resize(src->GetFrameSize());
+            ::memcpy(cur.data(), src->GetData(), src->GetFrameSize());
+        }
+        /* At this point, 'prev' contains the previous frame. */
+        assert(cur.size() == this->data.size());
+        assert(prev.size() == this->data.size());
+
+        /* Do the conversion depending on the type of the data.*/
+        switch (this->metadata.ScalarType) {
+            case core::misc::SIGNED_INTEGER:
+                switch (this->metadata.ScalarLength) {
+                    case 1: {
+                        auto c = reinterpret_cast<std::int8_t *>(cur.data());
+                        auto p = reinterpret_cast<std::int8_t *>(prev.data());
+                        auto d = reinterpret_cast<std::int8_t *>(this->data.data());
+                        this->calcDifference(d, c, p, cur.size() / sizeof(*c));
+                        } break;
+
+                    case 2: {
+                        auto c = reinterpret_cast<std::int16_t *>(cur.data());
+                        auto p = reinterpret_cast<std::int16_t *>(prev.data());
+                        auto d = reinterpret_cast<std::int16_t *>(this->data.data());
+                        this->calcDifference(d, c, p, cur.size() / sizeof(*c));
+                        } break;
+
+                    case 4: {
+                        auto c = reinterpret_cast<std::int32_t *>(cur.data());
+                        auto p = reinterpret_cast<std::int32_t *>(prev.data());
+                        auto d = reinterpret_cast<std::int32_t *>(this->data.data());
+                        this->calcDifference(d, c, p, cur.size() / sizeof(*c));
+                        } break;
+
+                    case 8: {
+                        auto c = reinterpret_cast<std::int64_t *>(cur.data());
+                        auto p = reinterpret_cast<std::int64_t *>(prev.data());
+                        auto d = reinterpret_cast<std::int64_t *>(this->data.data());
+                        this->calcDifference(d, c, p, cur.size() / sizeof(*c));
+                        } break;
+
+                    default:
+                        Log::DefaultLog.WriteError(L"%hs cannot process "
+                            L"%u-byte SIGNED_INTEGER data.",
+                            DifferenceVolume::ClassName(),
+                            this->metadata.ScalarLength);
+                        return false;
+                }
+                break;
+
+            case core::misc::UNSIGNED_INTEGER:
+                // HAZARD: unsigned-to-signed conversion is untested!
+                switch (this->metadata.ScalarLength) {
+                    case 1: {
+                        auto c = (cur.data());
+                        auto p = (prev.data());
+                        this->data.resize(2 * this->data.size());
+                        this->metadata.ScalarLength = 2 * src->GetMetadata()->ScalarLength;
+                        auto d = reinterpret_cast<std::int16_t *>(this->data.data());
+                        this->calcDifference(d, c, p, cur.size() / sizeof(*c));
+                        } break;
+
+                    case 2: {
+                        auto c = reinterpret_cast<std::uint16_t *>(cur.data());
+                        auto p = reinterpret_cast<std::uint16_t *>(prev.data());
+                        this->data.resize(2 * this->data.size());
+                        this->metadata.ScalarLength = 2 * src->GetMetadata()->ScalarLength;
+                        auto d = reinterpret_cast<std::int32_t *>(this->data.data());
+                        this->calcDifference(d, c, p, cur.size() / sizeof(*c));
+                        } break;
+
+                    case 4: {
+                        auto c = reinterpret_cast<std::uint32_t *>(cur.data());
+                        auto p = reinterpret_cast<std::uint32_t *>(prev.data());
+                        this->data.resize(2 * this->data.size());
+                        this->metadata.ScalarLength = 2 * src->GetMetadata()->ScalarLength;
+                        auto d = reinterpret_cast<std::int64_t *>(this->data.data());
+                        this->calcDifference(d, c, p, cur.size() / sizeof(*c));
+                        } break;
+
+                    case 8: {
+                        Log::DefaultLog.WriteWarn(L"Conversion from UINT64 "
+                            L"to INT64 in %hs might cause data truncation.",
+                            DifferenceVolume::ClassName());
+                        auto c = reinterpret_cast<std::uint64_t *>(cur.data());
+                        auto p = reinterpret_cast<std::uint64_t *>(prev.data());
+                        auto d = reinterpret_cast<std::int64_t *>(this->data.data());
+                        this->calcDifference(d, c, p, cur.size() / sizeof(*c));
+                        } break;
+
+                    default:
+                        Log::DefaultLog.WriteError(L"%hs cannot process "
+                            L"%u-byte UNSIGNED_INTEGER data.",
+                            DifferenceVolume::ClassName(),
+                            this->metadata.ScalarLength);
+                        return false;
+                }
+                break;
+
+            case core::misc::FLOATING_POINT:
+                switch (this->metadata.ScalarLength) {
+                    case 4: {
+                        auto c = reinterpret_cast<float *>(cur.data());
+                        auto p = reinterpret_cast<float *>(prev.data());
+                        auto d = reinterpret_cast<float *>(this->data.data());
+                        this->calcDifference(d, c, p, cur.size() / sizeof(*c));
+                        } break;
+
+                    case 8: {
+                        auto c = reinterpret_cast<double *>(cur.data());
+                        auto p = reinterpret_cast<double *>(prev.data());
+                        auto d = reinterpret_cast<double *>(this->data.data());
+                        this->calcDifference(d, c, p, cur.size() / sizeof(*c));
+                        } break;
+
+                    default:
+                        Log::DefaultLog.WriteError(L"%hs cannot process "
+                            L"%u-byte FLOATING_POINT data.",
+                            DifferenceVolume::ClassName(),
+                            this->metadata.ScalarLength);
+                        return false;
+                }
+                break;
+
+            default:
+                assert(false);  // This should not be reachable.
+                return false;
+        }
+
+        this->frameID = src->FrameID();
+        this->frameIdx = increment(this->frameIdx);
+    } /* end if (this->frameID != src->FrameID()) */
+
+    dst->SetData(this->data.data());
+    dst->SetMetadata(&this->metadata);
+
+    dst->SetDataHash(this->getHash());
+    return true;
+}
+
+
+/*
+ * megamol::stdplugin::volume::DifferenceVolume::onGetExtents
+ */
+bool megamol::stdplugin::volume::DifferenceVolume::onGetExtents(core::Call& call) {
+    using core::misc::VolumetricDataCall;
+    using vislib::sys::Log;
+
+    auto dst = dynamic_cast<VolumetricDataCall *>(&call);
+    auto src = this->slotIn.CallAs<VolumetricDataCall>();
+
+    if (dst == nullptr) {
+        Log::DefaultLog.WriteError(L"Call %hs of %hs received a wrong request.",
+            VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_EXTENTS),
+            DifferenceVolume::ClassName());
+        return false;
+    }
+
+    if (src == nullptr) {
+        Log::DefaultLog.WriteError(L"Call %hs of %hs has a wrong source.",
+            VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_EXTENTS),
+            DifferenceVolume::ClassName());
+        return false;
+    }
+
+    *src = *dst;
+    if (!(*src)(VolumetricDataCall::IDX_GET_EXTENTS)) {
+        Log::DefaultLog.WriteError(L"%hs failed to call %hs.",
+            DifferenceVolume::ClassName(),
+            VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_EXTENTS));
+        return false;
+    }
+    *dst = *src;
+
+    dst->SetDataHash(this->getHash());
+    return true;
+}
+
+
+/*
+ * megamol::stdplugin::volume::DifferenceVolume::onGetMetadata
+ */
+bool megamol::stdplugin::volume::DifferenceVolume::onGetMetadata(
+        core::Call& call) {
+    using core::misc::VolumetricDataCall;
+    using vislib::sys::Log;
+
+    auto dst = dynamic_cast<VolumetricDataCall *>(&call);
+    auto src = this->slotIn.CallAs<VolumetricDataCall>();
+
+    if (dst == nullptr) {
+        Log::DefaultLog.WriteError(L"Call %hs of %hs received a wrong request.",
+            VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_METADATA),
+            DifferenceVolume::ClassName());
+        return false;
+    }
+
+    if (src == nullptr) {
+        Log::DefaultLog.WriteError(L"Call %hs of %hs has a wrong source.",
+            VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_METADATA),
+            DifferenceVolume::ClassName());
+        return false;
+    }
+
+    *src = *dst;
+    if (!VolumetricDataCall::GetMetadata(*src)) {
+        return false;
+    }
+    *dst = *src;
+
+    dst->SetDataHash(this->getHash());
+    return true;
+}
+
+
+/*
+ * megamol::stdplugin::volume::DifferenceVolume::onUnsupported
+ */
+bool megamol::stdplugin::volume::DifferenceVolume::onUnsupported(
+        core::Call& call) {
+    return false;
+}
+
+
+/*
+ * megamol::stdplugin::volume::DifferenceVolume::release
+ */
+void megamol::stdplugin::volume::DifferenceVolume::release(void) {
+    for (auto& c : this->cache) {
+        c.clear();
+    }
+    this->data.clear();
+}
diff --git a/plugins/mmstd_volume/src/DifferenceVolume.h b/plugins/mmstd_volume/src/DifferenceVolume.h
new file mode 100644
index 000000000..97b350cb7
--- /dev/null
+++ b/plugins/mmstd_volume/src/DifferenceVolume.h
@@ -0,0 +1,182 @@
+/*
+ * DifferenceVolume.h
+ *
+ * Copyright (C) 2019 by Visualisierungsinstitut der Universitt Stuttgart.
+ * Alle Rechte vorbehalten.
+ */
+
+#pragma once
+
+#include <array>
+#include <vector>
+
+#include "mmcore/misc/VolumetricDataCall.h"
+#include "mmcore/misc/VolumetricMetadataStore.h"
+
+#include "mmcore/param/ParamSlot.h"
+
+#include "mmcore/Call.h"
+#include "mmcore/CalleeSlot.h"
+#include "mmcore/CallerSlot.h"
+#include "mmcore/Module.h"
+
+
+namespace megamol {
+namespace stdplugin {
+namespace volume {
+
+    /**
+     * Computes the difference between two time steps of a volumetric data
+     * source.
+     */
+    class DifferenceVolume : public core::Module {
+
+    public:
+
+        /**
+         * Answer the name of this module.
+         *
+         * @return The name of this module.
+         */
+        static inline constexpr const char* ClassName(void) {
+            return "DifferenceVolume";
+        }
+
+        /**
+         * Answer a human readable description of this module.
+         *
+         * @return A human readable description of this module.
+         */
+        static inline constexpr const char* Description(void) {
+            return "Computes the difference between volumes.";
+        }
+
+        /**
+         * Answers whether this module is available on the current system.
+         *
+         * @return 'true' if the module is available, 'false' otherwise.
+         */
+        static inline constexpr bool IsAvailable(void) {
+            return true;
+        }
+
+        /**
+         * Initialises a new instance.
+         */
+        DifferenceVolume(void);
+
+        /**
+         * Finalises an instance.
+         */
+        virtual ~DifferenceVolume(void);
+
+    protected:
+
+        /**
+         * Compute the size of a single frame in bytes.
+         */
+        static std::size_t getFrameSize(
+            const core::misc::VolumetricMetadata_t& md);
+
+        /**
+         * Gets the scalar type to be used for the difference volume.
+         */
+        static core::misc::ScalarType_t getDifferenceType(
+            const core::misc::VolumetricMetadata_t& md);
+
+        /**
+         * Increment the cache ring index.
+         */
+        static inline std::size_t increment(std::size_t frameIdx) {
+            return (++frameIdx % 2);
+        }
+
+        /**
+         * Compute the difference from 'prev' to 'cur' into 'dst'.
+         */
+        template<class D, class S>
+        void calcDifference(D *dst, const S *cur, const S *prev,
+            const std::size_t cnt);
+
+        /**
+         * Check whether the given metadata are compatible with the cache state
+         * of the module.
+         */
+        bool checkCompatibility(const core::misc::VolumetricMetadata_t& md) const;
+
+        /**
+         * Implementation of 'Create'.
+         *
+         * @return 'true' on success, 'false' otherwise.
+         */
+        virtual bool create(void);
+
+        /**
+         * Computes the hash of 'data'.
+         *
+         * @return The hash of the currently available data.
+         */
+        inline std::size_t getHash(void) {
+            auto retval = this->hashData;
+            retval ^= this->hashState + 0x9e3779b9 + (retval << 6)
+                + (retval >> 2);
+            return retval;
+        }
+
+        /**
+         * Gets the data from the source.
+         *
+         * @param caller The calling call.
+         *
+         * @return 'true' on success, 'false' on failure.
+         */
+        bool onGetData(core::Call& call);
+
+        /**
+         * Gets the data extents.
+         *
+         * @param caller The calling call.
+         *
+         * @return 'true' on success, 'false' on failure.
+         */
+        bool onGetExtents(core::Call& call);
+
+        /**
+         * Gets the meta data.
+         *
+         * @param caller The calling call.
+         *
+         * @return 'true' on success, 'false' on failure.
+         */
+        bool onGetMetadata(core::Call& call);
+
+        /**
+         * Callback for all unsupported operations.
+         */
+        bool onUnsupported(core::Call& call);
+
+        /**
+         * Clean up module.
+         */
+        virtual void release(void) override;
+
+    private:
+
+        std::array<std::vector<std::uint8_t>, 2> cache;
+        std::vector<std::uint8_t> data;
+        unsigned int frameID;
+        std::size_t frameIdx;
+        std::size_t hashData;
+        std::size_t hashState;
+        core::misc::VolumetricMetadataStore metadata;
+        core::param::ParamSlot paramIgnoreInputHash;
+        core::CallerSlot slotIn;
+        core::CalleeSlot slotOut;
+
+    };
+
+} /* end namespace volume */
+} /* namespace stdplugin */
+} /* namespace megamol */
+
+#include "DifferenceVolume.inl"
diff --git a/plugins/mmstd_volume/src/DifferenceVolume.inl b/plugins/mmstd_volume/src/DifferenceVolume.inl
new file mode 100644
index 000000000..4a06a0d54
--- /dev/null
+++ b/plugins/mmstd_volume/src/DifferenceVolume.inl
@@ -0,0 +1,36 @@
+/*
+ * DifferenceVolume.inl
+ *
+ * Copyright (C) 2019 by Visualisierungsinstitut der Universitt Stuttgart.
+ * Alle Rechte vorbehalten.
+ */
+
+
+/*
+ * megamol::stdplugin::volume::DifferenceVolume::calcDifference
+ */
+template<class D, class S>
+void megamol::stdplugin::volume::DifferenceVolume::calcDifference(D *dst,
+        const S *cur, const S *prev, const std::size_t cnt) {
+//#pragma omp parallel for
+//    for (std::size_t i = 0; i < cnt; ++i) {
+//        dst[i] = static_cast<D>(cur[i]) - static_cast<D>(prev[i]);
+//    }
+
+    const auto components = this->metadata.Components;
+
+    for (std::size_t i = 0; i < components; ++i) {
+        this->metadata.MinValues[i] = (std::numeric_limits<double>::max)();
+        this->metadata.MaxValues[i] = std::numeric_limits<double>::lowest();
+    }
+
+    for (std::size_t i = 0; i < cnt; ++i) {
+        dst[i] = static_cast<D>(cur[i]) - static_cast<D>(prev[i]);
+        if (dst[i] < this->metadata.MinValues[i % components]) {
+            this->metadata.MinValues[i % components] = dst[i];
+        }
+        if (dst[i] > this->metadata.MaxValues[i % components]) {
+            this->metadata.MaxValues[i % components] = dst[i];
+        }
+    }
+}
diff --git a/plugins/mmstd_volume/src/RaycastVolumeRenderer.cpp b/plugins/mmstd_volume/src/RaycastVolumeRenderer.cpp
index 4386318fe..c3381bfe9 100644
--- a/plugins/mmstd_volume/src/RaycastVolumeRenderer.cpp
+++ b/plugins/mmstd_volume/src/RaycastVolumeRenderer.cpp
@@ -7,33 +7,120 @@
 
 #include "RaycastVolumeRenderer.h"
 
-#include <array>
-
-#include "vislib/graphics/gl/ShaderSource.h"
+#include "linmath.h"
 
 #include "mmcore/CoreInstance.h"
 #include "mmcore/misc/VolumetricDataCall.h"
+#include "mmcore/param/BoolParam.h"
+#include "mmcore/param/ColorParam.h"
+#include "mmcore/param/EnumParam.h"
 #include "mmcore/param/FloatParam.h"
+#include "mmcore/utility/ScaledBoundingBoxes.h"
+#include "mmcore/view/AbstractRenderingView.h"
 #include "mmcore/view/CallGetTransferFunction.h"
+#include "mmcore/view/CallRender3D.h"
 
-#include "linmath.h"
+#include "vislib/graphics/gl/ShaderSource.h"
+
+#include "glowl/Texture.hpp"
+#include "glowl/Texture2D.hpp"
+#include "glowl/Texture3D.hpp"
+
+#include <algorithm>
+#include <array>
+#include <cmath>
+#include <limits>
+#include <memory>
+#include <vector>
+#include <iostream>
 
 using namespace megamol::stdplugin::volume;
 
 RaycastVolumeRenderer::RaycastVolumeRenderer()
     : Renderer3DModule()
+    , m_mode("mode", "Mode changing the behavior for the raycaster")
+    , m_ray_step_ratio_param("ray step ratio", "Adjust sampling rate")
+    , m_use_lighting_slot("lighting::use lighting", "Enable simple volumetric illumination")
+    , m_ka_slot("lighting::ka", "Ambient part for Phong lighting")
+    , m_kd_slot("lighting::kd", "Diffuse part for Phong lighting")
+    , m_ks_slot("lighting::ks", "Specular part for Phong lighting")
+    , m_shininess_slot("lighting::shininess", "Shininess for Phong lighting")
+    , m_ambient_color("lighting::ambient color", "Ambient color")
+    , m_specular_color("lighting::specular color", "Specular color")
+    , m_light_color("lighting::light color", "Light color")
+    , m_material_color("lighting::material color", "Material color")
+    , m_opacity_threshold("opacity threshold", "Opacity threshold for integrative rendering")
+    , m_iso_value("isovalue", "Isovalue for isosurface rendering")
+    , m_opacity("opacity", "Surface opacity for blending")
+    , paramOverride("override::enable", "Enable override of range")
+    , paramMinOverride("override::min", "Override the minimum value provided by the data set")
+    , paramMaxOverride("override::max", "Override the maximum value provided by the data set")
+    , m_renderer_callerSlot("Renderer", "Renderer for chaining")
     , m_volumetricData_callerSlot("getData", "Connects the volume renderer with a voluemtric data source")
-    , m_transferFunction_callerSlot("getTranfserFunction", "Connects the volume renderer with a transfer function")
-    , m_ray_step_ratio_param("ray step ratio", "") {
+    , m_transferFunction_callerSlot("getTranfserFunction", "Connects the volume renderer with a transfer function") {
+
+    this->m_renderer_callerSlot.SetCompatibleCall<megamol::core::view::CallRender3DDescription>();
+    this->MakeSlotAvailable(&this->m_renderer_callerSlot);
+
     this->m_volumetricData_callerSlot.SetCompatibleCall<megamol::core::misc::VolumetricDataCallDescription>();
     this->MakeSlotAvailable(&this->m_volumetricData_callerSlot);
 
     this->m_transferFunction_callerSlot.SetCompatibleCall<megamol::core::view::CallGetTransferFunctionDescription>();
     this->MakeSlotAvailable(&this->m_transferFunction_callerSlot);
 
-    auto* ep = new megamol::core::param::FloatParam(1.0);
-    this->m_ray_step_ratio_param << ep;
+    this->m_mode << new megamol::core::param::EnumParam(0);
+    this->m_mode.Param<megamol::core::param::EnumParam>()->SetTypePair(0, "Integration");
+    this->m_mode.Param<megamol::core::param::EnumParam>()->SetTypePair(1, "Isosurface");
+    this->m_mode.Param<core::param::EnumParam>()->SetTypePair(2, "Aggregate");
+    this->MakeSlotAvailable(&this->m_mode);
+
+    this->m_ray_step_ratio_param << new megamol::core::param::FloatParam(1.0f);
     this->MakeSlotAvailable(&this->m_ray_step_ratio_param);
+
+    this->m_opacity_threshold << new megamol::core::param::FloatParam(1.0f);
+    this->MakeSlotAvailable(&this->m_opacity_threshold);
+
+    this->m_iso_value << new megamol::core::param::FloatParam(0.5f);
+    this->MakeSlotAvailable(&this->m_iso_value);
+
+    this->m_opacity << new megamol::core::param::FloatParam(1.0f);
+    this->MakeSlotAvailable(&this->m_opacity);
+
+    this->m_use_lighting_slot << new core::param::BoolParam(false);
+    this->MakeSlotAvailable(&this->m_use_lighting_slot);
+
+    this->m_ka_slot << new core::param::FloatParam(0.1f, 0.0f);
+    this->MakeSlotAvailable(&this->m_ka_slot);
+
+    this->m_kd_slot << new core::param::FloatParam(0.5f, 0.0f);
+    this->MakeSlotAvailable(&this->m_kd_slot);
+
+    this->m_ks_slot << new core::param::FloatParam(0.4f, 0.0f);
+    this->MakeSlotAvailable(&this->m_ks_slot);
+
+    this->m_shininess_slot << new core::param::FloatParam(10.0f, 0.0f);
+    this->MakeSlotAvailable(&this->m_shininess_slot);
+
+    this->m_ambient_color << new core::param::ColorParam(1.0f, 1.0f, 1.0f, 1.0f);
+    this->MakeSlotAvailable(&this->m_ambient_color);
+
+    this->m_specular_color << new core::param::ColorParam(1.0f, 1.0f, 1.0f, 1.0f);
+    this->MakeSlotAvailable(&this->m_specular_color);
+
+    this->m_light_color << new core::param::ColorParam(1.0f, 1.0f, 1.0f, 1.0f);
+    this->MakeSlotAvailable(&this->m_light_color);
+
+    this->m_material_color << new core::param::ColorParam(0.95f, 0.67f, 0.47f, 1.0f);
+    this->MakeSlotAvailable(&this->m_material_color);
+
+    this->paramOverride << new megamol::core::param::BoolParam(false);
+    this->MakeSlotAvailable(&this->paramOverride);
+
+    this->paramMinOverride << new megamol::core::param::FloatParam(0.0f);
+    this->MakeSlotAvailable(&this->paramMinOverride);
+
+    this->paramMaxOverride << new megamol::core::param::FloatParam(1.0f);
+    this->MakeSlotAvailable(&this->paramMaxOverride);
 }
 
 RaycastVolumeRenderer::~RaycastVolumeRenderer() { this->Release(); }
@@ -41,27 +128,48 @@ RaycastVolumeRenderer::~RaycastVolumeRenderer() { this->Release(); }
 bool RaycastVolumeRenderer::create() {
     try {
         // create shader program
-        m_raycast_volume_compute_shdr = std::make_unique<vislib::graphics::gl::GLSLComputeShader>();
-        m_render_to_framebuffer_shdr = std::make_unique<vislib::graphics::gl::GLSLShader>();
-
         vislib::graphics::gl::ShaderSource compute_shader_src;
+        vislib::graphics::gl::ShaderSource compute_iso_shader_src;
+        vislib::graphics::gl::ShaderSource compute_aggr_shader_src;
         vislib::graphics::gl::ShaderSource vertex_shader_src;
         vislib::graphics::gl::ShaderSource fragment_shader_src;
+        vislib::graphics::gl::ShaderSource fragment_shader_aggr_src;
 
         if (!instance()->ShaderSourceFactory().MakeShaderSource("RaycastVolumeRenderer::compute", compute_shader_src))
             return false;
-        if (!m_raycast_volume_compute_shdr->Compile(compute_shader_src.Code(), compute_shader_src.Count()))
+        if (!m_raycast_volume_compute_shdr.Compile(compute_shader_src.Code(), compute_shader_src.Count()))
             return false;
-        if (!m_raycast_volume_compute_shdr->Link()) return false;
+        if (!m_raycast_volume_compute_shdr.Link()) return false;
+
+        if (!instance()->ShaderSourceFactory().MakeShaderSource(
+                "RaycastVolumeRenderer::compute_iso", compute_iso_shader_src))
+            return false;
+        if (!m_raycast_volume_compute_iso_shdr.Compile(compute_iso_shader_src.Code(), compute_iso_shader_src.Count()))
+            return false;
+        if (!m_raycast_volume_compute_iso_shdr.Link()) return false;
+
+        if (!instance()->ShaderSourceFactory().MakeShaderSource(
+                "RaycastVolumeRenderer::compute_aggr", compute_aggr_shader_src))
+            return false;
+        if (!m_raycast_volume_compute_aggr_shdr.Compile(compute_aggr_shader_src.Code(), compute_aggr_shader_src.Count()))
+            return false;
+        if (!m_raycast_volume_compute_aggr_shdr.Link()) return false;
 
         if (!instance()->ShaderSourceFactory().MakeShaderSource("RaycastVolumeRenderer::vert", vertex_shader_src))
             return false;
         if (!instance()->ShaderSourceFactory().MakeShaderSource("RaycastVolumeRenderer::frag", fragment_shader_src))
             return false;
-        if (!m_render_to_framebuffer_shdr->Compile(vertex_shader_src.Code(), vertex_shader_src.Count(),
+        if (!instance()->ShaderSourceFactory().MakeShaderSource("RaycastVolumeRenderer::frag_aggr", fragment_shader_aggr_src))
+            return false;
+        if (!m_render_to_framebuffer_shdr.Compile(vertex_shader_src.Code(), vertex_shader_src.Count(),
                 fragment_shader_src.Code(), fragment_shader_src.Count()))
             return false;
-        if (!m_render_to_framebuffer_shdr->Link()) return false;
+        if (!m_render_to_framebuffer_shdr.Link()) return false;
+
+        if (!m_render_to_framebuffer_aggr_shdr.Compile(vertex_shader_src.Code(), vertex_shader_src.Count(),
+                fragment_shader_aggr_src.Code(), fragment_shader_aggr_src.Count()))
+            return false;
+        if (!m_render_to_framebuffer_aggr_shdr.Link()) return false;
     } catch (vislib::graphics::gl::AbstractOpenGLShader::CompileException ce) {
         vislib::sys::Log::DefaultLog.WriteMsg(vislib::sys::Log::LEVEL_ERROR, "Unable to compile shader (@%s): %s\n",
             vislib::graphics::gl::AbstractOpenGLShader::CompileException::CompileActionName(ce.FailedAction()),
@@ -77,41 +185,16 @@ bool RaycastVolumeRenderer::create() {
         return false;
     }
 
-
-    // create render target texture
-    TextureLayout render_tgt_layout(GL_RGBA8, 1920, 1080, 1, GL_RGBA, GL_UNSIGNED_BYTE, 1,
-        {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
-            {GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_MIN_FILTER, GL_LINEAR},
-            {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
-        {});
-    m_render_target = std::make_unique<Texture2D>("raycast_volume_render_target", render_tgt_layout, nullptr);
-
-
-    // create empty volume texture
-    TextureLayout volume_layout(GL_R32F, 1, 1, 1, GL_RED, GL_FLOAT, 1,
-        {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
-            {GL_TEXTURE_MIN_FILTER, GL_LINEAR}, {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
-        {});
-    m_volume_texture = std::make_unique<Texture3D>("raycast_volume_texture", volume_layout, nullptr);
-
-    // create empty transfer function texture
-    TextureLayout tf(GL_RGBA8, 1, 1, 1, GL_RGBA, GL_UNSIGNED_BYTE, 1,
-        {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
-            {GL_TEXTURE_MIN_FILTER, GL_LINEAR}, {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
-        {});
-    m_transfer_function = std::make_unique<Texture2D>("raycast_volume_texture", tf, nullptr);
-
     return true;
 }
 
 void RaycastVolumeRenderer::release() {
-    m_raycast_volume_compute_shdr.reset(nullptr);
-    m_render_target.reset(nullptr);
 }
 
 bool RaycastVolumeRenderer::GetExtents(megamol::core::Call& call) {
     auto cr = dynamic_cast<core::view::CallRender3D*>(&call);
     auto cd = m_volumetricData_callerSlot.CallAs<megamol::core::misc::VolumetricDataCall>();
+    auto ci = m_renderer_callerSlot.CallAs<megamol::core::view::CallRender3D>();
 
     if (cr == nullptr) return false;
     if (cd == nullptr) return false;
@@ -126,8 +209,18 @@ bool RaycastVolumeRenderer::GetExtents(megamol::core::Call& call) {
     if (!(*cd)(core::misc::VolumetricDataCall::IDX_GET_METADATA)) return false;
 
     cr->SetTimeFramesCount(cd->FrameCount());
-    cr->AccessBoundingBoxes() = cd->GetBoundingBoxes();
-    cr->AccessBoundingBoxes().MakeScaledWorld(1.0f);
+
+    std::vector<core::BoundingBoxes> bbs{cd->GetBoundingBoxes()};
+
+    if (ci != nullptr) {
+        *ci = *cr;
+
+        if (!(*ci)(core::view::CallRender3D::FnGetExtents)) return false;
+
+        bbs.push_back(ci->GetBoundingBoxes());
+    }
+
+    cr->AccessBoundingBoxes() = core::utility::combineAndMagicScaleBoundingBoxes(bbs);
 
     return true;
 }
@@ -136,30 +229,108 @@ bool RaycastVolumeRenderer::Render(megamol::core::Call& call) {
     megamol::core::view::CallRender3D* cr = dynamic_cast<core::view::CallRender3D*>(&call);
     if (cr == NULL) return false;
 
+    // Chain renderer
+    auto ci = m_renderer_callerSlot.CallAs<megamol::core::view::CallRender3D>();
+
+    if (ci != nullptr) {
+        ci->SetCameraParameters(cr->GetCameraParameters());
+
+        if (this->m_mode.Param<core::param::EnumParam>()->Value() == 0 ||
+            this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+            if (this->fbo.IsValid()) this->fbo.Release();
+            this->fbo.Create(ci->GetViewport().Width(), ci->GetViewport().Height(), GL_RGBA8, GL_RGBA, GL_UNSIGNED_BYTE,
+                vislib::graphics::gl::FramebufferObject::ATTACHMENT_TEXTURE);
+            this->fbo.Enable();
+        }
+
+        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+        ci->SetTime(cr->Time());
+        if (!(*ci)(core::view::CallRender3D::FnRender)) return false;
+
+        if (this->m_mode.Param<core::param::EnumParam>()->Value() == 0 ||
+            this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+            this->fbo.Disable();
+        }
+    }
+
+    // create render target texture
+    if (this->m_render_target == nullptr || this->m_render_target->getWidth() != cr->GetViewport().Width() ||
+        this->m_render_target->getHeight() != cr->GetViewport().Height()) {
+
+        glowl::TextureLayout render_tgt_layout(GL_RGBA8, cr->GetViewport().Width(), cr->GetViewport().Height(), 1,
+            GL_RGBA, GL_UNSIGNED_BYTE, 1,
+            {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
+                {GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_MIN_FILTER, GL_LINEAR},
+                {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
+            {});
+        m_render_target =
+            std::make_unique<glowl::Texture2D>("raycast_volume_render_target", render_tgt_layout, nullptr);
+
+        // create normal target texture
+        glowl::TextureLayout normal_tgt_layout(GL_RGBA32F, cr->GetViewport().Width(), cr->GetViewport().Height(), 1,
+            GL_RGBA, GL_FLOAT, 1,
+            {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
+                {GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_MIN_FILTER, GL_LINEAR},
+                {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
+            {});
+        m_normal_target =
+            std::make_unique<glowl::Texture2D>("raycast_volume_normal_target", normal_tgt_layout, nullptr);
+
+        // create depth target texture
+        glowl::TextureLayout depth_tgt_layout(GL_R32F, cr->GetViewport().Width(), cr->GetViewport().Height(), 1, GL_R,
+            GL_FLOAT, 1,
+            {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
+                {GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_MIN_FILTER, GL_LINEAR},
+                {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
+            {});
+        m_depth_target = std::make_unique<glowl::Texture2D>("raycast_volume_depth_target", depth_tgt_layout, nullptr);
+    }
 
     // this is the apex of suck and must die
+    core::utility::glMagicScale scaling;
+    scaling.apply(cr->GetBoundingBoxes());
+
     GLfloat modelViewMatrix_column[16];
     glGetFloatv(GL_MODELVIEW_MATRIX, modelViewMatrix_column);
     GLfloat projMatrix_column[16];
     glGetFloatv(GL_PROJECTION_MATRIX, projMatrix_column);
+
+    std::array<float, 4> light = {0.0f, 0.0f, 1.0f, 1.0f};
+    glGetLightfv(GL_LIGHT0, GL_POSITION, light.data());
     // end suck
 
-    if (!updateVolumeData()) return false;
-    if (!updateTransferFunction()) return false;
+    if (!updateVolumeData(cr->Time())) return false;
 
     // enable raycast volume rendering program
-    m_raycast_volume_compute_shdr->Enable();
+    vislib::graphics::gl::GLSLComputeShader* compute_shdr;
+
+    // pick shader based on selected mode
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 0) {
+        if (!updateTransferFunction()) return false;
+
+        compute_shdr = &this->m_raycast_volume_compute_shdr;
+    } else if (this->m_mode.Param<core::param::EnumParam>()->Value() == 1) {
+        compute_shdr = &this->m_raycast_volume_compute_iso_shdr;
+    } else if (this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+        if (!updateTransferFunction()) return false;
+        compute_shdr = &this->m_raycast_volume_compute_aggr_shdr;
+    } else {
+        vislib::sys::Log::DefaultLog.WriteError("Unknown raycast mode.");
+        return false;
+    }
+
+    // setup
+    compute_shdr->Enable();
 
-    glUniformMatrix4fv(
-        m_raycast_volume_compute_shdr->ParameterLocation("view_mx"), 1, GL_FALSE, modelViewMatrix_column);
-    glUniformMatrix4fv(m_raycast_volume_compute_shdr->ParameterLocation("proj_mx"), 1, GL_FALSE, projMatrix_column);
+    glUniformMatrix4fv(compute_shdr->ParameterLocation("view_mx"), 1, GL_FALSE, modelViewMatrix_column);
+    glUniformMatrix4fv(compute_shdr->ParameterLocation("proj_mx"), 1, GL_FALSE, projMatrix_column);
 
     vec2 rt_resolution;
     rt_resolution[0] = static_cast<float>(m_render_target->getWidth());
     rt_resolution[1] = static_cast<float>(m_render_target->getHeight());
-    glUniform2fv(m_raycast_volume_compute_shdr->ParameterLocation("rt_resolution"), 1, rt_resolution);
+    glUniform2fv(compute_shdr->ParameterLocation("rt_resolution"), 1, rt_resolution);
 
-    // bbox sizes
     vec3 box_min;
     box_min[0] = m_volume_origin[0];
     box_min[1] = m_volume_origin[1];
@@ -168,88 +339,266 @@ bool RaycastVolumeRenderer::Render(megamol::core::Call& call) {
     box_max[0] = m_volume_origin[0] + m_volume_extents[0];
     box_max[1] = m_volume_origin[1] + m_volume_extents[1];
     box_max[2] = m_volume_origin[2] + m_volume_extents[2];
-    glUniform3fv(m_raycast_volume_compute_shdr->ParameterLocation("boxMin"), 1, box_min);
-    glUniform3fv(m_raycast_volume_compute_shdr->ParameterLocation("boxMax"), 1, box_max);
+    glUniform3fv(compute_shdr->ParameterLocation("boxMin"), 1, box_min);
+    glUniform3fv(compute_shdr->ParameterLocation("boxMax"), 1, box_max);
 
-    glUniform3f(m_raycast_volume_compute_shdr->ParameterLocation("halfVoxelSize"),
-        1.0f / (2.0f * (m_volume_resolution[0] - 1)), 1.0f / (2.0f * (m_volume_resolution[1] - 1)),
-        1.0f / (2.0f * (m_volume_resolution[2] - 1)));
+    glUniform3f(compute_shdr->ParameterLocation("halfVoxelSize"), 1.0f / (2.0f * (m_volume_resolution[0] - 1)),
+        1.0f / (2.0f * (m_volume_resolution[1] - 1)), 1.0f / (2.0f * (m_volume_resolution[2] - 1)));
     auto const maxResolution =
-        std::fmax(m_volume_resolution[0], std::fmax(m_volume_resolution[1], m_volume_resolution[2]));
-    auto const maxExtents = std::fmax(m_volume_extents[0], std::fmax(m_volume_extents[1], m_volume_extents[2]));
-    glUniform1f(m_raycast_volume_compute_shdr->ParameterLocation("voxelSize"), maxExtents / (maxResolution - 1.0f));
-    glUniform2fv(m_raycast_volume_compute_shdr->ParameterLocation("valRange"), 1, valRange.data());
-    glUniform1f(m_raycast_volume_compute_shdr->ParameterLocation("rayStepRatio"),
+        std::max(m_volume_resolution[0], std::max(m_volume_resolution[1], m_volume_resolution[2]));
+    auto const maxExtents = std::max(m_volume_extents[0], std::max(m_volume_extents[1], m_volume_extents[2]));
+    glUniform1f(compute_shdr->ParameterLocation("voxelSize"), maxExtents / (maxResolution - 1.0f));
+
+    // Force value range to user-defined range if requested.
+    if (this->paramOverride.Param<core::param::BoolParam>()->Value()) {
+        std::array<float, 2> overrideRange = {
+            this->paramMinOverride.Param<core::param::FloatParam>()->Value(),
+            this->paramMaxOverride.Param<core::param::FloatParam>()->Value()
+        };
+        glUniform2fv(compute_shdr->ParameterLocation("valRange"), 1, overrideRange.data());
+
+    } else {
+        glUniform2fv(compute_shdr->ParameterLocation("valRange"), 1, valRange.data());
+    }
+
+    glUniform1f(compute_shdr->ParameterLocation("rayStepRatio"),
         this->m_ray_step_ratio_param.Param<core::param::FloatParam>()->Value());
-    glUniform1f(m_raycast_volume_compute_shdr->ParameterLocation("opacityThreshold"), 1.0);
+
+    glUniform1i(compute_shdr->ParameterLocation("use_lighting"),
+        this->m_use_lighting_slot.Param<core::param::BoolParam>()->Value());
+    glUniform1f(compute_shdr->ParameterLocation("ka"),
+        this->m_ka_slot.Param<core::param::FloatParam>()->Value());
+    glUniform1f(compute_shdr->ParameterLocation("kd"),
+        this->m_kd_slot.Param<core::param::FloatParam>()->Value());
+    glUniform1f(compute_shdr->ParameterLocation("ks"),
+        this->m_ks_slot.Param<core::param::FloatParam>()->Value());
+    glUniform1f(compute_shdr->ParameterLocation("shininess"),
+        this->m_shininess_slot.Param<core::param::FloatParam>()->Value());
+    glUniform3fv(compute_shdr->ParameterLocation("light"), 1, light.data());
+    glUniform3fv(compute_shdr->ParameterLocation("ambient_col"), 1,
+        this->m_ambient_color.Param<core::param::ColorParam>()->Value().data());
+    glUniform3fv(compute_shdr->ParameterLocation("specular_col"), 1,
+        this->m_specular_color.Param<core::param::ColorParam>()->Value().data());
+    glUniform3fv(compute_shdr->ParameterLocation("light_col"), 1,
+        this->m_light_color.Param<core::param::ColorParam>()->Value().data());
+    glUniform3fv(compute_shdr->ParameterLocation("material_col"), 1,
+        this->m_material_color.Param<core::param::ColorParam>()->Value().data());
+
+    auto const arv = std::dynamic_pointer_cast<core::view::AbstractRenderingView const>(cr->PeekCallerSlot()->Parent());
+    std::array<float, 4> bkgndCol = {1.0f, 1.0f, 1.0f, 1.0f};
+    if (arv != nullptr) {
+        auto const ptr = arv->BkgndColour();
+        bkgndCol[0] = ptr[0];
+        bkgndCol[1] = ptr[1];
+        bkgndCol[2] = ptr[2];
+        bkgndCol[3] = 1.0f;
+    }
+    glUniform3fv(compute_shdr->ParameterLocation("background"), 1, bkgndCol.data());
+
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 0) {
+        glUniform1f(compute_shdr->ParameterLocation("opacityThreshold"),
+            this->m_opacity_threshold.Param<core::param::FloatParam>()->Value());
+    } else if (this->m_mode.Param<core::param::EnumParam>()->Value() == 1) {
+        glUniform1f(
+            compute_shdr->ParameterLocation("isoValue"), this->m_iso_value.Param<core::param::FloatParam>()->Value());
+
+        glUniform1f(
+            compute_shdr->ParameterLocation("opacity"), this->m_opacity.Param<core::param::FloatParam>()->Value());
+    }
+
+    this->m_opacity_threshold.Parameter()->SetGUIVisible(this->m_mode.Param<core::param::EnumParam>()->Value() == 0);
+    this->m_iso_value.Parameter()->SetGUIVisible(this->m_mode.Param<core::param::EnumParam>()->Value() == 1);
+    this->m_opacity.Parameter()->SetGUIVisible(this->m_mode.Param<core::param::EnumParam>()->Value() == 1);
 
     // bind volume texture
     glActiveTexture(GL_TEXTURE0);
     m_volume_texture->bindTexture();
-    glUniform1i(m_raycast_volume_compute_shdr->ParameterLocation("volume_tx3D"), 0);
+    glUniform1i(compute_shdr->ParameterLocation("volume_tx3D"), 0);
+
     // bind the transfer function
-    glActiveTexture(GL_TEXTURE1);
-    glBindTexture(GL_TEXTURE_1D, tf_texture);
-    glUniform1i(m_raycast_volume_compute_shdr->ParameterLocation("tf_tx1D"), 1);
-    /*m_transfer_function->bindTexture();
-    glUniform1i(m_raycast_volume_compute_shdr->ParameterLocation("transfer_function_tx2D"), 1);*/
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 0) {
+        glActiveTexture(GL_TEXTURE1);
+        glBindTexture(GL_TEXTURE_1D, tf_texture);
+        glUniform1i(compute_shdr->ParameterLocation("tf_tx1D"), 1);
+
+        if (ci != nullptr) {
+            glActiveTexture(GL_TEXTURE2);
+            this->fbo.BindColourTexture();
+            glUniform1i(compute_shdr->ParameterLocation("color_tx2D"), 2);
+
+            glActiveTexture(GL_TEXTURE3);
+            this->fbo.BindDepthTexture();
+            glUniform1i(compute_shdr->ParameterLocation("depth_tx2D"), 3);
+
+            glUniform1i(compute_shdr->ParameterLocation("use_depth_tx"), 1);
+        } else {
+            glUniform1i(compute_shdr->ParameterLocation("use_depth_tx"), 0);
+        }
+    }
+
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+        if (ci != nullptr) {
+            glActiveTexture(GL_TEXTURE2);
+            this->fbo.BindColourTexture();
+            glUniform1i(compute_shdr->ParameterLocation("color_tx2D"), 2);
+
+            glActiveTexture(GL_TEXTURE3);
+            this->fbo.BindDepthTexture();
+            glUniform1i(compute_shdr->ParameterLocation("depth_tx2D"), 3);
+
+            glUniform1i(compute_shdr->ParameterLocation("use_depth_tx"), 1);
+        } else {
+            glUniform1i(compute_shdr->ParameterLocation("use_depth_tx"), 0);
+        }
+    }
 
     // bind image texture
     m_render_target->bindImage(0, GL_WRITE_ONLY);
 
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 1) {
+        m_normal_target->bindImage(1, GL_WRITE_ONLY);
+        m_depth_target->bindImage(2, GL_WRITE_ONLY);
+    }
+
     // dispatch compute
-    m_raycast_volume_compute_shdr->Dispatch(
+    compute_shdr->Dispatch(
         static_cast<int>(std::ceil(rt_resolution[0] / 8.0f)), static_cast<int>(std::ceil(rt_resolution[1] / 8.0f)), 1);
 
-    m_raycast_volume_compute_shdr->Disable();
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 1) {
+        glBindImageTexture(2, 0, 0, GL_TRUE, 0, GL_WRITE_ONLY, GL_R8);
+        glBindImageTexture(1, 0, 0, GL_TRUE, 0, GL_WRITE_ONLY, GL_R8);
+    }
+
+    glBindImageTexture(0, 0, 0, GL_TRUE, 0, GL_WRITE_ONLY, GL_R8);
+
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 0 ||
+        this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+        glActiveTexture(GL_TEXTURE3);
+        glBindTexture(GL_TEXTURE_2D, 0);
+        glActiveTexture(GL_TEXTURE2);
+        glBindTexture(GL_TEXTURE_2D, 0);
+    }
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 0) {
+        glActiveTexture(GL_TEXTURE1);
+        glBindTexture(GL_TEXTURE_1D, 0);
+    }
+    glActiveTexture(GL_TEXTURE0);
+    glBindTexture(GL_TEXTURE_3D, 0);
+
+    compute_shdr->Disable();
 
     glMemoryBarrier(GL_TEXTURE_FETCH_BARRIER_BIT);
 
-    ////////
+    // read image back to determine min max
+    float rndr_min = std::numeric_limits<float>::max();
+    float rndr_max = std::numeric_limits<float>::lowest();
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+        glActiveTexture(GL_TEXTURE0);
+        m_render_target->bindTexture();
+        int width = 0;
+        int height = 0;
+        glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_WIDTH, &width);
+        glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_HEIGHT, &height);
+        std::vector<float> tmp_data(width*height*4);
+        glGetTexImage(GL_TEXTURE_2D, 0, GL_RGBA, GL_FLOAT, tmp_data.data());
+
+        for (size_t idx = 0; idx < tmp_data.size() / 4; ++idx) {
+            auto const val = tmp_data[idx * 4 + 3];
+            if (val < rndr_min) rndr_min = val;
+            if (val > rndr_max) rndr_max = val;
+        }
+
+        glBindTexture(GL_TEXTURE_2D, 0);
+    }
+
     // copy image to framebuffer
-    ///////
-    // TODO query gl state and reset to previous state?
-    glDisable(GL_DEPTH_TEST);
-    glEnable(GL_BLEND);
+    bool state_depth_test = glIsEnabled(GL_DEPTH_TEST);
+    bool state_blend = glIsEnabled(GL_BLEND);
+
+    GLint state_blend_src_rgb, state_blend_src_alpha, state_blend_dst_rgb, state_blend_dst_alpha;
+    glGetIntegerv(GL_BLEND_SRC_RGB, &state_blend_src_rgb);
+    glGetIntegerv(GL_BLEND_SRC_ALPHA, &state_blend_src_alpha);
+    glGetIntegerv(GL_BLEND_DST_RGB, &state_blend_dst_rgb);
+    glGetIntegerv(GL_BLEND_DST_ALPHA, &state_blend_dst_alpha);
+
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 0 ||
+        this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+        if (state_depth_test) glDisable(GL_DEPTH_TEST);
+    } else if (this->m_mode.Param<core::param::EnumParam>()->Value() == 1) {
+        if (!state_depth_test) glEnable(GL_DEPTH_TEST);
+    }
+
+    if (!state_blend) glEnable(GL_BLEND);
     glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
-    m_render_to_framebuffer_shdr->Enable();
+    auto fbo_shdr = &m_render_to_framebuffer_shdr;
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+        fbo_shdr = &m_render_to_framebuffer_aggr_shdr;
+    }
+
+    fbo_shdr->Enable();
 
-    glActiveTexture(GL_TEXTURE1);
+    glActiveTexture(GL_TEXTURE0);
     m_render_target->bindTexture();
-    glUniform1i(m_render_to_framebuffer_shdr->ParameterLocation("src_tx2D"), 1);
+    glUniform1i(fbo_shdr->ParameterLocation("src_tx2D"), 0);
 
-    glDrawArrays(GL_TRIANGLES, 0, 6);
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 1) {
+        glActiveTexture(GL_TEXTURE1);
+        m_normal_target->bindTexture();
+        glUniform1i(fbo_shdr->ParameterLocation("normal_tx2D"), 1);
 
-    m_render_to_framebuffer_shdr->Disable();
+        glActiveTexture(GL_TEXTURE2);
+        m_depth_target->bindTexture();
+        glUniform1i(fbo_shdr->ParameterLocation("depth_tx2D"), 2);
 
+        GLenum buffers[] = {GL_COLOR_ATTACHMENT0_EXT, GL_COLOR_ATTACHMENT1_EXT};
+        glDrawBuffers(2, buffers);
+    }
 
-    glUseProgram(0);
-    // glBindVertexArray(0);
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+        glActiveTexture(GL_TEXTURE1);
+        glBindTexture(GL_TEXTURE_1D, tf_texture);
+        glUniform1i(fbo_shdr->ParameterLocation("tf_tx1D"), 1);
+
+        glUniform2f(fbo_shdr->ParameterLocation("valRange"), rndr_min, rndr_max);
+    }
+
+    glDrawArrays(GL_TRIANGLES, 0, 6);
+
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 1) {
+        glActiveTexture(GL_TEXTURE2);
+        glBindTexture(GL_TEXTURE_2D, 0);
+        glActiveTexture(GL_TEXTURE1);
+        glBindTexture(GL_TEXTURE_2D, 0);
+    }
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+        glActiveTexture(GL_TEXTURE1);
+        glBindTexture(GL_TEXTURE_1D, 0);
+    }
     glActiveTexture(GL_TEXTURE0);
-    glBindTexture(GL_TEXTURE_3D, 0);
-    glActiveTexture(GL_TEXTURE1);
     glBindTexture(GL_TEXTURE_2D, 0);
 
-    glBindBuffer(GL_ARRAY_BUFFER, 0);
-    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
-    glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
-    glBindBuffer(GL_DRAW_INDIRECT_BUFFER, 0);
+    fbo_shdr->Disable();
 
-    glEnable(GL_DEPTH_TEST);
-    glDisable(GL_BLEND);
+    glBlendFuncSeparate(state_blend_src_rgb, state_blend_dst_rgb, state_blend_src_alpha, state_blend_dst_alpha);
+    if (!state_blend) glDisable(GL_BLEND);
+    if (state_depth_test) glEnable(GL_DEPTH_TEST); else glDisable(GL_DEPTH_TEST);
 
     return true;
 }
 
-bool RaycastVolumeRenderer::updateVolumeData() {
+bool RaycastVolumeRenderer::updateVolumeData(const unsigned int frameID) {
     auto* cd = this->m_volumetricData_callerSlot.CallAs<megamol::core::misc::VolumetricDataCall>();
 
     if (cd == nullptr) return false;
 
-    if (!(*cd)(core::misc::VolumetricDataCall::IDX_GET_EXTENTS)) return false;
-    if (!(*cd)(core::misc::VolumetricDataCall::IDX_GET_METADATA)) return false;
-    if (!(*cd)(core::misc::VolumetricDataCall::IDX_GET_DATA)) return false;
+    // Use the force
+    cd->SetFrameID(frameID, true);
+    do {
+        if (!(*cd)(core::misc::VolumetricDataCall::IDX_GET_EXTENTS)) return false;
+        if (!(*cd)(core::misc::VolumetricDataCall::IDX_GET_METADATA)) return false;
+        if (!(*cd)(core::misc::VolumetricDataCall::IDX_GET_DATA)) return false;
+    } while (cd->FrameID() != frameID);
 
     // TODO check time and frame id or whatever else
     if (this->m_volume_datahash != cd->DataHash() || this->m_frame_id != cd->FrameID()) {
@@ -328,47 +677,24 @@ bool RaycastVolumeRenderer::updateVolumeData() {
 
     // TODO if/else data already on GPU
 
-    // debug using dummy-data
-    std::array<uint8_t, 8> debug_volume_data = {255, 0, 255, 0, 255, 255, 0, 0};
-    TextureLayout debug_volume_layout(GL_R8, 2, 2, 2, GL_RED, GL_UNSIGNED_BYTE, 1,
-        {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
-            {GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_MIN_FILTER, GL_NEAREST},
-            {GL_TEXTURE_MAG_FILTER, GL_NEAREST}},
-        {});
-
-    TextureLayout volume_layout(internal_format, metadata->Resolution[0], metadata->Resolution[1],
+    glowl::TextureLayout volume_layout(internal_format, metadata->Resolution[0], metadata->Resolution[1],
         metadata->Resolution[2], format, type, 1,
         {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
             {GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_MIN_FILTER, GL_LINEAR},
             {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
         {});
 
-    m_volume_texture->reload(volume_layout, volumedata);
+    m_volume_texture = std::make_unique<glowl::Texture3D>("raycast_volume_texture", volume_layout, volumedata);
+
+    return true;
 }
 
 bool RaycastVolumeRenderer::updateTransferFunction() {
     core::view::CallGetTransferFunction* ct =
         this->m_transferFunction_callerSlot.CallAs<core::view::CallGetTransferFunction>();
-    //ct->SetRange(valRange);
+
     if (ct != NULL && ((*ct)())) {
         tf_texture = ct->OpenGLTexture();
-        /*float const* tf_tex = ct->GetTextureData();
-        unsigned int tf_size = ct->TextureSize();
-        auto tf_format = ct->OpenGLTextureFormat();
-
-        GLenum internal_format = tf_format == GL_RGB ? GL_RGB32F : GL_RGBA32F;
-        GLenum format = tf_format;
-        GLenum type = GL_FLOAT;
-
-        TextureLayout tf_layout(internal_format, tf_size, 1, 1, format, type, 1,
-            {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
-                {GL_TEXTURE_MIN_FILTER, GL_LINEAR}, {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
-            {});
-
-        m_transfer_function->reload(tf_layout, tf_tex);*/
-        // this->colorTransferGray(allColor, tf_tex, tex_size, processedColor, 3);
-    } else {
-        // this->colorTransferGray(allColor, NULL, 0, processedColor, 3);
     }
 
     return true;
diff --git a/plugins/mmstd_volume/src/RaycastVolumeRenderer.h b/plugins/mmstd_volume/src/RaycastVolumeRenderer.h
index 554bff170..b65e57765 100644
--- a/plugins/mmstd_volume/src/RaycastVolumeRenderer.h
+++ b/plugins/mmstd_volume/src/RaycastVolumeRenderer.h
@@ -7,20 +7,23 @@
 
 #ifndef RAYCAST_VOLUME_RENDERER_H_INCLUDED
 #define RAYCAST_VOLUME_RENDERER_H_INCLUDED
-#if (defined(_MSC_VER) && (_MSC_VER > 1000))
-#    pragma once
-#endif /* (defined(_MSC_VER) && (_MSC_VER > 1000)) */
-
-#include <array>
-
-#include "vislib/graphics/gl/GLSLComputeShader.h"
-#include "vislib/graphics/gl/OpenGLTexture2D.h"
+#pragma once
 
+#include "mmcore/Call.h"
 #include "mmcore/CallerSlot.h"
 #include "mmcore/param/ParamSlot.h"
-#include "mmcore/view/CallRender3D.h"
 #include "mmcore/view/Renderer3DModule.h"
 
+#include "vislib/graphics/gl/FramebufferObject.h"
+#include "vislib/graphics/gl/GLSLComputeShader.h"
+#include "vislib/graphics/gl/GLSLShader.h"
+
+#include "glowl/Texture2D.hpp"
+#include "glowl/Texture3D.hpp"
+
+#include <array>
+#include <limits>
+#include <memory>
 
 namespace megamol {
 namespace stdplugin {
@@ -95,355 +98,22 @@ protected:
      */
     bool Render(core::Call& call);
 
-    bool updateVolumeData();
+    bool updateVolumeData(const unsigned int frameID);
 
     bool updateTransferFunction();
 
 private:
-    /* OpenGL TextureLayout, Texture and Texture2D classes courtesy of glOwl by Michael Becher. */
-
-    struct TextureLayout {
-        TextureLayout() : width(0), internal_format(0), height(0), depth(0), format(0), type(0), levels(0) {}
-        /**
-         * \param internal_format Specifies the (sized) internal format of a texture (e.g. GL_RGBA32F)
-         * \param width Specifies the width of the texture in pixels.
-         * \param height Specifies the height of the texture in pixels. Will be ignored by Texture1D.
-         * \param depth Specifies the depth of the texture in pixels. Will be ignored by Texture1D and Texture2D.
-         * \param format Specifies the format of the texture (e.g. GL_RGBA)
-         * \param type Specifies the type of the texture (e.g. GL_FLOAT)
-         */
-        TextureLayout(
-            GLint internal_format, int width, int height, int depth, GLenum format, GLenum type, GLsizei levels)
-            : internal_format(internal_format)
-            , width(width)
-            , height(height)
-            , depth(depth)
-            , format(format)
-            , type(type)
-            , levels(levels) {}
-
-        /**
-         * \param internal_format Specifies the (sized) internal format of a texture (e.g. GL_RGBA32F)
-         * \param width Specifies the width of the texture in pixels.
-         * \param height Specifies the height of the texture in pixels. Will be ignored by Texture1D.
-         * \param depth Specifies the depth of the texture in pixels. Will be ignored by Texture1D and Texture2D.
-         * \param format Specifies the format of the texture (e.g. GL_RGBA)
-         * \param type Specifies the type of the texture (e.g. GL_FLOAT)
-         * \param int_parameters A list of integer texture parameters, each given by a pair of name and value (e.g.
-         * {{GL_TEXTURE_SPARSE_ARB,GL_TRUE},{...},...} \param int_parameters A list of float texture parameters, each
-         * given by a pair of name and value (e.g. {{GL_TEXTURE_MAX_ANISOTROPY_EX,4.0f},{...},...}
-         */
-        TextureLayout(GLint internal_format, int width, int height, int depth, GLenum format, GLenum type,
-            GLsizei levels, std::vector<std::pair<GLenum, GLint>> const& int_parameters,
-            std::vector<std::pair<GLenum, GLfloat>> const& float_parameters)
-            : internal_format(internal_format)
-            , width(width)
-            , height(height)
-            , depth(depth)
-            , format(format)
-            , type(type)
-            , levels(levels)
-            , int_parameters(int_parameters)
-            , float_parameters(float_parameters) {}
-        TextureLayout(GLint internal_format, int width, int height, int depth, GLenum format, GLenum type,
-            GLsizei levels, std::vector<std::pair<GLenum, GLint>>&& int_parameters,
-            std::vector<std::pair<GLenum, GLfloat>>&& float_parameters)
-            : internal_format(internal_format)
-            , width(width)
-            , height(height)
-            , depth(depth)
-            , format(format)
-            , type(type)
-            , levels(levels)
-            , int_parameters(int_parameters)
-            , float_parameters(float_parameters) {}
-
-        GLint internal_format;
-        int width;
-        int height;
-        int depth;
-        GLenum format;
-        GLenum type;
-
-        GLsizei levels;
-
-        std::vector<std::pair<GLenum, GLint>> int_parameters;
-        std::vector<std::pair<GLenum, GLfloat>> float_parameters;
-    };
-
-    class Texture {
-    protected:
-        std::string m_id; ///< Identifier set by application to help identifying textures
-
-        GLuint m_name;             ///< OpenGL texture name given by glGenTextures
-        GLuint64 m_texture_handle; ///< Actual OpenGL texture handle (used for bindless)
-
-        GLenum m_internal_format;
-        GLenum m_format;
-        GLenum m_type;
-
-        GLsizei m_levels;
-
-        // TODO: Store texture parameters as well ?
-    public:
-        Texture(std::string id, GLint internal_format, GLenum format, GLenum type, GLsizei levels)
-            : m_id(id), m_internal_format(internal_format), m_format(format), m_type(type), m_levels(levels) {}
-        virtual ~Texture() { glDeleteTextures(1, &m_name); }
-        Texture(const Texture&) = delete;
-
-        virtual void bindTexture() const = 0;
-
-        void bindImage(GLuint location, GLenum access) const {
-            glBindImageTexture(location, m_name, 0, GL_TRUE, 0, access, m_internal_format);
-        }
-
-        void makeResident() { glMakeTextureHandleResidentARB(m_texture_handle); }
-        void makeNonResident() { glMakeTextureHandleNonResidentARB(m_texture_handle); }
-
-        virtual void updateMipmaps() = 0;
-
-        virtual TextureLayout getTextureLayout() const = 0;
-
-        std::string getId() const { return m_id; }
-
-        GLuint getName() const { return m_name; }
-        GLuint64 getTextureHandle() const { return m_texture_handle; }
-        GLuint64 getImageHandle(GLint level, GLboolean layered, GLint layer) const {
-            return glGetImageHandleARB(m_name, level, layered, layer, m_internal_format);
-        }
-
-        GLenum getInternalFormat() const { return m_internal_format; }
-        GLenum getFormat() const { return m_format; }
-        GLenum getType() const { return m_type; }
-    };
-
-    class Texture2D : public Texture {
-    public:
-        /**
-         * \brief Constructor that creates and loads a 2D texture.
-         *
-         * \param id A identifier given to the texture object
-         * \param layout A TextureLayout struct that specifies size, format and parameters for the texture
-         * \param data Pointer to the actual texture data.
-         * \param generateMipmap Specifies whether a mipmap will be created for the texture
-         */
-        Texture2D(std::string id, TextureLayout const& layout, GLvoid* data, bool generateMipmap = false)
-            : Texture(id, layout.internal_format, layout.format, layout.type, layout.levels)
-            , m_width(layout.width)
-            , m_height(layout.height) {
-            glGenTextures(1, &m_name);
-
-            glBindTexture(GL_TEXTURE_2D, m_name);
-
-            for (auto& pname_pvalue : layout.int_parameters)
-                glTexParameteri(GL_TEXTURE_2D, pname_pvalue.first, pname_pvalue.second);
-
-            for (auto& pname_pvalue : layout.float_parameters)
-                glTexParameterf(GL_TEXTURE_2D, pname_pvalue.first, pname_pvalue.second);
-
-            GLsizei levels = 1;
-
-            if (generateMipmap) levels = 1 + floor(log2(std::max(m_width, m_height)));
-
-            glTexStorage2D(GL_TEXTURE_2D, levels, m_internal_format, m_width, m_height);
-
-            if (data != nullptr) glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, m_width, m_height, m_format, m_type, data);
-
-            if (generateMipmap) glGenerateMipmap(GL_TEXTURE_2D);
-
-            glBindTexture(GL_TEXTURE_2D, 0);
-
-            m_texture_handle = glGetTextureHandleARB(m_name);
-
-            GLenum err = glGetError();
-            if (err != GL_NO_ERROR) {
-                // "Do something cop!"
-                // std::cerr << "GL error during texture (id: " << id << ") creation: " << err << std::endl;
-            }
-        }
-        Texture2D(const Texture2D&) = delete;
-        Texture2D(Texture2D&& other) = delete;
-        Texture2D& operator=(const Texture2D& rhs) = delete;
-        Texture2D& operator=(Texture2D&& rhs) = delete;
-
-        /**
-         * \brief Bind the texture.
-         */
-        void bindTexture() const { glBindTexture(GL_TEXTURE_2D, m_name); }
-
-        void updateMipmaps() {
-            glBindTexture(GL_TEXTURE_2D, m_name);
-            glGenerateMipmap(GL_TEXTURE_2D);
-            glBindTexture(GL_TEXTURE_2D, 0);
-        }
-
-        /**
-         * \brief Reload the texture with any new format, type and size.
-         *
-         * \param layout A TextureLayout struct that specifies size, format and parameters for the texture
-         * \param data Pointer to the actual texture data.
-         * \param generateMipmap Specifies whether a mipmap will be created for the texture
-         */
-        void reload(TextureLayout const& layout, GLvoid const* data, bool generateMipmap = false) {
-            m_width = layout.width;
-            m_height = layout.height;
-            m_internal_format = layout.internal_format;
-            m_format = layout.format;
-            m_type = layout.type;
-
-            glDeleteTextures(1, &m_name);
-
-            glGenTextures(1, &m_name);
-
-            glBindTexture(GL_TEXTURE_2D, m_name);
-
-            for (auto& pname_pvalue : layout.int_parameters)
-                glTexParameteri(GL_TEXTURE_2D, pname_pvalue.first, pname_pvalue.second);
+    vislib::graphics::gl::GLSLComputeShader m_raycast_volume_compute_shdr;
+    vislib::graphics::gl::GLSLComputeShader m_raycast_volume_compute_iso_shdr;
+    vislib::graphics::gl::GLSLComputeShader m_raycast_volume_compute_aggr_shdr;
+    vislib::graphics::gl::GLSLShader m_render_to_framebuffer_shdr;
+    vislib::graphics::gl::GLSLShader m_render_to_framebuffer_aggr_shdr;
 
-            for (auto& pname_pvalue : layout.float_parameters)
-                glTexParameterf(GL_TEXTURE_2D, pname_pvalue.first, pname_pvalue.second);
+    std::unique_ptr<glowl::Texture2D> m_render_target;
+    std::unique_ptr<glowl::Texture2D> m_normal_target;
+    std::unique_ptr<glowl::Texture2D> m_depth_target;
 
-            GLsizei levels = 1;
-
-            if (generateMipmap) levels = 1 + floor(log2(std::max(m_width, m_height)));
-
-            glTexStorage2D(GL_TEXTURE_2D, levels, m_internal_format, m_width, m_height);
-
-            if (data != nullptr) glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, m_width, m_height, m_format, m_type, data);
-
-            if (generateMipmap) glGenerateMipmap(GL_TEXTURE_2D);
-
-            glBindTexture(GL_TEXTURE_2D, 0);
-
-            GLenum err = glGetError();
-            if (err != GL_NO_ERROR) {
-                // "Do something cop!"
-                // std::cerr << "GL error during  (id: " << m_id << ") reload: " << err << std::endl;
-            }
-        }
-
-        TextureLayout getTextureLayout() const {
-            return TextureLayout(m_internal_format, m_width, m_height, 1, m_format, m_type, m_levels);
-        }
-
-        unsigned int getWidth() const { return m_width; }
-
-        unsigned int getHeight() const { return m_height; }
-
-    private:
-        unsigned int m_width;
-        unsigned int m_height;
-    };
-
-    class Texture3D : public Texture {
-    public:
-        Texture3D(std::string id, TextureLayout const& layout, GLvoid* data)
-            : Texture(id, layout.internal_format, layout.format, layout.type, layout.levels)
-            , m_width(layout.width)
-            , m_height(layout.height)
-            , m_depth(layout.depth) {
-            glGenTextures(1, &m_name);
-
-            glBindTexture(GL_TEXTURE_3D, m_name);
-
-            for (auto& pname_pvalue : layout.int_parameters)
-                glTexParameteri(GL_TEXTURE_3D, pname_pvalue.first, pname_pvalue.second);
-
-            for (auto& pname_pvalue : layout.float_parameters)
-                glTexParameterf(GL_TEXTURE_3D, pname_pvalue.first, pname_pvalue.second);
-
-            glTexStorage3D(GL_TEXTURE_3D, 1, m_internal_format, m_width, m_height, m_depth);
-
-            if (data != nullptr)
-                glTexSubImage3D(GL_TEXTURE_3D, 0, 0, 0, 0, m_width, m_height, m_depth, m_format, m_type, data);
-
-            glBindTexture(GL_TEXTURE_3D, 0);
-
-            m_texture_handle = glGetTextureHandleARB(m_name);
-
-            GLenum err = glGetError();
-            if (err != GL_NO_ERROR) {
-                // "Do something cop!"
-                // std::cerr << "GL error during 3D texture (id:" << id << ") creation: " << err << std::endl;
-            }
-        }
-
-        Texture3D(const Texture3D&) = delete;
-        Texture3D(Texture3D&& other) = delete;
-        Texture3D& operator=(const Texture3D& rhs) = delete;
-        Texture3D& operator=(Texture3D&& rhs) = delete;
-
-        /**
-         * \brief Bind the texture.
-         */
-        void bindTexture() const { glBindTexture(GL_TEXTURE_3D, m_name); }
-
-        void updateMipmaps() {
-            glBindTexture(GL_TEXTURE_3D, m_name);
-            glGenerateMipmap(GL_TEXTURE_3D);
-            glBindTexture(GL_TEXTURE_3D, 0);
-        }
-
-        /**
-         * \brief Reload the texture.
-         * \param data Pointer to the new texture data.
-         */
-        void reload(TextureLayout const& layout, GLvoid const* data) {
-            m_width = layout.width;
-            m_height = layout.height;
-            m_depth = layout.depth;
-            m_internal_format = layout.internal_format;
-            m_format = layout.format;
-            m_type = layout.type;
-
-            glDeleteTextures(1, &m_name);
-
-            glGenTextures(1, &m_name);
-
-            glBindTexture(GL_TEXTURE_3D, m_name);
-
-            for (auto& pname_pvalue : layout.int_parameters)
-                glTexParameteri(GL_TEXTURE_3D, pname_pvalue.first, pname_pvalue.second);
-
-            for (auto& pname_pvalue : layout.float_parameters)
-                glTexParameterf(GL_TEXTURE_3D, pname_pvalue.first, pname_pvalue.second);
-
-            glTexStorage3D(GL_TEXTURE_3D, 1, m_internal_format, m_width, m_height, m_depth);
-
-            if (data != nullptr)
-                glTexSubImage3D(GL_TEXTURE_3D, 0, 0, 0, 0, m_width, m_height, m_depth, m_format, m_type, data);
-
-            glBindTexture(GL_TEXTURE_3D, 0);
-
-            GLenum err = glGetError();
-            if (err != GL_NO_ERROR) {
-                // "Do something cop!"
-                // std::cerr << "GL error during texture reloading: " << err << std::endl;
-            }
-        }
-
-        TextureLayout getTextureLayout() const {
-            return TextureLayout(m_internal_format, m_width, m_height, m_depth, m_format, m_type, m_levels);
-        }
-
-        unsigned int getWidth() { return m_width; }
-        unsigned int getHeight() { return m_height; }
-        unsigned int getDepth() { return m_depth; }
-
-    private:
-        unsigned int m_width;
-        unsigned int m_height;
-        unsigned int m_depth;
-    };
-
-    std::unique_ptr<vislib::graphics::gl::GLSLComputeShader> m_raycast_volume_compute_shdr;
-    std::unique_ptr<vislib::graphics::gl::GLSLShader> m_render_to_framebuffer_shdr;
-
-    std::unique_ptr<Texture2D> m_render_target;
-
-    std::unique_ptr<Texture3D> m_volume_texture;
-
-    std::unique_ptr<Texture2D> m_transfer_function;
+    std::unique_ptr<glowl::Texture3D> m_volume_texture;
 
     GLuint tf_texture;
 
@@ -454,13 +124,37 @@ private:
     float m_volume_extents[3];
     float m_volume_resolution[3];
 
+    /** Parameters for changing the behavior */
+    core::param::ParamSlot m_mode;
+
+    core::param::ParamSlot m_ray_step_ratio_param;
+    core::param::ParamSlot m_opacity_threshold;
+    core::param::ParamSlot m_iso_value;
+    core::param::ParamSlot m_opacity;
+
+    core::param::ParamSlot m_use_lighting_slot;
+    core::param::ParamSlot m_ka_slot;
+    core::param::ParamSlot m_kd_slot;
+    core::param::ParamSlot m_ks_slot;
+    core::param::ParamSlot m_shininess_slot;
+    core::param::ParamSlot m_ambient_color;
+    core::param::ParamSlot m_specular_color;
+    core::param::ParamSlot m_light_color;
+    core::param::ParamSlot m_material_color;
+
+    core::param::ParamSlot paramOverride;
+    core::param::ParamSlot paramMinOverride;
+    core::param::ParamSlot paramMaxOverride;
+
     /** caller slot */
+    megamol::core::CallerSlot m_renderer_callerSlot;
     megamol::core::CallerSlot m_volumetricData_callerSlot;
     megamol::core::CallerSlot m_transferFunction_callerSlot;
 
-    core::param::ParamSlot m_ray_step_ratio_param;
-
     std::array<float, 2> valRange;
+
+    /** FBO for chaining renderers */
+    vislib::graphics::gl::FramebufferObject fbo;
 };
 
 } // namespace volume
diff --git a/plugins/mmstd_volume/src/mmstd_volume.cpp b/plugins/mmstd_volume/src/mmstd_volume.cpp
index 6258579ab..57016396a 100644
--- a/plugins/mmstd_volume/src/mmstd_volume.cpp
+++ b/plugins/mmstd_volume/src/mmstd_volume.cpp
@@ -16,6 +16,7 @@
 #include "DirectVolumeRenderer.h"
 #include "BuckyBall.h"
 #include "GridBalls.h"
+#include "DifferenceVolume.h"
 #include "DirPartVolume.h"
 #include "VolumeCache.h"
 #include "RenderVolumeSlice.h"
@@ -64,7 +65,7 @@ MMSTD_VOLUME_API const void * mmplgCoreCompatibilityValue(void) {
  * mmplgModuleCount
  */
 MMSTD_VOLUME_API int mmplgModuleCount(void) {
-    return 10;
+    return 11;
 }
 
 
@@ -82,7 +83,8 @@ MMSTD_VOLUME_API void* mmplgModuleDescription(int idx) {
     case 6: return new megamol::core::factories::ModuleAutoDescription<megamol::stdplugin::volume::RenderVolumeSlice>();
 	case 7: return new megamol::core::factories::ModuleAutoDescription<megamol::stdplugin::volume::VolumetricDataSource>();
 	case 8: return new megamol::core::factories::ModuleAutoDescription<megamol::stdplugin::volume::RaycastVolumeRenderer>();
-	case 9: return new megamol::core::factories::ModuleAutoDescription<megamol::stdplugin::volume::DatRawWriter>();
+    case 9: return new megamol::core::factories::ModuleAutoDescription<megamol::stdplugin::volume::DatRawWriter>();
+    case 10: return new megamol::core::factories::ModuleAutoDescription<megamol::stdplugin::volume::DifferenceVolume>();
     }
     return NULL;
 }
diff --git a/plugins/pbs/src/HeadnodeServer.cpp b/plugins/pbs/src/HeadnodeServer.cpp
index 422bdd3c0..6cc9b7701 100644
--- a/plugins/pbs/src/HeadnodeServer.cpp
+++ b/plugins/pbs/src/HeadnodeServer.cpp
@@ -15,6 +15,7 @@
 #include "mmcore/view/AbstractView.h"
 #include "mmcore/view/CallRenderView.h"
 #include "vislib/RawStorageSerialiser.h"
+#include "mmcore/view/AbstractRenderingView.h"
 
 
 megamol::pbs::HeadnodeServer::HeadnodeServer()
@@ -107,9 +108,11 @@ void megamol::pbs::HeadnodeServer::ParamUpdated(core::param::ParamSlot& slot) {
 bool megamol::pbs::HeadnodeServer::get_cam_upd(std::vector<char>& msg) {
 
     AbstractNamedObject::const_ptr_type avp;
+    std::vector<char> const null_buf(MessageHeaderSize, 0);
     const core::view::AbstractView* av = nullptr;
     core::Call* call = nullptr;
     unsigned int csn = 0;
+    bool gotUpdate = false;
 
     av = nullptr;
     call = this->view_slot_.CallAs<core::Call>();
@@ -119,24 +122,59 @@ bool megamol::pbs::HeadnodeServer::get_cam_upd(std::vector<char>& msg) {
     }
     if (av == nullptr) return false;
 
-    csn = av->GetCameraSyncNumber();
-    if ((csn != syncnumber)) {
-        syncnumber = csn;
-        vislib::RawStorage mem;
-        vislib::RawStorageSerialiser serialiser(&mem);
-        av->SerialiseCamera(serialiser);
-
-        msg.resize(MessageHeaderSize + mem.GetSize());
-        msg[0] = static_cast<char>(MessageType::CAM_UPD_MSG);
-        auto size = mem.GetSize();
-        std::copy(reinterpret_cast<char*>(&size), reinterpret_cast<char*>(&size) + MessageSizeSize,
-            msg.begin() + MessageTypeSize);
-        std::copy(mem.AsAt<char>(0), mem.AsAt<char>(0) + mem.GetSize(), msg.begin() + MessageHeaderSize);
-
-        return true;
-    }
+ 
+    const auto fun = [this, &gotUpdate, &msg](Module* mod) {
+        const auto arv = dynamic_cast<core::view::AbstractRenderingView*>(mod);
+        if (!gotUpdate && arv != nullptr) {
+            const auto csn = arv->GetCameraSyncNumber();
+            if (this->syncnumbers.find(arv->FullName().PeekBuffer()) == this->syncnumbers.end() ||
+                csn != this->syncnumbers[arv->FullName().PeekBuffer()]) {
+
+                vislib::RawStorage mem(100);
+                vislib::RawStorageSerialiser serialiser(&mem);
+
+                arv->SerialiseCamera(serialiser);
+
+                const uint32_t viewlen = arv->FullName().Length() + 1;
+                msg.resize(MessageHeaderSize + mem.GetSize() + sizeof(uint32_t) + viewlen);
+                msg[0] = static_cast<char>(MessageType::CAM_UPD_MSG);
+                char* lenpos = msg.data() + 1 + MessageSizeSize;
+                *reinterpret_cast<uint32_t*>(lenpos) = viewlen;
+                char* namepos = lenpos + sizeof(uint32_t);
+                memcpy(namepos, arv->FullName().PeekBuffer(), viewlen);
+                auto size = mem.GetSize() + viewlen + sizeof(uint32_t);
+                std::copy(reinterpret_cast<char*>(&size), reinterpret_cast<char*>(&size) + MessageSizeSize,
+                    msg.begin() + MessageTypeSize);
+                std::copy(mem.AsAt<char>(0), mem.AsAt<char>(0) + mem.GetSize(),
+                    msg.begin() + MessageHeaderSize + sizeof(uint32_t) + viewlen);
+
+                gotUpdate = true;
+
+                this->syncnumbers[arv->FullName().PeekBuffer()] = csn;
+            }
+        }
+    };
+
+    this->GetCoreInstance()->EnumModulesNoLock(av->FullName().PeekBuffer(), fun);
+
+    //csn = av->GetCameraSyncNumber();
+    //if ((csn != syncnumber)) {
+    //    syncnumber = csn;
+    //    vislib::RawStorage mem;
+    //    vislib::RawStorageSerialiser serialiser(&mem);
+    //    av->SerialiseCamera(serialiser);
 
-    return false;
+    //    msg.resize(MessageHeaderSize + mem.GetSize());
+    //    msg[0] = static_cast<char>(MessageType::CAM_UPD_MSG);
+    //    auto size = mem.GetSize();
+    //    std::copy(reinterpret_cast<char*>(&size), reinterpret_cast<char*>(&size) + MessageSizeSize,
+    //        msg.begin() + MessageTypeSize);
+    //    std::copy(mem.AsAt<char>(0), mem.AsAt<char>(0) + mem.GetSize(), msg.begin() + MessageHeaderSize);
+
+    //    return true;
+    //}
+
+    return gotUpdate;
 }
 
 
@@ -179,20 +217,20 @@ void megamol::pbs::HeadnodeServer::do_communication() {
 
     // retrieve modulgraph
     if (this->deploy_project_slot_.Param<core::param::BoolParam>()->Value()) {
-    if (this->GetCoreInstance()->IsLuaProject()) {
-        auto const lua = std::string(this->GetCoreInstance()->GetMergedLuaProject());
-        std::vector<char> msg(MessageHeaderSize + lua.size());
-        msg[0] = MessageType::PRJ_FILE_MSG;
-        auto size = lua.size();
-        std::copy(reinterpret_cast<char*>(&size), reinterpret_cast<char*>(&size) + MessageSizeSize,
-            msg.begin() + MessageTypeSize);
-        std::copy(lua.begin(), lua.end(), msg.begin() + MessageHeaderSize);
-        {
-            std::lock_guard<std::mutex> lock(send_buffer_guard_);
-            send_buffer_.insert(send_buffer_.end(), msg.begin(), msg.end());
+        if (this->GetCoreInstance()->IsLuaProject()) {
+            auto const lua = std::string(this->GetCoreInstance()->GetMergedLuaProject());
+            std::vector<char> msg(MessageHeaderSize + lua.size());
+            msg[0] = MessageType::PRJ_FILE_MSG;
+            auto size = lua.size();
+            std::copy(reinterpret_cast<char*>(&size), reinterpret_cast<char*>(&size) + MessageSizeSize,
+                msg.begin() + MessageTypeSize);
+            std::copy(lua.begin(), lua.end(), msg.begin() + MessageHeaderSize);
+            {
+                std::lock_guard<std::mutex> lock(send_buffer_guard_);
+                send_buffer_.insert(send_buffer_.end(), msg.begin(), msg.end());
+            }
         }
     }
-    }
     try {
         while (run_threads_) {
             // Wait for message
@@ -215,7 +253,7 @@ void megamol::pbs::HeadnodeServer::do_communication() {
                 }
 
                 if (!send_buffer_.empty()) {
-		    // vislib::sys::Log::DefaultLog.WriteInfo("HeadnodeServer: Sending parameter update.\n");
+                    // vislib::sys::Log::DefaultLog.WriteInfo("HeadnodeServer: Sending parameter update.\n");
                     comm_fabric_.Send(send_buffer_, send_type::SEND);
                     send_buffer_.clear();
                     buffer_has_changed_.store(false);
diff --git a/plugins/pbs/src/HeadnodeServer.h b/plugins/pbs/src/HeadnodeServer.h
index 2a01e3668..b230cee66 100644
--- a/plugins/pbs/src/HeadnodeServer.h
+++ b/plugins/pbs/src/HeadnodeServer.h
@@ -12,6 +12,7 @@
 
 #include "DistributedProto.h"
 #include "FBOCommFabric.h"
+#include <map>
 
 namespace megamol {
 namespace pbs {
@@ -108,7 +109,8 @@ private:
 
     std::vector<char> send_buffer_;
 
-    unsigned int syncnumber = -1;
+    // unsigned int syncnumber = -1;
+    std::map<std::string, unsigned int> syncnumbers;
 
     std::thread comm_thread_;
 
diff --git a/plugins/pbs/src/RendernodeView.cpp b/plugins/pbs/src/RendernodeView.cpp
index 9d8114881..2d76bd6d8 100644
--- a/plugins/pbs/src/RendernodeView.cpp
+++ b/plugins/pbs/src/RendernodeView.cpp
@@ -14,6 +14,7 @@
 #include "vislib/RawStorageSerialiser.h"
 #include "vislib/sys/Log.h"
 #include "vislib/sys/SystemInformation.h"
+#include "mmcore/view/AbstractRenderingView.h"
 
 //#define RV_DEBUG_OUTPUT = 1
 
@@ -104,12 +105,23 @@ bool megamol::pbs::RendernodeView::process_msgs(Message_t const& msgs) {
                 msg.resize(size);
                 std::copy(ibegin + MessageHeaderSize, ibegin + MessageHeaderSize + size, msg.begin());
             }
-            vislib::RawStorageSerialiser ser(reinterpret_cast<unsigned char*>(msg.data()), msg.size());
-            auto view = this->getConnectedView();
-            if (view != nullptr) {
-                view->DeserialiseCamera(ser);
-            } else {
-                vislib::sys::Log::DefaultLog.WriteError("RendernodeView: Cannot update camera. No view connected.");
+            uint32_t namelen = *reinterpret_cast<uint32_t*>(msg.data());
+            std::string viewname(msg.data() + sizeof(uint32_t));
+
+            vislib::RawStorageSerialiser ser(reinterpret_cast<unsigned char*>(msg.data() + sizeof(uint32_t) + namelen), msg.size() - namelen - sizeof(uint32_t));
+            //vislib::sys::Log::DefaultLog.WriteInfo("got info about view %s (len: %u), ser mem len = %u",
+            //    viewname.c_str(), namelen, ser.Storage()->GetSize());
+
+            bool foundview = false;
+            const auto fun = [&ser, &foundview](core::view::AbstractRenderingView* mod) {
+                mod->DeserialiseCamera(ser);
+                foundview = true;
+            };
+
+            this->GetCoreInstance()->FindModuleNoLock<core::view::AbstractRenderingView>(viewname, fun);
+           
+            if (!foundview) {
+                vislib::sys::Log::DefaultLog.WriteError("RendernodeView: Cannot update camera. Cannot find view %s.", viewname.c_str());
             }
         } break;
         case MessageType::HEAD_DISC_MSG:
