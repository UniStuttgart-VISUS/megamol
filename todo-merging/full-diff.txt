diff --git a/.gitignore b/.gitignore
index 842cfc9c4..af782591d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -27,4 +27,9 @@ utils/MMPLD/test*.mmpld
 utils/MMPLD/test*.lua
 utils/MMPLD/test*.png
 utils/MMPLD/SphereTest.bat
-examples/
\ No newline at end of file
+/.vs
+/astroschulz.mmprj
+examples/
+/astroschulz2.mmprj
+solution/**/*
+deploy/**/*
diff --git a/.travis.yml b/.travis.yml
index 0a89596ae..91af51694 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -18,6 +18,17 @@ matrix:
       env:
         - CC=gcc-7
         - CXX=g++-7
+    - os: linux
+      dist: xenial
+      addons:
+        apt:
+          sources:
+            - ubuntu-toolchain-r-test
+          packages:
+            - g++-9
+      env:
+        - CC=gcc-9
+        - CXX=g++-9
 
 before_install:
   - . travis/install-cuda-xenial.sh
@@ -33,7 +44,7 @@ before_install:
   - sudo apt-get install -y libcgal-qt5-dev
   - sudo apt-get install -y libcgal-dev
   - mkdir build && cd build
-  - cmake ../ -DCMAKE_CXX_FLAGS=-Wno-deprecated-declarations -DENABLE_CUDA=ON -DSUPPRESS_CUDA_WARNINGS=TRUE -DBUILD_PROTEIN_CUDA_PLUGIN=ON
+  - cmake ../ -DCMAKE_CXX_FLAGS=-w -DENABLE_CUDA=ON -DSUPPRESS_CUDA_WARNINGS=TRUE -DBUILD_PROTEIN_CUDA_PLUGIN=ON
 
 install:
   - make install
diff --git a/CMakeExternals.cmake b/CMakeExternals.cmake
index 7daf497d6..448fe2a78 100644
--- a/CMakeExternals.cmake
+++ b/CMakeExternals.cmake
@@ -10,7 +10,7 @@ function(require_external NAME)
     if(TARGET libzmq OR TARGET libcppzmq)
       return()
     endif()
-    
+
     set(ZMQ_VER "4_2_3")
     string(REPLACE "_" "." ZMQ_TAG "v${ZMQ_VER}")
     if(MSVC_IDE)
@@ -85,7 +85,7 @@ function(require_external NAME)
     if(TARGET libpng)
       return()
     endif()
-    
+
     require_external(zlib)
 
     if(MSVC)
@@ -98,9 +98,10 @@ function(require_external NAME)
     endif()
     ExternalProject_Get_Property(zlib_ext INSTALL_DIR)
     add_external_project(libpng_ext
-      GIT_REPOSITORY https://git.code.sf.net/p/libpng/code
+      GIT_REPOSITORY https://github.com/UniStuttgart-VISUS/libpng.git
       GIT_TAG "v1.6.34"
       DEPENDS zlib_ext
+      BUILD_BYPRODUCTS "<INSTALL_DIR>/${LIBPNG_DEBUG}" "<INSTALL_DIR>/${LIBPNG_RELEASE}"
       CMAKE_ARGS
         -DPNG_SHARED=OFF
         -DPNG_TESTS=OFF
@@ -117,7 +118,7 @@ function(require_external NAME)
     if(TARGET zfp)
       return()
     endif()
-    
+
     if(WIN32)
       set(ZFP_LIB "lib/zfp.lib")
     else()
@@ -143,7 +144,7 @@ function(require_external NAME)
     if(TARGET glm)
       return()
     endif()
-    
+
     add_external_project(glm_ext
       GIT_REPOSITORY https://github.com/g-truc/glm.git
       GIT_TAG "0.9.8"
@@ -160,7 +161,7 @@ function(require_external NAME)
     if(TARGET glowl)
       return()
     endif()
-    
+
     add_external_project(glowl_ext
       GIT_REPOSITORY https://github.com/invor/glowl.git
       GIT_TAG "v0.1"
@@ -176,7 +177,7 @@ function(require_external NAME)
     if(TARGET json)
       return()
     endif()
-    
+
     add_external_project(json_ext
       GIT_REPOSITORY https://github.com/azadkuh/nlohmann_json_release.git
       GIT_TAG "v3.5.0"
@@ -193,7 +194,7 @@ function(require_external NAME)
     if(TARGET Eigen)
       return()
     endif()
-    
+
     add_external_project(Eigen_ext
       GIT_REPOSITORY https://github.com/eigenteam/eigen-git-mirror.git
       GIT_TAG "3.3.4"
@@ -204,12 +205,12 @@ function(require_external NAME)
     add_external_library(Eigen INTERFACE
       DEPENDS Eigen_ext
       INCLUDE_DIR "src/Eigen_ext")
-	  
+
   elseif(NAME STREQUAL "nanoflann")
     if(TARGET nanoflann)
       return()
     endif()
-    
+
     add_external_project(nanoflann_ext
       GIT_REPOSITORY https://github.com/jlblancoc/nanoflann.git
       GIT_TAG "v1.3.0"
@@ -220,12 +221,12 @@ function(require_external NAME)
     add_external_library(nanoflann INTERFACE
       DEPENDS nanoflann_ext
       INCLUDE_DIR "src/nanoflann_ext/include")
-	  
+
   elseif(NAME STREQUAL "Delaunator")
     if(TARGET Delaunator)
       return()
     endif()
-	
+
     add_external_project(Delaunator_ext
       GIT_REPOSITORY https://github.com/delfrrr/delaunator-cpp.git
       GIT_TAG "v0.4.0"
@@ -248,28 +249,45 @@ function(require_external NAME)
     set(TRACKING_NATNET_IMPORT_LIB "src/tracking_ext/tracking/natnet/lib/x64/NatNetLib.lib")
 
     add_external_project(tracking_ext
-      GIT_REPOSITORY https://github.com/UniStuttgart-VISUS/mm-tracking
-      CMAKE_ARGS 
-      -DCREATE_TRACKING_TEST_PROGRAM=OFF)
+        GIT_REPOSITORY https://github.com/UniStuttgart-VISUS/mm-tracking.git
+        CMAKE_ARGS 
+          -DCREATE_TRACKING_TEST_PROGRAM=OFF)
 
     add_external_library(tracking SHARED 
-      DEPENDS tracking_ext 
-      IMPORT_LIBRARY_DEBUG ${TRACKING_IMPORT_LIB}
-      IMPORT_LIBRARY_RELEASE ${TRACKING_IMPORT_LIB}
-      LIBRARY_DEBUG ${TRACKING_LIB}
-      LIBRARY_RELEASE ${TRACKING_LIB})
+        DEPENDS tracking_ext 
+        IMPORT_LIBRARY_DEBUG ${TRACKING_IMPORT_LIB}
+        IMPORT_LIBRARY_RELEASE ${TRACKING_IMPORT_LIB}
+        LIBRARY_DEBUG ${TRACKING_LIB}
+        LIBRARY_RELEASE ${TRACKING_LIB})
 
     add_external_library(natnet SHARED 
-      DEPENDS tracking_ext 
-      IMPORT_LIBRARY_DEBUG ${TRACKING_NATNET_IMPORT_LIB}
-      IMPORT_LIBRARY_RELEASE ${TRACKING_NATNET_IMPORT_LIB}
-      LIBRARY_DEBUG ${TRACKING_NATNET_LIB}     
-      LIBRARY_RELEASE ${TRACKING_NATNET_LIB})
+        DEPENDS tracking_ext 
+        IMPORT_LIBRARY_DEBUG ${TRACKING_NATNET_IMPORT_LIB}
+        IMPORT_LIBRARY_RELEASE ${TRACKING_NATNET_IMPORT_LIB}
+        LIBRARY_DEBUG ${TRACKING_NATNET_LIB}     
+        LIBRARY_RELEASE ${TRACKING_NATNET_LIB})
 
     add_external_library(tracking_int INTERFACE
       DEPENDS tracking_ext
       INCLUDE_DIR "src/tracking_ext/tracking/include")
 
+  elseif(NAME STREQUAL "sim_sort")
+    if(TARGET sim_sort)
+      return()
+    endif()
+
+    add_external_project(sim_sort_ext
+      GIT_REPOSITORY https://github.com/alexstraub1990/simultaneous-sort.git
+      CONFIGURE_COMMAND ""
+      BUILD_COMMAND ""
+      INSTALL_COMMAND ""
+      TEST_COMMAND ""
+    )
+    add_external_library(sim_sort INTERFACE
+      DEPENDS sim_sort_ext
+      INCLUDE_DIR "src/sim_sort_ext/include"
+    )
+
   else()
     message(FATAL_ERROR "Unknown external required \"${NAME}\"")
   endif()
diff --git a/core/Shaders/arrow.btf b/core/Shaders/arrow.btf
index b0797e818..dd43413f4 100644
--- a/core/Shaders/arrow.btf
+++ b/core/Shaders/arrow.btf
@@ -78,7 +78,7 @@ void main(void) {
     vec3 fromPos = gl_Vertex.xyz + (dir * 0.5) * lengthScale;
     vec3 toPos = gl_Vertex.xyz - (dir * 0.5) * lengthScale;
 
-    inPos = vec4((fromPos + toPos) * vec3(0.5), 1.0);
+    inPos = vec4(gl_Vertex.xyz, 1.0);
 
     rad.y = rad.x * rad.x;
     //rad.z = 1.0; // half cylinder length
@@ -233,16 +233,18 @@ void main(void) {
 
     if (bitflag_test(flags, FLAG_SELECTED, FLAG_SELECTED)) {
         gl_FrontColor = vec4(1.0, 0.0, 0.0, 1.0);
-    } else {
     }
-    if (bitflag_test(flags, FLAG_FILTERED, FLAG_FILTERED)) {
-    } else {
+    
     gl_Position = vec4(
       (minP + maxP) * 0.5,
       0.5, 
       ( CYL_HALF_LEN < lengthFilter * 0.5) ? 0.0 : 1.0
       );
+    
+    if (bitflag_test(flags, FLAG_FILTERED, FLAG_FILTERED)) {
+        gl_Position.w = 0.0;
     }
+    
     maxP = (maxP - minP) * 0.5 * winHalf;
     gl_PointSize = max(maxP.x, maxP.y) + 0.5;
 
diff --git a/core/Shaders/phong.glsl b/core/Shaders/phong.glsl
new file mode 100644
index 000000000..ea634f22b
--- /dev/null
+++ b/core/Shaders/phong.glsl
@@ -0,0 +1,21 @@
+uniform float ka;
+uniform float kd;
+uniform float ks;
+uniform float shininess;
+
+uniform vec3 light;
+
+uniform vec3 ambient_col;
+uniform vec3 specular_col;
+uniform vec3 light_col;
+
+vec3 phong(vec3 color, vec3 normal, vec3 eye, vec3 light) {
+    eye = normalize(eye);
+    light = normalize(light);
+
+    vec3 ambient = ka * ambient_col * color;
+    vec3 diffuse = kd * light_col * color * max(0, dot(normal, light));
+    vec3 specular = ks * light_col * specular_col * pow(max(0, dot(normal, normalize(light + eye))), shininess);
+
+    return clamp(ambient + diffuse + specular, vec3(0), vec3(1));
+}
diff --git a/core/Shaders/sphere/simple_frag_mainstart.glsl b/core/Shaders/sphere/simple_frag_mainstart.glsl
index ce783e1c5..4eba60c74 100644
--- a/core/Shaders/sphere/simple_frag_mainstart.glsl
+++ b/core/Shaders/sphere/simple_frag_mainstart.glsl
@@ -1,7 +1,6 @@
-#extension GL_ARB_explicit_attrib_location : require   // glsl version 130
-#extension GL_ARB_conservative_depth       : require   // glsl version 130
-layout (depth_greater) out float gl_FragDepth; 
-
+#extension GL_ARB_explicit_attrib_location : require // glsl version 130
+//#extension GL_ARB_conservative_depth       : require   // glsl version 130
+// layout (depth_greater) out float gl_FragDepth;
 
 #ifdef BACKSIDE_ENABLED
 uniform float hitsideFlag;
@@ -19,6 +18,8 @@ uniform vec4 viewAttr;
 uniform mat4 MVPinv;
 uniform mat4 MVPtransp;
 
+uniform float outlinesize = 2.0;
+
 FLACH in vec4 objPos;
 FLACH in vec4 camPos;
 FLACH in vec4 lightPos;
@@ -87,13 +88,13 @@ void main(void) {
     vec3 sphereintersection = lambda * ray + camPos.xyz;    // intersection point
     vec3 normal = sphereintersection / rad;
 
-
+    float d, dist1, dist2;
     if (any(notEqual(clipDat.xyz, vec3(0, 0, 0)))) {
         vec3 planeNormal = normalize(clipDat.xyz);
         vec3 clipPlaneBase = planeNormal * clipDat.w;
-        float d = -dot(planeNormal, clipPlaneBase - objPos.xyz);
-        float dist1 = dot(sphereintersection, planeNormal) + d;
-        float dist2 = d;
+        d = -dot(planeNormal, clipPlaneBase - objPos.xyz);
+        dist1 = dot(sphereintersection, planeNormal) + d;
+        dist2 = d;
         float t = -(dot(planeNormal, camPos.xyz) + d) / dot(planeNormal, ray);
         vec3 planeintersect = camPos.xyz + t * ray;
         if (dist1 > 0.0) {
diff --git a/core/Shaders/sphere/simple_frag_out-nolighting.glsl b/core/Shaders/sphere/simple_frag_out-nolighting.glsl
new file mode 100644
index 000000000..0b1604656
--- /dev/null
+++ b/core/Shaders/sphere/simple_frag_out-nolighting.glsl
@@ -0,0 +1,3 @@
+    // phong lighting with directional light
+    //outColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color.rgb), color.a);
+    outColor = color;
diff --git a/core/Shaders/sphere/simple_frag_outline-cutout.glsl b/core/Shaders/sphere/simple_frag_outline-cutout.glsl
new file mode 100644
index 000000000..b4df5ac98
--- /dev/null
+++ b/core/Shaders/sphere/simple_frag_outline-cutout.glsl
@@ -0,0 +1,24 @@
+//float m_pi = 3.14159265358;
+//float wid = m_pi / 64;
+//float azimuth = atan(normal.y, normal.x);
+//azimuth = azimuth + m_pi; // scale up to range (0,2pi)
+//float inclination = acos(normal.z);
+//
+//bool throwaway = false;
+//float divisions = 8.0;
+//for (int i = 0; i < int(divisions + 0.5); i++) {
+//    float curazi = float(i) * (2.0 * m_pi / divisions);
+//    float nextazi = float(i + 1) * (2.0 * m_pi / divisions);
+//    if (azimuth > curazi + wid && azimuth < nextazi - wid) {
+//        throwaway = true;
+//    }
+//}
+//
+//float wf = 4.0f;
+//if (inclination < wf * wid || inclination > m_pi - wf * wid) throwaway = false;
+//if (inclination > (m_pi / 2.0) - wid && inclination < (m_pi / 2.0) + wid) throwaway = false;
+//
+//if (throwaway) discard;
+
+if (radicand > outlinesize) discard;
+// TODO make this independent of the sphere radius
\ No newline at end of file
diff --git a/core/Shaders/sphere_outline.btf b/core/Shaders/sphere_outline.btf
new file mode 100644
index 000000000..5e2bd9eb2
--- /dev/null
+++ b/core/Shaders/sphere_outline.btf
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?>
+<btf type="MegaMolGLSLShader" version="1.0" namespace="sphere_outline">
+    <include file="common"/>
+
+    <shader name="vertex">
+        <snippet type="version">130</snippet>
+        <snippet name="CommonDefines"    type="file">commondefines.glsl</snippet>
+        <snippet name="Attributes"       type="file">sphere/simple_vert_attributes.glsl</snippet>
+        <snippet name="MainStart"        type="file">sphere/simple_vert_mainstart.glsl</snippet>
+        <snippet name="PosTrans"         type="file">sphere/simple_vert_postrans.glsl</snippet>
+        <snippet name="ClippingPlane"    type="file">sphere/simple_vert_clipping.glsl</snippet>
+        <snippet name="SphereTouchPlane" type="file">sphere/simple_vert_spheretouchplane.glsl</snippet>
+        <snippet name="PosOutput"        type="file">sphere/simple_vert_posout.glsl</snippet>
+        <snippet name="MainEnd"          type="file">sphere/simple_vert_mainend.glsl</snippet>
+    </shader>
+
+    <shader name="fragment">
+        <snippet type="version">130</snippet>
+        <snippet name="CommonDefines"    type="file">commondefines.glsl</snippet>
+        <snippet name="MainStart"        type="file">sphere/simple_frag_mainstart.glsl</snippet>
+        <snippet name="OutlineCutout"    type="file">sphere/simple_frag_outline-cutout.glsl</snippet>
+        <snippet name="OutLighting"      type="file">sphere/simple_frag_out-nolighting.glsl</snippet>
+        <snippet name="OutDepth"         type="file">sphere/simple_frag_out-depth.glsl</snippet>
+        <snippet name="MainEnd"          type="file">sphere/simple_frag_mainend.glsl</snippet>
+
+        <snippet name="LightDirectional" type="file">lightdirectional.glsl</snippet>
+    </shader>
+
+</btf>
diff --git a/core/include/mmcore/misc/VolumetricDataCall.h b/core/include/mmcore/misc/VolumetricDataCall.h
index 94abdbcc5..2730eed13 100644
--- a/core/include/mmcore/misc/VolumetricDataCall.h
+++ b/core/include/mmcore/misc/VolumetricDataCall.h
@@ -74,6 +74,19 @@ namespace misc {
          */
         static const char *FunctionName(unsigned int idx);
 
+        /**
+         * Invoke the metadata call and possibly the data call if the metadata
+         * call does not provide meaningful data.
+         *
+         * Consider using this convenience method if your sink is connected to
+         * a live source that cannot implement the metadata call.
+         *
+         * @param call Teh call to be invoked.
+         *
+         * @return true if the call succeeded, false otherwise.
+         */
+        static bool GetMetadata(core::misc::VolumetricDataCall& call);
+
         /** Index of the function retrieving the data. */
         static const unsigned int IDX_GET_DATA;
 
diff --git a/core/include/mmcore/misc/VolumetricDataCallTypes.h b/core/include/mmcore/misc/VolumetricDataCallTypes.h
index 7983dabc9..1e187893d 100644
--- a/core/include/mmcore/misc/VolumetricDataCallTypes.h
+++ b/core/include/mmcore/misc/VolumetricDataCallTypes.h
@@ -18,119 +18,126 @@ namespace megamol {
 namespace core {
 namespace misc {
 
-/** Possible type of grids. */
-enum GridType_t { NONE, CARTESIAN, RECTILINEAR, TETRAHEDRAL };
-
-/** Possible types of scalars. */
-enum ScalarType_t { UNKNOWN, SIGNED_INTEGER, UNSIGNED_INTEGER, FLOATING_POINT, BITS };
-
-/** Possible (physical) memory locations */
-enum MemoryLocation { VRAM, RAM };
-
-/** Structure containing all required metadata about a data set. */
-struct VolumetricMetadata_t {
-
-    /** Initialise a new instance. */
-    VolumetricMetadata_t(void) {
-        ::memset(this->Resolution, 0, sizeof(this->Resolution));
-        ::memset(this->SliceDists, 0, sizeof(this->SliceDists));
-        ::memset(this->Origin, 0, sizeof(this->Origin));
-        ::memset(this->IsUniform, 0, sizeof(this->IsUniform));
-        ::memset(this->Extents, 0, sizeof(this->Extents));
-        MinValues = nullptr;
-        MaxValues = nullptr;
-		MemLoc = RAM;
-    }
-
-    // creates a deep copy of the instance. beware that the owner of the copy
-    // needs to deallocate the components of SliceDists and all of MinValues and MaxValues explicitly!
-    VolumetricMetadata_t Clone() const {
-        VolumetricMetadata_t clone;
-        clone.Components = this->Components;
-        clone.GridType = this->GridType;
-        clone.ScalarType = this->ScalarType;
-        clone.ScalarLength = this->ScalarLength;
-        clone.NumberOfFrames = this->NumberOfFrames;
-        memcpy(clone.Resolution, this->Resolution, sizeof(size_t) * 3);
-        memcpy(clone.Origin, this->Origin, sizeof(float) * 3);
-        memcpy(clone.IsUniform, this->IsUniform, sizeof(bool) * 3);
-        memcpy(clone.Extents, this->Extents, sizeof(float) * 3);
-
-        if (this->GridType == RECTILINEAR) {
-            for (auto x = 0; x < 3; ++x) {
-                clone.SliceDists[x] = new float[this->Resolution[x] - 1];
-                memcpy(clone.SliceDists[x], this->SliceDists[x], sizeof(float) * (this->Resolution[x] - 1));
-            }
-        } else {
-            for (auto x = 0; x < 3; ++x) {
-                clone.SliceDists[x] = new float[1];
-                *clone.SliceDists[x] = *this->SliceDists[x];
-            }
-        }
-        clone.MinValues = new double[this->Components];
-        clone.MaxValues = new double[this->Components];
-        memcpy(clone.MinValues, this->MinValues, sizeof(double) * this->Components);
-        memcpy(clone.MaxValues, this->MaxValues, sizeof(double) * this->Components);
-		clone.MemLoc = this->MemLoc;
-        return clone;
-    }
-
-    /** The type of the grid. */
-    enum GridType_t GridType;
-
-    /** The resolution of the three dimensions. */
-    size_t Resolution[3];
-
-    /** The type of a scalar. */
-    enum ScalarType_t ScalarType;
-
-    /** The length of a scalar in bytes. */
-    size_t ScalarLength;
-
-    /** The number of components per grid point. */
-    size_t Components;
-
-    /**
-     * The distance between slices each of the three dimensions. The
-     * data source providing the metadata remains owner of the arrays.
-     */
-    float* SliceDists[3];
-
-    /**
-     * The origin of the coordinate system used by this data set
-     */
-    float Origin[3];
-
-    /**
-     * Determines whether SliceDists[i] is uniform and has only one
-     * entry.
-     */
-    bool IsUniform[3];
+    /** Possible type of grids. */
+    enum GridType_t { NONE, CARTESIAN, RECTILINEAR, TETRAHEDRAL };
 
-    /** The total number of frames in the data set. */
-    size_t NumberOfFrames;
+    /** Possible types of scalars. */
+    enum ScalarType_t { UNKNOWN, SIGNED_INTEGER, UNSIGNED_INTEGER, FLOATING_POINT, BITS };
 
-    /**
-     * The extents of the data set, taking into account that the slices
-     * might have different distances.
-     */
-    float Extents[3];
+    /** Possible (physical) memory locations */
+    enum MemoryLocation { VRAM, RAM };
 
     /**
-     * Minimal values per component.
+     * Structure containing all required metadata about a data set, which are
+     * natively stored by the datRaw library (the structure allows for zero-copy
+     * transfer of the metadata).
+     *
+     * Use a VolumetricMetadataStore if you need to compute the metadata
+     * yourself instead of obtaining them from the datraw library.
      */
-    double* MinValues;
+    struct VolumetricMetadata_t {
+
+        /** Initialise a new instance. */
+        VolumetricMetadata_t(void) {
+            ::memset(this->Resolution, 0, sizeof(this->Resolution));
+            ::memset(this->SliceDists, 0, sizeof(this->SliceDists));
+            ::memset(this->Origin, 0, sizeof(this->Origin));
+            ::memset(this->IsUniform, 0, sizeof(this->IsUniform));
+            ::memset(this->Extents, 0, sizeof(this->Extents));
+            MinValues = nullptr;
+            MaxValues = nullptr;
+		    MemLoc = RAM;
+        }
 
-    /**
-     * Maximal values per component.
-     */
-    double* MaxValues;
+        // creates a deep copy of the instance. beware that the owner of the copy
+        // needs to deallocate the components of SliceDists and all of MinValues and MaxValues explicitly!
+        VolumetricMetadata_t Clone() const {
+            VolumetricMetadata_t clone;
+            clone.Components = this->Components;
+            clone.GridType = this->GridType;
+            clone.ScalarType = this->ScalarType;
+            clone.ScalarLength = this->ScalarLength;
+            clone.NumberOfFrames = this->NumberOfFrames;
+            memcpy(clone.Resolution, this->Resolution, sizeof(size_t) * 3);
+            memcpy(clone.Origin, this->Origin, sizeof(float) * 3);
+            memcpy(clone.IsUniform, this->IsUniform, sizeof(bool) * 3);
+            memcpy(clone.Extents, this->Extents, sizeof(float) * 3);
+
+            if (this->GridType == RECTILINEAR) {
+                for (auto x = 0; x < 3; ++x) {
+                    clone.SliceDists[x] = new float[this->Resolution[x] - 1];
+                    memcpy(clone.SliceDists[x], this->SliceDists[x], sizeof(float) * (this->Resolution[x] - 1));
+                }
+            } else {
+                for (auto x = 0; x < 3; ++x) {
+                    clone.SliceDists[x] = new float[1];
+                    *clone.SliceDists[x] = *this->SliceDists[x];
+                }
+            }
+            clone.MinValues = new double[this->Components];
+            clone.MaxValues = new double[this->Components];
+            memcpy(clone.MinValues, this->MinValues, sizeof(double) * this->Components);
+            memcpy(clone.MaxValues, this->MaxValues, sizeof(double) * this->Components);
+		    clone.MemLoc = this->MemLoc;
+            return clone;
+        }
 
-	/**
-	 * (Physical) memory location of the volume data.
-	 */
-	enum MemoryLocation	MemLoc;
-};
+        /** The type of the grid. */
+        enum GridType_t GridType;
+
+        /** The resolution of the three dimensions. */
+        size_t Resolution[3];
+
+        /** The type of a scalar. */
+        enum ScalarType_t ScalarType;
+
+        /** The length of a scalar in bytes. */
+        size_t ScalarLength;
+
+        /** The number of components per grid point. */
+        size_t Components;
+
+        /**
+         * The distance between slices each of the three dimensions. The
+         * data source providing the metadata remains owner of the arrays.
+         */
+        float* SliceDists[3];
+
+        /**
+         * The origin of the coordinate system used by this data set
+         */
+        float Origin[3];
+
+        /**
+         * Determines whether SliceDists[i] is uniform and has only one
+         * entry.
+         */
+        bool IsUniform[3];
+
+        /** The total number of frames in the data set. */
+        size_t NumberOfFrames;
+
+        /**
+         * The extents of the data set, taking into account that the slices
+         * might have different distances.
+         */
+        float Extents[3];
+
+        /**
+         * Minimal values per component.
+         */
+        double* MinValues;
+
+        /**
+         * Maximal values per component.
+         */
+        double* MaxValues;
+
+	    /**
+	     * (Physical) memory location of the volume data.
+	     */
+	    enum MemoryLocation	MemLoc;
+    };
 
 } /* end namespace misc */
 } /* end namespace core */
diff --git a/core/include/mmcore/misc/VolumetricMetadataStore.h b/core/include/mmcore/misc/VolumetricMetadataStore.h
new file mode 100644
index 000000000..72f67ca54
--- /dev/null
+++ b/core/include/mmcore/misc/VolumetricMetadataStore.h
@@ -0,0 +1,56 @@
+/*
+ * VolumetricMetadataStore.h
+ *
+ * Copyright (C) 2019 by Visualisierungsinstitut der Universität Stuttgart.
+ * Alle rechte vorbehalten.
+ */
+
+#pragma once
+
+#include <array>
+#include <vector>
+
+#include "mmcore/api/MegaMolCore.std.h"
+
+#include "mmcore/misc/VolumetricDataCallTypes.h"
+
+
+namespace megamol {
+namespace core {
+namespace misc {
+
+    /**
+     * A self-contained storage class for VolumetricMetadata_t to be used if the
+     * metadata are not obtained from the datRaw library.
+     */
+    class MEGAMOLCORE_API VolumetricMetadataStore : public VolumetricMetadata_t {
+
+    public:
+
+        VolumetricMetadataStore(void) = default;
+
+        VolumetricMetadataStore(const VolumetricMetadataStore& rhs);
+
+        VolumetricMetadataStore(VolumetricMetadataStore&& rhs) noexcept;
+
+        VolumetricMetadataStore(const VolumetricMetadata_t& rhs);
+
+        VolumetricMetadataStore& operator =(const VolumetricMetadataStore& rhs);
+
+        VolumetricMetadataStore& operator =(VolumetricMetadataStore&& rhs) noexcept;
+
+        VolumetricMetadataStore& operator =(const VolumetricMetadata_t& rhs);
+
+    private:
+
+        void rewrire(void);
+
+        std::vector<double >maxValues;
+        std::vector<double> minValues;
+        std::array<std::vector<float>, 3> sliceDists;
+
+    };
+
+} /* end namespace misc */
+} /* end namespace core */
+} /* end namespace megamol */
diff --git a/core/include/mmcore/moldyn/ArrowRenderer.h b/core/include/mmcore/moldyn/ArrowRenderer.h
index 4f29b040f..59e7c6f0b 100644
--- a/core/include/mmcore/moldyn/ArrowRenderer.h
+++ b/core/include/mmcore/moldyn/ArrowRenderer.h
@@ -100,6 +100,9 @@ namespace moldyn {
         /** The arrow shader */
         vislib::graphics::gl::GLSLShader arrowShader;
 
+        /** The call for a chained renderer */
+        CallerSlot getRenderSlot;
+
         /** The call for data */
         CallerSlot getDataSlot;
 
diff --git a/core/include/mmcore/moldyn/SphereOutlineRenderer.h b/core/include/mmcore/moldyn/SphereOutlineRenderer.h
index 73e24ea94..7646f54b0 100644
--- a/core/include/mmcore/moldyn/SphereOutlineRenderer.h
+++ b/core/include/mmcore/moldyn/SphereOutlineRenderer.h
@@ -1,7 +1,7 @@
 /*
  * SphereOutlineRenderer.h
  *
- * Copyright (C) 2009 by VISUS (Universitaet Stuttgart)
+ * Copyright (C) 2009 - 2019 by VISUS (Universitaet Stuttgart)
  * Alle Rechte vorbehalten.
  */
 
@@ -114,6 +114,9 @@ namespace moldyn {
         /** The distance of the additional outlines as angles in radians */
         param::ParamSlot multiOutLineDistSlot;
 
+        /** A user-defined scaling factor applied on the radius. */
+        param::ParamSlot paramScaling;
+
         /** The sphere quadric */
         void *sphereQuadric;
 
diff --git a/core/include/mmcore/moldyn/SphereRenderer.h b/core/include/mmcore/moldyn/SphereRenderer.h
index 4aba3db56..f1a584f7a 100644
--- a/core/include/mmcore/moldyn/SphereRenderer.h
+++ b/core/include/mmcore/moldyn/SphereRenderer.h
@@ -234,7 +234,8 @@ namespace moldyn {
             SSBO_STREAM       = 3,
             BUFFER_ARRAY      = 4,
             SPLAT             = 5,
-            AMBIENT_OCCLUSION = 6 
+            AMBIENT_OCCLUSION = 6,
+            OUTLINE = 7
         };
 
         typedef std::map <std::tuple<int, int, bool>, std::shared_ptr<GLSLShader> > shaderMap;
@@ -344,6 +345,8 @@ namespace moldyn {
         megamol::core::param::ParamSlot aoConeLengthSlot;
         // High precision textures slot
         megamol::core::param::ParamSlot useHPTexturesSlot;
+        // size of the outline
+        megamol::core::param::ParamSlot outlineSizeSlot;
 
 
         /*********************************************************************/
@@ -388,6 +391,7 @@ namespace moldyn {
         bool renderSplat(view::CallRender3D* cr3d, MultiParticleDataCall* mpdc);
         bool renderBufferArray(view::CallRender3D* cr3d, MultiParticleDataCall* mpdc);
         bool renderAmbientOcclusion(view::CallRender3D* cr3d, MultiParticleDataCall* mpdc);
+        bool renderOutline(view::CallRender3D* cr3d, MultiParticleDataCall* mpdc);
 
         /**
          * Set pointers to vertex and color buffers and corresponding shader variables.
diff --git a/core/include/mmcore/thecam/utility/types.h b/core/include/mmcore/thecam/utility/types.h
index 20dc49ccd..12479cd81 100644
--- a/core/include/mmcore/thecam/utility/types.h
+++ b/core/include/mmcore/thecam/utility/types.h
@@ -42,6 +42,7 @@
 #    pragma managed(push, off)
 #endif /* defined(_WIN32) && defined(_MANAGED) */
 
+#include "mmcore/api/MegaMolCore.std.h"
 #include "mmcore/thecam/utility/config.h"
 
 #if defined(THE_WINDOWS)
@@ -79,13 +80,13 @@ typedef int do_not_initialise_t;
  * A constant that can be passed to some methods (eg megamol::core::thecam::ring_buffer::pop)
  * for omitting return values.
  */
-extern const discard_return_t discard_return;
+extern const discard_return_t MEGAMOLCORE_API discard_return;
 
 /**
  * A constant that can be passed to some constructors (eg of
  * megamol::core::thecam::math::vector) for omitting initialisation.
  */
-extern const do_not_initialise_t do_not_initialise;
+extern const do_not_initialise_t MEGAMOLCORE_API do_not_initialise;
 
 } /* end namespace utility */
 } /* end namespace thecam */
diff --git a/core/include/mmcore/utility/ScaledBoundingBoxes.h b/core/include/mmcore/utility/ScaledBoundingBoxes.h
new file mode 100644
index 000000000..abaeaff7d
--- /dev/null
+++ b/core/include/mmcore/utility/ScaledBoundingBoxes.h
@@ -0,0 +1,84 @@
+/*
+ * ScaledBoundingBoxes.h
+ *
+ * Copyright (C) 2019 by Universitaet Stuttgart (VIS).
+ * Alle Rechte vorbehalten.
+ */
+
+#ifndef MEGAMOLCORE_SCALEDBOUNDINGBOXES_INCLUDED
+#define MEGAMOLCORE_SCALEDBOUNDINGBOXES_INCLUDED
+#if (defined(_MSC_VER) && (_MSC_VER > 1000))
+#pragma once
+#endif
+
+#include "mmcore/BoundingBoxes.h"
+
+#include <vector>
+
+namespace megamol {
+namespace core {
+namespace utility {
+
+    /**
+     * Scale a bounding box with the given scale factor
+     *
+     * @param scale Scale factor
+     * @param bb Bounding box
+     *
+     * @return Scaled bounding box
+     */
+    BoundingBoxes MEGAMOLCORE_API scaleBoundingBoxes(float scale, const BoundingBoxes& bb);
+
+    /**
+     * Combine multiple bounding boxes and scale the result with the given scale factor
+     *
+     * @param scale Scale factor
+     * @param bbs Bounding boxes
+     *
+     * @return Combined and scaled bounding box
+     */
+    BoundingBoxes MEGAMOLCORE_API combineAndScaleBoundingBoxes(float scale, const std::vector<BoundingBoxes>& bbs);
+
+    /**
+     * Scale a bounding box with the MegaMol-internal magic scale factor
+     *
+     * @param bb Bounding box
+     *
+     * @return Scaled bounding box
+     */
+    BoundingBoxes MEGAMOLCORE_API magicScaleBoundingBoxes(const BoundingBoxes& bb);
+
+    /**
+     * Combine multiple bounding boxes and scale the result
+     * with the MegaMol-internal magic scale factor
+     *
+     * @param bbs Bounding boxes
+     *
+     * @return Combined and scaled bounding box
+     */
+    BoundingBoxes MEGAMOLCORE_API combineAndMagicScaleBoundingBoxes(const std::vector<BoundingBoxes>& bbs);
+
+    /**
+     * RAII class for applying "MegaMol magic scaling" and eventually reversing it
+     */
+    class MEGAMOLCORE_API glMagicScale {
+    public:
+        glMagicScale();
+        ~glMagicScale();
+
+        void apply(const BoundingBoxes& bb);
+
+        glMagicScale(const glMagicScale&) = delete;
+        glMagicScale(glMagicScale&&) noexcept = delete;
+        glMagicScale& operator=(const glMagicScale&) = delete;
+        glMagicScale& operator=(glMagicScale&&) noexcept = delete;
+
+    private:
+        float scale;
+    };
+
+}
+}
+}
+
+#endif
\ No newline at end of file
diff --git a/core/include/mmcore/view/AbstractView.h b/core/include/mmcore/view/AbstractView.h
index a7538a37c..b03065dfd 100644
--- a/core/include/mmcore/view/AbstractView.h
+++ b/core/include/mmcore/view/AbstractView.h
@@ -180,6 +180,16 @@ public:
      */
     virtual bool OnRenderView(Call& call);
 
+
+    /** 
+     * Callback requesting the extents of this view
+     *
+     * @param call The calling call
+     *
+     * @return The return value
+     */
+    virtual bool GetExtents(Call& call);
+
     /**
      * Callback requesting a rendering of this view
      *
@@ -287,8 +297,6 @@ private:
      */
     bool onResetView(Call& call);
 
-	bool GetExtentsCallback(Call& call);
-
     bool OnKeyCallback(Call& call);
 
     bool OnCharCallback(Call& call);
diff --git a/core/include/mmcore/view/CallRenderView.h b/core/include/mmcore/view/CallRenderView.h
index 72420c0bc..1551726c5 100644
--- a/core/include/mmcore/view/CallRenderView.h
+++ b/core/include/mmcore/view/CallRenderView.h
@@ -55,6 +55,9 @@ namespace view {
 		/** Function index of 'render' */
         static const unsigned int CALL_RENDER = AbstractCallRender::FnRender;
 
+        /** Function index of 'getExtents' */
+        static const unsigned int CALL_EXTENTS = AbstractCallRender::FnGetExtents;
+
         /** Function index of 'freeze' */
         static const unsigned int CALL_FREEZE = 7;
 
diff --git a/core/include/mmcore/view/SplitView.h b/core/include/mmcore/view/SplitView.h
index 25409147d..ebbb55dcc 100644
--- a/core/include/mmcore/view/SplitView.h
+++ b/core/include/mmcore/view/SplitView.h
@@ -12,10 +12,11 @@
 #endif /* (defined(_MSC_VER) && (_MSC_VER > 1000)) */
 
 #include "mmcore/CallerSlot.h"
+#include "mmcore/param/ColorParam.h"
 #include "mmcore/param/ParamSlot.h"
 #include "mmcore/view/AbstractView.h"
 #include "mmcore/view/CallRenderView.h"
-
+#include "mmcore/view/TimeControl.h"
 #include "vislib/graphics/gl/FramebufferObject.h"
 
 namespace megamol {
@@ -166,6 +167,9 @@ protected:
      */
     void unpackMouseCoordinates(float& x, float& y) override;
 
+    /** Override of GetExtents */
+    virtual bool GetExtents(core::Call& call) override;
+
 private:
     /**
      * Answer the renderer 1 call
@@ -233,6 +237,15 @@ private:
     /** The splitter colour slot */
     param::ParamSlot splitColourSlot;
 
+    /** Slot enabling time synchronization */
+    param::ParamSlot enableTimeSyncSlot;
+
+    /** Option for forwarding mouse and keyboard events to both child views */
+    param::ParamSlot inputToBothSlot;
+
+    /** The parameter storage for time control */
+    TimeControl timeCtrl;
+
     /** The override call */
     CallRenderView* overrideCall;
 
@@ -246,7 +259,7 @@ private:
 
     vislib::graphics::gl::FramebufferObject fbo2;
 
-    int focus;
+	int focus;
 
     float mouseX;
 
diff --git a/core/include/mmcore/view/View2D.h b/core/include/mmcore/view/View2D.h
index de4d32768..b720035d0 100644
--- a/core/include/mmcore/view/View2D.h
+++ b/core/include/mmcore/view/View2D.h
@@ -129,6 +129,8 @@ namespace view {
          */
         virtual bool OnRenderView(Call& call);
 
+        virtual bool GetExtents(Call& call) override;
+
         /**
          * Freezes, updates, or unfreezes the view onto the scene (not the
          * rendering, but camera settings, timing, etc).
diff --git a/core/include/mmcore/view/View3D.h b/core/include/mmcore/view/View3D.h
index 609ef47d6..3ee4b0d7e 100644
--- a/core/include/mmcore/view/View3D.h
+++ b/core/include/mmcore/view/View3D.h
@@ -145,6 +145,8 @@ namespace view {
          */
         virtual bool OnRenderView(Call& call);
 
+        virtual bool GetExtents(Call & call) override;
+
         /**
          * Freezes, updates, or unfreezes the view onto the scene (not the
          * rendering, but camera settings, timing, etc).
diff --git a/core/src/misc/VolumetricDataCall.cpp b/core/src/misc/VolumetricDataCall.cpp
index f5769deeb..ce42dac85 100644
--- a/core/src/misc/VolumetricDataCall.cpp
+++ b/core/src/misc/VolumetricDataCall.cpp
@@ -37,6 +37,47 @@ const char *megamol::core::misc::VolumetricDataCall::FunctionName(
 }
 
 
+/*
+ * megamol::core::misc::VolumetricDataCall::GetMetadata
+ */
+bool megamol::core::misc::VolumetricDataCall::GetMetadata(
+        core::misc::VolumetricDataCall& call) {
+    using core::misc::VolumetricDataCall;
+    using vislib::sys::Log;
+
+    if (!call(VolumetricDataCall::IDX_GET_METADATA)) {
+        Log::DefaultLog.WriteError(L"%hs::%hs failed.",
+            VolumetricDataCall::ClassName(),
+            VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_METADATA));
+        return false;
+    }
+
+    if (call.GetMetadata() == nullptr) {
+        /* Second chance ... */
+        if (!call(VolumetricDataCall::IDX_GET_DATA)) {
+            Log::DefaultLog.WriteError(L"%hs::%hs failed.",
+                VolumetricDataCall::ClassName(),
+                VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_DATA));
+            return false;
+        }
+    }
+
+    auto retval = (call.GetMetadata() != nullptr);
+
+    if (!retval) {
+        Log::DefaultLog.WriteError(L"Call to %hs::%hs or %hs::%hs succeeded, "
+            L"but none of them did provide any metadata. The call will be "
+            "considered to have failed.",
+            VolumetricDataCall::ClassName(),
+            VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_METADATA),
+            VolumetricDataCall::ClassName(),
+            VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_DATA));
+    }
+
+    return retval;
+}
+
+
 /*
  * megamol::core::misc::VolumetricDataCall::IDX_GET_DATA
  */
diff --git a/core/src/misc/VolumetricMetadataStore.cpp b/core/src/misc/VolumetricMetadataStore.cpp
new file mode 100644
index 000000000..b6bc62f8f
--- /dev/null
+++ b/core/src/misc/VolumetricMetadataStore.cpp
@@ -0,0 +1,147 @@
+/*
+ * VolumetricMetadataStore.cpp
+ *
+ * Copyright (C) 2019 by Visualisierungsinstitut der Universität Stuttgart.
+ * Alle rechte vorbehalten.
+ */
+
+#include "stdafx.h"
+#include "mmcore/misc/VolumetricMetadataStore.h"
+
+#include <cassert>
+
+
+/*
+ * megamol::core::misc::VolumetricMetadataStore::VolumetricMetadataStore
+ */
+megamol::core::misc::VolumetricMetadataStore::VolumetricMetadataStore(
+        const VolumetricMetadataStore& rhs)
+    : maxValues(rhs.maxValues), minValues(rhs.minValues),
+        sliceDists(rhs.sliceDists) {
+    this->rewrire();
+}
+
+
+/*
+ * megamol::core::misc::VolumetricMetadataStore::VolumetricMetadataStore
+ */
+megamol::core::misc::VolumetricMetadataStore::VolumetricMetadataStore(
+        VolumetricMetadataStore&& rhs) noexcept
+    : maxValues(std::move(rhs.maxValues)), minValues(std::move(rhs.minValues)),
+        sliceDists(std::move(rhs.sliceDists)) {
+    this->rewrire();
+    rhs.rewrire();
+    assert(rhs.MinValues == nullptr);
+    assert(rhs.MaxValues == nullptr);
+}
+
+
+/*
+ * megamol::core::misc::VolumetricMetadataStore::VolumetricMetadataStore
+ */
+megamol::core::misc::VolumetricMetadataStore::VolumetricMetadataStore(
+        const VolumetricMetadata_t& rhs) {
+    *this = rhs;
+}
+
+
+/*
+ * megamol::core::misc::VolumetricMetadataStore::operator =
+ */
+megamol::core::misc::VolumetricMetadataStore&
+megamol::core::misc::VolumetricMetadataStore::operator =(
+        const VolumetricMetadataStore& rhs) {
+    if (this != std::addressof(rhs)) {
+        ::memcpy(this, std::addressof(rhs), sizeof(VolumetricMetadata_t));
+        this->rewrire();
+    }
+    return *this;
+}
+
+
+/*
+ * megamol::core::misc::VolumetricMetadataStore::operator =
+ */
+megamol::core::misc::VolumetricMetadataStore&
+megamol::core::misc::VolumetricMetadataStore::operator =(
+        VolumetricMetadataStore&& rhs) noexcept {
+    if (this != std::addressof(rhs)) {
+        ::memcpy(this, std::addressof(rhs), sizeof(VolumetricMetadata_t));
+        this->rewrire();
+        rhs.rewrire();
+        assert(rhs.MinValues == nullptr);
+        assert(rhs.MaxValues == nullptr);
+    }
+    return *this;
+}
+
+
+/*
+ * megamol::core::misc::VolumetricMetadataStore::operator =
+ */
+megamol::core::misc::VolumetricMetadataStore&
+megamol::core::misc::VolumetricMetadataStore::operator =(
+        const VolumetricMetadata_t& rhs) {
+    if (this != std::addressof(rhs)) {
+        ::memcpy(this, std::addressof(rhs), sizeof(VolumetricMetadata_t));
+
+        this->maxValues.clear();
+        this->maxValues.resize(this->Components);
+        for (std::size_t i = 0; i < this->maxValues.size(); ++i) {
+            this->maxValues[i] = rhs.MaxValues[i];
+        }
+
+        this->minValues.clear();
+        this->minValues.resize(this->Components);
+        for (std::size_t i = 0; i < this->minValues.size(); ++i) {
+            this->minValues[i] = rhs.MinValues[i];
+        }
+
+        switch (this->GridType) {
+            case core::misc::CARTESIAN:
+                for (std::size_t i = 0; i < this->sliceDists.size(); ++i) {
+                    this->sliceDists[i].resize(1);
+                    this->sliceDists[i][0] = rhs.SliceDists[i][0];
+                }
+                break;
+
+            case core::misc::RECTILINEAR:
+                for (std::size_t i = 0; i < this->sliceDists.size(); ++i) {
+                    this->sliceDists[i].clear();
+                    auto cnt = rhs.Resolution[i] - 1;
+                    this->sliceDists[i].reserve(cnt);
+                    std::copy(rhs.SliceDists[i], rhs.SliceDists[i] + cnt,
+                        std::back_inserter(this->sliceDists[i]));
+                }
+                break;
+
+            default:
+                for (auto& s : this->sliceDists) {
+                    s.clear();
+                }
+                break;
+        }
+
+        this->rewrire();
+    }
+
+    return *this;
+}
+
+
+/*
+ * megamol::core::misc::VolumetricMetadataStore::rewrire
+ */
+void megamol::core::misc::VolumetricMetadataStore::rewrire(void) {
+    this->MaxValues = this->maxValues.empty()
+        ? nullptr
+        : this->maxValues.data();
+    this->MinValues = this->minValues.empty()
+        ? nullptr
+        : this->minValues.data();
+    for (std::size_t i = 0; i < this->sliceDists.size(); ++i) {
+        this->SliceDists[i] = this->sliceDists[i].empty()
+            ? nullptr :
+            this->sliceDists[i].data();
+    }
+}
diff --git a/core/src/moldyn/ArrowRenderer.cpp b/core/src/moldyn/ArrowRenderer.cpp
index 7dcbda4fd..5a4597eb3 100644
--- a/core/src/moldyn/ArrowRenderer.cpp
+++ b/core/src/moldyn/ArrowRenderer.cpp
@@ -6,16 +6,17 @@
  */
 
 #include "stdafx.h"
-#include "vislib/graphics/gl/IncludeAllGL.h"
 #include "mmcore/moldyn/ArrowRenderer.h"
-#include "mmcore/moldyn/MultiParticleDataCall.h"
 #include "mmcore/CoreInstance.h"
+#include "mmcore/FlagCall.h"
+#include "mmcore/moldyn/MultiParticleDataCall.h"
 #include "mmcore/param/FloatParam.h"
+#include "mmcore/utility/ScaledBoundingBoxes.h"
 #include "mmcore/view/CallClipPlane.h"
 #include "mmcore/view/CallGetTransferFunction.h"
 #include "mmcore/view/CallRender3D.h"
-#include "mmcore/FlagCall.h"
 #include "vislib/assert.h"
+#include "vislib/graphics/gl/IncludeAllGL.h"
 
 using namespace megamol::core;
 
@@ -23,13 +24,21 @@ using namespace megamol::core;
 /*
  * moldyn::ArrowRenderer::ArrowRenderer
  */
-moldyn::ArrowRenderer::ArrowRenderer(void) : Renderer3DModule(),
-        arrowShader(), getDataSlot("getdata", "Connects to the data source"),
-        getTFSlot("gettransferfunction", "Connects to the transfer function module"),
-        getFlagsSlot("getflags", "connects to a FlagStorage"),
-        //getClipPlaneSlot("getclipplane", "Connects to a clipping plane module"),
-        greyTF(0),
-        lengthScaleSlot("lengthScale", ""), lengthFilterSlot("lengthFilter", "Filters the arrows by length") {
+moldyn::ArrowRenderer::ArrowRenderer(void)
+    : Renderer3DModule()
+    , arrowShader()
+    , getRenderSlot("getrenderer", "Input renderer slot for chaining")
+    , getDataSlot("getdata", "Connects to the data source")
+    , getTFSlot("gettransferfunction", "Connects to the transfer function module")
+    , getFlagsSlot("getflags", "connects to a FlagStorage")
+    ,
+    // getClipPlaneSlot("getclipplane", "Connects to a clipping plane module"),
+    greyTF(0)
+    , lengthScaleSlot("lengthScale", "")
+    , lengthFilterSlot("lengthFilter", "Filters the arrows by length") {
+
+    this->getRenderSlot.SetCompatibleCall<view::CallRender3DDescription>();
+    this->MakeSlotAvailable(&this->getRenderSlot);
 
     this->getDataSlot.SetCompatibleCall<moldyn::MultiParticleDataCallDescription>();
     this->MakeSlotAvailable(&this->getDataSlot);
@@ -40,13 +49,13 @@ moldyn::ArrowRenderer::ArrowRenderer(void) : Renderer3DModule(),
     this->getFlagsSlot.SetCompatibleCall<FlagCallDescription>();
     this->MakeSlotAvailable(&this->getFlagsSlot);
 
-    //this->getClipPlaneSlot.SetCompatibleCall<view::CallClipPlaneDescription>();
-    //this->MakeSlotAvailable(&this->getClipPlaneSlot);
-    
+    // this->getClipPlaneSlot.SetCompatibleCall<view::CallClipPlaneDescription>();
+    // this->MakeSlotAvailable(&this->getClipPlaneSlot);
+
     this->lengthScaleSlot << new param::FloatParam(1.0f);
     this->MakeSlotAvailable(&this->lengthScaleSlot);
-    
-    this->lengthFilterSlot << new param::FloatParam( 0.0f, 0.0);
+
+    this->lengthFilterSlot << new param::FloatParam(0.0f, 0.0);
     this->MakeSlotAvailable(&this->lengthFilterSlot);
 }
 
@@ -54,9 +63,7 @@ moldyn::ArrowRenderer::ArrowRenderer(void) : Renderer3DModule(),
 /*
  * moldyn::ArrowRenderer::~ArrowRenderer
  */
-moldyn::ArrowRenderer::~ArrowRenderer(void) {
-    this->Release();
-}
+moldyn::ArrowRenderer::~ArrowRenderer(void) { this->Release(); }
 
 
 /*
@@ -78,32 +85,30 @@ bool moldyn::ArrowRenderer::create(void) {
 
     try {
         if (!this->arrowShader.Create(vert.Code(), vert.Count(), frag.Code(), frag.Count())) {
-            vislib::sys::Log::DefaultLog.WriteMsg(vislib::sys::Log::LEVEL_ERROR,
-                "Unable to compile arrow shader: Unknown error\n");
+            vislib::sys::Log::DefaultLog.WriteMsg(
+                vislib::sys::Log::LEVEL_ERROR, "Unable to compile arrow shader: Unknown error\n");
             return false;
         }
 
-    } catch(vislib::graphics::gl::AbstractOpenGLShader::CompileException ce) {
+    } catch (vislib::graphics::gl::AbstractOpenGLShader::CompileException ce) {
         vislib::sys::Log::DefaultLog.WriteMsg(vislib::sys::Log::LEVEL_ERROR,
-            "Unable to compile arrow shader (@%s): %s\n", 
-            vislib::graphics::gl::AbstractOpenGLShader::CompileException::CompileActionName(
-            ce.FailedAction()) ,ce.GetMsgA());
+            "Unable to compile arrow shader (@%s): %s\n",
+            vislib::graphics::gl::AbstractOpenGLShader::CompileException::CompileActionName(ce.FailedAction()),
+            ce.GetMsgA());
         return false;
-    } catch(vislib::Exception e) {
-        vislib::sys::Log::DefaultLog.WriteMsg(vislib::sys::Log::LEVEL_ERROR,
-            "Unable to compile arrow shader: %s\n", e.GetMsgA());
+    } catch (vislib::Exception e) {
+        vislib::sys::Log::DefaultLog.WriteMsg(
+            vislib::sys::Log::LEVEL_ERROR, "Unable to compile arrow shader: %s\n", e.GetMsgA());
         return false;
-    } catch(...) {
-        vislib::sys::Log::DefaultLog.WriteMsg(vislib::sys::Log::LEVEL_ERROR,
-            "Unable to compile arrow shader: Unknown exception\n");
+    } catch (...) {
+        vislib::sys::Log::DefaultLog.WriteMsg(
+            vislib::sys::Log::LEVEL_ERROR, "Unable to compile arrow shader: Unknown exception\n");
         return false;
     }
 
     glEnable(GL_TEXTURE_1D);
     glGenTextures(1, &this->greyTF);
-    unsigned char tex[6] = {
-        0, 0, 0,  255, 255, 255
-    };
+    unsigned char tex[6] = {0, 0, 0, 255, 255, 255};
     glBindTexture(GL_TEXTURE_1D, this->greyTF);
     glTexImage1D(GL_TEXTURE_1D, 0, GL_RGBA, 2, 0, GL_RGB, GL_UNSIGNED_BYTE, tex);
     glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
@@ -120,27 +125,26 @@ bool moldyn::ArrowRenderer::create(void) {
  * moldyn::ArrowRenderer::GetExtents
  */
 bool moldyn::ArrowRenderer::GetExtents(Call& call) {
-    view::CallRender3D *cr = dynamic_cast<view::CallRender3D*>(&call);
+    view::CallRender3D* cr = dynamic_cast<view::CallRender3D*>(&call);
     if (cr == NULL) return false;
 
     MultiParticleDataCall* c2 = this->getDataSlot.CallAs<MultiParticleDataCall>();
     if ((c2 != NULL) && ((*c2)(1))) {
         cr->SetTimeFramesCount(c2->FrameCount());
-        cr->AccessBoundingBoxes() = c2->AccessBoundingBoxes();
-
-        float scaling = cr->AccessBoundingBoxes().ObjectSpaceBBox().LongestEdge();
-        if (scaling > 0.0000001) {
-            scaling = 10.0f / scaling;
-        } else {
-            scaling = 1.0f;
-        }
-        cr->AccessBoundingBoxes().MakeScaledWorld(scaling);
+        cr->AccessBoundingBoxes() = core::utility::magicScaleBoundingBoxes(c2->AccessBoundingBoxes());
 
     } else {
         cr->SetTimeFramesCount(1);
         cr->AccessBoundingBoxes().Clear();
     }
 
+    auto chainedRenderer = this->getRenderSlot.CallAs<view::CallRender3D>();
+    if (chainedRenderer != nullptr) {
+        *chainedRenderer = *cr;
+        (*chainedRenderer)(view::CallRender3D::FnGetExtents);
+        *cr = *chainedRenderer;
+    }
+
     return true;
 }
 
@@ -158,23 +162,21 @@ void moldyn::ArrowRenderer::release(void) {
  * moldyn::ArrowRenderer::Render
  */
 bool moldyn::ArrowRenderer::Render(Call& call) {
-    view::CallRender3D *cr = dynamic_cast<view::CallRender3D*>(&call);
+    view::CallRender3D* cr = dynamic_cast<view::CallRender3D*>(&call);
     if (cr == NULL) return false;
 
-    MultiParticleDataCall *c2 = this->getDataSlot.CallAs<MultiParticleDataCall>();
-    float scaling = 1.0f;
+    auto chainedRenderer = this->getRenderSlot.CallAs<view::CallRender3D>();
+    if (chainedRenderer != nullptr) {
+        *chainedRenderer = *cr;
+        (*chainedRenderer)(view::CallRender3D::FnRender);
+        *cr = *chainedRenderer;
+    }
+
+    MultiParticleDataCall* c2 = this->getDataSlot.CallAs<MultiParticleDataCall>();
     if (c2 != NULL) {
         c2->SetFrameID(static_cast<unsigned int>(cr->Time()));
         if (!(*c2)(1)) return false;
 
-        // calculate scaling
-        scaling = c2->AccessBoundingBoxes().ObjectSpaceBBox().LongestEdge();
-        if (scaling > 0.0000001) {
-            scaling = 10.0f / scaling;
-        } else {
-            scaling = 1.0f;
-        }
-
         c2->SetFrameID(static_cast<unsigned int>(cr->Time()));
         if (!(*c2)(0)) return false;
     } else {
@@ -182,14 +184,14 @@ bool moldyn::ArrowRenderer::Render(Call& call) {
     }
 
     auto* cflags = this->getFlagsSlot.CallAs<FlagCall>();
-  
+
     float lengthScale = this->lengthScaleSlot.Param<param::FloatParam>()->Value();
     float lengthFilter = this->lengthFilterSlot.Param<param::FloatParam>()->Value();
 
-    //view::CallClipPlane *ccp = this->getClipPlaneSlot.CallAs<view::CallClipPlane>();
-    //float clipDat[4];
-    //float clipCol[3];
-    //if ((ccp != NULL) && (*ccp)()) {
+    // view::CallClipPlane *ccp = this->getClipPlaneSlot.CallAs<view::CallClipPlane>();
+    // float clipDat[4];
+    // float clipCol[3];
+    // if ((ccp != NULL) && (*ccp)()) {
     //    clipDat[0] = ccp->GetPlane().Normal().X();
     //    clipDat[1] = ccp->GetPlane().Normal().Y();
     //    clipDat[2] = ccp->GetPlane().Normal().Z();
@@ -220,15 +222,17 @@ bool moldyn::ArrowRenderer::Render(Call& call) {
 
     glUniform4fv(this->arrowShader.ParameterLocation("viewAttr"), 1, viewportStuff);
     glUniform3fv(this->arrowShader.ParameterLocation("camIn"), 1, cr->GetCameraParameters()->Front().PeekComponents());
-    glUniform3fv(this->arrowShader.ParameterLocation("camRight"), 1, cr->GetCameraParameters()->Right().PeekComponents());
+    glUniform3fv(
+        this->arrowShader.ParameterLocation("camRight"), 1, cr->GetCameraParameters()->Right().PeekComponents());
     glUniform3fv(this->arrowShader.ParameterLocation("camUp"), 1, cr->GetCameraParameters()->Up().PeekComponents());
     this->arrowShader.SetParameter("lengthScale", lengthScale);
     this->arrowShader.SetParameter("lengthFilter", lengthFilter);
 
-    //glUniform4fvARB(this->arrowShader.ParameterLocation("clipDat"), 1, clipDat);
-    //glUniform3fvARB(this->arrowShader.ParameterLocation("clipCol"), 1, clipCol);
+    // glUniform4fvARB(this->arrowShader.ParameterLocation("clipDat"), 1, clipDat);
+    // glUniform3fvARB(this->arrowShader.ParameterLocation("clipCol"), 1, clipCol);
 
-    glScalef(scaling, scaling, scaling);
+    core::utility::glMagicScale scaling;
+    scaling.apply(cr->GetBoundingBoxes());
 
     if (c2 != NULL) {
         unsigned int cial = glGetAttribLocationARB(this->arrowShader, "colIdx");
@@ -245,95 +249,96 @@ bool moldyn::ArrowRenderer::Render(Call& call) {
         }
 
         for (unsigned int i = 0; i < c2->GetParticleListCount(); i++) {
-            MultiParticleDataCall::Particles &parts = c2->AccessParticles(i);
+            MultiParticleDataCall::Particles& parts = c2->AccessParticles(i);
             float minC = 0.0f, maxC = 0.0f;
             unsigned int colTabSize = 0;
 
             // colour
             switch (parts.GetColourDataType()) {
-                case MultiParticleDataCall::Particles::COLDATA_NONE:
-                    glColor3ubv(parts.GetGlobalColour());
-                    break;
-                case MultiParticleDataCall::Particles::COLDATA_UINT8_RGB:
-                    glEnableClientState(GL_COLOR_ARRAY);
-                    glColorPointer(3, GL_UNSIGNED_BYTE, parts.GetColourDataStride(), parts.GetColourData());
-                    break;
-                case MultiParticleDataCall::Particles::COLDATA_UINT8_RGBA:
-                    glEnableClientState(GL_COLOR_ARRAY);
-                    glColorPointer(4, GL_UNSIGNED_BYTE, parts.GetColourDataStride(), parts.GetColourData());
-                    break;
-                case MultiParticleDataCall::Particles::COLDATA_FLOAT_RGB:
-                    glEnableClientState(GL_COLOR_ARRAY);
-                    glColorPointer(3, GL_FLOAT, parts.GetColourDataStride(), parts.GetColourData());
-                    break;
-                case MultiParticleDataCall::Particles::COLDATA_FLOAT_RGBA:
-                    glEnableClientState(GL_COLOR_ARRAY);
-                    glColorPointer(4, GL_FLOAT, parts.GetColourDataStride(), parts.GetColourData());
-                    break;
-                case MultiParticleDataCall::Particles::COLDATA_DOUBLE_I:
-                case MultiParticleDataCall::Particles::COLDATA_FLOAT_I: {
-                    glEnableVertexAttribArrayARB(cial);
-                    if (parts.GetColourDataType() == MultiParticleDataCall::Particles::COLDATA_FLOAT_I) {
-                        glVertexAttribPointerARB(
-                            cial, 1, GL_FLOAT, GL_FALSE, parts.GetColourDataStride(), parts.GetColourData());
-                    } else {
-                        glVertexAttribPointerARB(
-                            cial, 1, GL_DOUBLE, GL_FALSE, parts.GetColourDataStride(), parts.GetColourData());
-                    }
-
-                    glEnable(GL_TEXTURE_1D);
-                    view::CallGetTransferFunction *cgtf = this->getTFSlot.CallAs<view::CallGetTransferFunction>();
-                    if ((cgtf != NULL) && ((*cgtf)())) {
-                        glBindTexture(GL_TEXTURE_1D, cgtf->OpenGLTexture());
-                        colTabSize = cgtf->TextureSize();
-                    } else {
-                        glBindTexture(GL_TEXTURE_1D, this->greyTF);
-                        colTabSize = 2;
-                    }
-
-                    glUniform1i(this->arrowShader.ParameterLocation("colTab"), 0);
-                    minC = parts.GetMinColourIndexValue();
-                    maxC = parts.GetMaxColourIndexValue();
-                    glColor3ub(127, 127, 127);
-                } break;
-                default:
-                    glColor3ub(127, 127, 127);
-                    break;
+            case MultiParticleDataCall::Particles::COLDATA_NONE:
+                glColor3ubv(parts.GetGlobalColour());
+                break;
+            case MultiParticleDataCall::Particles::COLDATA_UINT8_RGB:
+                glEnableClientState(GL_COLOR_ARRAY);
+                glColorPointer(3, GL_UNSIGNED_BYTE, parts.GetColourDataStride(), parts.GetColourData());
+                break;
+            case MultiParticleDataCall::Particles::COLDATA_UINT8_RGBA:
+                glEnableClientState(GL_COLOR_ARRAY);
+                glColorPointer(4, GL_UNSIGNED_BYTE, parts.GetColourDataStride(), parts.GetColourData());
+                break;
+            case MultiParticleDataCall::Particles::COLDATA_FLOAT_RGB:
+                glEnableClientState(GL_COLOR_ARRAY);
+                glColorPointer(3, GL_FLOAT, parts.GetColourDataStride(), parts.GetColourData());
+                break;
+            case MultiParticleDataCall::Particles::COLDATA_FLOAT_RGBA:
+                glEnableClientState(GL_COLOR_ARRAY);
+                glColorPointer(4, GL_FLOAT, parts.GetColourDataStride(), parts.GetColourData());
+                break;
+            case MultiParticleDataCall::Particles::COLDATA_DOUBLE_I:
+            case MultiParticleDataCall::Particles::COLDATA_FLOAT_I: {
+                glEnableVertexAttribArrayARB(cial);
+                if (parts.GetColourDataType() == MultiParticleDataCall::Particles::COLDATA_FLOAT_I) {
+                    glVertexAttribPointerARB(
+                        cial, 1, GL_FLOAT, GL_FALSE, parts.GetColourDataStride(), parts.GetColourData());
+                } else {
+                    glVertexAttribPointerARB(
+                        cial, 1, GL_DOUBLE, GL_FALSE, parts.GetColourDataStride(), parts.GetColourData());
+                }
+
+                glEnable(GL_TEXTURE_1D);
+                view::CallGetTransferFunction* cgtf = this->getTFSlot.CallAs<view::CallGetTransferFunction>();
+                if ((cgtf != NULL) && ((*cgtf)())) {
+                    glBindTexture(GL_TEXTURE_1D, cgtf->OpenGLTexture());
+                    colTabSize = cgtf->TextureSize();
+                } else {
+                    glBindTexture(GL_TEXTURE_1D, this->greyTF);
+                    colTabSize = 2;
+                }
+
+                glUniform1i(this->arrowShader.ParameterLocation("colTab"), 0);
+                minC = parts.GetMinColourIndexValue();
+                maxC = parts.GetMaxColourIndexValue();
+                glColor3ub(127, 127, 127);
+            } break;
+            default:
+                glColor3ub(127, 127, 127);
+                break;
             }
 
             // radius and position
             switch (parts.GetVertexDataType()) {
-                case MultiParticleDataCall::Particles::VERTDATA_NONE:
-                    continue;
-                case MultiParticleDataCall::Particles::VERTDATA_FLOAT_XYZ:
-                    glEnableClientState(GL_VERTEX_ARRAY);
-                    glUniform4f(this->arrowShader.ParameterLocation("inConsts1"), parts.GetGlobalRadius(), minC, maxC, float(colTabSize));
-                    glVertexPointer(3, GL_FLOAT, parts.GetVertexDataStride(), parts.GetVertexData());
-                    break;
-                case MultiParticleDataCall::Particles::VERTDATA_FLOAT_XYZR:
-                    glEnableClientState(GL_VERTEX_ARRAY);
-                    glUniform4f(this->arrowShader.ParameterLocation("inConsts1"), -1.0f, minC, maxC, float(colTabSize));
-                    glVertexPointer(4, GL_FLOAT, parts.GetVertexDataStride(), parts.GetVertexData());
-                    break;
-                case MultiParticleDataCall::Particles::VERTDATA_DOUBLE_XYZ:
-                    glEnableClientState(GL_VERTEX_ARRAY);
-                    glUniform4f(this->arrowShader.ParameterLocation("inConsts1"), -1.0f, minC, maxC, float(colTabSize));
-                    glVertexPointer(3, GL_DOUBLE, parts.GetVertexDataStride(), parts.GetVertexData());
-                default:
-                    continue;
+            case MultiParticleDataCall::Particles::VERTDATA_NONE:
+                continue;
+            case MultiParticleDataCall::Particles::VERTDATA_FLOAT_XYZ:
+                glEnableClientState(GL_VERTEX_ARRAY);
+                glUniform4f(this->arrowShader.ParameterLocation("inConsts1"), parts.GetGlobalRadius(), minC, maxC,
+                    float(colTabSize));
+                glVertexPointer(3, GL_FLOAT, parts.GetVertexDataStride(), parts.GetVertexData());
+                break;
+            case MultiParticleDataCall::Particles::VERTDATA_FLOAT_XYZR:
+                glEnableClientState(GL_VERTEX_ARRAY);
+                glUniform4f(this->arrowShader.ParameterLocation("inConsts1"), -1.0f, minC, maxC, float(colTabSize));
+                glVertexPointer(4, GL_FLOAT, parts.GetVertexDataStride(), parts.GetVertexData());
+                break;
+            case MultiParticleDataCall::Particles::VERTDATA_DOUBLE_XYZ:
+                glEnableClientState(GL_VERTEX_ARRAY);
+                glUniform4f(this->arrowShader.ParameterLocation("inConsts1"), -1.0f, minC, maxC, float(colTabSize));
+                glVertexPointer(3, GL_DOUBLE, parts.GetVertexDataStride(), parts.GetVertexData());
+            default:
+                continue;
             }
 
             // direction
             switch (parts.GetDirDataType()) {
-                case MultiParticleDataCall::Particles::DIRDATA_FLOAT_XYZ:
-                    ::glEnableVertexAttribArrayARB(tpal);
-                    ::glVertexAttribPointerARB(tpal, 3, GL_FLOAT, GL_FALSE, parts.GetDirDataStride(), parts.GetDirData());
-                    break;
-                default:
-                    vislib::sys::Log::DefaultLog.WriteWarn(
-                        "ArrowRenderer: cannot render arrows without directional data!");
-                    continue;
+            case MultiParticleDataCall::Particles::DIRDATA_FLOAT_XYZ:
+                ::glEnableVertexAttribArrayARB(tpal);
+                ::glVertexAttribPointerARB(tpal, 3, GL_FLOAT, GL_FALSE, parts.GetDirDataStride(), parts.GetDirData());
+                break;
+            default:
+                vislib::sys::Log::DefaultLog.WriteWarn("ArrowRenderer: cannot render arrows without directional data!");
+                continue;
             }
+
             std::shared_ptr<FlagStorage::FlagVectorType> flags;
             unsigned int fal = 0;
             if (useFlags) {
@@ -342,16 +347,15 @@ bool moldyn::ArrowRenderer::Render(Call& call) {
                 flags = cflags->GetFlags();
                 fal = glGetAttribLocationARB(this->arrowShader, "flags");
                 ::glEnableVertexAttribArrayARB(fal);
-                ::glVertexAttribIPointer(
-                    fal, 1, GL_UNSIGNED_INT, sizeof(FlagStorage::FlagItemType), flags.get()->data());
+                ::glVertexAttribIPointer(fal, 1, GL_UNSIGNED_INT, 0, flags->data());
             }
 
             glDrawArrays(GL_POINTS, 0, static_cast<GLsizei>(parts.GetCount()));
 
             if (useFlags) {
+                glDisableVertexAttribArrayARB(fal);
                 cflags->SetFlags(flags);
                 (*cflags)(core::FlagCall::CallUnmapFlags);
-                glDisableVertexAttribArrayARB(fal);
             }
 
             glDisableClientState(GL_COLOR_ARRAY);
@@ -365,7 +369,6 @@ bool moldyn::ArrowRenderer::Render(Call& call) {
         }
 
         c2->Unlock();
-
     }
 
     this->arrowShader.Disable();
diff --git a/core/src/moldyn/SphereOutlineRenderer.cpp b/core/src/moldyn/SphereOutlineRenderer.cpp
index 507c03937..59b9983e7 100644
--- a/core/src/moldyn/SphereOutlineRenderer.cpp
+++ b/core/src/moldyn/SphereOutlineRenderer.cpp
@@ -16,6 +16,7 @@
 #include "mmcore/param/IntParam.h"
 #include "mmcore/param/FloatParam.h"
 #include "mmcore/view/CallRender3D.h"
+#include "mmcore/utility/ScaledBoundingBoxes.h"
 #include <GL/glu.h>
 #include "vislib/assert.h"
 #include "vislib/math/mathfunctions.h"
@@ -39,6 +40,7 @@ moldyn::SphereOutlineRenderer::SphereOutlineRenderer(void) : Renderer3DModule(),
         circleSegSlot("seg", "The number of line segments to construct the circle"),
         multiOutlineCntSlot("multiOutline::count", "The (half) number of additional outlines"),
         multiOutLineDistSlot("multiOutline::dist", "The distance of the additional outlines as angles in radians"),
+        paramScaling("scaling", "A scaling factor for the radius"),
         sphereQuadric(NULL) {
 
     this->getDataSlot.SetCompatibleCall<moldyn::MultiParticleDataCallDescription>();
@@ -62,6 +64,9 @@ moldyn::SphereOutlineRenderer::SphereOutlineRenderer(void) : Renderer3DModule(),
     this->multiOutLineDistSlot << new param::FloatParam(0.1f, 0.0f);
     this->MakeSlotAvailable(&this->multiOutLineDistSlot);
 
+    this->paramScaling << new param::FloatParam(1.0f, (std::numeric_limits<float>::min)());
+    this->MakeSlotAvailable(&this->paramScaling);
+
 }
 
 
@@ -149,6 +154,11 @@ bool moldyn::SphereOutlineRenderer::Render(Call& call) {
         return false;
     }
 
+    ::glEnable(GL_DEPTH_TEST);  // Der Oberhass
+    ::glDisable(GL_TEXTURE_1D); // Der Turbohass!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+    ::glDisable(GL_TEXTURE_2D); // Der Turbohass!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+    ::glDisable(GL_TEXTURE_3D); // Der Turbohass!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+    ::glPushMatrix();       // Der HASS!
     glScalef(scaling, scaling, scaling); // ... unklar ob problematisch, aber eigentlich nicht
 
     const int rep = this->repSlot.Param<param::EnumParam>()->Value();
@@ -207,6 +217,9 @@ bool moldyn::SphereOutlineRenderer::Render(Call& call) {
                     vislib::math::Point<float, 3> posP(const_cast<float*>(posData));
                     posP.Set(posP.X() * scaling, posP.Y() * scaling, posP.Z() * scaling);
 
+                    // Apply user-defined scaling.
+                    rad *= this->paramScaling.Param<param::FloatParam>()->Value();
+
                     // Calculate outline angles
                     float d = cr->GetCameraParameters()->EyePosition().Distance(posP);
                     float p = (rad * rad * scaling * scaling) / d;
@@ -263,6 +276,8 @@ bool moldyn::SphereOutlineRenderer::Render(Call& call) {
         ::gluQuadricDrawStyle(static_cast<GLUquadric*>(this->sphereQuadric), GLU_FILL);
         ::glEnable(GL_CULL_FACE);
 
+        ::glDisable(GL_LIGHTING);   // Der Hass!!!
+
         for (unsigned int i = 0; i < c2->GetParticleListCount(); i++) {
             MultiParticleDataCall::Particles &parts = c2->AccessParticles(i);
             float rad = parts.GetGlobalRadius();
@@ -277,6 +292,9 @@ bool moldyn::SphereOutlineRenderer::Render(Call& call) {
                 if (loadRad) rad = posData[3];
                 vislib::math::Point<float, 3> posP(const_cast<float*>(posData));
 
+                // Apply user-defined scaling.
+                rad *= this->paramScaling.Param<param::FloatParam>()->Value();
+
                 ::glPushMatrix();
                 ::glTranslatef(posP.X(), posP.Y(), posP.Z());
                 ::glScalef(rad, rad, rad);
@@ -299,5 +317,7 @@ bool moldyn::SphereOutlineRenderer::Render(Call& call) {
 
     }
 
+    ::glPopMatrix();    // Der Hass!
+
     return true;
 }
diff --git a/core/src/moldyn/SphereRenderer.cpp b/core/src/moldyn/SphereRenderer.cpp
index 8ec3e658c..eb566c87f 100644
--- a/core/src/moldyn/SphereRenderer.cpp
+++ b/core/src/moldyn/SphereRenderer.cpp
@@ -95,7 +95,8 @@ moldyn::SphereRenderer::SphereRenderer(void)
     , aoOffsetSlot("ao::offset", "Ambient Occlusion: Offset from Surface")
     , aoStrengthSlot("ao::strength", "Ambient Occlusion: Strength")
     , aoConeLengthSlot("ao::conelen", "Ambient Occlusion: Cone length")
-    , useHPTexturesSlot("ao::high_prec_tex", "Ambient Occlusion: Use high precision textures") {
+    , useHPTexturesSlot("ao::high_prec_tex", "Ambient Occlusion: Use high precision textures")
+    , outlineSizeSlot("outline::width", "Width of the outline") {
 
     this->radiusScalingParam << new core::param::FloatParam(1.0f);
     this->MakeSlotAvailable(&this->radiusScalingParam);
@@ -136,6 +137,9 @@ moldyn::SphereRenderer::SphereRenderer(void)
     this->useHPTexturesSlot << (new core::param::BoolParam(false));
     this->MakeSlotAvailable(&this->useHPTexturesSlot);
 
+    this->outlineSizeSlot << (new core::param::FloatParam(2.0f, 0.0f));
+    this->MakeSlotAvailable(&this->outlineSizeSlot);
+
     // Initialising enum param with all possible modes (needed for configurator) 
     // (Removing not available render modes later in create function)
     param::EnumParam* rmp = new param::EnumParam(this->renderMode);
@@ -146,6 +150,7 @@ moldyn::SphereRenderer::SphereRenderer(void)
     rmp->SetTypePair(RenderMode::BUFFER_ARRAY,      "Buffer_Array"); 
     rmp->SetTypePair(RenderMode::SPLAT,             "Splat");   
     rmp->SetTypePair(RenderMode::AMBIENT_OCCLUSION, "Ambient_Occlusion"); 
+    rmp->SetTypePair(RenderMode::OUTLINE, "Outline");
     this->renderModeParam << rmp;
     this->MakeSlotAvailable(&this->renderModeParam);
 
@@ -193,6 +198,9 @@ bool moldyn::SphereRenderer::create(void) {
     if (this->isRenderModeAvailable(RenderMode::AMBIENT_OCCLUSION)) {
         this->renderModeParam.Param<param::EnumParam>()->SetTypePair(RenderMode::AMBIENT_OCCLUSION, "Ambient_Occlusion");
     }
+    if (this->isRenderModeAvailable(RenderMode::OUTLINE)) {
+        this->renderModeParam.Param<param::EnumParam>()->SetTypePair(RenderMode::OUTLINE, "Outline");
+    }
     this->MakeSlotAvailable(&this->renderModeParam);
 
     // Check initial render mode
@@ -465,6 +473,23 @@ bool moldyn::SphereRenderer::createResources() {
             this->triggerRebuildGBuffer = true;
         } break;
 
+        case RenderMode::OUTLINE: {
+            vertShaderName = "sphere_outline::vertex";
+            fragShaderName = "sphere_outline::fragment";
+            if (!instance()->ShaderSourceFactory().MakeShaderSource(vertShaderName.PeekBuffer(), *this->vertShader)) {
+                return false;
+            }
+            if (!instance()->ShaderSourceFactory().MakeShaderSource(fragShaderName.PeekBuffer(), *this->fragShader)) {
+                return false;
+            }
+            if (!this->sphereShader.Create(this->vertShader->Code(), this->vertShader->Count(),
+                    this->fragShader->Code(), this->fragShader->Count())) {
+                vislib::sys::Log::DefaultLog.WriteMsg(
+                    vislib::sys::Log::LEVEL_ERROR, "Unable to compile sphere shader: Unknown error\n");
+                return false;
+            }
+        } break;
+
         default:
             return false;
         }
@@ -568,6 +593,11 @@ bool moldyn::SphereRenderer::isRenderModeAvailable(RenderMode rm, bool silent) {
             errorstr += "[SphereRenderer] Render Mode 'AMBIENT_OCCLUSION' is not available. Extension GL_ARB_gpu_shader_fp64 is not available. \n";
         }
         break;
+    case (RenderMode::OUTLINE):
+        if (ogl_IsVersionGEQ(1, 4) == 0) { // TODO change to needed openGL version
+            errorstr += "[SphereRenderer] Render Mode 'OUTLINE' is not available. Minimum OpenGL version is 1.4 \n";
+        }
+        break;
     default:
         errorstr += "[SphereRenderer] BUG: Unknown render mode ... \n";
         break;
@@ -607,6 +637,9 @@ std::string moldyn::SphereRenderer::getRenderModeString(RenderMode rm) {
     case (RenderMode::AMBIENT_OCCLUSION):
         mode = "AMBIENT OCCLUSION";
         break;
+    case (RenderMode::OUTLINE):
+        mode = "OUTLINE";
+        break;
     default:
         mode = "unknown";
         break;
@@ -711,6 +744,8 @@ bool moldyn::SphereRenderer::Render(view::CallRender3D& call) {
     case (RenderMode::AMBIENT_OCCLUSION):
         retval = this->renderAmbientOcclusion(cr3d, mpdc); 
         break;
+    case (RenderMode::OUTLINE):
+        retval = this->renderOutline(cr3d, mpdc); break;
     default:
         break;
     }
@@ -1174,6 +1209,75 @@ bool moldyn::SphereRenderer::renderSplat(view::CallRender3D* cr3d, MultiParticle
     return true;
 }
 
+bool moldyn::SphereRenderer::renderOutline(view::CallRender3D* cr3d, MultiParticleDataCall* mpdc) {
+
+    this->sphereShader.Enable();
+
+    GLuint vertAttribLoc = glGetAttribLocationARB(this->sphereShader, "inVertex");
+    GLuint colAttribLoc = glGetAttribLocationARB(this->sphereShader, "inColor");
+    GLuint colIdxAttribLoc = glGetAttribLocationARB(this->sphereShader, "colIdx");
+
+    glUniform4fv(this->sphereShader.ParameterLocation("viewAttr"), 1, this->curViewAttrib);
+    glUniform3fv(
+        this->sphereShader.ParameterLocation("camIn"), 1, cr3d->GetCameraParameters()->Front().PeekComponents());
+    glUniform3fv(
+        this->sphereShader.ParameterLocation("camRight"), 1, cr3d->GetCameraParameters()->Right().PeekComponents());
+    glUniform3fv(this->sphereShader.ParameterLocation("camUp"), 1, cr3d->GetCameraParameters()->Up().PeekComponents());
+    glUniform1f(
+        this->sphereShader.ParameterLocation("scaling"), this->radiusScalingParam.Param<param::FloatParam>()->Value());
+    glUniform1f(
+        this->sphereShader.ParameterLocation("outlinesize"), this->outlineSizeSlot.Param<param::FloatParam>()->Value());
+    glUniform4fv(this->sphereShader.ParameterLocation("clipDat"), 1, this->curClipDat);
+    glUniform4fv(this->sphereShader.ParameterLocation("clipCol"), 1, this->curClipCol);
+    glUniform4fv(this->sphereShader.ParameterLocation("lpos"), 1, this->curLightPos);
+    glUniformMatrix4fv(this->sphereShader.ParameterLocation("MVinv"), 1, GL_FALSE, this->curMVinv.PeekComponents());
+    glUniformMatrix4fv(this->sphereShader.ParameterLocation("MVP"), 1, GL_FALSE, this->curMVP.PeekComponents());
+    glUniformMatrix4fv(this->sphereShader.ParameterLocation("MVPinv"), 1, GL_FALSE, this->curMVPinv.PeekComponents());
+    glUniformMatrix4fv(
+        this->sphereShader.ParameterLocation("MVPtransp"), 1, GL_FALSE, this->curMVPtransp.PeekComponents());
+
+    for (unsigned int i = 0; i < mpdc->GetParticleListCount(); i++) {
+        MultiParticleDataCall::Particles& parts = mpdc->AccessParticles(i);
+
+        GLuint vao, vb, cb;
+        if (this->renderMode == RenderMode::SIMPLE_CLUSTERED) {
+            parts.GetVAOs(vao, vb, cb);
+            if (parts.IsVAO()) {
+                glBindVertexArray(vao);
+                this->setPointers<GLSLShader>(parts, this->sphereShader, vb, parts.GetVertexData(), vertAttribLoc, cb,
+                    parts.GetColourData(), colAttribLoc, colIdxAttribLoc);
+            }
+        }
+        if ((this->renderMode == RenderMode::SIMPLE) || (!parts.IsVAO())) {
+            this->setPointers<GLSLShader>(parts, this->sphereShader, 0, parts.GetVertexData(), vertAttribLoc, 0,
+                parts.GetColourData(), colAttribLoc, colIdxAttribLoc);
+        }
+
+        glDrawArrays(GL_POINTS, 0, static_cast<GLsizei>(parts.GetCount()));
+
+        if (this->renderMode == RenderMode::SIMPLE_CLUSTERED) {
+            if (parts.IsVAO()) {
+                glBindVertexArray(0); // vao
+            }
+        }
+
+        // Reset states set in setPointers()
+        glBindBuffer(GL_ARRAY_BUFFER, 0);
+        glDisableVertexAttribArrayARB(vertAttribLoc);
+        glDisableVertexAttribArrayARB(colAttribLoc);
+        glDisableVertexAttribArrayARB(colIdxAttribLoc);
+        glDisable(GL_TEXTURE_1D);
+    }
+
+    mpdc->Unlock();
+
+    this->sphereShader.Disable();
+
+    return true;
+
+    return true;
+}
+
 
 bool moldyn::SphereRenderer::renderBufferArray(view::CallRender3D* cr3d, MultiParticleDataCall* mpdc) {
 
@@ -2130,8 +2234,12 @@ void moldyn::SphereRenderer::renderDeferredPass(megamol::core::view::CallRender3
             "inBoundsSize", 1, cr3d->AccessBoundingBoxes().ObjectSpaceClipBox().GetSize().PeekDimension());
     }
 
-    glBegin(GL_POINTS);
-    glVertex2f(0.0f, 0.0f);
+    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+    glBegin(GL_QUADS);
+    glVertex2f(-1.0f, 1.0f);
+    glVertex2f(-1.0f, -1.0f);
+    glVertex2f(1.0f, -1.0f);
+    glVertex2f(1.0f, 1.0f);
     glEnd();
 
     glBindTexture(GL_TEXTURE_2D, 0);
diff --git a/core/src/utility/ScaledBoundingBoxes.cpp b/core/src/utility/ScaledBoundingBoxes.cpp
new file mode 100644
index 000000000..641314758
--- /dev/null
+++ b/core/src/utility/ScaledBoundingBoxes.cpp
@@ -0,0 +1,104 @@
+/*
+ * ScaledBoundingBoxes.cpp
+ *
+ * Copyright (C) 2019 by Universitaet Stuttgart (VIS).
+ * Alle Rechte vorbehalten.
+ */
+
+#include "stdafx.h"
+#include "mmcore/utility/ScaledBoundingBoxes.h"
+
+#include "mmcore/BoundingBoxes.h"
+
+#include "glad/glad.h"
+
+#include <stdexcept>
+#include <vector>
+
+namespace megamol {
+namespace core {
+namespace utility {
+
+namespace {
+float magicScale(const BoundingBoxes& bb) {
+    float scale = bb.ObjectSpaceBBox().LongestEdge();
+
+    if (scale > 0.0000001) {
+        //scale = 10.0f / scale;
+        scale = 1.0f / scale;
+    } else {
+        scale = 1.0f;
+    }
+
+    return scale;
+}
+}
+
+BoundingBoxes scaleBoundingBoxes(float scale, const BoundingBoxes& bb) {
+    auto out = bb;
+    out.MakeScaledWorld(scale);
+
+    return out;
+}
+
+BoundingBoxes combineAndScaleBoundingBoxes(float scale, const std::vector<BoundingBoxes>& bbs) {
+    if (bbs.empty()) throw std::runtime_error("List of bounding boxes must not be empty");
+
+    auto out = bbs.front();
+
+    for (auto& bb : bbs) {
+        auto osbb = out.ObjectSpaceBBox();
+        auto oscb = out.ObjectSpaceClipBox();
+
+        osbb.Union(bb.ObjectSpaceBBox());
+        oscb.Union(bb.ObjectSpaceClipBox());
+
+        out.SetObjectSpaceBBox(osbb);
+        out.SetObjectSpaceClipBox(oscb);
+    }
+
+    out.MakeScaledWorld(scale);
+
+    return out;
+}
+
+BoundingBoxes magicScaleBoundingBoxes(const BoundingBoxes& bb) { return scaleBoundingBoxes(magicScale(bb), bb); }
+
+BoundingBoxes combineAndMagicScaleBoundingBoxes(const std::vector<BoundingBoxes>& bbs) {
+    if (bbs.empty()) throw std::runtime_error("List of bounding boxes must not be empty");
+
+    auto out = bbs.front();
+
+    for (auto& bb : bbs) {
+        auto osbb = out.ObjectSpaceBBox();
+        auto oscb = out.ObjectSpaceClipBox();
+
+        osbb.Union(bb.ObjectSpaceBBox());
+        oscb.Union(bb.ObjectSpaceClipBox());
+
+        out.SetObjectSpaceBBox(osbb);
+        out.SetObjectSpaceClipBox(oscb);
+    }
+
+    out.MakeScaledWorld(magicScale(out));
+
+    return out;
+}
+
+glMagicScale::glMagicScale() : scale(1.0f) { }
+
+glMagicScale::~glMagicScale() {
+    glScalef(1.0f / this->scale, 1.0f / this->scale, 1.0f / this->scale);
+}
+
+void glMagicScale::apply(const BoundingBoxes& bb) {
+    glScalef(1.0f / this->scale, 1.0f / this->scale, 1.0f / this->scale);
+
+    this->scale = magicScale(bb);
+
+    glScalef(this->scale, this->scale, this->scale);
+};
+
+}
+}
+}
\ No newline at end of file
diff --git a/core/src/utility/plugins/PluginManager.cpp b/core/src/utility/plugins/PluginManager.cpp
index 03ec7c7f9..34678122c 100644
--- a/core/src/utility/plugins/PluginManager.cpp
+++ b/core/src/utility/plugins/PluginManager.cpp
@@ -162,10 +162,15 @@ PluginManager::collection_type PluginManager::ContinueLoad200(
             LibraryVersionInfo &lvi = comp_info->libs[li];
             if (vislib::StringA("MegaMolCore").Equals(lvi.name)) {
                 MegaMolCore_compatibility_checked = true;
+                // mueller: where is the sense in having a separate variable which is sometimes wrong?
+                //vislib::VersionNumber v(
+                //    (lvi.version_len > 0) ? std::atoi(lvi.version[0].c_str()) : 0,
+                //    (lvi.version_len > 1) ? std::atoi(lvi.version[1].c_str()) : 0,
+                //    (lvi.version_len > 2) ? lvi.version[2].c_str() : 0);
                 vislib::VersionNumber v(
-                    (lvi.version_len > 0) ? std::atoi(lvi.version[0].c_str()) : 0,
-                    (lvi.version_len > 1) ? std::atoi(lvi.version[1].c_str()) : 0,
-                    (lvi.version_len > 2) ? lvi.version[2].c_str() : 0);
+                    (lvi.version.size() > 0) ? std::atoi(lvi.version[0].c_str()) : 0,
+                    (lvi.version.size() > 1) ? std::atoi(lvi.version[1].c_str()) : 0,
+                    (lvi.version.size() > 2) ? lvi.version[2].c_str() : 0);
                 if ((v.GetMajorVersionNumber() != mmcoreVer.GetMajorVersionNumber())
                     && (v.GetMinorVersionNumber() != mmcoreVer.GetMinorVersionNumber())
                     && (v.GetRevisionNumber() != mmcoreVer.GetRevisionNumber())) {
@@ -178,10 +183,15 @@ PluginManager::collection_type PluginManager::ContinueLoad200(
 
             } else if (vislib::StringA("vislib").Equals(lvi.name)) {
                 vislib_compatibility_checked = true;
+                // mueller: where is the sense in having a separate variable which is sometimes wrong?
+                // vislib::VersionNumber v(
+                //    (lvi.version_len > 0) ? std::atoi(lvi.version[0].c_str()) : 0,
+                //    (lvi.version_len > 1) ? std::atoi(lvi.version[1].c_str()) : 0,
+                //    (lvi.version_len > 2) ? lvi.version[2].c_str() : 0);
                 vislib::VersionNumber v(
-                    (lvi.version_len > 0) ? std::atoi(lvi.version[0].c_str()) : 0,
-                    (lvi.version_len > 1) ? std::atoi(lvi.version[1].c_str()) : 0,
-                    (lvi.version_len > 2) ? lvi.version[2].c_str() : 0);
+                    (lvi.version.size() > 0) ? std::atoi(lvi.version[0].c_str()) : 0,
+                    (lvi.version.size() > 1) ? std::atoi(lvi.version[1].c_str()) : 0,
+                    (lvi.version.size() > 2) ? lvi.version[2].c_str() : 0);
                 if ((v.GetMajorVersionNumber() != vislibVer.GetMajorVersionNumber())
                     && (v.GetMinorVersionNumber() != vislibVer.GetMinorVersionNumber())
                     && (v.GetRevisionNumber() != vislibVer.GetRevisionNumber())) {
diff --git a/core/src/view/AbstractView.cpp b/core/src/view/AbstractView.cpp
index 784379402..f39294af3 100644
--- a/core/src/view/AbstractView.cpp
+++ b/core/src/view/AbstractView.cpp
@@ -1,7 +1,7 @@
 /*
  * AbstractView.cpp
  *
- * Copyright (C) 2008 by Universitaet Stuttgart (VIS). 
+ * Copyright (C) 2008 by Universitaet Stuttgart (VIS).
  * Alle Rechte vorbehalten.
  */
 
@@ -12,11 +12,11 @@
 #include "mmcore/CoreInstance.h"
 #include "mmcore/param/AbstractParam.h"
 #include "mmcore/param/ParamSlot.h"
-#include "mmcore/view/CallRenderView.h"
 #include "mmcore/view/AbstractCallRender.h"
+#include "mmcore/view/CallRenderView.h"
 #include "vislib/Array.h"
-#include "vislib/assert.h"
 #include "vislib/UnsupportedOperationException.h"
+#include "vislib/assert.h"
 
 using namespace megamol::core;
 using vislib::sys::Log;
@@ -25,9 +25,8 @@ using vislib::sys::Log;
 /*
  * view::AbstractView::AbstractView
  */
-view::AbstractView::AbstractView(void) : Module(),
-        renderSlot("render", "Connects modules requesting renderings"),
-        hooks() {
+view::AbstractView::AbstractView(void)
+    : Module(), renderSlot("render", "Connects modules requesting renderings"), hooks() {
     // InputCall
     this->renderSlot.SetCallback(
         view::CallRenderView::ClassName(), InputCall::FunctionName(InputCall::FnOnKey), &AbstractView::OnKeyCallback);
@@ -43,7 +42,7 @@ view::AbstractView::AbstractView(void) : Module(),
     this->renderSlot.SetCallback(view::CallRenderView::ClassName(),
         AbstractCallRender::FunctionName(AbstractCallRender::FnRender), &AbstractView::OnRenderView);
     this->renderSlot.SetCallback(view::CallRenderView::ClassName(),
-        AbstractCallRender::FunctionName(AbstractCallRender::FnGetExtents), &AbstractView::GetExtentsCallback);
+        AbstractCallRender::FunctionName(AbstractCallRender::FnGetExtents), &AbstractView::GetExtents);
     // CallRenderView
     this->renderSlot.SetCallback(view::CallRenderView::ClassName(),
         view::CallRenderView::FunctionName(view::CallRenderView::CALL_FREEZE), &AbstractView::OnFreezeView);
@@ -66,8 +65,7 @@ view::AbstractView::~AbstractView(void) {
 /*
  * view::AbstractView::IsParamRelevant
  */
-bool view::AbstractView::IsParamRelevant(
-        const vislib::SmartPtr<param::AbstractParam>& param) const {
+bool view::AbstractView::IsParamRelevant(const vislib::SmartPtr<param::AbstractParam>& param) const {
     const AbstractNamedObject* ano = dynamic_cast<const AbstractNamedObject*>(this);
     if (ano == NULL) return false;
     if (param.IsNull()) return false;
@@ -80,26 +78,24 @@ bool view::AbstractView::IsParamRelevant(
 /*
  * view::AbstractView::DesiredWindowPosition
  */
-bool view::AbstractView::DesiredWindowPosition(int *x, int *y, int *w,
-        int *h, bool *nd) {
-    Module *tm = dynamic_cast<Module*>(this);
+bool view::AbstractView::DesiredWindowPosition(int* x, int* y, int* w, int* h, bool* nd) {
+    Module* tm = dynamic_cast<Module*>(this);
     if (tm != NULL) {
 
         // this is not working properly if the main module/view is placed at top namespace root
-        //vislib::StringA name(tm->Name());
-        //if (tm->Parent() != NULL) name = tm->Parent()->Name();
+        // vislib::StringA name(tm->Name());
+        // if (tm->Parent() != NULL) name = tm->Parent()->Name();
         vislib::StringA name(tm->GetDemiRootName());
 
         if (name.IsEmpty()) {
-            vislib::sys::Log::DefaultLog.WriteMsg(vislib::sys::Log::LEVEL_INFO + 1200,
-                "View does not seem to have a name. Odd.");
+            vislib::sys::Log::DefaultLog.WriteMsg(
+                vislib::sys::Log::LEVEL_INFO + 1200, "View does not seem to have a name. Odd.");
         } else {
             name.Append("-Window");
 
             if (tm->GetCoreInstance()->Configuration().IsConfigValueSet(name)) {
                 if (this->desiredWindowPosition(
-                        tm->GetCoreInstance()->Configuration().ConfigValue(name),
-                        x, y, w, h, nd)) {
+                        tm->GetCoreInstance()->Configuration().ConfigValue(name), x, y, w, h, nd)) {
                     vislib::sys::Log::DefaultLog.WriteMsg(vislib::sys::Log::LEVEL_INFO + 200,
                         "Loaded desired window geometry from \"%s\"", name.PeekBuffer());
                     return true;
@@ -116,9 +112,7 @@ bool view::AbstractView::DesiredWindowPosition(int *x, int *y, int *w,
         name = "*-Window";
 
         if (tm->GetCoreInstance()->Configuration().IsConfigValueSet(name)) {
-            if (this->desiredWindowPosition(
-                    tm->GetCoreInstance()->Configuration().ConfigValue(name),
-                    x, y, w, h, nd)) {
+            if (this->desiredWindowPosition(tm->GetCoreInstance()->Configuration().ConfigValue(name), x, y, w, h, nd)) {
                 vislib::sys::Log::DefaultLog.WriteMsg(vislib::sys::Log::LEVEL_INFO + 200,
                     "Loaded desired window geometry from \"%s\"", name.PeekBuffer());
                 return true;
@@ -140,24 +134,32 @@ bool view::AbstractView::DesiredWindowPosition(int *x, int *y, int *w,
  * view::AbstractView::OnRenderView
  */
 bool view::AbstractView::OnRenderView(Call& call) {
-    throw vislib::UnsupportedOperationException(
-        "AbstractView::OnRenderView", __FILE__, __LINE__);
+    throw vislib::UnsupportedOperationException("AbstractView::OnRenderView", __FILE__, __LINE__);
 }
 
 /*
  * view::AbstractView::desiredWindowPosition
  */
-bool view::AbstractView::desiredWindowPosition(const vislib::StringW& str,
-        int *x, int *y, int *w, int *h, bool *nd) {
+bool view::AbstractView::desiredWindowPosition(const vislib::StringW& str, int* x, int* y, int* w, int* h, bool* nd) {
     vislib::StringW v = str;
     int vi = -1;
     v.TrimSpaces();
 
-    if (x != NULL) { *x = INT_MIN; }
-    if (y != NULL) { *y = INT_MIN; }
-    if (w != NULL) { *w = INT_MIN; }
-    if (h != NULL) { *h = INT_MIN; }
-    if (nd != NULL) { *nd = false; }
+    if (x != NULL) {
+        *x = INT_MIN;
+    }
+    if (y != NULL) {
+        *y = INT_MIN;
+    }
+    if (w != NULL) {
+        *w = INT_MIN;
+    }
+    if (h != NULL) {
+        *h = INT_MIN;
+    }
+    if (nd != NULL) {
+        *nd = false;
+    }
 
     while (!v.IsEmpty()) {
         if ((v[0] == L'X') || (v[0] == L'x')) {
@@ -176,8 +178,7 @@ bool view::AbstractView::desiredWindowPosition(const vislib::StringW& str,
             }
             vi = 4;
         } else {
-            Log::DefaultLog.WriteMsg(
-                vislib::sys::Log::LEVEL_WARN,
+            Log::DefaultLog.WriteMsg(vislib::sys::Log::LEVEL_WARN,
                 "Unexpected character %s in window position definition.\n",
                 vislib::StringA(vislib::StringA(v)[0], 1).PeekBuffer());
             break;
@@ -191,46 +192,59 @@ bool view::AbstractView::desiredWindowPosition(const vislib::StringW& str,
             // now we want to parse a double :-/
             int cp = 0;
             int len = v.Length();
-            while ((cp < len) && (((v[cp] >= L'0') && (v[cp] <= L'9'))
-                    || (v[cp] == L'+') /*|| (v[cp] == L'.')
-                    || (v[cp] == L',') */|| (v[cp] == L'-')
-                    /*|| (v[cp] == L'e') || (v[cp] == L'E')*/)) {
+            while ((cp < len) && (((v[cp] >= L'0') && (v[cp] <= L'9')) || (v[cp] == L'+') /*|| (v[cp] == L'.')
+                                                                       || (v[cp] == L',') */
+                                     || (v[cp] == L'-')
+                                     /*|| (v[cp] == L'e') || (v[cp] == L'E')*/)) {
                 cp++;
             }
 
             try {
                 int i = vislib::CharTraitsW::ParseInt(v.Substring(0, cp));
                 switch (vi) {
-                    case 0 :
-                        if (x != NULL) { *x = i; }
-                        break;
-                    case 1 :
-                        if (y != NULL) { *y = i; }
-                        break;
-                    case 2 :
-                        if (w != NULL) { *w = i; }
-                        break;
-                    case 3 :
-                        if (h != NULL) { *h = i; }
-                        break;
+                case 0:
+                    if (x != NULL) {
+                        *x = i;
+                    }
+                    break;
+                case 1:
+                    if (y != NULL) {
+                        *y = i;
+                    }
+                    break;
+                case 2:
+                    if (w != NULL) {
+                        *w = i;
+                    }
+                    break;
+                case 3:
+                    if (h != NULL) {
+                        *h = i;
+                    }
+                    break;
                 }
-            } catch(...) {
-                const char *str = "unknown";
+            } catch (...) {
+                const char* str = "unknown";
                 switch (vi) {
-                    case 0 : str = "X"; break;
-                    case 1 : str = "Y"; break;
-                    case 2 : str = "W"; break;
-                    case 3 : str = "H"; break;
+                case 0:
+                    str = "X";
+                    break;
+                case 1:
+                    str = "Y";
+                    break;
+                case 2:
+                    str = "W";
+                    break;
+                case 3:
+                    str = "H";
+                    break;
                 }
                 vi = -1;
-                Log::DefaultLog.WriteMsg(
-                    vislib::sys::Log::LEVEL_WARN,
-                    "Unable to parse value for %s.\n", str);
+                Log::DefaultLog.WriteMsg(vislib::sys::Log::LEVEL_WARN, "Unable to parse value for %s.\n", str);
             }
 
             v = v.Substring(cp);
         }
-
     }
 
     return true;
@@ -240,7 +254,7 @@ bool view::AbstractView::desiredWindowPosition(const vislib::StringW& str,
 /*
  * view::AbstractView::unpackMouseCoordinates
  */
-void view::AbstractView::unpackMouseCoordinates(float &x, float &y) {
+void view::AbstractView::unpackMouseCoordinates(float& x, float& y) {
     // intentionally empty
     // do something smart in the derived classes
 }
@@ -254,9 +268,9 @@ bool view::AbstractView::onResetView(Call& call) {
 }
 
 
-bool view::AbstractView::GetExtentsCallback(Call& call) {
-	// NOP, because thats the way it was before.
-	return false; 
+bool view::AbstractView::GetExtents(Call& call) {
+    throw vislib::UnsupportedOperationException("AbstractView::GetExtents", __FILE__, __LINE__);
+    return false;
 }
 
 bool view::AbstractView::OnKeyCallback(Call& call) {
diff --git a/core/src/view/SplitView.cpp b/core/src/view/SplitView.cpp
index 88b0420b3..3b46dc1d7 100644
--- a/core/src/view/SplitView.cpp
+++ b/core/src/view/SplitView.cpp
@@ -6,6 +6,7 @@
  */
 #include "stdafx.h"
 #include "mmcore/view/SplitView.h"
+#include "mmcore/param/BoolParam.h"
 #include "mmcore/param/ColorParam.h"
 #include "mmcore/param/EnumParam.h"
 #include "mmcore/param/FloatParam.h"
@@ -30,6 +31,9 @@ view::SplitView::SplitView()
     , splitPositionSlot("split.pos", "Splitter position")
     , splitWidthSlot("split.width", "Splitter width")
     , splitColourSlot("split.colour", "Splitter colour")
+    , enableTimeSyncSlot("timeLord",
+          "Enables time synchronization between the connected views. The time of this view is then used instead")
+    , inputToBothSlot("inputToBoth", "Forward input to both child views")
     , overrideCall(nullptr)
     , clientArea()
     , clientArea1()
@@ -60,15 +64,22 @@ view::SplitView::SplitView()
 
     this->splitColourSlot << new param::ColorParam(0.75f, 0.75f, 0.75f, 1.0f);
     this->MakeSlotAvailable(&this->splitColourSlot);
-}
 
-view::SplitView::~SplitView() { this->Release(); }
+    this->enableTimeSyncSlot << new param::BoolParam(false);
+    this->MakeSlotAvailable(&this->enableTimeSyncSlot);
+
+    this->inputToBothSlot << new param::BoolParam(false);
+    this->MakeSlotAvailable(&this->inputToBothSlot);
 
-float view::SplitView::DefaultTime(double instTime) const {
-    // This view does not do any time control
-    return 0.0f;
+    for (unsigned int i = 0; this->timeCtrl.GetSlot(i) != nullptr; i++) {
+        this->MakeSlotAvailable(this->timeCtrl.GetSlot(i));
+    }
 }
 
+view::SplitView::~SplitView(void) { this->Release(); }
+
+float view::SplitView::DefaultTime(double instTime) const { return this->timeCtrl.Time(instTime); }
+
 unsigned int view::SplitView::GetCameraSyncNumber() const {
     Log::DefaultLog.WriteWarn("SplitView::GetCameraSyncNumber unsupported");
     return 0u;
@@ -85,6 +96,8 @@ void view::SplitView::DeserialiseCamera(vislib::Serialiser& serialiser) {
 void view::SplitView::Render(const mmcRenderViewContext& context) {
     // TODO: Affinity
 
+	 float time = static_cast<float>(context.Time);
+
     if (this->doHookCode()) {
         this->doBeforeRenderHook();
     }
@@ -102,17 +115,61 @@ void view::SplitView::Render(const mmcRenderViewContext& context) {
         vph = this->overrideCall->ViewportHeight();
     }
 
+    if (this->enableTimeSyncSlot.Param<param::BoolParam>()->Value()) {
+        auto cr = this->render1();
+        (*cr)(CallRenderView::CALL_EXTENTS);
+        auto fcount = cr->TimeFramesCount();
+        auto insitu = cr->IsInSituTime();
+        cr = this->render2();
+        (*cr)(CallRenderView::CALL_EXTENTS);
+        fcount = std::min(fcount, cr->TimeFramesCount());
+        insitu = insitu && cr->IsInSituTime();
+
+        this->timeCtrl.SetTimeExtend(fcount, insitu);
+        if (time > static_cast<float>(fcount)) {
+            time = static_cast<float>(fcount);
+        }
+    }
+
+    //float sp = this->splitPositionSlot.Param<param::FloatParam>()->Value();
+    //float shw = this->splitWidthSlot.Param<param::FloatParam>()->Value() * 0.5f;
+    //auto so = static_cast<Orientation>(this->splitOrientationSlot.Param<param::EnumParam>()->Value());
+    //if (so == HORIZONTAL) {
+    //    auto oc = this->overrideCall;
+    //    float splitpos = oc->VirtualWidth() * sp;
+
+    //    auto left1 = oc->TileX();
+    //    auto right1 = std::max(std::min(oc->TileX() + oc->TileWidth(), splitpos), oc->TileX());
+    //    if (left1 == right1) {
+    //        // skip client 1
+    //        // draw no handle at all
+    //    }
+    //    // or the other way round?
+    //    auto top1 = oc->TileY();
+    //    auto bottom1 = oc->TileY() + oc->TileHeight();
+
+    //    auto left2 = std::min(std::max(oc->TileX(), splitpos), oc->TileX() + oc->TileWidth());
+    //    auto right2 = oc->TileX() + oc->TileWidth();
+    //    if (left2 == right2) {
+    //        // skip client 2
+    //        // draw no handle at all
+    //    }
+    //    auto top2 = top1;
+    //    auto bottom2 = bottom1;
+    //} else {
+    //}
+
     if (this->splitPositionSlot.IsDirty() || this->splitOrientationSlot.IsDirty() || this->splitWidthSlot.IsDirty() ||
         !this->fbo1.IsValid() || !this->fbo2.IsValid() ||
         !vislib::math::IsEqual(this->clientArea.Width(), static_cast<float>(vpw)) ||
         !vislib::math::IsEqual(this->clientArea.Height(), static_cast<float>(vph))) {
-
         this->updateSize(vpw, vph);
 
         if (this->overrideCall != nullptr) {
             this->overrideCall->EnableOutputBuffer();
         }
     }
+
     auto renderAndBlit = [&](vislib::graphics::gl::FramebufferObject& fbo, CallRenderView* crv,
                              const vislib::math::Rectangle<float>& ca) {
         if (crv == nullptr) {
@@ -122,6 +179,10 @@ void view::SplitView::Render(const mmcRenderViewContext& context) {
         crv->SetInstanceTime(context.InstanceTime);
         crv->SetTime(-1.0f);
 
+        if (this->enableTimeSyncSlot.Param<param::BoolParam>()->Value()) {
+            crv->SetTime(static_cast<float>(time));
+        }
+
 #if defined(DEBUG) || defined(_DEBUG)
         unsigned int otl = vislib::Trace::GetInstance().GetLevel();
         vislib::Trace::GetInstance().SetLevel(0);
@@ -163,6 +224,25 @@ void view::SplitView::Render(const mmcRenderViewContext& context) {
     renderAndBlit(this->fbo2, this->render2(), this->clientArea2);
 }
 
+bool view::SplitView::GetExtents(core::Call& call) {
+    if (this->enableTimeSyncSlot.Param<param::BoolParam>()->Value()) {
+        auto cr = this->render1();
+        if (!(*cr)(CallRenderView::CALL_EXTENTS)) return false;
+        auto time = cr->TimeFramesCount();
+        auto insitu = cr->IsInSituTime();
+        cr = this->render2();
+        if (!(*cr)(CallRenderView::CALL_EXTENTS)) return false;
+        time = std::min(time, cr->TimeFramesCount());
+        insitu = insitu && cr->IsInSituTime();
+
+        CallRenderView* crv = dynamic_cast<CallRenderView*>(&call);
+        if (crv == nullptr) return false;
+        crv->SetTimeFramesCount(time);
+        crv->SetIsInSituTime(insitu);
+    }
+    return true;
+}
+
 void view::SplitView::ResetView() {
     for (auto crv : {this->render1(), this->render2()}) {
         if (crv != nullptr) (*crv)(CallRenderView::CALL_RESETVIEW);
@@ -185,6 +265,9 @@ bool view::SplitView::OnRenderView(Call& call) {
     mmcRenderViewContext context;
     ::ZeroMemory(&context, sizeof(context));
     context.Time = crv->Time();
+    if (this->enableTimeSyncSlot.Param<param::BoolParam>()->Value() && context.Time < 0.0) {
+        context.Time = this->DefaultTime(crv->InstanceTime());
+    }
     context.InstanceTime = crv->InstanceTime();
     this->Render(context);
 
@@ -200,37 +283,59 @@ void view::SplitView::UpdateFreeze(bool freeze) {
 }
 
 bool view::SplitView::OnKey(Key key, KeyAction action, Modifiers mods) {
-    bool consumed = false;
+    auto* crv = this->renderHovered();
+    auto* crv1 = this->render1();
+    auto* crv2 = this->render2();
 
-    for (auto crv : {this->render1(), this->render2()}) {
-        if (crv != nullptr) {
-            InputEvent evt;
-            evt.tag = InputEvent::Tag::Key;
-            evt.keyData.key = key;
-            evt.keyData.action = action;
-            evt.keyData.mods = mods;
+    if (crv != nullptr) {
+        InputEvent evt;
+        evt.tag = InputEvent::Tag::Key;
+        evt.keyData.key = key;
+        evt.keyData.action = action;
+        evt.keyData.mods = mods;
+
+        if (this->inputToBothSlot.Param<param::BoolParam>()->Value()) {
+            crv1->SetInputEvent(evt);
+            auto consumed = (*crv1)(view::CallRenderView::FnOnKey);
+
+            crv2->SetInputEvent(evt);
+            consumed |= (*crv2)(view::CallRenderView::FnOnKey);
+
+            return consumed;
+        } else {
             crv->SetInputEvent(evt);
-            if ((*crv)(view::CallRenderView::FnOnKey)) consumed = true;
+            if (!(*crv)(view::CallRenderView::FnOnKey)) return false;
         }
     }
 
-    return consumed;
+    return false;
 }
 
 bool view::SplitView::OnChar(unsigned int codePoint) {
-    bool consumed = false;
+    auto* crv = this->renderHovered();
+    auto* crv1 = this->render1();
+    auto* crv2 = this->render2();
 
-    for (auto crv : {this->render1(), this->render2()}) {
-        if (crv != nullptr) {
-            InputEvent evt;
-            evt.tag = InputEvent::Tag::Char;
-            evt.charData.codePoint = codePoint;
+    if (crv != nullptr) {
+        InputEvent evt;
+        evt.tag = InputEvent::Tag::Char;
+        evt.charData.codePoint = codePoint;
+
+        if (this->inputToBothSlot.Param<param::BoolParam>()->Value()) {
+            crv1->SetInputEvent(evt);
+            auto consumed = (*crv1)(view::CallRenderView::FnOnChar);
+
+            crv2->SetInputEvent(evt);
+            consumed |= (*crv2)(view::CallRenderView::FnOnChar);
+
+            return consumed;
+        } else {
             crv->SetInputEvent(evt);
-            if ((*crv)(view::CallRenderView::FnOnChar)) consumed = true;
+            if (!(*crv)(view::CallRenderView::FnOnChar)) return false;
         }
     }
 
-    return consumed;
+    return false;
 }
 
 bool view::SplitView::OnMouseButton(MouseButton button, MouseButtonAction action, Modifiers mods) {
@@ -240,28 +345,33 @@ bool view::SplitView::OnMouseButton(MouseButton button, MouseButtonAction action
 
     this->dragSplitter = false;
 
-    if (action == MouseButtonAction::PRESS) {
-        if (crv == crv1) {
-            this->focus = 1;
-        } else if (crv == crv2) {
-            this->focus = 2;
-        } else {
-            this->focus = 0;
-            this->dragSplitter = true;
-        }
+    auto down = (action == MouseButtonAction::PRESS);
+    if (down && crv != crv1 && crv != crv2) {
+        this->dragSplitter = true;
     }
 
-    if (crv) {
+    if (crv != nullptr) {
         InputEvent evt;
         evt.tag = InputEvent::Tag::MouseButton;
         evt.mouseButtonData.button = button;
         evt.mouseButtonData.action = action;
         evt.mouseButtonData.mods = mods;
-        crv->SetInputEvent(evt);
-        if (!(*crv)(view::CallRenderView::FnOnMouseButton)) return false;
+
+        if (this->inputToBothSlot.Param<param::BoolParam>()->Value()) {
+            crv1->SetInputEvent(evt);
+            auto consumed = (*crv1)(view::CallRenderView::FnOnMouseButton);
+
+            crv2->SetInputEvent(evt);
+            consumed |= (*crv2)(view::CallRenderView::FnOnMouseButton);
+
+            return consumed;
+        } else {
+            crv->SetInputEvent(evt);
+            if (!(*crv)(view::CallRenderView::FnOnMouseButton)) return false;
+        }
     }
 
-    return true;
+    return false;
 }
 
 
@@ -300,26 +410,51 @@ bool view::SplitView::OnMouseMove(double x, double y) {
         evt.tag = InputEvent::Tag::MouseMove;
         evt.mouseMoveData.x = mx;
         evt.mouseMoveData.y = my;
-        crv->SetInputEvent(evt);
-        if (!(*crv)(view::CallRenderView::FnOnMouseMove)) return false;
+
+        if (this->inputToBothSlot.Param<param::BoolParam>()->Value()) {
+            crv1->SetInputEvent(evt);
+            auto consumed = (*crv1)(view::CallRenderView::FnOnMouseMove);
+
+            crv2->SetInputEvent(evt);
+            consumed |= (*crv2)(view::CallRenderView::FnOnMouseMove);
+
+            return consumed;
+        } else {
+            crv->SetInputEvent(evt);
+            if (!(*crv)(view::CallRenderView::FnOnMouseMove)) return false;
+        }
     }
 
-    return true;
+    return false;
 }
 
 
 bool view::SplitView::OnMouseScroll(double dx, double dy) {
     auto* crv = this->renderHovered();
-    if (crv == nullptr) return false;
+    auto* crv1 = this->render1();
+    auto* crv2 = this->render2();
 
-    InputEvent evt;
-    evt.tag = InputEvent::Tag::MouseScroll;
-    evt.mouseScrollData.dx = dx;
-    evt.mouseScrollData.dy = dy;
-    crv->SetInputEvent(evt);
-    if (!(*crv)(view::CallRenderView::FnOnMouseScroll)) return false;
+    if (crv != nullptr) {
+        InputEvent evt;
+        evt.tag = InputEvent::Tag::MouseScroll;
+        evt.mouseScrollData.dx = dx;
+        evt.mouseScrollData.dy = dy;
 
-    return true;
+        if (this->inputToBothSlot.Param<param::BoolParam>()->Value()) {
+            crv1->SetInputEvent(evt);
+            auto consumed = (*crv1)(view::CallRenderView::FnOnMouseScroll);
+
+            crv2->SetInputEvent(evt);
+            consumed |= (*crv2)(view::CallRenderView::FnOnMouseScroll);
+
+            return consumed;
+        } else {
+            crv->SetInputEvent(evt);
+            if (!(*crv)(view::CallRenderView::FnOnMouseScroll)) return false;
+        }
+    }
+
+    return false;
 }
 
 bool view::SplitView::create() {
diff --git a/core/src/view/View2D.cpp b/core/src/view/View2D.cpp
index 6f05462c0..b343bc3a5 100644
--- a/core/src/view/View2D.cpp
+++ b/core/src/view/View2D.cpp
@@ -40,7 +40,7 @@ view::View2D::View2D(void) : view::AbstractRenderingView(),
     this->rendererSlot.SetCompatibleCall<CallRender2DDescription>();
     this->MakeSlotAvailable(&this->rendererSlot);
 
-    this->resetViewSlot << new param::ButtonParam(core::view::Key::KEY_HOME);
+    this->resetViewSlot << new param::ButtonParam();
     this->resetViewSlot.SetUpdateCallback(&View2D::onResetView);
     this->MakeSlotAvailable(&this->resetViewSlot);
 
@@ -375,6 +375,10 @@ bool view::View2D::OnKey(Key key, KeyAction action, Modifiers mods) {
     auto* cr = this->rendererSlot.CallAs<view::CallRender2D>();
     if (cr == NULL) return false;
 
+    if (key == Key::KEY_HOME) {
+        onResetView(this->resetViewSlot);
+    }
+
     InputEvent evt;
     evt.tag = InputEvent::Tag::Key;
     evt.keyData.key = key;
@@ -532,3 +536,20 @@ bool view::View2D::onResetView(param::ParamSlot& p) {
     this->ResetView();
     return true;
 }
+
+/*
+ * view::View2D::GetExtents
+ */
+bool view::View2D::GetExtents(Call& call) { 
+    view::CallRenderView* crv = dynamic_cast<view::CallRenderView*>(&call);
+    if (crv == nullptr) return false;
+
+    CallRender2D* cr2d = this->rendererSlot.CallAs<CallRender2D>();
+    if (cr2d == nullptr) return false;
+
+    if (!(*cr2d)(CallRender2D::FnGetExtents)) return false;
+
+    crv->SetTimeFramesCount(cr2d->TimeFramesCount());
+    crv->SetIsInSituTime(cr2d->IsInSituTime());
+    return true; 
+}
diff --git a/core/src/view/View3D.cpp b/core/src/view/View3D.cpp
index 8a431a3e6..dcea6ff09 100644
--- a/core/src/view/View3D.cpp
+++ b/core/src/view/View3D.cpp
@@ -133,7 +133,7 @@ view::View3D::View3D(void)
     this->restoreCameraSettingsSlot.SetUpdateCallback(&View3D::onRestoreCamera);
     this->MakeSlotAvailable(&this->restoreCameraSettingsSlot);
 
-    this->resetViewSlot << new param::ButtonParam(view::Key::KEY_HOME);
+    this->resetViewSlot << new param::ButtonParam();
     this->resetViewSlot.SetUpdateCallback(&View3D::onResetView);
     this->MakeSlotAvailable(&this->resetViewSlot);
 
@@ -709,6 +709,10 @@ bool view::View3D::OnKey(Key key, KeyAction action, Modifiers mods) {
     auto* cr = this->rendererSlot.CallAs<view::CallRender3D>();
     if (cr == NULL) return false;
 
+    if (key == Key::KEY_HOME) {
+        onResetView(this->resetViewSlot);
+    }
+
     running = mods.test(Modifier::SHIFT);
     bool down = (action == KeyAction::PRESS || action == KeyAction::REPEAT) && (action != KeyAction::RELEASE);
     bool ret = true;
@@ -1571,3 +1575,20 @@ void view::View3D::renderViewCube(void) {
     glLineWidth(1.0f);
     glDisable(GL_CULL_FACE);
 }
+
+/*
+ * view::View3D::GetExtents
+ */
+bool view::View3D::GetExtents(Call& call) { 
+    view::CallRenderView* crv = dynamic_cast<view::CallRenderView*>(&call);
+    if (crv == nullptr) return false;
+
+    CallRender3D* cr3d = this->rendererSlot.CallAs<CallRender3D>();
+    if (cr3d == nullptr) return false;
+
+    if (!(*cr3d)(CallRender3D::FnGetExtents)) return false;
+
+    crv->SetTimeFramesCount(cr3d->TimeFramesCount());
+    crv->SetIsInSituTime(cr3d->IsInSituTime());
+    return true; 
+}
diff --git a/core/src/view/special/ScreenShooter.cpp b/core/src/view/special/ScreenShooter.cpp
index 7161205c8..e4ff65f41 100644
--- a/core/src/view/special/ScreenShooter.cpp
+++ b/core/src/view/special/ScreenShooter.cpp
@@ -7,9 +7,12 @@
 
 #include "stdafx.h"
 #include "mmcore/view/special/ScreenShooter.h"
+
 #include <climits>
+#include <limits>
 #include <map>
 #include <sstream>
+
 #include "mmcore/AbstractNamedObject.h"
 #include "mmcore/AbstractNamedObjectContainer.h"
 #include "mmcore/CoreInstance.h"
@@ -939,11 +942,12 @@ bool view::special::ScreenShooter::triggerButtonClicked(param::ParamSlot& slot)
             if (this->makeAnimSlot.Param<param::BoolParam>()->Value()) {
                 param::ParamSlot* timeSlot = this->findTimeParam(vi->View());
                 if (timeSlot != nullptr) {
-                    timeSlot->Param<param::FloatParam>()->SetValue(
-                        static_cast<float>(this->animFromSlot.Param<param::IntParam>()->Value()));
-                    this->animLastFrameTime = (float)UINT_MAX;
+                    auto startTime = static_cast<float>(this->animFromSlot.Param<param::IntParam>()->Value());
+                    Log::DefaultLog.WriteInfo("Starting animation of screen shots at %f.", time);
+                    timeSlot->Param<param::FloatParam>()->SetValue(startTime);
+                    this->animLastFrameTime = std::numeric_limits<decltype(animLastFrameTime)>::lowest();
                 } else {
-                    Log::DefaultLog.WriteError("Unable to make animation screen shots");
+                    Log::DefaultLog.WriteError("Unable to make animation screen shots.");
                     this->makeAnimSlot.Param<param::BoolParam>()->SetValue(false);
                 }
                 // this is not a good idea because the animation module interferes with the "anim::time" parameter in
diff --git a/plugins/astro/CMakeLists.txt b/plugins/astro/CMakeLists.txt
new file mode 100644
index 000000000..6005bfcf0
--- /dev/null
+++ b/plugins/astro/CMakeLists.txt
@@ -0,0 +1,51 @@
+#
+# MegaMolâ¢ astro Plugin
+# Copyright 2017, by MegaMol Team
+# Alle Rechte vorbehalten. All rights reserved.
+#
+string(TOUPPER astro EXPORT_NAME)
+option(BUILD_${EXPORT_NAME}_PLUGIN "Option to build astro" ON)
+
+if(BUILD_${EXPORT_NAME}_PLUGIN)
+  project(astro)
+
+  # Check option dependencies: First list item is always the current build option,
+  # afterwards list the dependencies.
+  set(DEP_LIST "${DEP_LIST};BUILD_${EXPORT_NAME}_PLUGIN BUILD_CORE BUILD_MMSTD_DATATOOLS_PLUGIN" CACHE INTERNAL "")
+
+  require_external(nanoflann)
+  require_external(sim_sort)
+  require_external(glowl)
+
+  file(GLOB_RECURSE public_header_files RELATIVE "${CMAKE_CURRENT_SOURCE_DIR}" "include/*.h")
+  file(GLOB_RECURSE source_files RELATIVE "${CMAKE_CURRENT_SOURCE_DIR}" "src/*.cpp")
+  file(GLOB_RECURSE header_files RELATIVE "${CMAKE_CURRENT_SOURCE_DIR}" "src/*.h")
+  file(GLOB_RECURSE shader_files RELATIVE "${CMAKE_CURRENT_SOURCE_DIR}" "Shaders/*")
+
+  # Target definition
+  add_library(${PROJECT_NAME} SHARED ${public_header_files} ${header_files} ${shader_files} ${source_files})
+  set_target_properties(${PROJECT_NAME} PROPERTIES SUFFIX ".mmplg" CXX_STANDARD 17)
+  target_compile_definitions(${PROJECT_NAME} PRIVATE ${EXPORT_NAME}_EXPORTS)
+  target_include_directories(${PROJECT_NAME} PUBLIC
+    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
+    "include" "src")
+  target_link_libraries(${PROJECT_NAME} PRIVATE core mmstd_datatools nanoflann sim_sort glowl)
+
+  # Installation rules for generated files
+  install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/include/ DESTINATION "include")
+  install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/Shaders/ DESTINATION "share/shaders")
+  if(WIN32)
+    install(TARGETS ${PROJECT_NAME} RUNTIME DESTINATION "bin")
+    install(TARGETS ${PROJECT_NAME} ARCHIVE DESTINATION "lib")
+    install(FILES $<TARGET_PDB_FILE:${PROJECT_NAME}> DESTINATION bin OPTIONAL)
+  else()
+    install(TARGETS ${PROJECT_NAME} DESTINATION "lib" EXPORT ${PROJECT_NAME}-target)
+  endif()
+
+  # Grouping in Visual Studio
+  set_target_properties(${PROJECT_NAME} PROPERTIES FOLDER plugins)
+  source_group("Public Header Files" FILES ${public_header_files})
+  source_group("Header Files" FILES ${header_files})
+  source_group("Source Files" FILES ${source_files})
+  source_group("Shaders" FILES ${shader_files})
+endif()
diff --git a/plugins/astro/Shaders/SurfaceLIC-Compute.glsl b/plugins/astro/Shaders/SurfaceLIC-Compute.glsl
new file mode 100644
index 000000000..9465efc2a
--- /dev/null
+++ b/plugins/astro/Shaders/SurfaceLIC-Compute.glsl
@@ -0,0 +1,165 @@
+#extension GL_ARB_compute_shader : enable
+
+/* near and far clipping planes */
+uniform float cam_near;
+uniform float cam_far;
+
+/* render target resolution */
+uniform vec2 rt_resolution;
+
+/* world space extents */
+uniform vec3 origin;
+uniform vec3 resolution;
+
+/* noise properties */
+uniform int noise_bands;
+uniform float noise_scale;
+
+/* streamline arc length */
+uniform float arc_length;
+
+/* number of advection steps */
+uniform int num_advections;
+
+/* depth threshold */
+uniform float epsilon;
+
+/* velocity coloring */
+uniform int coloring;
+
+/* maximum velocity magnitude */
+uniform float max_magnitude;
+
+/* input textures */
+uniform highp sampler2D depth_tx2D;
+uniform highp sampler2D velocity_tx2D;
+uniform highp sampler2D position_tx2D;
+uniform highp sampler2D normal_tx2D;
+uniform highp sampler3D noise_tx3D;
+uniform highp sampler1D tf_tx1D;
+
+/* output image */
+layout(rgba32f, binding = 0) writeonly uniform highp image2D render_target;
+
+/* linearize depth value */
+float linearize(float depth) {
+    // Reconstruct clip space coordinates
+    const vec3 clip_pos = vec3(0.0f, 0.0f, depth * 2.0f - 1.0f);
+
+    // Inverse transform to view space
+    vec4 view_pos = inverse(proj_mx) * vec4(clip_pos, 1.0f);
+    view_pos /= view_pos.w;
+
+    return (-view_pos.z - cam_near) / (cam_far - cam_near);
+}
+
+/* get velocity magnitude for selected coloring mode */
+float velocity_magnitude(vec2 screen_pos) {
+    const vec3 velocity = texture(velocity_tx2D, screen_pos).xyz;
+
+    if (coloring == 0) {
+        // Return stored original magnitude
+        return velocity.z;
+    } else if (coloring == 1) {
+        // Return projected magnitude
+        return length(velocity.xy);
+    } else if (coloring == 2) {
+        // Return difference between original and projected magnitude
+        return velocity.z - length(velocity.xy);
+    }
+
+    return 0.0f;
+}
+
+/* blocks for computation */
+layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
+
+void main() {
+    // Get pixel coordinates
+    vec3 gID = gl_GlobalInvocationID.xyz;
+
+    if (gID.x >= rt_resolution.x || gID.y >= rt_resolution.y) return;
+
+    const ivec2 pixel_coords = ivec2(gID.xy);
+    vec2 pixel_tex_coords = pixel_coords / rt_resolution;
+
+    // Check for surface at this pixel
+    vec4 color = vec4(0.0f);
+    float depth = texture(depth_tx2D, pixel_tex_coords).x;
+
+    if (depth >= 0.0f && depth < 1.0f) {
+        // Get position and normal at the current pixel
+        const vec3 normal = texture(normal_tx2D, pixel_tex_coords).xyz;
+        const vec3 coloring = texture(tf_tx1D, velocity_magnitude(pixel_tex_coords) / max_magnitude).xyz;
+        const vec4 world_pos = screen_to_world_space(pixel_tex_coords, depth);
+
+        // Advect and integrate
+        float value = 0.0f;
+        float weight = 0.0f;
+        float last_depth = depth;
+
+        const float step_size = arc_length / num_advections;
+
+        for (int steps = 0; steps < num_advections; ++steps) {
+            // Get screen-space velocity and perform advection
+            vec2 velocity = texture(velocity_tx2D, pixel_tex_coords).xy;
+
+            if (length(velocity) == 0.0f) {
+                break;
+            }
+
+            pixel_tex_coords += step_size * normalize(velocity);
+
+            // Check depth
+            depth = texture(depth_tx2D, pixel_tex_coords).x;
+
+            if (abs(linearize(depth) - linearize(last_depth)) > epsilon) {
+                break;
+            }
+
+            last_depth = depth;
+
+            // Compute noise for the current position
+            const vec4 world_coords = screen_to_world_space(pixel_tex_coords, depth);
+            const vec3 noise_coords = (world_coords.xyz - origin) / resolution;
+
+            const float center_scale_exact = log2(linearize(depth));
+            const float center_scale = ceil(center_scale_exact);
+            const float center_scale_deviation = abs(center_scale_exact - center_scale);
+
+            const int lower_scale = int(center_scale - floor(noise_bands / 2.0f));
+            const int higher_scale = int(center_scale + floor((noise_bands - 1) / 2.0f));
+
+            float noise = 0.0f;
+            float noise_weight = 0.0f;
+
+            for (int i = lower_scale; i <= higher_scale; ++i) {
+                const float alpha = exp(-1.0f / (1.0f - pow((1.0f / (2.0f * (higher_scale - lower_scale))) *
+                                                                (i - center_scale + center_scale_deviation),
+                                                            2.0f)));
+
+                noise += alpha * texture(noise_tx3D, noise_coords * noise_scale * (1.0f / exp2(float(i)))).x;
+                noise_weight += alpha;
+            }
+
+            noise /= noise_weight;
+
+            // Aggregate noise weighted by streamline length
+            const float rbf_weight =
+                exp(-1.0f / (1.0f - pow((1.0f / (2.0f * arc_length)) * (steps * step_size), 2.0f)));
+
+            value += noise * rbf_weight;
+            weight += rbf_weight;
+        }
+
+        value /= weight;
+
+        // Set color
+        const vec3 inv_view_dir = (inverse(view_mx) * vec4(0.0f, 0.0f, 0.0f, 1.0f) - world_pos).xyz;
+        const vec3 light_dir = light - world_pos.xyz;
+
+        color = vec4(phong(value * coloring, normal, inv_view_dir, light_dir), 1.0f);
+    }
+
+    imageStore(render_target, pixel_coords, color);
+}
diff --git a/plugins/astro/Shaders/SurfaceLIC-Functions.glsl b/plugins/astro/Shaders/SurfaceLIC-Functions.glsl
new file mode 100644
index 000000000..4785ffca1
--- /dev/null
+++ b/plugins/astro/Shaders/SurfaceLIC-Functions.glsl
@@ -0,0 +1,15 @@
+/* matrices */
+uniform mat4 view_mx;
+uniform mat4 proj_mx; 
+
+/* transform screen to world space coordinates */
+vec4 screen_to_world_space(vec2 screen_pos, float depth) {
+    // Reconstruct clip space coordinates
+    const vec3 clip_pos = vec3(screen_pos, depth) * 2.0f - vec3(1.0f);
+
+    // Inverse transform to world space
+    vec4 world_pos = inverse(proj_mx * view_mx) * vec4(clip_pos, 1.0f);
+    world_pos /= world_pos.w;
+
+    return world_pos;
+}
diff --git a/plugins/astro/Shaders/SurfaceLIC-Precompute.glsl b/plugins/astro/Shaders/SurfaceLIC-Precompute.glsl
new file mode 100644
index 000000000..478808929
--- /dev/null
+++ b/plugins/astro/Shaders/SurfaceLIC-Precompute.glsl
@@ -0,0 +1,52 @@
+#extension GL_ARB_compute_shader : enable
+
+/* render target resolution */
+uniform vec2 rt_resolution;
+
+/* world space extents */
+uniform vec3 origin;
+uniform vec3 resolution;
+
+/* input textures */
+uniform highp sampler2D depth_tx2D;
+uniform highp sampler2D normal_tx2D;
+uniform highp sampler3D velocity_tx3D;
+
+/* output image */
+layout(rgba32f, binding = 0) writeonly uniform highp image2D velocity_target;
+
+/* blocks for computation */
+layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
+
+void main() {
+    // Get pixel coordinates
+    vec3 gID = gl_GlobalInvocationID.xyz;
+
+    if (gID.x >= rt_resolution.x || gID.y >= rt_resolution.y) return;
+
+    const ivec2 pixel_coords = ivec2(gID.xy);
+    vec2 pixel_tex_coords = pixel_coords / rt_resolution;
+
+    // Check for surface at this pixel
+    vec3 velocity = vec3(0.0f);
+    float magnitude = 0.0f;
+
+    const float depth = texture(depth_tx2D, pixel_tex_coords).x;
+    const vec3 normal = texture(normal_tx2D, pixel_tex_coords).xyz;
+
+    if (depth >= 0.0f && depth < 1.0f) {
+        // Get position in world space
+        const vec4 world_pos = screen_to_world_space(pixel_tex_coords, depth);
+
+        // Get velocity
+        velocity = texture(velocity_tx3D, (world_pos.xyz - origin) / resolution).xyz;
+
+        magnitude = length(velocity);
+
+        // Project velocity onto the surface
+        velocity -= dot(velocity, normal) * normal;
+        velocity = ((proj_mx * view_mx) * vec4(velocity, 0.0f)).xyz;
+    }
+
+    imageStore(velocity_target, pixel_coords, vec4(velocity.xy, magnitude, 1.0f));
+}
diff --git a/plugins/astro/Shaders/SurfaceLICRenderer.btf b/plugins/astro/Shaders/SurfaceLICRenderer.btf
new file mode 100644
index 000000000..a4193aed1
--- /dev/null
+++ b/plugins/astro/Shaders/SurfaceLICRenderer.btf
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="utf-8"?>
+<btf type="MegaMolGLSLShader" version="1.0" namespace="SurfaceLICRenderer">
+    <shader name="precompute">
+        <snippet type="version">430</snippet>
+        <snippet type="file">SurfaceLIC-Functions.glsl</snippet>
+        <snippet type="file">SurfaceLIC-Precompute.glsl</snippet>
+    </shader>
+
+    <shader name="compute">
+        <snippet type="version">430</snippet>
+        <snippet type="file">phong.glsl</snippet>
+        <snippet type="file">SurfaceLIC-Functions.glsl</snippet>
+        <snippet type="file">SurfaceLIC-Compute.glsl</snippet>
+    </shader>
+</btf>
diff --git a/plugins/astro/include/astro/AstroDataCall.h b/plugins/astro/include/astro/AstroDataCall.h
new file mode 100644
index 000000000..adc593f24
--- /dev/null
+++ b/plugins/astro/include/astro/AstroDataCall.h
@@ -0,0 +1,575 @@
+/*
+ * AstroDataCall.h
+ *
+ * Copyright (C) 2019 by Universitaet Stuttgart (VISUS).
+ * Alle Rechte vorbehalten.
+ */
+
+#ifndef MEGAMOLCORE_ASTRODATACALL_H_INCLUDED
+#define MEGAMOLCORE_ASTRODATACALL_H_INCLUDED
+#if (defined(_MSC_VER) && (_MSC_VER > 1000))
+#    pragma once
+#endif /* (defined(_MSC_VER) && (_MSC_VER > 1000)) */
+
+#include <glm/glm.hpp>
+#include <memory>
+#include "astro/astro.h"
+#include "mmcore/AbstractGetData3DCall.h"
+#include "mmcore/factories/CallAutoDescription.h"
+#include "vislib/math/Cuboid.h"
+
+namespace megamol {
+namespace astro {
+
+typedef std::shared_ptr<std::vector<glm::vec3>> vec3ArrayPtr;
+typedef std::shared_ptr<std::vector<float>> floatArrayPtr;
+typedef std::shared_ptr<std::vector<bool>> boolArrayPtr;
+typedef std::shared_ptr<std::vector<int64_t>> idArrayPtr;
+
+class ASTRO_API AstroDataCall : public core::AbstractGetData3DCall {
+public:
+    /**
+     * Answer the name of the objects of this description.
+     *
+     * @return The name of the objects of this description.
+     */
+    static const char* ClassName(void) { return "AstroDataCall"; }
+
+
+    /**
+     * Gets a human readable description of the module.
+     *
+     * @return A human readable description of the module.
+     */
+    static const char* Description(void) { return "Call to get astronomical particle data."; }
+
+    /** Index of the 'GetData' function */
+    static const unsigned int CallForGetData;
+
+    /** Index of the 'GetExtent' function */
+    static const unsigned int CallForGetExtent;
+
+    /** Ctor. */
+    AstroDataCall(void);
+
+    /** Dtor. */
+    virtual ~AstroDataCall(void);
+
+    /**
+     * Answer the number of functions used for this call.
+     *
+     * @return The number of functions used for this call.
+     */
+    static unsigned int FunctionCount(void) { return 2; }
+
+    /**
+     * Answer the name of the function used for this call.
+     *
+     * @param idx The index of the function to return it's name.
+     *
+     * @return The name of the requested function.
+     */
+    static const char* FunctionName(unsigned int idx) {
+        switch (idx) {
+        case 0:
+            return "getData";
+        case 1:
+            return "getExtent";
+        }
+        return "";
+    }
+
+    /**
+     * Sets the position vector
+     *
+     * @param positionVec Pointer to the new position vector to be set
+     */
+    inline void SetPositions(vec3ArrayPtr& positionVec) { this->positions = positionVec; }
+
+    /**
+     * Retrieve the pointer to the vector storing the positions
+     *
+     * @return Pointer to the position array
+     */
+    inline const vec3ArrayPtr GetPositions(void) const { return this->positions; }
+
+    /**
+     * Sets the velocity vector
+     *
+     * @param velocityVec Pointer to the new velocity vector to be set
+     */
+    inline void SetVelocities(vec3ArrayPtr& velocityVec) { this->velocities = velocityVec; }
+
+    /**
+     * Retrieve the pointer to the vector storing the velocities
+     *
+     * @return Pointer to the velocity array
+     */
+    inline const vec3ArrayPtr GetVelocities(void) const { return this->velocities; }
+
+    /**
+     * Sets the velocity derivative vector
+     *
+     * @param derivatives Pointer to the new velocity derivative vector to be set
+     */
+    inline void SetVelocityDerivatives(vec3ArrayPtr& derivatives) { this->velocityDerivatives = derivatives; }
+
+    /**
+     * Retrieve the pointer to the vector storing the velocity derivatives
+     *
+     * @return Pointer to the velocity derivative array
+     */
+    inline const vec3ArrayPtr GetVelocityDerivatives(void) const { return this->velocityDerivatives; }
+
+    /**
+     * Sets the temperature vector
+     *
+     * @param temparatureVec Pointer to the new temperature vector to be set
+     */
+    inline void SetTemperature(floatArrayPtr& temparatureVec) { this->temperatures = temparatureVec; }
+
+    /**
+     * Retrieve the pointer to the vector storing the temperature
+     *
+     * @return Pointer to the temperature array
+     */
+    inline const floatArrayPtr GetTemperature(void) const { return this->temperatures; }
+
+    /**
+     * Sets the temperature derivative vector
+     *
+     * @param derivatives Pointer to the new temperature derivative vector to be set
+     */
+    inline void SetTemperatureDerivatives(floatArrayPtr& derivatives) { this->temperatureDerivatives = derivatives; }
+
+    /**
+     * Retrieve the pointer to the vector storing the temperature derivatives
+     *
+     * @return Pointer to the temperature derivative array
+     */
+    inline const floatArrayPtr GetTemperatureDerivatives(void) const { return this->temperatureDerivatives; }
+
+    /**
+     * Sets the mass vector
+     *
+     * @param massVec Pointer to the new mass vector to be set
+     */
+    inline void SetMass(floatArrayPtr& massVec) { this->masses = massVec; }
+
+    /**
+     * Retrieve the pointer to the vector storing the mass
+     *
+     * @return Pointer to the mass array
+     */
+    inline const floatArrayPtr GetMass(void) const { return this->masses; }
+
+    /**
+     * Sets the internal energy vector
+     *
+     * @param internalEnergyVec Pointer to the new internal energy vector to be set
+     */
+    inline void SetInternalEnergy(floatArrayPtr& internalEnergyVec) { this->internalEnergies = internalEnergyVec; }
+
+    /**
+     * Retrieve the pointer to the vector storing the internal energy
+     *
+     * @return Pointer to the internal energy array
+     */
+    inline const floatArrayPtr GetInternalEnergy(void) const { return this->internalEnergies; }
+
+    /**
+     * Sets the internal energy derivative vector
+     *
+     * @param derivative Pointer to the new internal energy derivative vector to be set
+     */
+    inline void SetInternalEnergyDerivatives(floatArrayPtr& derivative) {
+        this->internalEnergyDerivatives = derivative;
+    }
+
+    /**
+     * Retrieve the pointer to the vector storing the internal energy derivatives
+     *
+     * @return Pointer to the internal energy derivative array
+     */
+    inline const floatArrayPtr GetInternalEnergyDerivatives(void) const { return this->internalEnergyDerivatives; }
+
+    /**
+     * Sets the smoothing length vector
+     *
+     * @param smoothingLengthVec Pointer to the new smoothing length vector to be set
+     */
+    inline void SetSmoothingLength(floatArrayPtr& smoothingLengthVec) { this->smoothingLengths = smoothingLengthVec; }
+
+    /**
+     * Retrieve the pointer to the vector storing the smoothing length
+     *
+     * @return Pointer to the smoothing length array
+     */
+    inline const floatArrayPtr GetSmoothingLength(void) const { return this->smoothingLengths; }
+
+    /**
+     * Sets the smoothing length derivative vector
+     *
+     * @param derivative Pointer to the new smoothing length derivative vector to be set
+     */
+    inline void SetSmoothingLengthDerivatives(floatArrayPtr& derivative) {
+        this->smoothingLengthDerivatives = derivative;
+    }
+
+    /**
+     * Retrieve the pointer to the vector storing the smoothing length
+     *
+     * @return Pointer to the smoothing length array
+     */
+    inline const floatArrayPtr GetSmoothingLengthDerivatives(void) const { return this->smoothingLengthDerivatives; }
+
+    /**
+     * Sets the molecular weight vector
+     *
+     * @param molecularWeightVec Pointer to the new molecular weight vector to be set
+     */
+    inline void SetMolecularWeights(floatArrayPtr& molecularWeightVec) { this->molecularWeights = molecularWeightVec; }
+
+    /**
+     * Retrieve the pointer to the vector storing the molecular weight
+     *
+     * @return Pointer to the molecular weight array
+     */
+    inline const floatArrayPtr GetMolecularWeights(void) const { return this->molecularWeights; }
+
+    /**
+     * Sets the molecular weight derivative vector
+     *
+     * @param derivative Pointer to the new molecular weight derivative vector to be set
+     */
+    inline void SetMolecularWeightDerivatives(floatArrayPtr& derivative) {
+        this->molecularWeightDerivatives = derivative;
+    }
+
+    /**
+     * Retrieve the pointer to the vector storing the molecular weight derivative
+     *
+     * @return Pointer to the molecular weight derivative array
+     */
+    inline const floatArrayPtr GetMolecularWeightDerivatives(void) const { return this->molecularWeightDerivatives; }
+
+    /**
+     * Sets the density vector
+     *
+     * @param densityVec Pointer to the new density vector to be set
+     */
+    inline void SetDensity(floatArrayPtr& densityVec) { this->densities = densityVec; }
+
+    /**
+     * Retrieve the pointer to the vector storing the density
+     *
+     * @return Pointer to the density array
+     */
+    inline const floatArrayPtr GetDensity(void) const { return this->densities; }
+
+    /**
+     * Sets the density derivative vector
+     *
+     * @param derivative Pointer to the new density derivative vector to be set
+     */
+    inline void SetDensityDerivative(floatArrayPtr& derivative) { this->densityDerivatives = derivative; }
+
+    /**
+     * Retrieve the pointer to the vector storing the density derivative
+     *
+     * @return Pointer to the density derivative array
+     */
+    inline const floatArrayPtr GetDensityDerivative(void) const { return this->densityDerivatives; }
+
+    /**
+     * Sets the gravitational potential vector
+     *
+     * @param gravitationalPotentialVec Pointer to the new gravitational potential vector to be set
+     */
+    inline void SetGravitationalPotential(floatArrayPtr& gravitationalPotentialVec) {
+        this->gravitationalPotentials = gravitationalPotentialVec;
+    }
+
+    /**
+     * Retrieve the pointer to the vector storing the gravitational potential
+     *
+     * @return Pointer to the gravitational potential array
+     */
+    inline const floatArrayPtr GetGravitationalPotential(void) const { return this->gravitationalPotentials; }
+
+    /**
+     * Sets the gravitational potential derivative vector
+     *
+     * @param derivative Pointer to the new gravitational potential derivative vector to be set
+     */
+    inline void SetGravitationalPotentialDerivatives(floatArrayPtr& derivative) {
+        this->gravitationalPotentialDerivatives = derivative;
+    }
+
+    /**
+     * Retrieve the pointer to the vector storing the gravitational potential derivatives
+     *
+     * @return Pointer to the gravitational potential derivative array
+     */
+    inline const floatArrayPtr GetGravitationalPotentialDerivatives(void) const {
+        return this->gravitationalPotentialDerivatives;
+    }
+
+    /**
+     * Sets the entropy vector
+     *
+     * @param entropyVec Pointer to the new entropy vector to be set
+     */
+    inline void SetEntropy(floatArrayPtr& entropyVec) { this->entropies = entropyVec; }
+
+    /**
+     * Retrieve the pointer to the vector storing the entropy
+     *
+     * @return Pointer to the entropy array
+     */
+    inline const floatArrayPtr GetEntropy(void) const { return this->entropies; }
+
+    /**
+     * Sets the entropy derivative vector
+     *
+     * @param derivative Pointer to the new entropy derivative vector to be set
+     */
+    inline void SetEntropyDerivatives(floatArrayPtr& derivative) { this->entropyDerivatives = derivative; }
+
+    /**
+     * Retrieve the pointer to the vector storing the entropy derivatives
+     *
+     * @return Pointer to the entropy derivative array
+     */
+    inline const floatArrayPtr GetEntropyDerivatives(void) const { return this->entropyDerivatives; }
+
+    /**
+     * Sets the baryon flag vector
+     *
+     * @param isBaryonVec Pointer to the new baryon flag vector to be set
+     */
+    inline void SetIsBaryonFlags(boolArrayPtr& isBaryonVec) { this->isBaryonFlags = isBaryonVec; }
+
+    /**
+     * Retrieve the pointer to the vector storing the baryon flags
+     * The content is true if the respecting particle is a baryon particle. It will contain 'false' if the particle is
+     * dark matter.
+     *
+     * @return Pointer to the baryon flag array
+     */
+    inline const boolArrayPtr GetIsBaryonFlags(void) const { return this->isBaryonFlags; }
+
+    /**
+     * Sets the star flag vector
+     *
+     * @param isStarVec Pointer to the new star flag vector to be set
+     */
+    inline void SetIsStarFlags(boolArrayPtr& isStarVec) { this->isStarFlags = isStarVec; }
+
+    /**
+     * Retrieve the pointer to the vector storing the star flags
+     *
+     * @return Pointer to the star flag array
+     */
+    inline const boolArrayPtr GetIsStarFlags(void) const { return this->isStarFlags; }
+
+    /**
+     * Sets the wind flag vector
+     *
+     * @param isWindVec Pointer to the new wind flag vector to be set
+     */
+    inline void SetIsWindFlags(boolArrayPtr& isWindVec) { this->isWindFlags = isWindVec; }
+
+    /**
+     * Retrieve the pointer to the vector storing the wind flags
+     *
+     * @return Pointer to the wind flag array
+     */
+    inline const boolArrayPtr GetIsWindFlags(void) const { return this->isWindFlags; }
+
+    /**
+     * Sets the star forming gas flag vector
+     *
+     * @param isWindVec Pointer to the new star forming gas flag vector to be set
+     */
+    inline void SetIsStarFormingGasFlags(boolArrayPtr& isStarFormingGasVec) {
+        this->isStarFormingGasFlags = isStarFormingGasVec;
+    }
+
+    /**
+     * Retrieve the pointer to the vector storing the star forming gas flags
+     *
+     * @return Pointer to the star forming gas flag array
+     */
+    inline const boolArrayPtr GetIsStarFormingGasFlags(void) const { return this->isStarFormingGasFlags; }
+
+    /**
+     * Sets the AGN flag vector
+     *
+     * @param isWindVec Pointer to the new AGN flag vector to be set
+     */
+    inline void SetIsAGNFlags(boolArrayPtr& isAGNVec) { this->isAGNFlags = isAGNVec; }
+
+    /**
+     * Retrieve the pointer to the vector storing the AGN flags
+     *
+     * @return Pointer to the AGN flag array
+     */
+    inline const boolArrayPtr GetIsAGNFlags(void) const { return this->isAGNFlags; }
+
+    /**
+     * Sets the particle ID vector
+     *
+     * @param particleIDVec Pointer to the new particle ID vector to be set
+     */
+    inline void SetParticleIDs(idArrayPtr& particleIDVec) { this->particleIDs = particleIDVec; }
+
+    /**
+     * Retrieve the pointer to the vector storing the particle IDs
+     *
+     * @return Pointer to the particle ID array
+     */
+    inline const idArrayPtr GetParticleIDs(void) const { return this->particleIDs; }
+
+    /**
+     * Sets the AGN distance vector
+     *
+     * @param agnDistances Pointer to the new agn distance vector to be set
+     */
+    inline void SetAGNDistances(floatArrayPtr& agnDistances) { this->agnDistances = agnDistances; }
+
+    /**
+     * Retrieve the pointer to the vector storing the AGN distances
+     *
+     * @return Pointer to the agn distance array
+     */
+    inline const floatArrayPtr GetAgnDistances(void) const { return this->agnDistances; }
+
+    /**
+     * Retrieve the number of particles stored in this call.
+     * This will only result in a value greater 0 if the positions array is set.
+     * All other arrays may be unset.
+     *
+     * @return The numbers of particles stored
+     */
+    inline size_t GetParticleCount(void) const {
+        if (positions == nullptr) return 0;
+        return positions->size();
+    }
+
+    /**
+     * Clears all of the stored values for a clean start.
+     */
+    inline void ClearValues(void) {
+        this->positions.reset();
+        this->velocities.reset();
+        this->temperatures.reset();
+        this->masses.reset();
+        this->internalEnergies.reset();
+        this->smoothingLengths.reset();
+        this->molecularWeights.reset();
+        this->densities.reset();
+        this->gravitationalPotentials.reset();
+        this->entropies.reset();
+        this->isBaryonFlags.reset();
+        this->isStarFlags.reset();
+        this->isWindFlags.reset();
+        this->isStarFormingGasFlags.reset();
+        this->isAGNFlags.reset();
+        this->particleIDs.reset();
+        this->agnDistances.reset();
+
+        this->velocityDerivatives.reset();
+        this->temperatureDerivatives.reset();
+        this->internalEnergyDerivatives.reset();
+        this->smoothingLengthDerivatives.reset();
+        this->molecularWeightDerivatives.reset();
+        this->densityDerivatives.reset();
+        this->gravitationalPotentialDerivatives.reset();
+        this->entropyDerivatives.reset();
+    }
+
+private:
+    /** Pointer to the position array */
+    vec3ArrayPtr positions;
+
+    /** Pointer to the velocity array */
+    vec3ArrayPtr velocities;
+
+    /** Pointer to the array containing the velocity derivatives */
+    vec3ArrayPtr velocityDerivatives;
+
+    /** Pointer to the temperature array */
+    floatArrayPtr temperatures;
+
+    /** Pointer to the array containing the temperature derivatives */
+    floatArrayPtr temperatureDerivatives;
+
+    /** Pointer to the mass array */
+    floatArrayPtr masses;
+
+    /** Pointer to the interal energy array */
+    floatArrayPtr internalEnergies;
+
+    /** Pointer to the array containing the internal energy derivatives */
+    floatArrayPtr internalEnergyDerivatives;
+
+    /** Pointer to the smoothing length array */
+    floatArrayPtr smoothingLengths;
+
+    /** Pointer to the array containing the smoothing length derivatives */
+    floatArrayPtr smoothingLengthDerivatives;
+
+    /** Pointer to the molecular weight array */
+    floatArrayPtr molecularWeights;
+
+    /** Pointer to the array containing the molecular weight derivatives */
+    floatArrayPtr molecularWeightDerivatives;
+
+    /** Pointer to the density array */
+    floatArrayPtr densities;
+
+    /** Pointer to the array containing the density derivatives */
+    floatArrayPtr densityDerivatives;
+
+    /** Pointer to the gravitational potential array */
+    floatArrayPtr gravitationalPotentials;
+
+    /** Pointer to the array containing the gravitational potential derivatives */
+    floatArrayPtr gravitationalPotentialDerivatives;
+
+    /** Pointer to the entropy array */
+    floatArrayPtr entropies;
+
+    /** Pointer to the array containing the entropy derivatives */
+    floatArrayPtr entropyDerivatives;
+
+    /** Pointer to the baryon flag array */
+    boolArrayPtr isBaryonFlags;
+
+    /** Pointer to the star flag array */
+    boolArrayPtr isStarFlags;
+
+    /** Pointer to the wind flag array */
+    boolArrayPtr isWindFlags;
+
+    /** Pointer to the star forming gas flag array */
+    boolArrayPtr isStarFormingGasFlags;
+
+    /** Pointer to the AGN flag array */
+    boolArrayPtr isAGNFlags;
+
+    /** Pointer to the particle ID array */
+    idArrayPtr particleIDs;
+
+    /** Pointer to the array storing the distance to the AGNs */
+    floatArrayPtr agnDistances;
+};
+
+/** Description class typedef */
+typedef megamol::core::factories::CallAutoDescription<AstroDataCall> AstroDataCallDescription;
+
+} // namespace astro
+} // namespace megamol
+
+#endif
diff --git a/plugins/astro/include/astro/astro.h b/plugins/astro/include/astro/astro.h
new file mode 100644
index 000000000..a40c774d0
--- /dev/null
+++ b/plugins/astro/include/astro/astro.h
@@ -0,0 +1,97 @@
+/*
+ * astro.h
+ * Copyright (C) 2009-2019 by MegaMol Team
+ * Alle Rechte vorbehalten.
+ */
+#ifndef ASTRO_H_INCLUDED
+#define ASTRO_H_INCLUDED
+#if (defined(_MSC_VER) && (_MSC_VER > 1000))
+#pragma once
+#endif /* (defined(_MSC_VER) && (_MSC_VER > 1000)) */
+
+
+#ifdef _WIN32
+// The following ifdef block is the standard way of creating macros which make exporting 
+// from a DLL simpler. All files within this DLL are compiled with the TRISOUPPLUGIN_EXPORTS
+// symbol defined on the command line. this symbol should not be defined on any project
+// that uses this DLL. This way any other project whose source files include this file see 
+// TRISOUPPLUGIN_API functions as being imported from a DLL, whereas this DLL sees symbols
+// defined with this macro as being exported.
+#ifdef ASTRO_EXPORTS
+#define ASTRO_API __declspec(dllexport)
+#else
+#define ASTRO_API __declspec(dllimport)
+#endif
+#else /* _WIN32 */
+#define ASTRO_API
+#endif /* _WIN32 */
+
+#include "mmcore/utility/plugins/Plugin200Instance.h"
+
+#ifdef ASTRO_EXPORTS
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Returns the version of the MegaMol plugin api used by this plugin.
+ *
+ * @return 200 -- (ver.: 2.00)
+ */
+ASTRO_API int mmplgPluginAPIVersion(void);
+
+/**
+ * Provides compatibility information
+ *
+ * @param onError Callback function pointer used when an error occures
+ *
+ * @return The compatibility information struct, or nullptr in case of an
+ *         error.
+ *
+ * @remarks Always use 'mmplgReleasePluginCompatibilityInfo' to release the
+ *          memory of the returned struct.
+ */
+ASTRO_API
+::megamol::core::utility::plugins::PluginCompatibilityInfo *
+mmplgGetPluginCompatibilityInfo(
+    ::megamol::core::utility::plugins::ErrorCallback onError);
+
+/**
+ * Releases the memory of a compatibility information struct previously
+ * returned by 'mmplgGetPluginCompatibilityInfo'
+ *
+ * @param ci The compatibility information struct to be released
+ */
+ASTRO_API void mmplgReleasePluginCompatibilityInfo(
+    ::megamol::core::utility::plugins::PluginCompatibilityInfo* ci);
+
+/**
+ * Creates a new instance of this plugin
+ *
+ * @param onError Callback function pointer used when an error occures
+ *
+ * @return A new instance of this plugin, or nullptr in case of an error
+ *
+ * @remarks Always use 'mmplgReleasePluginInstance' to release the memory of
+ *          the returned object.
+ */
+ASTRO_API
+::megamol::core::utility::plugins::AbstractPluginInstance*
+mmplgGetPluginInstance
+    (::megamol::core::utility::plugins::ErrorCallback onError);
+
+/**
+ * Releases the memory of the plugin instance previously returned by
+ * 'mmplgGetPluginInstance'
+ *
+ * @param pi The plugin instance to be released
+ */
+ASTRO_API void mmplgReleasePluginInstance(
+    ::megamol::core::utility::plugins::AbstractPluginInstance* pi);
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+#endif
+
+#endif /* ASTRO_H_INCLUDED */
diff --git a/plugins/astro/src/AstroDataCall.cpp b/plugins/astro/src/AstroDataCall.cpp
new file mode 100644
index 000000000..c781d95f6
--- /dev/null
+++ b/plugins/astro/src/AstroDataCall.cpp
@@ -0,0 +1,35 @@
+/*
+ * AstroDataCall.cpp
+ *
+ * Copyright (C) 2019 by Universitaet Stuttgart (VISUS).
+ * Alle Rechte vorbehalten.
+ */
+
+#include "stdafx.h"
+#include "astro/AstroDataCall.h"
+
+using namespace megamol::astro;
+
+/*
+ * AstroDataCall::CallForGetData
+ */
+const unsigned int AstroDataCall::CallForGetData = 0;
+
+/*
+ * AstroDataCall::CallForGetExtent
+ */
+const unsigned int AstroDataCall::CallForGetExtent = 1;
+
+/*
+ * AstroDataCall::AstroDataCall
+ */
+AstroDataCall::AstroDataCall(void) {
+    // intentionally empty
+}
+
+/*
+ * AstroDataCall::~AstroDataCall
+ */
+AstroDataCall::~AstroDataCall(void) {
+    // intentionally empty
+}
diff --git a/plugins/astro/src/AstroParticleConverter.cpp b/plugins/astro/src/AstroParticleConverter.cpp
new file mode 100644
index 000000000..09ab512cb
--- /dev/null
+++ b/plugins/astro/src/AstroParticleConverter.cpp
@@ -0,0 +1,599 @@
+/*
+ * AstroParticleConverter.cpp
+ *
+ * Copyright (C) 2019 by VISUS (Universitaet Stuttgart)
+ * All rights reserved.
+ */
+
+#include "stdafx.h"
+#include "AstroParticleConverter.h"
+#include <glm/gtc/type_ptr.hpp>
+
+#include "simultaneous_sort.h"
+
+using namespace megamol;
+using namespace megamol::astro;
+using namespace megamol::core;
+using namespace megamol::core::moldyn;
+
+/*
+ * AstroParticleConverter::AstroParticleConverter
+ */
+AstroParticleConverter::AstroParticleConverter(void)
+    : Module()
+    , sphereDataSlot("sphereData", "Output slot for the resulting sphere data")
+    , sphereSpecialSlot(
+          "formattedSphereData", "Output slot for the sphere data containing density and velocity informaton")
+    , astroDataSlot("astroData", "Input slot for astronomical data")
+    , colorModeSlot("colorMode", "Coloring mode for the output particles")
+    , minColorSlot("minColor", "minimum color of the used range")
+    , midColorSlot("midColor", "median color of the used range")
+    , maxColorSlot("maxColor", "maximum color of the used range")
+    , useMidColorSlot("useMidColor", "Enables the usage of the mid color in the color interpolation")
+    , minValueSlot("minValue", "minimum value of the currently shown parameter")
+    , maxValueSlot("maxValue", "maximum value of the currently shown parameter")
+    , lastDataHash(0)
+    , hashOffset(0)
+    , valmin(0.0f)
+    , valmax(1.0f)
+    , densityMin(0.0f)
+    , densityMax(0.0f) {
+
+    this->astroDataSlot.SetCompatibleCall<AstroDataCallDescription>();
+    this->MakeSlotAvailable(&this->astroDataSlot);
+
+    this->sphereDataSlot.SetCallback(
+        MultiParticleDataCall::ClassName(), MultiParticleDataCall::FunctionName(0), &AstroParticleConverter::getData);
+    this->sphereDataSlot.SetCallback(
+        MultiParticleDataCall::ClassName(), MultiParticleDataCall::FunctionName(1), &AstroParticleConverter::getExtent);
+    this->MakeSlotAvailable(&this->sphereDataSlot);
+
+    this->sphereSpecialSlot.SetCallback(MultiParticleDataCall::ClassName(), MultiParticleDataCall::FunctionName(0),
+        &AstroParticleConverter::getSpecialData);
+    this->sphereSpecialSlot.SetCallback(
+        MultiParticleDataCall::ClassName(), MultiParticleDataCall::FunctionName(1), &AstroParticleConverter::getExtent);
+    this->MakeSlotAvailable(&this->sphereSpecialSlot);
+
+    param::EnumParam* enu = new param::EnumParam(static_cast<int>(ColoringMode::GRAVITATIONAL_POTENTIAL));
+    enu->SetTypePair(static_cast<int>(ColoringMode::MASS), "Mass");
+    enu->SetTypePair(static_cast<int>(ColoringMode::INTERNAL_ENERGY), "Internal Energy");
+    enu->SetTypePair(static_cast<int>(ColoringMode::SMOOTHING_LENGTH), "Smoothing Length");
+    enu->SetTypePair(static_cast<int>(ColoringMode::MOLECULAR_WEIGHT), "Molecular Weight");
+    enu->SetTypePair(static_cast<int>(ColoringMode::DENSITY), "Density");
+    enu->SetTypePair(static_cast<int>(ColoringMode::GRAVITATIONAL_POTENTIAL), "Gravitational Potential");
+    enu->SetTypePair(static_cast<int>(ColoringMode::IS_BARYON), "Baryon");
+    enu->SetTypePair(static_cast<int>(ColoringMode::IS_STAR), "Star");
+    enu->SetTypePair(static_cast<int>(ColoringMode::IS_WIND), "Wind");
+    enu->SetTypePair(static_cast<int>(ColoringMode::IS_STAR_FORMING_GAS), "Star-forming Gas");
+    enu->SetTypePair(static_cast<int>(ColoringMode::IS_AGN), "AGN");
+    enu->SetTypePair(static_cast<int>(ColoringMode::IS_DARK_MATTER), "Dark Matter");
+    enu->SetTypePair(static_cast<int>(ColoringMode::TEMPERATURE), "Temperature");
+    enu->SetTypePair(static_cast<int>(ColoringMode::ENTROPY), "Entropy");
+    enu->SetTypePair(static_cast<int>(ColoringMode::INTERNAL_ENERGY_DERIVATIVE), "Internal Energy Derivative");
+    enu->SetTypePair(static_cast<int>(ColoringMode::SMOOTHING_LENGTH_DERIVATIVE), "Smoothing Length Derivative");
+    enu->SetTypePair(static_cast<int>(ColoringMode::MOLECULAR_WEIGHT_DERIVATIVE), "Molecular Weight Derivative");
+    enu->SetTypePair(static_cast<int>(ColoringMode::DENSITY_DERIVATIVE), "Density Derivative");
+    enu->SetTypePair(
+        static_cast<int>(ColoringMode::GRAVITATIONAL_POTENTIAL_DERIVATIVE), "Gravitational Potential Derivative");
+    enu->SetTypePair(static_cast<int>(ColoringMode::TEMPERATURE_DERIVATIVE), "Temperature Derivative");
+    enu->SetTypePair(static_cast<int>(ColoringMode::ENTROPY_DERIVATIVE), "Entropy Derivative");
+    enu->SetTypePair(static_cast<int>(ColoringMode::AGN_DISTANCES), "AGN Distances");
+    this->colorModeSlot << enu;
+    this->MakeSlotAvailable(&this->colorModeSlot);
+
+    this->minColorSlot.SetParameter(new param::ColorParam("#146496"));
+    this->MakeSlotAvailable(&this->minColorSlot);
+
+    this->midColorSlot.SetParameter(new param::ColorParam("#f0f0f0"));
+    this->MakeSlotAvailable(&this->midColorSlot);
+
+    this->maxColorSlot.SetParameter(new param::ColorParam("#ae3b32"));
+    this->MakeSlotAvailable(&this->maxColorSlot);
+
+    this->useMidColorSlot.SetParameter(new param::BoolParam(true));
+    this->MakeSlotAvailable(&this->useMidColorSlot);
+
+    auto minPar = new param::FloatParam(0.0f);
+    minPar->SetGUIReadOnly(true);
+    this->minValueSlot.SetParameter(minPar);
+    this->MakeSlotAvailable(&this->minValueSlot);
+
+    auto maxPar = new param::FloatParam(0.0f);
+    maxPar->SetGUIReadOnly(true);
+    this->maxValueSlot.SetParameter(maxPar);
+    this->MakeSlotAvailable(&this->maxValueSlot);
+}
+
+/*
+ * AstroParticleConverter::~AstroParticleConverter
+ */
+AstroParticleConverter::~AstroParticleConverter(void) { this->Release(); }
+
+/*
+ * AstroParticleConverter::create
+ */
+bool AstroParticleConverter::create(void) {
+    // intentionally empty
+    return true;
+}
+
+/*
+ * AstroParticleConverter::release
+ */
+void AstroParticleConverter::release(void) {
+    // intentionally empty
+}
+
+/*
+ * AstroParticleConverter::getData
+ */
+bool AstroParticleConverter::getData(Call& call) {
+    MultiParticleDataCall* mpdc = dynamic_cast<MultiParticleDataCall*>(&call);
+    if (mpdc == nullptr) return false;
+
+    AstroDataCall* ast = this->astroDataSlot.CallAs<AstroDataCall>();
+    if (ast == nullptr) return false;
+
+    ast->SetFrameID(mpdc->FrameID(), mpdc->IsFrameForced());
+    // ast->SetUnlocker(nullptr, false);
+
+    if ((*ast)(AstroDataCall::CallForGetData)) {
+        bool freshMinMax = false;
+        if (this->lastDataHash != ast->DataHash() || this->colorModeSlot.IsDirty() ||
+            this->lastFrame != mpdc->FrameID()) {
+            this->lastFrame = mpdc->FrameID();
+            this->lastDataHash = ast->DataHash();
+            this->colorModeSlot.ResetDirty();
+            this->calcMinMaxValues(*ast);
+            freshMinMax = true;
+        }
+        auto particleCount = ast->GetParticleCount();
+        mpdc->SetDataHash(this->lastDataHash + this->hashOffset);
+        mpdc->SetParticleListCount(1);
+        MultiParticleDataCall::Particles& p = mpdc->AccessParticles(0);
+        p.SetCount(particleCount);
+        if (p.GetCount() > 0) {
+            p.SetVertexData(MultiParticleDataCall::Particles::VERTDATA_FLOAT_XYZ, ast->GetPositions()->data());
+            if (freshMinMax || this->minColorSlot.IsDirty() || this->midColorSlot.IsDirty() ||
+                this->maxColorSlot.IsDirty() || this->useMidColorSlot.IsDirty()) {
+                this->calcColorTable(*ast);
+                this->minColorSlot.ResetDirty();
+                this->midColorSlot.ResetDirty();
+                this->maxColorSlot.ResetDirty();
+                this->useMidColorSlot.ResetDirty();
+            }
+            p.SetColourData(MultiParticleDataCall::Particles::COLDATA_FLOAT_RGBA, this->usedColors.data());
+            p.SetColourMapIndexValues(this->valmin, this->valmax);
+            p.SetDirData(SimpleSphericalParticles::DirDataType::DIRDATA_FLOAT_XYZ, ast->GetVelocities()->data());
+        }
+        // ast->Unlock();
+        return true;
+    }
+    ast->Unlock();
+    return false;
+}
+
+/*
+ * AstroParticleConverter::getSpecialData
+ */
+bool AstroParticleConverter::getSpecialData(Call& call) {
+    MultiParticleDataCall* mpdc = dynamic_cast<MultiParticleDataCall*>(&call);
+    if (mpdc == nullptr) return false;
+
+    AstroDataCall* ast = this->astroDataSlot.CallAs<AstroDataCall>();
+    if (ast == nullptr) return false;
+
+    ast->SetFrameID(mpdc->FrameID(), mpdc->IsFrameForced());
+    // ast->SetUnlocker(nullptr, false);
+
+    if ((*ast)(AstroDataCall::CallForGetData)) {
+        bool freshMinMax = false;
+        if (this->lastDataHash != ast->DataHash() || this->colorModeSlot.IsDirty() ||
+            this->lastFrame != mpdc->FrameID()) {
+            this->lastFrame = mpdc->FrameID();
+            this->lastDataHash = ast->DataHash();
+            this->colorModeSlot.ResetDirty();
+            this->calcMinMaxValues(*ast);
+            freshMinMax = true;
+        }
+
+        auto particleCount = ast->GetParticleCount();
+        auto positions = *ast->GetPositions().get();
+        vel_ = *ast->GetVelocities().get();
+        dens_ = *ast->GetDensity().get();
+        sl_ = *ast->GetSmoothingLength().get();
+        temp_ = *ast->GetTemperature().get();
+        mass_ = *ast->GetMass().get();
+        mw_ = *ast->GetMolecularWeights().get();
+
+        auto isBaryon = ast->GetIsBaryonFlags();
+        std::vector<char> ib(isBaryon->size());
+        for (size_t idx = 0; idx < isBaryon->size(); ++idx) {
+            if (isBaryon->operator[](idx)) {
+                ib[idx] = 1;
+            } else {
+                ib[idx] = 0;
+            }
+        }
+
+        /*pos_.clear();
+        pos_.reserve(particleCount / 2);
+        vel_.clear();
+        vel_.reserve(particleCount / 2);
+        dens_.clear();
+        dens_.reserve(particleCount / 2);*/
+
+        sort_with([](auto a, auto b) { return a > b; }, ib, positions, vel_, dens_, sl_, temp_, mass_, mw_);
+
+        auto it = std::find(ib.cbegin(), ib.cend(), false);
+        auto idx = std::distance(ib.cbegin(), it);
+
+        positions.erase(positions.begin() + idx, positions.end());
+        vel_.erase(vel_.begin() + idx, vel_.end());
+        dens_.erase(dens_.begin() + idx, dens_.end());
+        sl_.erase(sl_.begin() + idx, sl_.end());
+        temp_.erase(temp_.begin() + idx, temp_.end());
+        mass_.erase(mass_.begin() + idx, mass_.end());
+        mw_.erase(mw_.begin() + idx, mw_.end());
+
+        pos_.resize(positions.size());
+
+        for (size_t idx = 0; idx < positions.size(); ++idx) {
+            pos_[idx].x = positions[idx].x;
+            pos_[idx].y = positions[idx].y;
+            pos_[idx].z = positions[idx].z;
+            pos_[idx].w = sl_[idx];
+        }
+
+        mpdc->SetDataHash(this->lastDataHash + this->hashOffset);
+        mpdc->SetParticleListCount(1);
+        MultiParticleDataCall::Particles& p = mpdc->AccessParticles(0);
+        p.SetCount(pos_.size());
+        if (p.GetCount() > 0) {
+            p.SetVertexData(MultiParticleDataCall::Particles::VERTDATA_FLOAT_XYZR, pos_.data());
+            if (freshMinMax || this->minColorSlot.IsDirty() || this->midColorSlot.IsDirty() ||
+                this->maxColorSlot.IsDirty() || this->useMidColorSlot.IsDirty()) {
+                this->calcColorTable(*ast);
+                this->minColorSlot.ResetDirty();
+                this->midColorSlot.ResetDirty();
+                this->maxColorSlot.ResetDirty();
+                this->useMidColorSlot.ResetDirty();
+            }
+            auto const sel = colorModeSlot.Param<core::param::EnumParam>()->Value();
+            if (sel == static_cast<int>(ColoringMode::TEMPERATURE)) {
+                p.SetColourData(MultiParticleDataCall::Particles::COLDATA_FLOAT_I, temp_.data());
+                auto minmax_val = std::minmax_element(temp_.begin(), temp_.end());
+                p.SetColourMapIndexValues(*minmax_val.first, *minmax_val.second);
+            } else if (sel == static_cast<int>(ColoringMode::MASS)) {
+                p.SetColourData(MultiParticleDataCall::Particles::COLDATA_FLOAT_I, mass_.data());
+                auto minmax_val = std::minmax_element(mass_.begin(), mass_.end());
+                p.SetColourMapIndexValues(*minmax_val.first, *minmax_val.second);
+            } else if (sel == static_cast<int>(ColoringMode::MOLECULAR_WEIGHT)) {
+                p.SetColourData(MultiParticleDataCall::Particles::COLDATA_FLOAT_I, mw_.data());
+                auto minmax_val = std::minmax_element(mw_.begin(), mw_.end());
+                p.SetColourMapIndexValues(*minmax_val.first, *minmax_val.second);
+            } else {
+                p.SetColourData(MultiParticleDataCall::Particles::COLDATA_FLOAT_I, dens_.data());
+                auto minmax_val = std::minmax_element(dens_.begin(), dens_.end());
+                p.SetColourMapIndexValues(*minmax_val.first, *minmax_val.second);
+            }
+            p.SetDirData(SimpleSphericalParticles::DirDataType::DIRDATA_FLOAT_XYZ, vel_.data());
+        }
+        // ast->Unlock();
+        return true;
+    }
+    ast->Unlock();
+    return true;
+}
+
+/*
+ * AstroParticleConverter::getExtent
+ */
+bool AstroParticleConverter::getExtent(Call& call) {
+    MultiParticleDataCall* mpdc = dynamic_cast<MultiParticleDataCall*>(&call);
+    if (mpdc == nullptr) return false;
+
+    AstroDataCall* ast = this->astroDataSlot.CallAs<AstroDataCall>();
+    if (ast == nullptr) return false;
+
+    ast->SetUnlocker(nullptr, false);
+    if ((*ast)(AstroDataCall::CallForGetExtent)) {
+        mpdc->SetFrameCount(ast->FrameCount());
+        if (this->colorModeSlot.IsDirty() || this->minColorSlot.IsDirty() || this->midColorSlot.IsDirty() ||
+            this->maxColorSlot.IsDirty() || this->useMidColorSlot.IsDirty()) {
+            this->hashOffset++;
+        }
+        mpdc->SetDataHash(ast->DataHash() + this->hashOffset);
+        mpdc->AccessBoundingBoxes() = ast->AccessBoundingBoxes();
+        ast->Unlock();
+        return true;
+    }
+    ast->Unlock();
+    return false;
+}
+
+/*
+ * AstroParticleConverter::calcMinMaxValues
+ */
+void AstroParticleConverter::calcMinMaxValues(const AstroDataCall& ast) {
+    auto colmode = static_cast<ColoringMode>(this->colorModeSlot.Param<param::EnumParam>()->Value());
+    this->valmin = this->densityMin = 0.0f;
+    this->valmax = this->densityMax = 1.0f;
+
+    if (ast.GetParticleCount() < 1) { // when no particles are present the pointer dereferencing later does not work
+        this->minValueSlot.Param<param::FloatParam>()->SetValue(this->valmin);
+        this->maxValueSlot.Param<param::FloatParam>()->SetValue(this->valmax);
+        return;
+    }
+
+    switch (colmode) {
+    case megamol::astro::AstroParticleConverter::ColoringMode::MASS:
+        this->valmin = *std::min_element(ast.GetMass()->begin(), ast.GetMass()->end());
+        this->valmax = *std::max_element(ast.GetMass()->begin(), ast.GetMass()->end());
+        break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::INTERNAL_ENERGY:
+        this->valmin = *std::min_element(ast.GetInternalEnergy()->begin(), ast.GetInternalEnergy()->end());
+        this->valmax = *std::max_element(ast.GetInternalEnergy()->begin(), ast.GetInternalEnergy()->end());
+        break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::SMOOTHING_LENGTH:
+        this->valmin = *std::min_element(ast.GetSmoothingLength()->begin(), ast.GetSmoothingLength()->end());
+        this->valmax = *std::max_element(ast.GetSmoothingLength()->begin(), ast.GetSmoothingLength()->end());
+        break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::MOLECULAR_WEIGHT:
+        this->valmin = *std::min_element(ast.GetMolecularWeights()->begin(), ast.GetMolecularWeights()->end());
+        this->valmax = *std::max_element(ast.GetMolecularWeights()->begin(), ast.GetMolecularWeights()->end());
+        break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::DENSITY:
+        this->valmin = *std::min_element(ast.GetDensity()->begin(), ast.GetDensity()->end());
+        this->valmax = *std::max_element(ast.GetDensity()->begin(), ast.GetDensity()->end());
+        break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::GRAVITATIONAL_POTENTIAL:
+        this->valmin =
+            *std::min_element(ast.GetGravitationalPotential()->begin(), ast.GetGravitationalPotential()->end());
+        this->valmax =
+            *std::max_element(ast.GetGravitationalPotential()->begin(), ast.GetGravitationalPotential()->end());
+        break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::TEMPERATURE:
+        this->valmin = *std::min_element(ast.GetTemperature()->begin(), ast.GetTemperature()->end());
+        this->valmax = *std::max_element(ast.GetTemperature()->begin(), ast.GetTemperature()->end());
+        break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::ENTROPY:
+        this->valmin = *std::min_element(ast.GetEntropy()->begin(), ast.GetEntropy()->end());
+        this->valmax = *std::max_element(ast.GetEntropy()->begin(), ast.GetEntropy()->end());
+        break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::INTERNAL_ENERGY_DERIVATIVE:
+        this->valmin =
+            *std::min_element(ast.GetInternalEnergyDerivatives()->begin(), ast.GetInternalEnergyDerivatives()->end());
+        this->valmax =
+            *std::max_element(ast.GetInternalEnergyDerivatives()->begin(), ast.GetInternalEnergyDerivatives()->end());
+        break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::SMOOTHING_LENGTH_DERIVATIVE:
+        this->valmin =
+            *std::min_element(ast.GetSmoothingLengthDerivatives()->begin(), ast.GetSmoothingLengthDerivatives()->end());
+        this->valmax =
+            *std::max_element(ast.GetSmoothingLengthDerivatives()->begin(), ast.GetSmoothingLengthDerivatives()->end());
+        break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::MOLECULAR_WEIGHT_DERIVATIVE:
+        this->valmin =
+            *std::min_element(ast.GetMolecularWeightDerivatives()->begin(), ast.GetMolecularWeightDerivatives()->end());
+        this->valmax =
+            *std::max_element(ast.GetMolecularWeightDerivatives()->begin(), ast.GetMolecularWeightDerivatives()->end());
+        break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::DENSITY_DERIVATIVE:
+        this->valmin = *std::min_element(ast.GetDensityDerivative()->begin(), ast.GetDensityDerivative()->end());
+        this->valmax = *std::max_element(ast.GetDensityDerivative()->begin(), ast.GetDensityDerivative()->end());
+        break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::GRAVITATIONAL_POTENTIAL_DERIVATIVE:
+        this->valmin = *std::min_element(
+            ast.GetGravitationalPotentialDerivatives()->begin(), ast.GetGravitationalPotentialDerivatives()->end());
+        this->valmax = *std::max_element(
+            ast.GetGravitationalPotentialDerivatives()->begin(), ast.GetGravitationalPotentialDerivatives()->end());
+        break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::TEMPERATURE_DERIVATIVE:
+        this->valmin =
+            *std::min_element(ast.GetTemperatureDerivatives()->begin(), ast.GetTemperatureDerivatives()->end());
+        this->valmax =
+            *std::max_element(ast.GetTemperatureDerivatives()->begin(), ast.GetTemperatureDerivatives()->end());
+        break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::ENTROPY_DERIVATIVE:
+        this->valmin = *std::min_element(ast.GetEntropyDerivatives()->begin(), ast.GetEntropyDerivatives()->end());
+        this->valmax = *std::max_element(ast.GetEntropyDerivatives()->begin(), ast.GetEntropyDerivatives()->end());
+        break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::AGN_DISTANCES:
+        this->valmin = *std::min_element(ast.GetAgnDistances()->begin(), ast.GetAgnDistances()->end());
+        this->valmax = *std::max_element(ast.GetAgnDistances()->begin(), ast.GetAgnDistances()->end());
+        break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::IS_BARYON:
+    case megamol::astro::AstroParticleConverter::ColoringMode::IS_STAR:
+    case megamol::astro::AstroParticleConverter::ColoringMode::IS_WIND:
+    case megamol::astro::AstroParticleConverter::ColoringMode::IS_STAR_FORMING_GAS:
+    case megamol::astro::AstroParticleConverter::ColoringMode::IS_AGN:
+    case megamol::astro::AstroParticleConverter::ColoringMode::IS_DARK_MATTER:
+    default:
+        this->valmin = 0.0f;
+        this->valmax = 1.0f;
+        break;
+    }
+    this->minValueSlot.Param<param::FloatParam>()->SetValue(this->valmin);
+    this->maxValueSlot.Param<param::FloatParam>()->SetValue(this->valmax);
+
+    this->densityMin = *std::min_element(ast.GetDensity()->begin(), ast.GetDensity()->end());
+    this->densityMax = *std::max_element(ast.GetDensity()->begin(), ast.GetDensity()->end());
+}
+
+/*
+ * AstroParticleConverter::calcColorTable
+ */
+void AstroParticleConverter::calcColorTable(const AstroDataCall& ast) {
+    float value = 0.0f;
+    auto colmode = static_cast<ColoringMode>(this->colorModeSlot.Param<param::EnumParam>()->Value());
+    this->usedColors.resize(ast.GetPositions()->size());
+    auto minCol = glm::make_vec4(this->minColorSlot.Param<param::ColorParam>()->Value().data());
+    auto midCol = glm::make_vec4(this->midColorSlot.Param<param::ColorParam>()->Value().data());
+    auto maxCol = glm::make_vec4(this->maxColorSlot.Param<param::ColorParam>()->Value().data());
+    auto useMid = this->useMidColorSlot.Param<param::BoolParam>()->Value();
+    float denom = this->valmax - this->valmin;
+
+    switch (colmode) {
+    case megamol::astro::AstroParticleConverter::ColoringMode::MASS: {
+        auto v = ast.GetMass();
+        for (size_t i = 0; i < this->usedColors.size(); ++i) {
+            float alpha = (v->at(i) - this->valmin) / denom;
+            this->usedColors[i] = this->interpolateColor(minCol, midCol, maxCol, alpha, useMid);
+        }
+    } break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::INTERNAL_ENERGY: {
+        auto v = ast.GetInternalEnergy();
+        for (size_t i = 0; i < this->usedColors.size(); ++i) {
+            float alpha = (v->at(i) - this->valmin) / denom;
+            this->usedColors[i] = this->interpolateColor(minCol, midCol, maxCol, alpha, useMid);
+        }
+    } break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::SMOOTHING_LENGTH: {
+        auto v = ast.GetSmoothingLength();
+        for (size_t i = 0; i < this->usedColors.size(); ++i) {
+            float alpha = (v->at(i) - this->valmin) / denom;
+            this->usedColors[i] = this->interpolateColor(minCol, midCol, maxCol, alpha, useMid);
+        }
+    } break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::MOLECULAR_WEIGHT: {
+        auto v = ast.GetMolecularWeights();
+        for (size_t i = 0; i < this->usedColors.size(); ++i) {
+            float alpha = (v->at(i) - this->valmin) / denom;
+            this->usedColors[i] = this->interpolateColor(minCol, midCol, maxCol, alpha, useMid);
+        }
+    } break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::DENSITY: {
+        auto v = ast.GetDensity();
+        for (size_t i = 0; i < this->usedColors.size(); ++i) {
+            float alpha = (v->at(i) - this->valmin) / denom;
+            this->usedColors[i] = this->interpolateColor(minCol, midCol, maxCol, alpha, useMid);
+        }
+    } break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::GRAVITATIONAL_POTENTIAL: {
+        auto v = ast.GetGravitationalPotential();
+        for (size_t i = 0; i < this->usedColors.size(); ++i) {
+            float alpha = (v->at(i) - this->valmin) / denom;
+            this->usedColors[i] = this->interpolateColor(minCol, midCol, maxCol, alpha, useMid);
+        }
+    } break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::TEMPERATURE: {
+        auto v = ast.GetTemperature();
+        for (size_t i = 0; i < this->usedColors.size(); ++i) {
+            float alpha = (v->at(i) - this->valmin) / denom;
+            this->usedColors[i] = this->interpolateColor(minCol, midCol, maxCol, alpha, useMid);
+        }
+    } break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::ENTROPY: {
+        auto v = ast.GetEntropy();
+        for (size_t i = 0; i < this->usedColors.size(); ++i) {
+            float alpha = (v->at(i) - this->valmin) / denom;
+            this->usedColors[i] = this->interpolateColor(minCol, midCol, maxCol, alpha, useMid);
+        }
+    } break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::IS_BARYON: {
+        auto v = ast.GetIsBaryonFlags();
+        for (size_t i = 0; i < this->usedColors.size(); ++i) {
+            v->at(i) ? this->usedColors[i] = maxCol : this->usedColors[i] = minCol;
+        }
+    } break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::IS_STAR: {
+        auto v = ast.GetIsStarFlags();
+        for (size_t i = 0; i < this->usedColors.size(); ++i) {
+            v->at(i) ? this->usedColors[i] = maxCol : this->usedColors[i] = minCol;
+        }
+    } break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::IS_WIND: {
+        auto v = ast.GetIsWindFlags();
+        for (size_t i = 0; i < this->usedColors.size(); ++i) {
+            v->at(i) ? this->usedColors[i] = maxCol : this->usedColors[i] = minCol;
+        }
+    } break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::IS_STAR_FORMING_GAS: {
+        auto v = ast.GetIsStarFormingGasFlags();
+        for (size_t i = 0; i < this->usedColors.size(); ++i) {
+            v->at(i) ? this->usedColors[i] = maxCol : this->usedColors[i] = minCol;
+        }
+    } break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::IS_AGN: {
+        auto v = ast.GetIsAGNFlags();
+        for (size_t i = 0; i < this->usedColors.size(); ++i) {
+            v->at(i) ? this->usedColors[i] = maxCol : this->usedColors[i] = minCol;
+        }
+    } break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::IS_DARK_MATTER: { // inverse case to IS_BARYON
+        auto v = ast.GetIsBaryonFlags();
+        for (size_t i = 0; i < this->usedColors.size(); ++i) {
+            v->at(i) ? this->usedColors[i] = minCol : this->usedColors[i] = maxCol;
+        }
+    } break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::INTERNAL_ENERGY_DERIVATIVE: {
+        auto v = ast.GetInternalEnergyDerivatives();
+        for (size_t i = 0; i < this->usedColors.size(); ++i) {
+            float alpha = (v->at(i) - this->valmin) / denom;
+            this->usedColors[i] = this->interpolateColor(minCol, midCol, maxCol, alpha, useMid);
+        }
+    } break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::SMOOTHING_LENGTH_DERIVATIVE: {
+        auto v = ast.GetSmoothingLengthDerivatives();
+        for (size_t i = 0; i < this->usedColors.size(); ++i) {
+            float alpha = (v->at(i) - this->valmin) / denom;
+            this->usedColors[i] = this->interpolateColor(minCol, midCol, maxCol, alpha, useMid);
+        }
+    } break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::MOLECULAR_WEIGHT_DERIVATIVE: {
+        auto v = ast.GetMolecularWeightDerivatives();
+        for (size_t i = 0; i < this->usedColors.size(); ++i) {
+            float alpha = (v->at(i) - this->valmin) / denom;
+            this->usedColors[i] = this->interpolateColor(minCol, midCol, maxCol, alpha, useMid);
+        }
+    } break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::DENSITY_DERIVATIVE: {
+        auto v = ast.GetDensityDerivative();
+        for (size_t i = 0; i < this->usedColors.size(); ++i) {
+            float alpha = (v->at(i) - this->valmin) / denom;
+            this->usedColors[i] = this->interpolateColor(minCol, midCol, maxCol, alpha, useMid);
+        }
+    } break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::GRAVITATIONAL_POTENTIAL_DERIVATIVE: {
+        auto v = ast.GetGravitationalPotentialDerivatives();
+        for (size_t i = 0; i < this->usedColors.size(); ++i) {
+            float alpha = (v->at(i) - this->valmin) / denom;
+            this->usedColors[i] = this->interpolateColor(minCol, midCol, maxCol, alpha, useMid);
+        }
+    } break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::TEMPERATURE_DERIVATIVE: {
+        auto v = ast.GetTemperatureDerivatives();
+        for (size_t i = 0; i < this->usedColors.size(); ++i) {
+            float alpha = (v->at(i) - this->valmin) / denom;
+            this->usedColors[i] = this->interpolateColor(minCol, midCol, maxCol, alpha, useMid);
+        }
+    } break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::ENTROPY_DERIVATIVE: {
+        auto v = ast.GetEntropyDerivatives();
+        for (size_t i = 0; i < this->usedColors.size(); ++i) {
+            float alpha = (v->at(i) - this->valmin) / denom;
+            this->usedColors[i] = this->interpolateColor(minCol, midCol, maxCol, alpha, useMid);
+        }
+    } break;
+    case megamol::astro::AstroParticleConverter::ColoringMode::AGN_DISTANCES: {
+        auto v = ast.GetAgnDistances();
+        for (size_t i = 0; i < this->usedColors.size(); ++i) {
+            float alpha = (v->at(i) - this->valmin) / denom;
+            this->usedColors[i] = this->interpolateColor(minCol, midCol, maxCol, alpha, useMid);
+        }
+    } break;
+    default:
+        break;
+    }
+}
+
+/*
+ * AstroParticleConverter::interpolateColor
+ */
+glm::vec4 AstroParticleConverter::interpolateColor(const glm::vec4& minCol, const glm::vec4& midCol,
+    const glm::vec4& maxCol, const float alpha, const bool useMidValue) {
+    if (!useMidValue) return glm::mix(minCol, maxCol, alpha);
+    if (alpha < 0.5f) return glm::mix(minCol, midCol, alpha * 2.0f);
+    return glm::mix(midCol, maxCol, (alpha - 0.5f) * 2.0f);
+}
diff --git a/plugins/astro/src/AstroParticleConverter.h b/plugins/astro/src/AstroParticleConverter.h
new file mode 100644
index 000000000..5e2a0cb22
--- /dev/null
+++ b/plugins/astro/src/AstroParticleConverter.h
@@ -0,0 +1,115 @@
+/*
+ * AstroParticleConverter.h
+ *
+ * Copyright (C) 2019 by VISUS (Universitaet Stuttgart)
+ * Alle Rechte vorbehalten.
+ */
+
+#ifndef MEGAMOLCORE_ASTROPARTICLECONVERTER_H_INCLUDED
+#define MEGAMOLCORE_ASTROPARTICLECONVERTER_H_INCLUDED
+#if (defined(_MSC_VER) && (_MSC_VER > 1000))
+#    pragma once
+#endif /* (defined(_MSC_VER) && (_MSC_VER > 1000)) */
+
+#include "mmcore/CalleeSlot.h"
+#include "mmcore/CallerSlot.h"
+#include "mmcore/Module.h"
+#include "mmcore/param/BoolParam.h"
+#include "mmcore/param/ColorParam.h"
+#include "mmcore/param/EnumParam.h"
+#include "mmcore/param/FloatParam.h"
+#include "mmcore/param/ParamSlot.h"
+
+#include "astro/AstroDataCall.h"
+#include "mmcore/moldyn/MultiParticleDataCall.h"
+
+namespace megamol {
+namespace astro {
+
+class AstroParticleConverter : public core::Module {
+public:
+    static const char* ClassName(void) { return "AstroParticleConverter"; }
+    static const char* Description(void) {
+        return "Converts data contained in a AstroDataCall to a MultiParticleDataCall";
+    }
+    static bool IsAvailable(void) { return true; }
+
+    /** Ctor. */
+    AstroParticleConverter(void);
+
+    /** Dtor. */
+    virtual ~AstroParticleConverter(void);
+
+protected:
+    virtual bool create(void);
+    virtual void release(void);
+
+private:
+    enum class ColoringMode : uint8_t {
+        MASS = 0,
+        INTERNAL_ENERGY = 1,
+        SMOOTHING_LENGTH = 2,
+        MOLECULAR_WEIGHT = 3,
+        DENSITY = 4,
+        GRAVITATIONAL_POTENTIAL = 5,
+        IS_BARYON = 6,
+        IS_STAR = 7,
+        IS_WIND = 8,
+        IS_STAR_FORMING_GAS = 9,
+        IS_AGN = 10,
+        IS_DARK_MATTER = 11,
+        TEMPERATURE = 12,
+        ENTROPY = 13,
+        INTERNAL_ENERGY_DERIVATIVE = 14,
+        SMOOTHING_LENGTH_DERIVATIVE = 15,
+        MOLECULAR_WEIGHT_DERIVATIVE = 16,
+        DENSITY_DERIVATIVE = 17,
+        GRAVITATIONAL_POTENTIAL_DERIVATIVE = 18,
+        TEMPERATURE_DERIVATIVE = 19,
+        ENTROPY_DERIVATIVE = 20,
+        AGN_DISTANCES = 21
+    };
+
+    bool getData(core::Call& call);
+    bool getSpecialData(core::Call& call);
+    bool getExtent(core::Call& call);
+
+    void calcMinMaxValues(const AstroDataCall& ast);
+    void calcColorTable(const AstroDataCall& ast);
+
+    glm::vec4 interpolateColor(const glm::vec4& minCol, const glm::vec4& midCol, const glm::vec4& maxCol,
+        const float alpha, const bool useMidValue = false);
+
+    core::param::ParamSlot colorModeSlot;
+    core::param::ParamSlot minColorSlot;
+    core::param::ParamSlot midColorSlot;
+    core::param::ParamSlot maxColorSlot;
+    core::param::ParamSlot useMidColorSlot;
+
+    core::param::ParamSlot minValueSlot;
+    core::param::ParamSlot maxValueSlot;
+
+    std::vector<glm::vec4> usedColors;
+
+    core::CalleeSlot sphereDataSlot;
+    core::CalleeSlot sphereSpecialSlot;
+    core::CallerSlot astroDataSlot;
+    size_t lastDataHash;
+    size_t hashOffset;
+    unsigned int lastFrame = 0;
+    float valmin, valmax;
+    float densityMin, densityMax;
+
+    std::vector<glm::vec4> pos_;
+    std::vector<glm::vec3> vel_;
+    std::vector<float> dens_;
+    std::vector<float> sl_;
+    std::vector<float> temp_;
+    std::vector<float> mass_;
+    std::vector<float> mw_;
+};
+
+} // namespace astro
+} // namespace megamol
+
+#endif /* MEGAMOLCORE_ASTROPARTICLECONVERTER_H_INCLUDED */
diff --git a/plugins/astro/src/AstroSchulz.cpp b/plugins/astro/src/AstroSchulz.cpp
new file mode 100644
index 000000000..683a914dd
--- /dev/null
+++ b/plugins/astro/src/AstroSchulz.cpp
@@ -0,0 +1,923 @@
+/*
+ * AstroSchulz.cpp
+ *
+ * Copyright (C) 2019 by VISUS (Universitaet Stuttgart)
+ * All rights reserved.
+ */
+
+#include "stdafx.h"
+#include "AstroSchulz.h"
+
+#include <array>
+
+#include "mmcore/param/BoolParam.h"
+
+#include "vislib/math/mathfunctions.h"
+
+#include "vislib/sys/Log.h"
+
+
+/*
+ * megamol::astro::AstroSchulz::AstroSchulz
+ */
+megamol::astro::AstroSchulz::AstroSchulz(void) : Module(),
+        frameID((std::numeric_limits<unsigned int>::max)()),
+        hashInput(0),
+        hashState(0),
+        paramsInclude{{// The ParamSlot has been defeated!!!
+            {"includePosition", "Include the position."}, {"includeVelocity", "Include the velocity vectors."},
+            {"includeVelocityMagnitude", "Include the magnitude of the velocity vectors."},
+            {"includeTemperature", "Include the temperature."}, {"includeMass", "Include the mass."},
+            {"includeInternalEnergy", "Include the internal energy."},
+            {"includeSmoothingLength", "include the smoothing length."},
+            {"includeMolecularWeight", "Include the molecular weight."}, {"includeDensity", "Include the density."},
+            {"includeGravitationalPotential", "Include the graviational potential."},
+            {"includeEntropy", "Include entropy."}, {"includeBaryon", "Include the Boolean indicating baryons."},
+            {"includeStar", "Include the Boolean indicating stars."},
+            {"includeWind", "Include the Boolean indicating wind."},
+            {"includeStarFormingGas", "Include the Boolean indicating start forming gas."},
+            {"includeActiveGalactivNucleus", "Include the Boolean indicating AGNs."},
+            {"includeID", "Include the particle ID."},
+            {"includeVelocityDerivative", "Include the velocity vector derivatives"}, 
+            {"includeInternalEnergyDerivative", "Include the internal energy derivative"}, 
+            {"includeSmoothingLengthDerivative", "include the smoothing length derivative"}, 
+            {"includeMolecularWeightDerivative", "Include the molecular weight derivative"}, 
+            {"includeDensityDerivative", "Include the density derivative"}, 
+            {"includeGravitationalPotentialDerivative", "Include the graviational potential derivative"}, 
+            {"includeTemperatureDerivative", "Include the temperature derivative"}, 
+            {"includeEntropyDerivative", "Include entropy derivative"},
+            {"includeAGNDistances", "Include the distances to the AGNs"},
+            {"includeTime", "Load all timesteps into a single table and add the frame number as column."}}}, 
+        paramFullRange("fullRange", "Scan the whole trajecory for min/man ranges."),
+        slotAstroData("astroData", "Input slot for astronomical data"),
+        slotTableData("tableData", "Output slot for the resulting sphere data") {
+    // Publish the slots.
+    this->slotAstroData.SetCompatibleCall<AstroDataCallDescription>();
+    this->MakeSlotAvailable(&this->slotAstroData);
+
+    this->slotTableData.SetCallback(megamol::stdplugin::datatools::table::TableDataCall::ClassName(),
+        megamol::stdplugin::datatools::table::TableDataCall::FunctionName(0), &AstroSchulz::getData);
+    this->slotTableData.SetCallback(megamol::stdplugin::datatools::table::TableDataCall::ClassName(),
+        megamol::stdplugin::datatools::table::TableDataCall::FunctionName(1), &AstroSchulz::getHash);
+    this->MakeSlotAvailable(&this->slotTableData);
+
+    this->paramFullRange << new core::param::BoolParam(false);
+    this->MakeSlotAvailable(&this->paramFullRange);
+
+    for (auto& p : this->paramsInclude) {
+        p << new core::param::BoolParam(true);
+        this->MakeSlotAvailable(&p);
+    }
+
+    this->paramsInclude.back().Param<core::param::BoolParam>()->SetValue(false);
+}
+
+
+/*
+ * megamol::astro::AstroSchulz::~AstroSchulz
+ */
+megamol::astro::AstroSchulz::~AstroSchulz(void) {
+    // TODO: This is toxic!
+    this->Release();
+}
+
+
+/*
+ * megamol::astro::AstroSchulz::create
+ */
+bool megamol::astro::AstroSchulz::create(void) { return true; }
+
+
+/*
+ * megamol::astro::AstroSchulz::release
+ */
+void megamol::astro::AstroSchulz::release(void) {}
+
+
+/*
+ * megamol::astro::AstroSchulz::getData
+ */
+bool megamol::astro::AstroSchulz::getData(AstroDataCall& call, const unsigned int frameID) {
+    // Log::DefaultLog.WriteInfo(L"Requesting astro frame %u ...", frameID);
+    call.SetFrameID(frameID, true);
+
+    do {
+        if (!call(AstroDataCall::CallForGetData)) {
+            vislib::sys::Log::DefaultLog.WriteWarn(L"%hs failed in %hs.",
+                AstroDataCall::FunctionName(AstroDataCall::CallForGetData), AstroSchulz::ClassName());
+            return false;
+        }
+    } while (call.FrameID() != frameID);
+
+    return true;
+}
+
+
+/*
+ * megamol::astro::AstroSchulz::updateRange
+ */
+void megamol::astro::AstroSchulz::updateRange(std::pair<float, float>& range, const float value) {
+    if (value < range.first) {
+        range.first = value;
+    }
+    if (value > range.second) {
+        range.second = value;
+    }
+}
+
+
+/*
+ * megamol::astro::AstroSchulz::convert
+ */
+void megamol::astro::AstroSchulz::convert(float* dst, const std::size_t col, const vec3ArrayPtr& src) {
+    assert(dst != nullptr);
+    assert(src != nullptr);
+
+    std::array<std::pair<float, float>, 3> range = {
+        AstroSchulz::initialiseRange(), AstroSchulz::initialiseRange(), AstroSchulz::initialiseRange()};
+
+    for (auto s : *src) {
+        for (std::size_t i = 0; i < s.length(); ++i) {
+            dst[i] = s[i];
+
+            AstroSchulz::updateRange(range[i], dst[i]);
+            assert(range[i].first <= range[i].second);
+            assert(dst[i] >= range[i].first);
+            assert(dst[i] <= range[i].second);
+        }
+
+        dst += this->columns.size();
+    }
+
+    for (std::size_t i = 0; i < 3; ++i) {
+        this->setRange(col + i, range[i]);
+    }
+}
+
+
+/*
+ * megamol::astro::AstroSchulz::convert
+ */
+void megamol::astro::AstroSchulz::convert(float* dst, const std::size_t col, const floatArrayPtr& src) {
+    assert(dst != nullptr);
+    assert(src != nullptr);
+    auto range = AstroSchulz::initialiseRange();
+    assert(range.first > range.second);
+
+    for (auto s : *src) {
+        *dst = s;
+
+        AstroSchulz::updateRange(range, *dst);
+        assert(range.first <= range.second);
+        assert(s >= range.first);
+        assert(s <= range.second);
+
+        dst += this->columns.size();
+    }
+
+    this->setRange(col, range);
+}
+
+
+/*
+ * megamol::astro::AstroSchulz::convert
+ */
+void megamol::astro::AstroSchulz::convert(float* dst, const std::size_t col, const boolArrayPtr& src) {
+    assert(dst != nullptr);
+    assert(src != nullptr);
+    auto range = AstroSchulz::initialiseRange();
+
+    for (auto s : *src) {
+        *dst = s ? 1.0f : 0.0f;
+        assert((*dst == 0.0f) || (*dst == 1.0f));
+
+        AstroSchulz::updateRange(range, *dst);
+        assert(range.first <= range.second);
+        assert(*dst >= range.first);
+        assert(*dst <= range.second);
+
+        dst += this->columns.size();
+    }
+
+    // this->columns[col].SetMinimumValue(range.first);
+    // this->columns[col].SetMaximumValue(range.second);
+}
+
+
+/*
+ * megamol::astro::AstroSchulz::convert
+ */
+void megamol::astro::AstroSchulz::convert(float* dst, const std::size_t col, const idArrayPtr& src) {
+    assert(dst != nullptr);
+    assert(src != nullptr);
+    auto range = AstroSchulz::initialiseRange();
+
+    for (auto s : *src) {
+        *dst = static_cast<float>(s);
+
+        AstroSchulz::updateRange(range, *dst);
+        assert(range.first <= range.second);
+        assert(*dst >= range.first);
+        assert(*dst <= range.second);
+
+        dst += this->columns.size();
+    }
+
+    this->setRange(col, range);
+}
+
+
+/*
+ * megamol::astro::AstroSchulz::getData
+ */
+bool megamol::astro::AstroSchulz::getData(core::Call& call) {
+    using megamol::stdplugin::datatools::table::TableDataCall;
+    using vislib::sys::Log;
+
+    auto ast = this->slotAstroData.CallAs<AstroDataCall>();
+    auto tab = static_cast<TableDataCall*>(&call);
+
+    if (ast == nullptr) {
+        Log::DefaultLog.WriteWarn(L"AstroDataCall is not connected "
+                                  L"in AstroSchulz.",
+            nullptr);
+        return false;
+    }
+    if (tab == nullptr) {
+        Log::DefaultLog.WriteWarn(L"TableDataCall is not connected "
+                                  L"in AstroSchulz.",
+            nullptr);
+        return false;
+    }
+
+    if (!(*ast)(AstroDataCall::CallForGetExtent)) {
+        Log::DefaultLog.WriteWarn(L"AstroDataCall::CallForGetExtent failed "
+                                  L"in AstroSchulz.",
+            nullptr);
+        return false;
+    }
+
+    if (this->paramFullRange.IsDirty()) {
+        auto p = this->paramFullRange.Param<core::param::BoolParam>();
+
+        if (p->Value()) {
+            this->getRanges(0, ast->FrameCount());
+        } else {
+            this->ranges.clear();
+        }
+
+        this->paramFullRange.ResetDirty();
+    }
+
+    if (!this->getData(tab->GetFrameID())) {
+        return false;
+    }
+
+    tab->SetFrameCount(ast->FrameCount());
+    tab->SetDataHash(this->getHash());
+    tab->Set(
+        this->columns.size(), this->values.size() / this->columns.size(), this->columns.data(), this->values.data());
+    tab->SetUnlocker(nullptr);
+
+    return true;
+}
+
+
+/*
+ * megamol::astro::AstroSchulz::getData
+ */
+bool megamol::astro::AstroSchulz::getData(const unsigned int frameID) {
+    using namespace core::param;
+    using megamol::stdplugin::datatools::table::TableDataCall;
+    using vislib::sys::Log;
+
+    auto ast = this->slotAstroData.CallAs<AstroDataCall>();
+    if (ast == nullptr) {
+        Log::DefaultLog.WriteWarn(L"AstroDataCall is not connected "
+                                  L"in AstroSchulz.",
+            nullptr);
+        return false;
+    }
+
+    auto isParamChange = this->columns.empty() || std::any_of(this->paramsInclude.begin(), this->paramsInclude.end(),
+                                                      [](const ParamSlot& param) { return param.IsDirty(); });
+
+    // Update column metadata if selection changed.
+    if (isParamChange) {
+        auto col = 0;
+        this->columns.clear();
+        this->columns.reserve(21);
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("PositionX");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+
+            this->columns.emplace_back();
+            this->columns.back().SetName("PositionY");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+
+            this->columns.emplace_back();
+            this->columns.back().SetName("PositionZ");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+        }
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("VelocityX");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+
+            this->columns.emplace_back();
+            this->columns.back().SetName("VelocityY");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+
+            this->columns.emplace_back();
+            this->columns.back().SetName("VelocityZ");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+        }
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("Velocity");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+        }
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("Temperature");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+        }
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("Mass");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+        }
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("InternalEnergy");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+        }
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("SmoothingLength");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+        }
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("MolecularWeight");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+        }
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("Density");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+        }
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("GraviationalPotential");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+        }
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("Entropy");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+        }
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("Baryon");
+            this->columns.back().SetType(TableDataCall::ColumnType::CATEGORICAL);
+            this->columns.back().SetMinimumValue(0.0f);
+            this->columns.back().SetMaximumValue(1.0f);
+        }
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("Star");
+            this->columns.back().SetType(TableDataCall::ColumnType::CATEGORICAL);
+            this->columns.back().SetMinimumValue(0.0f);
+            this->columns.back().SetMaximumValue(1.0f);
+        }
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("Wind");
+            this->columns.back().SetType(TableDataCall::ColumnType::CATEGORICAL);
+            this->columns.back().SetMinimumValue(0.0f);
+            this->columns.back().SetMaximumValue(1.0f);
+        }
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("StarFormingGas");
+            this->columns.back().SetType(TableDataCall::ColumnType::CATEGORICAL);
+            this->columns.back().SetMinimumValue(0.0f);
+            this->columns.back().SetMaximumValue(1.0f);
+        }
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("ActiveGalacticNucleus");
+            this->columns.back().SetType(TableDataCall::ColumnType::CATEGORICAL);
+            this->columns.back().SetMinimumValue(0.0f);
+            this->columns.back().SetMaximumValue(1.0f);
+        }
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("ID");
+            this->columns.back().SetType(TableDataCall::ColumnType::CATEGORICAL);
+            this->columns.back().SetMinimumValue(0.0f);
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+        }
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("VelocityDerivativeX");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+
+            this->columns.emplace_back();
+            this->columns.back().SetName("VelocityDerivativeY");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+
+            this->columns.emplace_back();
+            this->columns.back().SetName("VelocityDerivativeZ");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+        }
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("InternalEnergyDerivative");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+        }
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("SmoothingLengthDerivative");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+        }
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("MolecularWeightDerivative");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+        }
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("DensityDerivative");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+        }
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("GraviationalPotentialDerivative");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+        }
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("TemperatureDerivative");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+        }
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("EntropyDerivative");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+        }
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("AGNDistances");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(std::numeric_limits<float>::lowest());
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+        }
+
+        // Further values have to be inserted here. This always has to happen before the frame column is set.
+
+        if (this->paramsInclude[col++].Param<BoolParam>()->Value()) {
+            this->columns.emplace_back();
+            this->columns.back().SetName("Frame");
+            this->columns.back().SetType(TableDataCall::ColumnType::QUANTITATIVE);
+            this->columns.back().SetMinimumValue(0.0f);
+            this->columns.back().SetMaximumValue((std::numeric_limits<float>::max)());
+        }
+
+        for (auto& p : this->paramsInclude) {
+            p.ResetDirty();
+        }
+    }
+
+    if (this->paramsInclude.back().Param<BoolParam>()->Value()) {
+        Log::DefaultLog.WriteInfo(L"Creating union of all astro frames ...");
+
+        if (!(*ast)(AstroDataCall::CallForGetExtent)) {
+            Log::DefaultLog.WriteInfo(L"Failed to get extents of astro data.");
+            return false;
+        }
+
+        if (isParamChange) {
+            this->frameID = (std::numeric_limits<decltype(this->frameID)>::max)();
+            this->hashInput = (std::numeric_limits<decltype(this->hashInput)>::max)();
+            ++this->hashState;
+
+            this->values.clear();
+
+            const auto cntFrames = ast->FrameCount();
+            for (auto frameID = 0; frameID < cntFrames; ++frameID) {
+                Log::DefaultLog.WriteInfo(L"Adding astro frame %u to the union.", frameID);
+                if (!AstroSchulz::getData(*ast, frameID)) {
+                    return false;
+                }
+
+                // Determine location and size of current frame.
+                const auto cnt = ast->GetParticleCount();
+                const auto offset = this->values.size();
+                const auto size = offset + cnt * this->columns.size();
+
+                // If this is the first frame, reserve memory for all.
+                if (offset == 0) {
+                    this->values.reserve(cntFrames * size);
+                }
+
+                // Actually resize the table to hold the current frame.
+                this->values.resize(size);
+
+                // Add the current frame at the end.
+                this->getData(this->values.data() + offset, *ast);
+
+                // Add the frame number.
+                for (auto r = 0; r < cnt; ++r) {
+                    this->values[offset + r * this->columns.size() + (this->columns.size() - 1)] = frameID;
+                }
+            }
+        }
+
+    } else {
+        // Receive a single frame into 'ast'.
+        if (!AstroSchulz::getData(*ast, frameID)) {
+            return false;
+        }
+
+        // Copy the data into the table as necessary.
+        bool hashChanged = this->hashInput != ast->DataHash();
+        if (isParamChange || hashChanged || (this->frameID != frameID)) {
+            Log::DefaultLog.WriteInfo(L"Astro data are new (frame %u), filling "
+                                      L"table ...",
+                frameID);
+            this->frameID = frameID;
+            this->hashInput = ast->DataHash();
+            if (isParamChange || hashChanged) {
+                ++this->hashState;
+            }
+
+            const auto cnt = ast->GetParticleCount();
+            this->values.resize(cnt * this->columns.size());
+            this->getData(this->values.data(), *ast);
+        }
+    }
+
+    return true;
+}
+
+
+/*
+ * megamol::astro::AstroSchulz::getData
+ */
+void megamol::astro::AstroSchulz::getData(float* dst, const AstroDataCall& ast) {
+    using core::param::BoolParam;
+
+    auto col = 0;
+    auto cnt = ast.GetParticleCount();
+    auto logicalCol = 0;
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->convert(dst, col, ast.GetPositions());
+        col += 3;
+        dst += 3;
+    }
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->convert(dst, col, ast.GetVelocities());
+        col += 3;
+        dst += 3;
+    }
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->norm(dst, col, ast.GetVelocities());
+        ++col;
+        ++dst;
+    }
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->convert(dst, col, ast.GetTemperature());
+        ++col;
+        ++dst;
+    }
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->convert(dst, col, ast.GetMass());
+        ++col;
+        ++dst;
+    }
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->convert(dst, col, ast.GetInternalEnergy());
+        ++col;
+        ++dst;
+    }
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->convert(dst, col, ast.GetSmoothingLength());
+        ++col;
+        ++dst;
+    }
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->convert(dst, col, ast.GetMolecularWeights());
+        ++col;
+        ++dst;
+    }
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->convert(dst, col, ast.GetDensity());
+        ++col;
+        ++dst;
+    }
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->convert(dst, col, ast.GetGravitationalPotential());
+        ++col;
+        ++dst;
+    }
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->convert(dst, col, ast.GetEntropy());
+        ++col;
+        ++dst;
+    }
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->convert(dst, col, ast.GetIsBaryonFlags());
+        ++col;
+        ++dst;
+    }
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->convert(dst, col, ast.GetIsStarFlags());
+        ++col;
+        ++dst;
+    }
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->convert(dst, col, ast.GetIsWindFlags());
+        ++col;
+        ++dst;
+    }
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->convert(dst, col, ast.GetIsStarFormingGasFlags());
+        ++col;
+        ++dst;
+    }
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->convert(dst, col, ast.GetIsAGNFlags());
+        ++col;
+        ++dst;
+    }
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->convert(dst, col, ast.GetParticleIDs());
+        ++col;
+        ++dst;
+    }
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->convert(dst, col, ast.GetVelocityDerivatives());
+        col += 3;
+        dst += 3;
+    }
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->convert(dst, col, ast.GetInternalEnergyDerivatives());
+        ++col;
+        ++dst;
+    }
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->convert(dst, col, ast.GetSmoothingLengthDerivatives());
+        ++col;
+        ++dst;
+    }
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->convert(dst, col, ast.GetMolecularWeightDerivatives());
+        ++col;
+        ++dst;
+    }
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->convert(dst, col, ast.GetDensityDerivative());
+        ++col;
+        ++dst;
+    }
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->convert(dst, col, ast.GetGravitationalPotentialDerivatives());
+        ++col;
+        ++dst;
+    }
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->convert(dst, col, ast.GetTemperatureDerivatives());
+        ++col;
+        ++dst;
+    }
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->convert(dst, col, ast.GetEntropyDerivatives());
+        ++col;
+        ++dst;
+    }
+
+    if (this->paramsInclude[logicalCol++].Param<BoolParam>()->Value()) {
+        this->convert(dst, col, ast.GetAgnDistances());
+        ++col;
+        ++dst;
+    }
+
+    // new values have to be included here, using the correct order
+}
+
+
+/*
+ * megamol::astro::AstroSchulz::getHash
+ */
+bool megamol::astro::AstroSchulz::getHash(core::Call& call) {
+    using megamol::stdplugin::datatools::table::TableDataCall;
+
+    auto ast = this->slotAstroData.CallAs<AstroDataCall>();
+    auto tab = dynamic_cast<TableDataCall*>(&call);
+    if (tab == nullptr) {
+        return false;
+    }
+    if (ast == nullptr) {
+        return false;
+    }
+
+    //???? this->assertData();
+    if (!(*ast)(AstroDataCall::CallForGetExtent)) {
+        return false;
+    }
+
+    auto fc = ast->FrameCount();
+    tab->SetFrameCount(ast->FrameCount());
+
+    tab->SetDataHash(this->getHash());
+    tab->SetUnlocker(nullptr);
+
+    return true;
+}
+
+
+/*
+ * megamol::astro::AstroSchulz::getRanges
+ */
+bool megamol::astro::AstroSchulz::getRanges(const unsigned int start, const unsigned int cnt) {
+    using vislib::sys::Log;
+
+    // Note: option to disable column implies that the columns are not generated
+    // before the first data are retrieved. Therefore, we need to test-retrieve
+    // the first frame here to find out the number of columns.
+    decltype(this->ranges) ranges;
+    if (this->getData(start)) {
+        ranges.resize(this->columns.size());
+    }
+
+    Log::DefaultLog.WriteInfo(L"Scanning astro trajectory for global "
+                              L"min/max ranges. Please wait while MegaMol is working for you ...",
+        nullptr);
+
+    std::generate(ranges.begin(), ranges.end(), AstroSchulz::initialiseRange);
+    this->ranges.clear();
+
+    for (unsigned int f = start; f < start + cnt; ++f) {
+        if (this->getData(f)) {
+            for (std::size_t c = 0; c < this->columns.size(); ++c) {
+                AstroSchulz::updateRange(ranges[c], this->columns[c].MinimumValue());
+                AstroSchulz::updateRange(ranges[c], this->columns[c].MaximumValue());
+            }
+        } else {
+            return false;
+        }
+    }
+
+    this->ranges = std::move(ranges);
+
+    for (std::size_t c = 0; c < this->columns.size(); ++c) {
+        if (this->isQuantitative(c)) {
+            Log::DefaultLog.WriteInfo(L"Values of column \"%hs\" are within "
+                                      L"[%f, %f].",
+                this->columns[c].Name().c_str(), this->ranges[c].first, this->ranges[c].second);
+        }
+    }
+
+    return true;
+}
+
+
+/*
+ * megamol::astro::AstroSchulz::norm
+ */
+void megamol::astro::AstroSchulz::norm(float* dst, const std::size_t col, const vec3ArrayPtr& src) {
+    auto range = AstroSchulz::initialiseRange();
+
+    for (auto s : *src) {
+        *dst = glm::length(s);
+
+        AstroSchulz::updateRange(range, *dst);
+        assert(range.first <= range.second);
+        assert(*dst >= range.first);
+        assert(*dst <= range.second);
+
+        dst += this->columns.size();
+    }
+
+    this->setRange(col, range);
+}
+
+
+/*
+ * megamol::astro::AstroSchulz::setRange
+ */
+void megamol::astro::AstroSchulz::setRange(const std::size_t col, const std::pair<float, float>& src) {
+    assert(col < this->columns.size());
+    assert(src.first <= src.second);
+    if (this->ranges.empty()) {
+        this->columns[col].SetMinimumValue(src.first);
+        this->columns[col].SetMaximumValue(src.second);
+    } else if (this->isQuantitative(col)) {
+        this->columns[col].SetMinimumValue(this->ranges[col].first);
+        this->columns[col].SetMaximumValue(this->ranges[col].second);
+    }
+}
diff --git a/plugins/astro/src/AstroSchulz.h b/plugins/astro/src/AstroSchulz.h
new file mode 100644
index 000000000..f8971600d
--- /dev/null
+++ b/plugins/astro/src/AstroSchulz.h
@@ -0,0 +1,130 @@
+/*
+ * AstroSchulz.h
+ *
+ * Copyright (C) 2019 by VISUS (Universitaet Stuttgart)
+ * Alle Rechte vorbehalten.
+ */
+
+#ifndef MEGAMOL_ASTRO_ASTROSCHULZ_H_INCLUDED
+#define MEGAMOL_ASTRO_ASTROSCHULZ_H_INCLUDED
+#if (defined(_MSC_VER) && (_MSC_VER > 1000))
+#pragma once
+#endif /* (defined(_MSC_VER) && (_MSC_VER > 1000)) */
+
+#include "astro/AstroDataCall.h"
+
+#include <array>
+
+#include "mmcore/CalleeSlot.h"
+#include "mmcore/CallerSlot.h"
+#include "mmcore/Module.h"
+
+#include "mmcore/moldyn/MultiParticleDataCall.h"
+
+#include "mmcore/param/ParamSlot.h"
+
+#include "mmstd_datatools/table/TableDataCall.h"
+
+
+namespace megamol {
+namespace astro {
+
+    /// <summary>
+    /// Converts from <see cref="AstroDataCall" /> to a table for data
+    /// visualisation.
+    /// </summary>
+    class AstroSchulz : public core::Module {
+
+    public:
+
+        static inline const char *ClassName(void) {
+            return "AstroSchulz"; 
+        }
+
+        static inline const char *Description(void) {
+            return "Converts data contained in a AstroDataCall to a "
+                "TableDataCall";
+        }
+
+        static bool IsAvailable(void) {
+            return true;
+        }
+
+        /** Ctor. */
+        AstroSchulz(void);
+
+        /** Dtor. */
+        virtual ~AstroSchulz(void);
+
+    protected:
+
+        virtual bool create(void);
+
+        virtual void release(void);
+
+    private:
+
+        typedef megamol::stdplugin::datatools::table::TableDataCall::ColumnInfo
+            ColumnInfo;
+
+        static bool getData(AstroDataCall& call, const unsigned int frameID);
+
+        static constexpr inline std::pair<float, float> initialiseRange(void) {
+            return std::make_pair((std::numeric_limits<float>::max)(),
+                std::numeric_limits<float>::lowest());
+        }
+
+        static void updateRange(std::pair<float, float>& range,
+            const float value);
+
+        void convert(float *dst, const std::size_t col, const vec3ArrayPtr& src);
+
+        void convert(float *dst, const std::size_t col, const floatArrayPtr& src);
+
+        void convert(float *dst, const std::size_t col, const boolArrayPtr& src);
+
+        void convert(float *dst, const std::size_t col, const idArrayPtr& src);
+
+        bool getData(core::Call& call);
+
+        bool getData(const unsigned int frameID);
+
+        void getData(float *dst, const AstroDataCall& ast);
+
+        inline std::size_t getHash(void) {
+            auto retval = this->hashInput;
+            retval ^= this->hashState + 0x9e3779b9 + (retval << 6)
+                + (retval >> 2);
+            return retval;
+        }
+
+        bool getHash(core::Call& call);
+
+        bool getRanges(const unsigned int start, const unsigned int cnt);
+
+        inline bool isQuantitative(const std::size_t col) {
+            using megamol::stdplugin::datatools::table::TableDataCall;
+            return ((col < this->columns.size()) && (this->columns[col].Type()
+                == TableDataCall::ColumnType::QUANTITATIVE));
+        }
+
+        void norm(float *dst, const std::size_t col, const vec3ArrayPtr& src);
+
+        void setRange(const std::size_t col, const std::pair<float, float>& src);
+
+        std::vector<ColumnInfo> columns;
+        unsigned int frameID;
+        std::size_t hashInput;
+        std::size_t hashState;
+        core::param::ParamSlot paramFullRange;
+        std::array<core::param::ParamSlot, 27> paramsInclude;
+        std::vector<std::pair<float, float>> ranges;
+        core::CallerSlot slotAstroData;
+        core::CalleeSlot slotTableData;
+        std::vector<float> values;
+    };
+
+} /* end namespace astro */
+} /* end namespace megamol */
+
+#endif /* MEGAMOL_ASTRO_ASTROSCHULZ_H_INCLUDED */
diff --git a/plugins/astro/src/Contest2019DataLoader.cpp b/plugins/astro/src/Contest2019DataLoader.cpp
new file mode 100644
index 000000000..88285777b
--- /dev/null
+++ b/plugins/astro/src/Contest2019DataLoader.cpp
@@ -0,0 +1,719 @@
+/*
+ * Contest2019DataLoader.cpp
+ *
+ * Copyright (C) 2019 by VISUS (Universitaet Stuttgart)
+ * Alle Rechte vorbehalten.
+ */
+
+#include "stdafx.h"
+#include "Contest2019DataLoader.h"
+#include <algorithm>
+#include <fstream>
+#include "astro/AstroDataCall.h"
+#include "mmcore/param/BoolParam.h"
+#include "mmcore/param/FilePathParam.h"
+#include "mmcore/param/FloatParam.h"
+#include "mmcore/param/IntParam.h"
+#include "vislib/sys/Log.h"
+
+using namespace megamol::core;
+using namespace megamol::astro;
+
+#define MAX_MISSED_FILE_NUMBER 5
+
+/*
+ * Contest2019DataLoader::Frame::Frame
+ */
+Contest2019DataLoader::Frame::Frame(view::AnimDataModule& owner) : view::AnimDataModule::Frame(owner), redshift(0.0f) {
+    // intentionally empty
+}
+
+/*
+ * Contest2019DataLoader::Frame::~Frame
+ */
+Contest2019DataLoader::Frame::~Frame(void) {
+    // all the smart pointers are deleted automatically
+}
+
+/*
+ * Contest2019DataLoader::Frame::LoadFrame
+ */
+bool Contest2019DataLoader::Frame::LoadFrame(std::string filepath, unsigned int frameIdx, float redshift) {
+    if (filepath.empty()) return false;
+    this->frame = frameIdx;
+    std::vector<SavedData> readDataVec;
+
+    std::ifstream file(filepath, std::ios::binary);
+    if (!file.is_open()) {
+        vislib::sys::Log::DefaultLog.WriteError("Could not open input file \"%s\"", filepath.c_str());
+        return false;
+    }
+    // determine size of the file
+    file.seekg(0, std::ios_base::end);
+    uint64_t size = file.tellg();
+    uint64_t partCount = size / sizeof(SavedData);
+    readDataVec.resize(partCount);
+
+    // read the data
+    file.seekg(0, std::ios_base::beg);
+    file.read(reinterpret_cast<char*>(readDataVec.data()), sizeof(SavedData) * partCount);
+
+    // init the fields if necessary
+    if (this->positions == nullptr) {
+        this->positions = std::make_shared<std::vector<glm::vec3>>();
+    }
+    if (this->velocities == nullptr) {
+        this->velocities = std::make_shared<std::vector<glm::vec3>>();
+    }
+    if (this->velocityDerivatives == nullptr) {
+        this->velocityDerivatives = std::make_shared<std::vector<glm::vec3>>();
+    }
+    if (this->temperatures == nullptr) {
+        this->temperatures = std::make_shared<std::vector<float>>();
+    }
+    if (this->temperatureDerivatives == nullptr) {
+        this->temperatureDerivatives = std::make_shared<std::vector<float>>();
+    }
+    if (this->masses == nullptr) {
+        this->masses = std::make_shared<std::vector<float>>();
+    }
+    if (this->internalEnergies == nullptr) {
+        this->internalEnergies = std::make_shared<std::vector<float>>();
+    }
+    if (this->internalEnergyDerivatives == nullptr) {
+        this->internalEnergyDerivatives = std::make_shared<std::vector<float>>();
+    }
+    if (this->smoothingLengths == nullptr) {
+        this->smoothingLengths = std::make_shared<std::vector<float>>();
+    }
+    if (this->smoothingLengthDerivatives == nullptr) {
+        this->smoothingLengthDerivatives = std::make_shared<std::vector<float>>();
+    }
+    if (this->molecularWeights == nullptr) {
+        this->molecularWeights = std::make_shared<std::vector<float>>();
+    }
+    if (this->molecularWeightDerivatives == nullptr) {
+        this->molecularWeightDerivatives = std::make_shared<std::vector<float>>();
+    }
+    if (this->densities == nullptr) {
+        this->densities = std::make_shared<std::vector<float>>();
+    }
+    if (this->densityDerivatives == nullptr) {
+        this->densityDerivatives = std::make_shared<std::vector<float>>();
+    }
+    if (this->gravitationalPotentials == nullptr) {
+        this->gravitationalPotentials = std::make_shared<std::vector<float>>();
+    }
+    if (this->gravitationalPotentialDerivatives == nullptr) {
+        this->gravitationalPotentialDerivatives = std::make_shared<std::vector<float>>();
+    }
+    if (this->entropy == nullptr) {
+        this->entropy = std::make_shared<std::vector<float>>();
+    }
+    if (this->entropyDerivatives == nullptr) {
+        this->entropyDerivatives = std::make_shared<std::vector<float>>();
+    }
+    if (this->isBaryonFlags == nullptr) {
+        this->isBaryonFlags = std::make_shared<std::vector<bool>>();
+    }
+    if (this->isStarFlags == nullptr) {
+        this->isStarFlags = std::make_shared<std::vector<bool>>();
+    }
+    if (this->isWindFlags == nullptr) {
+        this->isWindFlags = std::make_shared<std::vector<bool>>();
+    }
+    if (this->isStarFormingGasFlags == nullptr) {
+        this->isStarFormingGasFlags = std::make_shared<std::vector<bool>>();
+    }
+    if (this->isAGNFlags == nullptr) {
+        this->isAGNFlags = std::make_shared<std::vector<bool>>();
+    }
+    if (this->particleIDs == nullptr) {
+        this->particleIDs = std::make_shared<std::vector<int64_t>>();
+    }
+    if (this->agnDistances == nullptr) {
+        this->agnDistances = std::make_shared<std::vector<float>>();
+    }
+
+    this->positions->resize(partCount);
+    this->velocities->resize(partCount);
+    this->temperatures->resize(partCount);
+    this->masses->resize(partCount);
+    this->internalEnergies->resize(partCount);
+    this->smoothingLengths->resize(partCount);
+    this->molecularWeights->resize(partCount);
+    this->densities->resize(partCount);
+    this->gravitationalPotentials->resize(partCount);
+    this->entropy->resize(partCount);
+    this->isBaryonFlags->resize(partCount);
+    this->isStarFlags->resize(partCount);
+    this->isWindFlags->resize(partCount);
+    this->isStarFormingGasFlags->resize(partCount);
+    this->isAGNFlags->resize(partCount);
+    this->particleIDs->resize(partCount);
+    this->agnDistances->resize(partCount);
+
+    this->velocityDerivatives->resize(partCount);
+    this->temperatureDerivatives->resize(partCount);
+    this->internalEnergyDerivatives->resize(partCount);
+    this->smoothingLengthDerivatives->resize(partCount);
+    this->molecularWeightDerivatives->resize(partCount);
+    this->densityDerivatives->resize(partCount);
+    this->gravitationalPotentialDerivatives->resize(partCount);
+    this->entropyDerivatives->resize(partCount);
+
+    // copy the data over
+
+    this->redshift = redshift;
+    for (uint64_t i = 0; i < partCount; ++i) {
+        const auto& s = readDataVec[i];
+        this->positions->operator[](i) = glm::vec3(s.x, s.y, s.z);
+        this->velocities->operator[](i) = glm::vec3(s.vx, s.vy, s.vz);
+        this->temperatures->operator[](i) = 0.0f; // oops, we do not have temperatures
+        this->masses->operator[](i) = s.mass;
+        this->internalEnergies->operator[](i) = s.internalEnergy;
+        this->smoothingLengths->operator[](i) = s.smoothingLength;
+        this->molecularWeights->operator[](i) = s.molecularWeight;
+        this->densities->operator[](i) = s.density;
+        this->gravitationalPotentials->operator[](i) = s.gravitationalPotential;
+        this->entropy->operator[](i) = 0.0f; // we calculate it later
+        this->isBaryonFlags->operator[](i) = (s.bitmask >> 1) & 0x1;
+        this->isStarFlags->operator[](i) = (s.bitmask >> 5) & 0x1;
+        this->isWindFlags->operator[](i) = (s.bitmask >> 6) & 0x1;
+        this->isStarFormingGasFlags->operator[](i) = (s.bitmask >> 7) & 0x1;
+        this->isAGNFlags->operator[](i) = (s.bitmask >> 8) & 0x1;
+        this->particleIDs->operator[](i) = s.particleID;
+
+        // calculate the temperature ourselves
+        // formula out of the mail of J.D Emberson 20.6.2019
+        if (this->isBaryonFlags->at(i)) {
+            this->temperatures->operator[](i) =
+                4.8e5f * this->internalEnergies->at(i) / std::pow(1.0f + redshift, 3.0f);
+        }
+
+        // calculate the entropy ourselves
+        // formula directly from the contest description
+        if (this->isBaryonFlags->at(i) && this->temperatures->at(i) > 0.0f && this->densities->at(i) > 0.0f) {
+            auto t = (*this->temperatures)[i];
+            auto p = (*this->densities)[i];
+            this->entropy->operator[](i) = std::log(t / std::pow(p, 2.0f / 3.0f));
+
+            // This is Juhans formula:
+            // auto mu = (*this->masses)[i];
+            // auto eps = (*this->internalEnergies)[i];
+            //(*this->entropy)[i] = std::log((mu * eps) / std::pow(p, 2.0f / 3.0f));
+        }
+
+        // the derivatives will be calculated later, when the frame before and after are known
+    }
+    return true;
+}
+
+/*
+ * Contest2019DataLoader::Frame::SetData
+ */
+void Contest2019DataLoader::Frame::SetData(
+    AstroDataCall& call, const vislib::math::Cuboid<float>& boundingBox, const vislib::math::Cuboid<float>& clipBox) {
+    if (this->positions == nullptr || this->positions->empty()) {
+        call.ClearValues();
+    }
+    call.SetPositions(this->positions);
+    call.SetVelocities(this->velocities);
+    call.SetVelocityDerivatives(this->velocityDerivatives);
+    call.SetTemperature(this->temperatures);
+    call.SetTemperatureDerivatives(this->temperatureDerivatives);
+    call.SetMass(this->masses);
+    call.SetInternalEnergy(this->internalEnergies);
+    call.SetInternalEnergyDerivatives(this->internalEnergyDerivatives);
+    call.SetSmoothingLength(this->smoothingLengths);
+    call.SetSmoothingLengthDerivatives(this->smoothingLengthDerivatives);
+    call.SetMolecularWeights(this->molecularWeights);
+    call.SetMolecularWeightDerivatives(this->molecularWeightDerivatives);
+    call.SetDensity(this->densities);
+    call.SetDensityDerivative(this->densityDerivatives);
+    call.SetGravitationalPotential(this->gravitationalPotentials);
+    call.SetGravitationalPotentialDerivatives(this->gravitationalPotentialDerivatives);
+    call.SetEntropy(this->entropy);
+    call.SetEntropyDerivatives(this->entropyDerivatives);
+    call.SetIsBaryonFlags(this->isBaryonFlags);
+    call.SetIsStarFlags(this->isStarFlags);
+    call.SetIsWindFlags(this->isWindFlags);
+    call.SetIsStarFormingGasFlags(this->isStarFormingGasFlags);
+    call.SetIsAGNFlags(this->isAGNFlags);
+    call.SetParticleIDs(this->particleIDs);
+    call.SetAGNDistances(this->agnDistances);
+}
+
+/*
+ * Contest2019DataLoader::Frame::ZeroDerivatives
+ */
+void Contest2019DataLoader::Frame::ZeroDerivatives(void) {
+    if (this->velocityDerivatives != nullptr) {
+        std::fill(this->velocityDerivatives->begin(), this->velocityDerivatives->end(), glm::vec3(0.0f));
+    }
+    if (this->temperatureDerivatives != nullptr) {
+        std::fill(this->temperatureDerivatives->begin(), this->temperatureDerivatives->end(), 0.0f);
+    }
+    if (this->internalEnergyDerivatives != nullptr) {
+        std::fill(this->internalEnergyDerivatives->begin(), this->internalEnergyDerivatives->end(), 0.0f);
+    }
+    if (this->smoothingLengthDerivatives != nullptr) {
+        std::fill(this->smoothingLengthDerivatives->begin(), this->smoothingLengthDerivatives->end(), 0.0f);
+    }
+    if (this->molecularWeightDerivatives != nullptr) {
+        std::fill(this->molecularWeightDerivatives->begin(), this->molecularWeightDerivatives->end(), 0.0f);
+    }
+    if (this->densityDerivatives != nullptr) {
+        std::fill(this->densityDerivatives->begin(), this->densityDerivatives->end(), 0.0f);
+    }
+    if (this->gravitationalPotentialDerivatives != nullptr) {
+        std::fill(
+            this->gravitationalPotentialDerivatives->begin(), this->gravitationalPotentialDerivatives->end(), 0.0f);
+    }
+    if (this->entropyDerivatives != nullptr) {
+        std::fill(this->entropyDerivatives->begin(), this->entropyDerivatives->end(), 0.0f);
+    }
+}
+
+/*
+ * Contest2019DataLoader::Frame::ZeroAGNDistances
+ */
+void Contest2019DataLoader::Frame::ZeroAGNDistances(void) {
+    if (this->agnDistances != nullptr) {
+        std::fill(this->agnDistances->begin(), this->agnDistances->end(), 0.0f);
+    }
+}
+
+/*
+ * Contest2019DataLoader::Frame::CalculateDerivatives
+ */
+void Contest2019DataLoader::Frame::CalculateDerivatives(
+    Contest2019DataLoader::Frame* frameBefore, Contest2019DataLoader::Frame* frameAfter) {
+    // if there is only one frame we leave the derivatives at 0
+    if ((frameBefore->frame == frameAfter->frame) && (this->frame == frameBefore->frame)) {
+        return;
+    }
+    if (frameBefore->frame == this->frame) {
+        this->CalculateDerivativesForwardDifferences(frameAfter);
+        return;
+    }
+    if (frameAfter->frame == this->frame) {
+        this->CalculateDerivativesBackwardDifferences(frameAfter);
+        return;
+    }
+    this->CalculateDerivativesCentralDifferences(frameBefore, frameAfter);
+}
+
+/*
+ * Contest2019DataLoader::Frame::buildParticleIDMap
+ */
+void Contest2019DataLoader::Frame::buildParticleIDMap(const Frame* frame, std::map<int64_t, int64_t>& outIndexMap) {
+    outIndexMap.clear();
+    if (frame != nullptr && frame->particleIDs != nullptr) {
+        for (int64_t i = 0; i < frame->particleIDs->size(); i++) {
+            outIndexMap.insert(std::pair<int64_t, int64_t>(frame->particleIDs->at(i), i));
+        }
+    }
+}
+
+/*
+ * Contest2019DataLoader::Frame::CalculateDerivativesBackwardDifferences
+ */
+void Contest2019DataLoader::Frame::CalculateDerivativesBackwardDifferences(Contest2019DataLoader::Frame* frameBefore) {
+    if (this->particleIDs == nullptr) return;
+    std::map<int64_t, int64_t> mapBefore;
+    this->buildParticleIDMap(frameBefore, mapBefore);
+    int64_t idbefore;
+    for (int64_t i = 0; i < this->particleIDs->size(); ++i) {
+        idbefore = (mapBefore.count(this->particleIDs->at(i)) > 0) ? mapBefore[this->particleIDs->at(i)] : -1;
+        if (idbefore >= 0) {
+            this->velocityDerivatives->at(i) =
+                backwardDifference(this->velocities->at(i), frameBefore->velocities->at(idbefore));
+            this->temperatureDerivatives->at(i) =
+                backwardDifference(this->temperatures->at(i), frameBefore->temperatures->at(idbefore));
+            this->internalEnergyDerivatives->at(i) =
+                backwardDifference(this->internalEnergies->at(i), frameBefore->internalEnergies->at(idbefore));
+            this->smoothingLengthDerivatives->at(i) =
+                backwardDifference(this->smoothingLengths->at(i), frameBefore->smoothingLengths->at(idbefore));
+            this->molecularWeightDerivatives->at(i) =
+                backwardDifference(this->molecularWeights->at(i), frameBefore->molecularWeights->at(idbefore));
+            this->densityDerivatives->at(i) =
+                backwardDifference(this->densities->at(i), frameBefore->densities->at(idbefore));
+            this->gravitationalPotentialDerivatives->at(i) = backwardDifference(
+                this->gravitationalPotentials->at(i), frameBefore->gravitationalPotentials->at(idbefore));
+            this->entropyDerivatives->at(i) =
+                backwardDifference(this->entropy->at(i), frameBefore->entropy->at(idbefore));
+        }
+    }
+}
+
+/*
+ * Contest2019DataLoader::Frame::CalculateDerivativesForwardDifferences
+ */
+void Contest2019DataLoader::Frame::CalculateDerivativesForwardDifferences(Contest2019DataLoader::Frame* frameAfter) {
+    if (this->particleIDs == nullptr) return;
+    std::map<int64_t, int64_t> mapAfter;
+    this->buildParticleIDMap(frameAfter, mapAfter);
+    int64_t idafter;
+    for (int64_t i = 0; i < this->particleIDs->size(); ++i) {
+        idafter = (mapAfter.count(this->particleIDs->at(i)) > 0) ? mapAfter[this->particleIDs->at(i)] : -1;
+        if (idafter >= 0) {
+            this->velocityDerivatives->at(i) =
+                forwardDifference(this->velocities->at(i), frameAfter->velocities->at(idafter));
+            this->temperatureDerivatives->at(i) =
+                forwardDifference(this->temperatures->at(i), frameAfter->temperatures->at(idafter));
+            this->internalEnergyDerivatives->at(i) =
+                forwardDifference(this->internalEnergies->at(i), frameAfter->internalEnergies->at(idafter));
+            this->smoothingLengthDerivatives->at(i) =
+                forwardDifference(this->smoothingLengths->at(i), frameAfter->smoothingLengths->at(idafter));
+            this->molecularWeightDerivatives->at(i) =
+                forwardDifference(this->molecularWeights->at(i), frameAfter->molecularWeights->at(idafter));
+            this->densityDerivatives->at(i) =
+                forwardDifference(this->densities->at(i), frameAfter->densities->at(idafter));
+            this->gravitationalPotentialDerivatives->at(i) = forwardDifference(
+                this->gravitationalPotentials->at(i), frameAfter->gravitationalPotentials->at(idafter));
+            this->entropyDerivatives->at(i) = forwardDifference(this->entropy->at(i), frameAfter->entropy->at(idafter));
+        }
+    }
+}
+
+/*
+ * Contest2019DataLoader::Frame::CalculateDerivativesCentralDifferences
+ */
+void Contest2019DataLoader::Frame::CalculateDerivativesCentralDifferences(
+    Contest2019DataLoader::Frame* frameBefore, Contest2019DataLoader::Frame* frameAfter) {
+    if (this->particleIDs == nullptr) return;
+    std::map<int64_t, int64_t> mapBefore, mapAfter;
+    this->buildParticleIDMap(frameBefore, mapBefore);
+    this->buildParticleIDMap(frameAfter, mapAfter);
+    int64_t idbefore, idafter;
+    for (int64_t i = 0; i < this->particleIDs->size(); ++i) {
+        // retrieve indices in other frames
+        idbefore = (mapBefore.count(this->particleIDs->at(i)) > 0) ? mapBefore[this->particleIDs->at(i)] : -1;
+        idafter = (mapAfter.count(this->particleIDs->at(i)) > 0) ? mapAfter[this->particleIDs->at(i)] : -1;
+        // fallback to other difference modes if some particle ids are not available
+        if (idbefore >= 0 && idafter >= 0) {
+            this->velocityDerivatives->at(i) =
+                centralDifference(frameBefore->velocities->at(idbefore), frameAfter->velocities->at(idafter));
+            this->temperatureDerivatives->at(i) =
+                centralDifference(frameBefore->temperatures->at(idbefore), frameAfter->temperatures->at(idafter));
+            this->internalEnergyDerivatives->at(i) = centralDifference(
+                frameBefore->internalEnergies->at(idbefore), frameAfter->internalEnergies->at(idafter));
+            this->smoothingLengthDerivatives->at(i) = centralDifference(
+                frameBefore->smoothingLengths->at(idbefore), frameAfter->smoothingLengths->at(idafter));
+            this->molecularWeightDerivatives->at(i) = centralDifference(
+                frameBefore->molecularWeights->at(idbefore), frameAfter->molecularWeights->at(idafter));
+            this->densityDerivatives->at(i) =
+                centralDifference(frameBefore->densities->at(idbefore), frameAfter->densities->at(idafter));
+            this->gravitationalPotentialDerivatives->at(i) = centralDifference(
+                frameBefore->gravitationalPotentials->at(idbefore), frameAfter->gravitationalPotentials->at(idafter));
+            this->entropyDerivatives->at(i) =
+                centralDifference(frameBefore->entropy->at(idbefore), frameAfter->entropy->at(idafter));
+        } else if (idbefore < 0 && idafter >= 0) {
+            this->velocityDerivatives->at(i) =
+                forwardDifference(this->velocities->at(i), frameAfter->velocities->at(idafter));
+            this->temperatureDerivatives->at(i) =
+                forwardDifference(this->temperatures->at(i), frameAfter->temperatures->at(idafter));
+            this->internalEnergyDerivatives->at(i) =
+                forwardDifference(this->internalEnergies->at(i), frameAfter->internalEnergies->at(idafter));
+            this->smoothingLengthDerivatives->at(i) =
+                forwardDifference(this->smoothingLengths->at(i), frameAfter->smoothingLengths->at(idafter));
+            this->molecularWeightDerivatives->at(i) =
+                forwardDifference(this->molecularWeights->at(i), frameAfter->molecularWeights->at(idafter));
+            this->densityDerivatives->at(i) =
+                forwardDifference(this->densities->at(i), frameAfter->densities->at(idafter));
+            this->gravitationalPotentialDerivatives->at(i) = forwardDifference(
+                this->gravitationalPotentials->at(i), frameAfter->gravitationalPotentials->at(idafter));
+            this->entropyDerivatives->at(i) = forwardDifference(this->entropy->at(i), frameAfter->entropy->at(idafter));
+        } else if (idafter < 0 && idbefore >= 0) {
+            this->velocityDerivatives->at(i) =
+                backwardDifference(this->velocities->at(i), frameBefore->velocities->at(idbefore));
+            this->temperatureDerivatives->at(i) =
+                backwardDifference(this->temperatures->at(i), frameBefore->temperatures->at(idbefore));
+            this->internalEnergyDerivatives->at(i) =
+                backwardDifference(this->internalEnergies->at(i), frameBefore->internalEnergies->at(idbefore));
+            this->smoothingLengthDerivatives->at(i) =
+                backwardDifference(this->smoothingLengths->at(i), frameBefore->smoothingLengths->at(idbefore));
+            this->molecularWeightDerivatives->at(i) =
+                backwardDifference(this->molecularWeights->at(i), frameBefore->molecularWeights->at(idbefore));
+            this->densityDerivatives->at(i) =
+                backwardDifference(this->densities->at(i), frameBefore->densities->at(idbefore));
+            this->gravitationalPotentialDerivatives->at(i) = backwardDifference(
+                this->gravitationalPotentials->at(i), frameBefore->gravitationalPotentials->at(idbefore));
+            this->entropyDerivatives->at(i) =
+                backwardDifference(this->entropy->at(i), frameBefore->entropy->at(idbefore));
+        }
+    }
+}
+
+/*
+ * Contest2019DataLoader::Frame::CalculateAGNDistances
+ */
+void Contest2019DataLoader::Frame::CalculateAGNDistances(void) {
+    if (this->positions == nullptr) return;
+    if (this->isAGNFlags == nullptr) return;
+    if (this->agnDistances == nullptr) return;
+
+    // get out all AGN Positions
+    std::vector<glm::vec3> agnPositions;
+    for (size_t i = 0; i < this->positions->size(); ++i) {
+        if (this->isAGNFlags->at(i)) {
+            agnPositions.push_back(this->positions->at(i));
+        }
+    }
+    // add all mirrored version to account for cyclic boundary conditions
+    std::vector<glm::vec3> apos;
+    for (size_t i = 0; i < agnPositions.size(); i++) {
+        const auto& pos = agnPositions.at(i);
+        for (int x = -1; x <= 1; x++) {
+            for (int y = -1; y <= 1; y++) {
+                for (int z = -1; z <= 1; z++) {
+                    apos.push_back(pos + glm::vec3(static_cast<float>(x * 64.0f), static_cast<float>(y * 64.0f),
+                                             static_cast<float>(z * 64.0f)));
+                }
+            }
+        }
+    }
+
+    if (apos.size() == 0) return;
+    for (size_t i = 0; i < this->positions->size(); ++i) {
+        float mindist = std::numeric_limits<float>::max();
+        auto& myPos = this->positions->at(i);
+        for (const auto& agnPos : apos) {
+            float dist = glm::distance(myPos, agnPos);
+            if (dist < mindist) mindist = dist;
+        }
+        this->agnDistances->at(i) = mindist;
+    }
+}
+
+/*
+ * Contest2019DataLoader::Contest2019DataLoader
+ */
+Contest2019DataLoader::Contest2019DataLoader(void)
+    : view::AnimDataModule()
+    , getDataSlot("getData", "Slot for handling the file loading requests")
+    , firstFilename("firstFilename", "The name of the first file to load")
+    , filesToLoad("filesToLoad",
+          "The total number of files that should be loaded. A value smaller than 0 means all available "
+          "ones from the first given are loaded.")
+    , calculateDerivatives("calculateDerivatives",
+          "Enables the calculation of derivatives of all relevant values. "
+          "This option increases the frame loading time significantly. The effect of this slot might be delayed as "
+          "already existing frames are not re-evaluated.")
+    , calculateAGNDistances("calculateAGNDistances",
+          "Enables the calculation of the distance to the AGNs. This option increases the frame loading time "
+          "significantly. The effect of this slot might be delayed as already existing frames are not re-evaluated.") {
+
+    this->getDataSlot.SetCallback(AstroDataCall::ClassName(),
+        AstroDataCall::FunctionName(AstroDataCall::CallForGetData), &Contest2019DataLoader::getDataCallback);
+    this->getDataSlot.SetCallback(AstroDataCall::ClassName(),
+        AstroDataCall::FunctionName(AstroDataCall::CallForGetExtent), &Contest2019DataLoader::getExtentCallback);
+    this->MakeSlotAvailable(&this->getDataSlot);
+
+    this->firstFilename.SetParameter(new param::FilePathParam(""));
+    this->firstFilename.SetUpdateCallback(&Contest2019DataLoader::filenameChangedCallback);
+    this->MakeSlotAvailable(&this->firstFilename);
+
+    this->filesToLoad.SetParameter(new param::IntParam(-1));
+    this->filesToLoad.SetUpdateCallback(&Contest2019DataLoader::filenameChangedCallback);
+    this->MakeSlotAvailable(&this->filesToLoad);
+
+    this->calculateDerivatives.SetParameter(new param::BoolParam(true));
+    this->MakeSlotAvailable(&this->calculateDerivatives);
+
+    this->calculateAGNDistances.SetParameter(new param::BoolParam(true));
+    this->MakeSlotAvailable(&this->calculateAGNDistances);
+
+    // static bounding box size, because we know (TM)
+    this->boundingBox = vislib::math::Cuboid<float>(0.0f, 0.0f, 0.0f, 64.0f, 64.0f, 64.0f);
+    this->clipBox = this->boundingBox;
+
+    this->data_hash = 0;
+
+    this->setFrameCount(1);
+    this->initFrameCache(1);
+}
+
+/*
+ * Contest2019DataLoader::~Contest2019DataLoader
+ */
+Contest2019DataLoader::~Contest2019DataLoader(void) { this->Release(); }
+
+/*
+ * Contest2019DataLoader::constructFrame
+ */
+view::AnimDataModule::Frame* Contest2019DataLoader::constructFrame(void) const {
+    Frame* f = new Frame(*const_cast<Contest2019DataLoader*>(this));
+    return f;
+}
+
+/*
+ * Contest2019DataLoader::create
+ */
+bool Contest2019DataLoader::create(void) { return true; }
+
+/*
+ * Contest2019DataLoader::loadFrame
+ */
+void Contest2019DataLoader::loadFrame(view::AnimDataModule::Frame* frame, unsigned int idx) {
+    using vislib::sys::Log;
+    Frame* f = dynamic_cast<Frame*>(frame);
+    // the allocation of the dummy frames here is stupid and should be done globally to avoid too many allocations.
+    // the parallel nature of the AnimDataModule makes this impossible
+    Frame* fbefore = new Frame(*this);
+    Frame* fafter = new Frame(*this);
+    if (f == nullptr) return;
+    unsigned int frameID = idx % this->FrameCount();
+    unsigned int frameIDBefore = frameID > 0 ? (frameID - 1) : frameID;
+    unsigned int frameIDAfter = frameID < this->redshiftsForFilename.size() - 1 ? (frameID + 1) : frameID;
+    std::string filename = "";
+    std::string filenameBefore = "";
+    std::string filenameAfter = "";
+    float redshift = 0.0f;
+    float redshiftBefore = 0.0f;
+    float redshiftAfter = 0.0f;
+    if (frameID < this->filenames.size() && frameID < this->redshiftsForFilename.size()) {
+        filename = this->filenames.at(frameID);
+        redshift = this->redshiftsForFilename.at(frameID);
+    }
+    if (frameIDBefore < this->filenames.size() && frameIDBefore < this->redshiftsForFilename.size()) {
+        filenameBefore = this->filenames.at(frameIDBefore);
+        redshiftBefore = this->redshiftsForFilename.at(frameIDBefore);
+    }
+    if (frameIDAfter < this->filenames.size() && frameIDAfter < this->redshiftsForFilename.size()) {
+        filenameAfter = this->filenames.at(frameIDAfter);
+        redshiftAfter = this->redshiftsForFilename.at(frameIDAfter);
+    }
+    if (!filename.empty()) {
+        if (!f->LoadFrame(filename, frameID, redshift)) {
+            Log::DefaultLog.WriteMsg(Log::LEVEL_ERROR, "Unable to read frame %d from file\n", idx);
+        }
+    }
+    bool calcDerivatives = this->calculateDerivatives.Param<param::BoolParam>()->Value();
+    if (!filenameBefore.empty() && calcDerivatives) {
+        if (!fbefore->LoadFrame(filenameBefore, frameIDBefore, redshiftBefore)) {
+            Log::DefaultLog.WriteMsg(Log::LEVEL_ERROR, "Unable to read frame before frame %d from file\n", idx);
+        }
+    }
+    if (!filenameAfter.empty() && calcDerivatives) {
+        if (!fafter->LoadFrame(filenameAfter, frameIDAfter, redshiftAfter)) {
+            Log::DefaultLog.WriteMsg(Log::LEVEL_ERROR, "Unable to read frame after frame %d from file\n", idx);
+        }
+    }
+    f->ZeroDerivatives();
+    if (calcDerivatives) {
+        f->CalculateDerivatives(fbefore, fafter);
+    }
+    f->ZeroAGNDistances();
+    if (this->calculateAGNDistances.Param<param::BoolParam>()->Value()) {
+        f->CalculateAGNDistances();
+    }
+    delete fbefore;
+    delete fafter;
+}
+
+/*
+ * Contest2019DataLoader::release
+ */
+void Contest2019DataLoader::release(void) { this->resetFrameCache(); }
+
+/*
+ * Contest2019DataLoader::filenameChangedCallback
+ */
+bool Contest2019DataLoader::filenameChangedCallback(param::ParamSlot& slot) {
+    this->filenames.clear();
+    this->resetFrameCache();
+    this->data_hash++;
+    std::string firstfile(this->firstFilename.Param<param::FilePathParam>()->Value());
+    int toLoadCount = this->filesToLoad.Param<param::IntParam>()->Value();
+
+    /* Note for all debugging purposes: The application will land here once on startup with only the default values
+     * for the input parameters. This first call can be ignored.*/
+
+    if (firstfile.empty()) return false;
+    if (toLoadCount == 0) return false;
+
+    auto lastPoint = firstfile.find_last_of('.');
+    std::string prefix = firstfile.substr(0, lastPoint + 1);
+    std::string postfix = firstfile.substr(lastPoint + 1);
+    int firstID = std::stoi(postfix);
+    int curID = firstID;
+    int loadedCounter = 0;
+    int missedFiles = 0;
+
+    bool done = false;
+    while (!done) {
+        std::string curFilename = prefix + std::to_string(curID);
+
+        // TODO: WARNING: This scalefactor calculation is dependant on the used data set containing 625 time steps
+        // starting at z=200 going to z=0. For other data set sizes this calculation has to be adapted. (The physicists
+        // were too stupid to include this value into the data)
+        float scaleFactor = 1.0f / 201.0f + static_cast<float>(curID + 1) * (1.0f - 1.0f / 201.0f) / 625.0f;
+        float redshift = (1.0f / scaleFactor) - 1.0f;
+
+        std::ifstream file(curFilename);
+        if (file.good()) {
+            file.close();
+            this->filenames.push_back(curFilename);
+            this->redshiftsForFilename.push_back(redshift);
+        } else {
+            file.close();
+            if (toLoadCount < 0) {
+                done = true;
+            } else {
+                vislib::sys::Log::DefaultLog.WriteWarn(
+                    "Could not find the suggested input file \"%s\"", curFilename.c_str());
+                missedFiles++;
+            }
+        }
+        loadedCounter++;
+        curID++;
+        if (loadedCounter >= toLoadCount && toLoadCount > 0) {
+            done = true;
+        }
+        if (missedFiles > MAX_MISSED_FILE_NUMBER) {
+            vislib::sys::Log::DefaultLog.WriteWarn(
+                "Already could not open %i files, aborting further checking", int(MAX_MISSED_FILE_NUMBER));
+            done = true;
+            return false;
+        }
+    }
+    this->setFrameCount(static_cast<unsigned int>(this->filenames.size()));
+    this->initFrameCache(std::min(this->FrameCount(), 100u)); // TODO change this to a dynamic / user selected value
+
+    return true;
+}
+
+/*
+ * Contest2019DataLoader::getDataCallback
+ */
+bool Contest2019DataLoader::getDataCallback(Call& caller) {
+    AstroDataCall* ast = dynamic_cast<AstroDataCall*>(&caller);
+    if (ast == nullptr) return false;
+
+    Frame* f = dynamic_cast<Frame*>(this->requestLockedFrame(ast->FrameID(), ast->IsFrameForced()));
+    if (f == nullptr) return false;
+    ast->SetUnlocker(new Unlocker(*f));
+    ast->SetFrameID(f->FrameNumber());
+    ast->SetDataHash(this->data_hash);
+    f->SetData(*ast, this->boundingBox, this->clipBox);
+
+    return true;
+}
+
+/*
+ * Contest2019DataLoader::getExtentCallback
+ */
+bool Contest2019DataLoader::getExtentCallback(Call& caller) {
+    AstroDataCall* ast = dynamic_cast<AstroDataCall*>(&caller);
+    if (ast == nullptr) return false;
+
+    ast->SetFrameCount(this->FrameCount());
+    ast->AccessBoundingBoxes().Clear();
+    ast->AccessBoundingBoxes().SetObjectSpaceBBox(this->boundingBox);
+    ast->AccessBoundingBoxes().SetObjectSpaceClipBox(this->clipBox);
+    ast->SetDataHash(this->data_hash);
+
+    return true;
+}
diff --git a/plugins/astro/src/Contest2019DataLoader.h b/plugins/astro/src/Contest2019DataLoader.h
new file mode 100644
index 000000000..986a41077
--- /dev/null
+++ b/plugins/astro/src/Contest2019DataLoader.h
@@ -0,0 +1,363 @@
+/*
+ * Constest2019DataLoader.h
+ *
+ * Copyright (C) 2019 by VISUS (Universitaet Stuttgart)
+ * Alle Rechte vorbehalten.
+ */
+
+#ifndef MEGAMOLCORE_CONTEST2019DATALOADER_H_INCLUDED
+#define MEGAMOLCORE_CONTEST2019DATALOADER_H_INCLUDED
+#if (defined(_MSC_VER) && (_MSC_VER > 1000))
+#    pragma once
+#endif /* (defined(_MSC_VER) && (_MSC_VER > 1000)) */
+
+#include <map>
+#include "astro/AstroDataCall.h"
+#include "mmcore/CalleeSlot.h"
+#include "mmcore/param/ParamSlot.h"
+#include "mmcore/view/AnimDataModule.h"
+#include "vislib/math/Cuboid.h"
+
+namespace megamol {
+namespace astro {
+
+template <typename T> T centralDifference(T valBefore, T valAfter, float stepSize = 1.0f) {
+    return (valAfter - valBefore) / (2.0f * stepSize);
+}
+
+template <typename T> T forwardDifference(T myVal, T valAfter, float stepSize = 1.0f) {
+    return (valAfter - myVal) / stepSize;
+}
+
+template <typename T> T backwardDifference(T myVal, T valBefore, float stepSize = 1.0f) {
+    return (myVal - valBefore) / stepSize;
+}
+
+class Contest2019DataLoader : public core::view::AnimDataModule {
+public:
+    /**
+     * Answer the name of this module.
+     *
+     * @return The name of this module.
+     */
+    static const char* ClassName(void) { return "Contest2019DataLoader"; }
+
+    /**
+     * Answer a human readable description of this module.
+     *
+     * @return A human readable description of this module.
+     */
+    static const char* Description(void) { return "Data source module for the data of the SciVis Contest 2019."; }
+
+    /**
+     * Answers whether this module is available on the current system.
+     *
+     * @return 'true' if the module is available, 'false' otherwise.
+     */
+    static bool IsAvailable(void) { return true; }
+
+    /** Ctor. */
+    Contest2019DataLoader(void);
+
+    /** Dtor. */
+    virtual ~Contest2019DataLoader(void);
+
+protected:
+    /**
+     * Constructs a new frame
+     */
+    virtual core::view::AnimDataModule::Frame* constructFrame(void) const;
+
+    /**
+     * Function that is called once upon initialization.
+     *
+     * @return True on success, false otherwise
+     */
+    virtual bool create(void);
+
+    /**
+     * Loads the data of a single frame from disk
+     *
+     * @param frame Pointer to the frame that will contain the data
+     * @param idx The index of the frame
+     */
+    virtual void loadFrame(core::view::AnimDataModule::Frame* frame, unsigned int idx);
+
+    /**
+     * Function that is called once upon destruction
+     */
+    virtual void release(void);
+
+    /**
+     * Frame description
+     */
+    class Frame : public core::view::AnimDataModule::Frame {
+    public:
+        /** Frame Copy Ctor. */
+        Frame(core::view::AnimDataModule& owner);
+
+        /** Frame Dtor. */
+        virtual ~Frame(void);
+
+        /**
+         * Clears the frame data by deleting all contained pointers
+         */
+        inline void Clear(void) {
+            this->positions.reset();
+            this->velocities.reset();
+            this->temperatures.reset();
+            this->masses.reset();
+            this->internalEnergies.reset();
+            this->smoothingLengths.reset();
+            this->molecularWeights.reset();
+            this->densities.reset();
+            this->gravitationalPotentials.reset();
+            this->entropy.reset();
+            this->isBaryonFlags.reset();
+            this->isStarFlags.reset();
+            this->isWindFlags.reset();
+            this->isStarFormingGasFlags.reset();
+            this->isAGNFlags.reset();
+            this->particleIDs.reset();
+
+            this->velocityDerivatives.reset();
+            this->temperatureDerivatives.reset();
+            this->internalEnergyDerivatives.reset();
+            this->smoothingLengthDerivatives.reset();
+            this->molecularWeightDerivatives.reset();
+            this->densityDerivatives.reset();
+            this->gravitationalPotentialDerivatives.reset();
+            this->entropyDerivatives.reset();
+        }
+
+        /**
+         * Loads a frame from a given file into this object
+         *
+         * @param filepath The path to the file to load from. As all frames are in seperate files, no open stream is
+         * necessary.
+         * @param frameIdx The zero-based index of the loaded frame.
+         * @param redshift The redshift value for the frame
+         *
+         * @return True on success, false otherwise.
+         */
+        bool LoadFrame(std::string filepath, unsigned int frameIdx, float redshift = 0.0f);
+
+        /**
+         * Sets the data pointers of a given call to the internally stored values
+         *
+         * @param call The call that will be filled with the new data
+         * @param boundingBox The bounding box of the data set
+         * @param clipBox The clip box of the data set
+         */
+        void SetData(AstroDataCall& call, const vislib::math::Cuboid<float>& boundingBox,
+            const vislib::math::Cuboid<float>& clipBox);
+
+        /**
+         * Calculates the derivatives of the frame using the frame before and the frame after as input
+         */
+        void CalculateDerivatives(Frame* frameBefore, Frame* frameAfter);
+
+        void CalculateDerivativesCentralDifferences(Frame* frameBefore, Frame* frameAfter);
+
+        void CalculateDerivativesBackwardDifferences(Frame* frameBefore);
+
+        void CalculateDerivativesForwardDifferences(Frame* frameAfter);
+
+        void ZeroDerivatives(void);
+
+        void CalculateAGNDistances(void);
+
+        void ZeroAGNDistances(void);
+
+    private:
+#pragma pack(push, 1)
+        /**
+         * Struct representing one particle in the file stored on disk
+         */
+        struct SavedData {
+            float x;
+            float vx;
+            float y;
+            float vy;
+            float z;
+            float vz;
+            float mass;
+            float internalEnergy;
+            float smoothingLength;
+            float molecularWeight;
+            float density;
+            float gravitationalPotential;
+            int64_t particleID;
+            uint16_t bitmask;
+        };
+#pragma pack(pop)
+
+        void buildParticleIDMap(const Frame* frame, std::map<int64_t, int64_t>& outIndexMap);
+
+        /** Pointer to the position array */
+        vec3ArrayPtr positions = nullptr;
+
+        /** Pointer to the velocity array */
+        vec3ArrayPtr velocities = nullptr;
+
+        /** Pointer to the velocity derivative array */
+        vec3ArrayPtr velocityDerivatives = nullptr;
+
+        /** Pointer to the temperature array */
+        floatArrayPtr temperatures = nullptr;
+
+        /** Pointer to the temperature derivative array */
+        floatArrayPtr temperatureDerivatives = nullptr;
+
+        /** Pointer to the mass array */
+        floatArrayPtr masses = nullptr;
+
+        /** Pointer to the interal energy array */
+        floatArrayPtr internalEnergies = nullptr;
+
+        /** Pointer to the interal energy derivative array */
+        floatArrayPtr internalEnergyDerivatives = nullptr;
+
+        /** Pointer to the smoothing length array */
+        floatArrayPtr smoothingLengths = nullptr;
+
+        /** Pointer to the smoothing length derivative array */
+        floatArrayPtr smoothingLengthDerivatives = nullptr;
+
+        /** Pointer to the molecular weight array */
+        floatArrayPtr molecularWeights = nullptr;
+
+        /** Pointer to the molecular weight derivative array */
+        floatArrayPtr molecularWeightDerivatives = nullptr;
+
+        /** Pointer to the density array */
+        floatArrayPtr densities = nullptr;
+
+        /** Pointer to the density derivative array */
+        floatArrayPtr densityDerivatives = nullptr;
+
+        /** Pointer to the gravitational potential array */
+        floatArrayPtr gravitationalPotentials = nullptr;
+
+        /** Pointer to the gravitational potential derivative array */
+        floatArrayPtr gravitationalPotentialDerivatives = nullptr;
+
+        /** Pointer to the entropy array */
+        floatArrayPtr entropy = nullptr;
+
+        /** Pointer to the entropy derivative array */
+        floatArrayPtr entropyDerivatives = nullptr;
+
+        /** Pointer to the baryon flag array */
+        boolArrayPtr isBaryonFlags = nullptr;
+
+        /** Pointer to the star flag array */
+        boolArrayPtr isStarFlags = nullptr;
+
+        /** Pointer to the wind flag array */
+        boolArrayPtr isWindFlags = nullptr;
+
+        /** Pointer to the star forming gas flag array */
+        boolArrayPtr isStarFormingGasFlags = nullptr;
+
+        /** Pointer to the AGN flag array */
+        boolArrayPtr isAGNFlags = nullptr;
+
+        /** Pointer to the particle ID array */
+        idArrayPtr particleIDs = nullptr;
+
+        /** Pointer to the agn distance array */
+        floatArrayPtr agnDistances = nullptr;
+
+        /** The redshift value of this frame */
+        float redshift;
+    };
+
+    /**
+     * Unlocker for the frame data
+     */
+    class Unlocker : public AstroDataCall::Unlocker {
+    public:
+        /** Copy Ctor. */
+        Unlocker(Frame& frame) : AstroDataCall::Unlocker(), frame(&frame) {
+            // intentionally empty
+        }
+
+        /** Dtor. */
+        virtual ~Unlocker(void) {
+            this->Unlock();
+            ASSERT(this->frame == nullptr);
+        }
+
+        /** Overload of the unlock method */
+        virtual void Unlock(void) {
+            if (this->frame != nullptr) {
+                this->frame->Unlock();
+                this->frame = nullptr; // DO NOT DELETE!
+            }
+        }
+
+    private:
+        /** Pointer to the contained frame */
+        Frame* frame;
+    };
+#
+    /**
+     * Function to retrieve the stored data
+     *
+     * @param caller The calling call
+     * @return True on success, false otherwise
+     */
+    bool getDataCallback(core::Call& caller);
+
+    /**
+     * Function to retrieve the stored data set extents
+     *
+     * @param caller The calling call
+     * @return True on success, false otherwise
+     */
+    bool getExtentCallback(core::Call& caller);
+
+    /**
+     * Callback function that is called when the filename or the count of filenames to read is changed
+     *
+     * @param slot The calling slot
+     * @return True on success, false otherwise
+     */
+    bool filenameChangedCallback(core::param::ParamSlot& slot);
+
+    /** Slot containing the name of the first loaded file */
+    core::param::ParamSlot firstFilename;
+
+    /** Slot containing the number of files that should be loaded< */
+    core::param::ParamSlot filesToLoad;
+
+    /** Slot determining whether the derivatives should be calculated */
+    core::param::ParamSlot calculateDerivatives;
+
+    /** Slot determining whether the distances to the AGNs should be calculated */
+    core::param::ParamSlot calculateAGNDistances;
+
+    /** Slot to send the data over */
+    core::CalleeSlot getDataSlot;
+
+    /** The bounding box of the data */
+    vislib::math::Cuboid<float> boundingBox;
+
+    /** The clip box of the data */
+    vislib::math::Cuboid<float> clipBox;
+
+    /** Hash that changes with changing data */
+    size_t data_hash;
+
+    /** Vector containing the paths to all loadable files */
+    std::vector<std::string> filenames;
+
+    /** Vector containing the redshift value for all loadable files */
+    std::vector<float> redshiftsForFilename;
+};
+
+} // namespace astro
+} // namespace megamol
+
+#endif /* MEGAMOLCORE_CONTEST2019DATALOADER_H_INCLUDED */
diff --git a/plugins/astro/src/DirectionToColour.cpp b/plugins/astro/src/DirectionToColour.cpp
new file mode 100644
index 000000000..e67702d22
--- /dev/null
+++ b/plugins/astro/src/DirectionToColour.cpp
@@ -0,0 +1,497 @@
+/*
+ * DirectionToColour.cpp
+ *
+ * Copyright (C) 2019 by VISUS (Universitaet Stuttgart)
+ * All rights reserved.
+ */
+
+#include "stdafx.h"
+#include "DirectionToColour.h"
+
+#include <cassert>
+#include <limits>
+
+#include <glm/gtc/constants.hpp>
+
+#include <glm/gtx/vector_angle.hpp>
+
+#include "mmcore/param/ColorParam.h"
+#include "mmcore/param/EnumParam.h"
+
+#include "vislib/sys/Log.h"
+
+
+
+/*
+ * megamol::astro::DirectionToColour::DirectionToColour
+ */
+megamol::astro::DirectionToColour::DirectionToColour(void) : Module(),
+        frameID(0),
+        hashData((std::numeric_limits<std::size_t>::max)()),
+        hashState((std::numeric_limits<std::size_t>::max)()),
+        paramColour1("colour1", "Sets the base colour for saturation-based colouring."),
+        paramColour2("colour2", "Sets the second colour for two-colour mode."),
+        paramMode("mode", "Changes the colouring mode for mapping direction to colour."),
+        slotInput("input", "Obtains the input particle data."),
+        slotOutput("output", "Output of the coloured data.") {
+    using namespace core::moldyn;
+
+    /* Configure and publish the slots. */
+    this->slotInput.SetCompatibleCall<MultiParticleDataCallDescription>();
+    this->MakeSlotAvailable(&this->slotInput);
+
+    this->slotOutput.SetCallback(MultiParticleDataCall::ClassName(),
+        MultiParticleDataCall::FunctionName(0),
+        &DirectionToColour::getData);
+    this->slotOutput.SetCallback(MultiParticleDataCall::ClassName(),
+        MultiParticleDataCall::FunctionName(1),
+        &DirectionToColour::getExtent);
+    this->MakeSlotAvailable(&this->slotOutput);
+
+    /* Configure and publish parameters. */
+    {
+        auto param = new core::param::EnumParam(Mode::Hsl);
+        param->SetTypePair(Mode::Hsl, "HSL plane & lightness");
+        param->SetTypePair(Mode::HelmholtzComplementary, "Mixed complementary colours (Helmholtz)");
+        param->SetTypePair(Mode::IttenComplementary, "Mixed complementary colours (Itten)");
+        param->SetTypePair(Mode::MaxHelmholtzComplementary, "Maximum complementary colours (Helmholtz)");
+        param->SetTypePair(Mode::MaxIttenComplementary, "Maximum complementary colours (Itten)");
+        param->SetTypePair(Mode::SaturationLightness, "Saturation plane & lightness");
+        param->SetTypePair(Mode::HuesLightness, "Hue interpolation & lightness");
+        this->paramMode << param;
+        this->MakeSlotAvailable(&this->paramMode);
+    }
+
+    this->paramColour1 << new core::param::ColorParam(_T("Chartreuse"));
+    this->MakeSlotAvailable(&this->paramColour1);
+
+    this->paramColour2 << new core::param::ColorParam(_T("Cyan"));
+    this->MakeSlotAvailable(&this->paramColour2);
+}
+
+
+/*
+ * megamol::astro::DirectionToColour::~DirectionToColour
+ */
+megamol::astro::DirectionToColour::~DirectionToColour(void) {
+    this->Release();
+}
+
+
+/*
+ * megamol::astro::DirectionToColour::create
+ */
+bool megamol::astro::DirectionToColour::create(void) {
+    return true;
+}
+
+
+/*
+ * megamol::astro::DirectionToColour::release
+ */
+void megamol::astro::DirectionToColour::release(void) { }
+
+
+/*
+ * megamol::astro::DirectionToColour::angle
+ */
+float megamol::astro::DirectionToColour::angle(const glm::vec2& v1,
+        const glm::vec2& v2) {
+    // Non-shitty version of angle between two vectors from
+    // https://math.stackexchange.com/questions/878785/how-to-find-an-angle-in-range0-360-between-2-vectors
+    auto dot = glm::dot(v1, v2);
+    auto det = v1.x * v2.y - v1.y * v2.x;   // cross for vec2 seems to be missing.
+    return std::atan2(det, dot);
+}
+
+
+/*
+ * megamol::astro::DirectionToColour::getDirections
+ */
+const std::uint8_t *megamol::astro::DirectionToColour::getDirections(
+        const core::moldyn::SimpleSphericalParticles& particles) {
+    using core::moldyn::SimpleSphericalParticles;
+    using vislib::sys::Log;
+
+    switch (particles.GetDirDataType()) {
+        case SimpleSphericalParticles::DIRDATA_FLOAT_XYZ:
+            return static_cast<const std::uint8_t *>(particles.GetDirData());
+
+        default:
+            Log::DefaultLog.WriteWarn(L"The input particles do not have "
+                L"directional information.");
+            return nullptr;
+    }
+}
+
+
+/*
+ * megamol::astro::DirectionToColour::hsl2Rgb
+ */
+void megamol::astro::DirectionToColour::hsl2Rgb(float *dst, const float h,
+        const float s, const float l) {
+    assert(dst != nullptr);
+    auto a = s * (std::min)(l, 1.0f - l);
+    auto f = [a, h, l](const int n) {
+        auto k = static_cast<int>(n + h / 30.0f) % 12;
+        return l - a * (std::max)(min3(k - 3.0f, 9.0f - k, 1.0f), -1.0f);
+    };
+
+    dst[0] = f(0);
+    dst[1] = f(8);
+    dst[2] = f(4);
+}
+
+
+/*
+ * megamol::astro::DirectionToColour::makeComplementaryColouring
+ */
+std::vector<float> megamol::astro::DirectionToColour::makeComplementaryColouring(
+        const std::uint8_t *directions, const std::uint64_t cntParticles,
+        const std::size_t stride, const glm::vec3& x1, const glm::vec3& x2,
+        const glm::vec3& y1, const glm::vec3& y2, const glm::vec3& z1,
+        const glm::vec3& z2, const bool mix) {
+    assert(directions != nullptr);
+
+    std::vector<float> retval(3 * cntParticles);
+
+    for (UINT64 i = 0; i < cntParticles; ++i, directions += stride) {
+        auto ptr = reinterpret_cast<const float *>(directions);
+        glm::vec3 dir(ptr[0], ptr[1], ptr[2]);
+        auto len = glm::length(dir);
+
+        if (len != 0.0f) {
+            /* Vector has a direction, so compute a colour. */
+            dir /= len;
+            dir *= 0.5f;
+            dir += 0.5f;
+
+            glm::vec3 hsl;
+
+            if (!mix && (dir.x > dir.y) && (dir.x > dir.z)) {
+                hsl = glm::mix(x1, x2, dir.x);
+
+            } else if (!mix && (dir.y > dir.x) && (dir.y > dir.z)) {
+                hsl = glm::mix(y1, y2, dir.y);
+
+            } else if (!mix && (dir.z > dir.x) && (dir.z > dir.y)) {
+                hsl = glm::mix(z1, z2, dir.z);
+
+            } else {
+                auto x = glm::mix(x1, x2, dir.x);
+                auto y = glm::mix(y1, y2, dir.y);
+                auto z = glm::mix(z1, z2, dir.z);
+                hsl = dir.x * +dir.y * y + dir.z * z;
+
+            }
+
+            DirectionToColour::hsl2Rgb(retval.data() + 3 * i, hsl.x, hsl.y,
+                hsl.z);
+
+        } else {
+            /* Zero-length vectors are black. */
+            retval[3 * i + 0] = retval[3 * i + 1] = retval[3 * i + 2] = 0.0f;
+        }
+    }
+
+    return retval;
+}
+
+
+/*
+ * megamol::astro::DirectionToColour::makeHslColouring
+ */
+std::vector<float> megamol::astro::DirectionToColour::makeHslColouring(
+        const std::uint8_t *directions, const std::uint64_t cntParticles,
+        const std::size_t stride, const Mode mode,
+        const std::array<float, 4> & baseColour1,
+        const std::array<float, 4> & baseColour2) {
+    assert(directions != nullptr);
+    static constexpr const auto PI = glm::pi<float>();
+    static constexpr const auto SCALE = 0.8f;
+    static const auto BASE_HUE1 = rgb2Hsl(baseColour1).front();
+    static const auto BASE_HUE2 = rgb2Hsl(baseColour2).front();
+    static const glm::vec2 X(1.0f, 0.0f);
+
+    std::vector<float> retval(3 * cntParticles);
+
+    for (UINT64 i = 0; i < cntParticles; ++i, directions += stride) {
+        auto ptr = reinterpret_cast<const float *>(directions);
+        glm::vec3 dir(ptr[0], ptr[1], ptr[2]);
+        auto len = glm::length(dir);
+
+        if (len != 0.0f) {
+            /* Vector has a direction, so compute a colour. */
+            dir /= len;
+
+            // Determine the lightness, which is the length on the y-axis. Note
+            // that lightness must be within [0, 1] for colour conversion, so we
+            // need to rescale it. In order from vectors being black, we
+            // truncate the range to SCALE percent of what is possible.
+            auto lightness = dir.y;
+            lightness *= 0.5f * SCALE;
+            lightness += 0.5f + 0.5f * (1.0f - SCALE);
+
+            // Project direction on xz-plane, which defines the hue.
+            auto proj = glm::vec2(dir.x, dir.y);
+            proj = glm::normalize(proj);
+
+            // Determine the angle with the x-axis, which we use for hue.
+            auto hue = DirectionToColour::angle(X, proj);
+            if (hue < 0.0f) {
+                hue = 2.0f * PI - hue;
+            }
+            assert(hue >= 0.0f);
+
+            switch (mode) {
+                case Mode::SaturationLightness:
+                    hue /= (2.0f * PI);
+                    assert(hue <= 2.0f * PI);
+                    DirectionToColour::hsl2Rgb(retval.data() + 3 * i,
+                        BASE_HUE1, hue, lightness);
+                    break;
+
+                case Mode::HuesLightness:
+                    hue /= (2.0f * PI);
+                    hue = glm::mix(BASE_HUE1, BASE_HUE2, hue);
+                    DirectionToColour::hsl2Rgb(retval.data() + 3 * i,
+                        hue, 1.0f, lightness);
+                    break;
+
+                default:
+                    hue = glm::degrees(hue);
+                    DirectionToColour::hsl2Rgb(retval.data() + 3 * i, hue, 1.0f,
+                        lightness);
+                    break;
+            }
+
+        } else {
+            /* Zero-length vectors are black. */
+            retval[3 * i + 0] = retval[3 * i + 1] = retval[3 * i + 2] = 0.0f;
+        }
+    }
+
+    return retval;
+}
+
+
+/*
+ * megamol::astro::DirectionToColour::rgb2Hsl
+ */
+std::array<float, 3> megamol::astro::DirectionToColour::rgb2Hsl(const float r,
+        const float g, const float b) {
+    const auto minRgb = (std::min)((std::min)(r, g), b);
+    const auto maxRgb = (std::max)((std::max)(r, g), b);
+    const auto delta = maxRgb - minRgb;
+    std::array<float, 3> retval;
+
+    retval[2] = (maxRgb + minRgb) / 2.0f;
+
+    if (delta == 0.0f) {
+        retval[0] = retval[1] = 0.0f;
+
+    } else {
+        retval[1] = (retval[2] <= 0.5)
+            ? (delta / (maxRgb + minRgb))
+            : (delta / (2 - maxRgb - minRgb));
+
+        float hue;
+
+        if (r == maxRgb) {
+            hue = ((g - b) / 6.0f) / delta;
+
+        } else if (g == maxRgb) {
+            hue = (1.0f / 3.0f) + ((b - r) / 6.0f) / delta;
+
+        } else {
+            hue = (2.0f / 3.0f) + ((r - g) / 6.0f) / delta;
+        }
+
+        if (hue < 0.0f)
+            hue += 1.0f;
+        if (hue > 1.0f)
+            hue -= 1.0f;
+
+        retval[0] = hue * 360.0f;
+    }
+
+    return retval;
+}
+
+
+/*
+ * megamol::astro::DirectionToColour::getData
+ */
+bool megamol::astro::DirectionToColour::getData(core::Call& call) {
+    using core::moldyn::MultiParticleDataCall;
+    using core::moldyn::SimpleSphericalParticles;
+    using core::param::ColorParam;
+    using core::param::EnumParam;
+    using vislib::sys::Log;
+
+    auto src = this->slotInput.CallAs<MultiParticleDataCall>();
+    auto dst = dynamic_cast<MultiParticleDataCall *>(&call);
+    const auto isLocalChange = this->paramColour1.IsDirty()
+        || this->paramColour2.IsDirty()
+        || this->paramMode.IsDirty();
+
+    /* Sanity checks. */
+    if (src == nullptr) {
+        Log::DefaultLog.WriteError(L"The input slot of %hs is invalid.",
+            DirectionToColour::ClassName());
+        return false;
+    }
+
+    if (dst == nullptr) {
+        Log::DefaultLog.WriteError(L"The output slot of %hs is invalid.",
+            DirectionToColour::ClassName());
+        return false;
+    }
+
+    /* Request the source data. */
+    *src = *dst;
+    if (!(*src)(0)) {
+        Log::DefaultLog.WriteError(L"The call to %hs failed in %hs.",
+            MultiParticleDataCall::FunctionName(0),
+            MultiParticleDataCall::ClassName());
+        return false;
+    }
+    *dst = *src;
+
+    /* Generate the colours. */
+    if (isLocalChange
+            || (this->hashData != src->DataHash())
+            || (this->frameID != src->FrameID())) {
+        const auto mode = static_cast<Mode>(this->paramMode.Param<EnumParam>()
+            ->Value());
+        this->colours.clear();
+
+        for (UINT i = 0; i < dst->GetParticleListCount(); ++i) {
+            auto& particles = dst->AccessParticles(i);
+            auto directions = getDirections(particles);
+
+            if (directions != nullptr) {
+                switch (mode) {
+                    case Mode::HelmholtzComplementary:
+                    case Mode::MaxHelmholtzComplementary:
+                        this->colours.emplace_back(
+                            DirectionToColour::makeComplementaryColouring(
+                                directions,
+                                particles.GetCount(),
+                                particles.GetDirDataStride(),
+                                glm::vec3(0.0f, 1.0f, 0.5f),    // red
+                                glm::vec3(180.0f, 1.0f, 0.5f),  // cyan
+                                glm::vec3(120.0f, 1.0f, 0.5f),  // green
+                                glm::vec3(300.0f, 1.0f, 0.5f),  // magenta
+                                glm::vec3(240.0f, 1.0f, 0.5f),  // blue
+                                glm::vec3(60.0f, 1.0f, 0.5f),   // yellow
+                                mode == Mode::HelmholtzComplementary));
+                        break;
+
+                    case Mode::IttenComplementary:
+                    case Mode::MaxIttenComplementary:
+                        this->colours.emplace_back(
+                            DirectionToColour::makeComplementaryColouring(
+                                directions,
+                                particles.GetCount(),
+                                particles.GetDirDataStride(),
+                                glm::vec3(0.0f, 1.0f, 0.5f),    // red
+                                glm::vec3(120.0f, 1.0f, 0.5f),  // green
+                                glm::vec3(240, 1.0f, 0.5f),     // blue
+                                glm::vec3(30.0f, 1.0f, 0.5f),   // orange
+                                glm::vec3(60.0f, 1.0f, 0.5f),   // yellow
+                                glm::vec3(270.0f, 1.0f, 0.5f),  // violet
+                                mode == Mode::IttenComplementary));
+                        break;
+
+                    case Mode::SaturationLightness:
+                        this->colours.emplace_back(
+                            DirectionToColour::makeHslColouring(
+                                directions,
+                                particles.GetCount(),
+                                particles.GetDirDataStride(),
+                                mode,
+                                this->paramColour1.Param<ColorParam>()->Value(),
+                                this->paramColour2.Param<ColorParam>()->Value()));
+                        break;
+
+                    case Mode::Hsl:
+                    default:
+                        this->colours.emplace_back(
+                            DirectionToColour::makeHslColouring(
+                                directions,
+                                particles.GetCount(),
+                                particles.GetDirDataStride(),
+                                mode,
+                                this->paramColour1.Param<ColorParam>()->Value(),
+                                this->paramColour2.Param<ColorParam>()->Value()));
+                        break;
+                }
+
+            } else {
+                this->colours.emplace_back();
+            }
+        }
+
+        this->frameID = src->FrameID();
+        this->hashData = src->DataHash();
+
+        if (isLocalChange) {
+            this->paramColour1.ResetDirty();
+            this->paramColour2.ResetDirty();
+            this->paramMode.ResetDirty();
+            ++this->hashState;
+        }
+    }
+
+    /* Assign the new colours. */
+    assert(this->colours.size() == dst->GetParticleListCount());
+    for (UINT i = 0; i < dst->GetParticleListCount(); ++i) {
+        auto& particles = dst->AccessParticles(i);
+
+        if (!this->colours[i].empty()) {
+            particles.SetColourData(
+                SimpleSphericalParticles::ColourDataType::COLDATA_FLOAT_RGB,
+                this->colours[i].data());
+        }
+    }
+
+    dst->SetDataHash(this->getHash());
+
+    return true;
+}
+
+
+/*
+ * megamol::astro::DirectionToColour::getExtent
+ */
+bool megamol::astro::DirectionToColour::getExtent(core::Call& call) {
+    using core::moldyn::MultiParticleDataCall;
+    using vislib::sys::Log;
+
+    auto src = this->slotInput.CallAs<MultiParticleDataCall>();
+    auto dst = dynamic_cast<MultiParticleDataCall *>(&call);
+
+    /* Sanity checks. */
+    if (src == nullptr) {
+        Log::DefaultLog.WriteError(L"The input slot of %hs is invalid.",
+            DirectionToColour::ClassName());
+        return false;
+    }
+
+    if (dst == nullptr) {
+        Log::DefaultLog.WriteError(L"The output slot of %hs is invalid.",
+            DirectionToColour::ClassName());
+        return false;
+    }
+
+    *src = *dst;
+    auto retval = (*src)(1);
+
+    if (retval) {
+        *dst = *src;
+        dst->SetDataHash(this->getHash());
+    }
+
+    return retval;
+}
diff --git a/plugins/astro/src/DirectionToColour.h b/plugins/astro/src/DirectionToColour.h
new file mode 100644
index 000000000..3a7c856cd
--- /dev/null
+++ b/plugins/astro/src/DirectionToColour.h
@@ -0,0 +1,132 @@
+/*
+ * DirectionToColour.h
+ *
+ * Copyright (C) 2019 by VISUS (Universitaet Stuttgart)
+ * Alle Rechte vorbehalten.
+ */
+
+#pragma once
+
+#include <array>
+
+#include <glm/glm.hpp>
+
+#include "mmcore/CalleeSlot.h"
+#include "mmcore/CallerSlot.h"
+#include "mmcore/Module.h"
+
+#include "mmcore/param/ParamSlot.h"
+
+#include "mmcore/moldyn/MultiParticleDataCall.h"
+
+
+namespace megamol {
+namespace astro {
+
+    /// <summary>
+    /// Converts from <see cref="AstroDataCall" /> to a table for data
+    /// visualisation.
+    /// </summary>
+    class DirectionToColour : public core::Module {
+
+    public:
+
+        /// <summary>
+        /// Specifies the possible colouring modes.
+        /// </summary>
+        enum Mode {
+            Hsl = 0,
+            HelmholtzComplementary,
+            IttenComplementary,
+            MaxHelmholtzComplementary,
+            MaxIttenComplementary,
+            SaturationLightness,
+            HuesLightness,
+        };
+
+        static inline const char *ClassName(void) {
+            return "DirectionToColour"; 
+        }
+
+        static inline const char *Description(void) {
+            return "Generates particle colours based on directional vectors "
+                "and the HSL colour model.";
+        }
+
+        static bool IsAvailable(void) {
+            return true;
+        }
+
+        /// <summary>
+        /// Initialises a new instance.
+        /// </summary>
+        DirectionToColour(void);
+
+        /// <summary>
+        /// Finalises the instance.
+        /// </summary>
+        virtual ~DirectionToColour(void);
+
+    protected:
+
+        virtual bool create(void);
+
+        virtual void release(void);
+
+    private:
+
+        static float angle(const glm::vec2& v1, const glm::vec2& v2);
+
+        static const std::uint8_t *getDirections(
+            const core::moldyn::SimpleSphericalParticles& particles);
+
+        static void hsl2Rgb(float *dst, const float h, const float s,
+            const float l);
+
+        static std::vector<float> makeComplementaryColouring(
+            const std::uint8_t *directions, const std::uint64_t cntParticles,
+            const std::size_t stride, const glm::vec3& x1, const glm::vec3& x2,
+            const glm::vec3& y1, const glm::vec3& y2, const glm::vec3& z1,
+            const glm::vec3& z2, const bool mix);
+
+        static std::vector<float> makeHslColouring(const std::uint8_t *directions,
+            const std::uint64_t cntParticles, const std::size_t stride,
+            const Mode mode, const std::array<float, 4> & baseColour1,
+            const std::array<float, 4>& baseColour2);
+
+        static inline float min3(const float x, const float y, const float z) {
+            return (std::min)((std::min)(x, y), z);
+        }
+
+        static std::array<float, 3> rgb2Hsl(const float r, const float g,
+            const float b);
+
+        static inline std::array<float, 3> rgb2Hsl(
+                const std::array<float, 4>& rgb) {
+            return rgb2Hsl(rgb[0], rgb[1], rgb[2]);
+        }
+
+        bool getData(core::Call& call);
+
+        bool getExtent(core::Call& call);
+
+        inline std::size_t getHash(void) {
+            auto retval = this->hashData;
+            retval ^= this->hashState + 0x9e3779b9 + (retval << 6)
+                + (retval >> 2);
+            return retval;
+        }
+
+        std::vector<std::vector<float>> colours;
+        unsigned int frameID;
+        std::size_t hashData;
+        std::size_t hashState;
+        core::param::ParamSlot paramColour1;
+        core::param::ParamSlot paramColour2;
+        core::param::ParamSlot paramMode;
+        core::CallerSlot slotInput;
+        core::CalleeSlot slotOutput;
+    };
+
+} /* end namespace astro */
+} /* end namespace megamol */
diff --git a/plugins/astro/src/FilamentFilter.cpp b/plugins/astro/src/FilamentFilter.cpp
new file mode 100644
index 000000000..c8b10c12b
--- /dev/null
+++ b/plugins/astro/src/FilamentFilter.cpp
@@ -0,0 +1,407 @@
+/*
+ * FilamentFilter.cpp
+ *
+ * Copyright (C) 2019 by VISUS (Universitaet Stuttgart)
+ * Alle Rechte vorbehalten.
+ */
+#include "stdafx.h"
+#include "FilamentFilter.h"
+
+#include <algorithm>
+#include <climits>
+#include <queue>
+#include <set>
+#include "mmcore/param/BoolParam.h"
+#include "mmcore/param/FloatParam.h"
+#include "mmcore/param/IntParam.h"
+
+using namespace megamol;
+using namespace megamol::astro;
+using namespace megamol::core;
+
+/*
+ * FilamentFilter::FilamentFilter
+ */
+FilamentFilter::FilamentFilter(void)
+    : Module()
+    , filamentOutSlot("filamentOut", "Output slot for the filament particles")
+    , particlesInSlot("particlesIn", "Input slot for the astro particle data")
+    , radiusSlot("radius", "The used radius for the FOF algorithm")
+    , isActiveSlot("isActive", "When deactivated this module only passes through the incoming data")
+    , densitySeedPercentageSlot(
+          "densityPercentage", "Percentage of data points that is thrown away because of too low density")
+    , minClusterSizeSlot("minClusterSize", "Minimal number of particles in a detected cluster")
+    , maxParticlePercentageCuttoff(
+          "maxParticlePercentage", "Maximum percentage of particles that is considered as candidates")
+    , recalculateFilaments(true)
+    , hashOffset(0)
+    , lastDataHash(0) {
+
+    this->particlesInSlot.SetCompatibleCall<AstroDataCallDescription>();
+    this->MakeSlotAvailable(&this->particlesInSlot);
+
+    this->filamentOutSlot.SetCallback(AstroDataCall::ClassName(),
+        AstroDataCall::FunctionName(AstroDataCall::CallForGetData), &FilamentFilter::getData);
+    this->filamentOutSlot.SetCallback(AstroDataCall::ClassName(),
+        AstroDataCall::FunctionName(AstroDataCall::CallForGetExtent), &FilamentFilter::getExtent);
+    this->MakeSlotAvailable(&this->filamentOutSlot);
+
+    this->isActiveSlot.SetParameter(new param::BoolParam(true));
+    this->MakeSlotAvailable(&this->isActiveSlot);
+
+    this->radiusSlot.SetParameter(new param::FloatParam(0.45f, 0.0f));
+    this->MakeSlotAvailable(&this->radiusSlot);
+
+    this->minClusterSizeSlot.SetParameter(new param::IntParam(100, 2));
+    this->MakeSlotAvailable(&this->minClusterSizeSlot);
+
+    this->densitySeedPercentageSlot.SetParameter(new param::FloatParam(90.0f, 0.0f, 100.0f));
+    this->MakeSlotAvailable(&this->densitySeedPercentageSlot);
+
+    this->maxParticlePercentageCuttoff.SetParameter(new param::FloatParam(1.0f, 0.0f, 100.0f));
+    this->MakeSlotAvailable(&this->maxParticlePercentageCuttoff);
+
+    this->initFields();
+}
+
+/*
+ * FilamentFilter::~FilamentFilter
+ */
+FilamentFilter::~FilamentFilter(void) { this->Release(); }
+
+/*
+ * FilamentFilter::create
+ */
+bool FilamentFilter::create(void) {
+    // intentionally empty
+    return true;
+}
+
+/*
+ * FilamentFilter::release
+ */
+void FilamentFilter::release(void) {
+    // intentionally empty
+}
+
+/*
+ * FilamentFilter::getData
+ */
+bool FilamentFilter::getData(core::Call& call) {
+    AstroDataCall* adc = dynamic_cast<AstroDataCall*>(&call);
+    if (adc == nullptr) return false;
+
+    AstroDataCall* inCall = this->particlesInSlot.CallAs<AstroDataCall>();
+    if (inCall == nullptr) return false;
+
+    inCall->operator=(*adc);
+    inCall->SetUnlocker(nullptr, false);
+    if ((*inCall)(AstroDataCall::CallForGetData)) {
+        if (this->isActiveSlot.Param<param::BoolParam>()->Value()) {
+            if (this->recalculateFilaments) {
+                this->filterFilaments(*inCall);
+                this->recalculateFilaments = false;
+            }
+            this->copyContentToOutCall(*adc);
+        } else {
+            adc->operator=(*inCall);
+        }
+        inCall->Unlock();
+        return true;
+    }
+    inCall->Unlock();
+    return false;
+}
+
+/*
+ * FilamentFilter::getExtent
+ */
+bool FilamentFilter::getExtent(core::Call& call) {
+    AstroDataCall* adc = dynamic_cast<AstroDataCall*>(&call);
+    if (adc == nullptr) return false;
+
+    AstroDataCall* inCall = this->particlesInSlot.CallAs<AstroDataCall>();
+    if (inCall == nullptr) return false;
+
+    inCall->operator=(*adc);
+    adc->SetUnlocker(nullptr, false);
+    if ((*inCall)(AstroDataCall::CallForGetExtent)) {
+        adc->operator=(*inCall);
+        if (this->lastDataHash != inCall->DataHash() || this->lastTimestep != adc->FrameID() ||
+            this->radiusSlot.IsDirty() || this->densitySeedPercentageSlot.IsDirty() ||
+            this->minClusterSizeSlot.IsDirty() || this->maxParticlePercentageCuttoff.IsDirty()) {
+            this->hashOffset++;
+            this->lastTimestep = adc->FrameID();
+            this->lastDataHash = inCall->DataHash();
+            this->radiusSlot.ResetDirty();
+            this->densitySeedPercentageSlot.ResetDirty();
+            this->minClusterSizeSlot.ResetDirty();
+            this->maxParticlePercentageCuttoff.ResetDirty();
+            this->recalculateFilaments = true;
+        }
+        if (this->isActiveSlot.IsDirty() && this->positions != nullptr && !this->positions->empty()) {
+            this->isActiveSlot.ResetDirty();
+            this->recalculateFilaments = true;
+            this->hashOffset++;
+        }
+        adc->SetDataHash(this->lastDataHash + this->hashOffset);
+        return true;
+    }
+    return false;
+}
+
+/*
+ * FilamentFilter::copyContentToOutCall
+ */
+bool FilamentFilter::copyContentToOutCall(AstroDataCall& outCall) {
+    outCall.SetPositions(this->positions);
+    outCall.SetVelocities(this->velocities);
+    outCall.SetTemperature(this->temperatures);
+    outCall.SetMass(this->masses);
+    outCall.SetInternalEnergy(this->internalEnergies);
+    outCall.SetSmoothingLength(this->smoothingLengths);
+    outCall.SetMolecularWeights(this->molecularWeights);
+    outCall.SetDensity(this->densities);
+    outCall.SetGravitationalPotential(this->gravitationalPotentials);
+    outCall.SetEntropy(this->entropies);
+    outCall.SetIsBaryonFlags(this->isBaryonFlags);
+    outCall.SetIsStarFlags(this->isStarFlags);
+    outCall.SetIsWindFlags(this->isWindFlags);
+    outCall.SetIsStarFormingGasFlags(this->isStarFormingGasFlags);
+    outCall.SetIsAGNFlags(this->isAGNFlags);
+    outCall.SetParticleIDs(this->particleIDs);
+    return true;
+}
+
+/*
+ * FilamentFilter::initFields
+ */
+void FilamentFilter::initFields(void) {
+    if (this->positions == nullptr) {
+        this->positions = std::make_shared<std::vector<glm::vec3>>();
+    }
+    if (this->velocities == nullptr) {
+        this->velocities = std::make_shared<std::vector<glm::vec3>>();
+    }
+    if (this->temperatures == nullptr) {
+        this->temperatures = std::make_shared<std::vector<float>>();
+    }
+    if (this->masses == nullptr) {
+        this->masses = std::make_shared<std::vector<float>>();
+    }
+    if (this->internalEnergies == nullptr) {
+        this->internalEnergies = std::make_shared<std::vector<float>>();
+    }
+    if (this->smoothingLengths == nullptr) {
+        this->smoothingLengths = std::make_shared<std::vector<float>>();
+    }
+    if (this->molecularWeights == nullptr) {
+        this->molecularWeights = std::make_shared<std::vector<float>>();
+    }
+    if (this->densities == nullptr) {
+        this->densities = std::make_shared<std::vector<float>>();
+    }
+    if (this->gravitationalPotentials == nullptr) {
+        this->gravitationalPotentials = std::make_shared<std::vector<float>>();
+    }
+    if (this->entropies == nullptr) {
+        this->entropies = std::make_shared<std::vector<float>>();
+    }
+    if (this->isBaryonFlags == nullptr) {
+        this->isBaryonFlags = std::make_shared<std::vector<bool>>();
+    }
+    if (this->isStarFlags == nullptr) {
+        this->isStarFlags = std::make_shared<std::vector<bool>>();
+    }
+    if (this->isWindFlags == nullptr) {
+        this->isWindFlags = std::make_shared<std::vector<bool>>();
+    }
+    if (this->isStarFormingGasFlags == nullptr) {
+        this->isStarFormingGasFlags = std::make_shared<std::vector<bool>>();
+    }
+    if (this->isAGNFlags == nullptr) {
+        this->isAGNFlags = std::make_shared<std::vector<bool>>();
+    }
+    if (this->particleIDs == nullptr) {
+        this->particleIDs = std::make_shared<std::vector<int64_t>>();
+    }
+}
+
+/*
+ * FilamentFilter::getMinMaxDensity
+ */
+std::pair<float, float> FilamentFilter::getMinMaxDensity(const AstroDataCall& call) const {
+    const auto& dens = call.GetDensity();
+    if (dens == nullptr) return std::make_pair(0.0f, 0.0f);
+    auto resit = std::minmax_element(dens->begin(), dens->end());
+    return std::make_pair(*resit.first, *resit.second);
+}
+
+/*
+ * FilamentFilter::getMinMaxDensity
+ */
+void FilamentFilter::retrieveDensityCandidateList(
+    const AstroDataCall& call, std::vector<std::pair<float, uint64_t>>& result) {
+    result.clear();
+    const auto& dens = call.GetDensity();
+    if (dens == nullptr) return;
+    auto minmax = this->getMinMaxDensity(call);
+    result.resize(dens->size());
+    for (uint64_t i = 0; i < dens->size(); i++) {
+        result[i] = std::make_pair(dens->at(i), i);
+    }
+    // sort all the densities in descending order and only keep a certain percentage
+    std::sort(result.rbegin(), result.rend());
+    float percentage = this->densitySeedPercentageSlot.Param<param::FloatParam>()->Value();
+    percentage = 100.0f - percentage;
+    percentage /= 100.0f;
+    float minDensity = percentage * minmax.second;
+    auto foundval =
+        std::find_if(result.begin(), result.end(), [&minDensity](const auto& x) { return minDensity > x.first; });
+    result.erase(foundval, result.end());
+    const auto maxPartCount = static_cast<uint64_t>(
+        call.GetParticleCount() * (this->maxParticlePercentageCuttoff.Param<param::FloatParam>()->Value() / 100.0f));
+    if (result.size() > maxPartCount) {
+        result.resize(maxPartCount);
+    }
+}
+
+/*
+ * FilamentFilter::initSearchStructure
+ */
+void FilamentFilter::initSearchStructure(const AstroDataCall& call) {
+    const auto& posPtr = call.GetPositions();
+    this->pointCloud.pts.resize(posPtr->size());
+    std::memcpy(this->pointCloud.pts.data(), posPtr->data(), posPtr->size() * sizeof(glm::vec3));
+    if (this->searchIndexPtr != nullptr) {
+        this->searchIndexPtr.reset();
+    }
+    this->searchIndexPtr =
+        std::make_shared<my_kd_tree_t>(3, this->pointCloud, nanoflann::KDTreeSingleIndexAdaptorParams(10));
+    this->searchIndexPtr->buildIndex();
+}
+
+/*
+ * FilamentFilter::copyInCallToContent
+ */
+bool FilamentFilter::copyInCallToContent(const AstroDataCall& inCall, const std::set<uint64_t>& indexSet) {
+    this->positions->resize(indexSet.size());
+    this->velocities->resize(indexSet.size());
+    this->temperatures->resize(indexSet.size());
+    this->masses->resize(indexSet.size());
+    this->internalEnergies->resize(indexSet.size());
+    this->smoothingLengths->resize(indexSet.size());
+    this->molecularWeights->resize(indexSet.size());
+    this->densities->resize(indexSet.size());
+    this->gravitationalPotentials->resize(indexSet.size());
+    this->entropies->resize(indexSet.size());
+    this->isBaryonFlags->resize(indexSet.size());
+    this->isStarFlags->resize(indexSet.size());
+    this->isWindFlags->resize(indexSet.size());
+    this->isStarFormingGasFlags->resize(indexSet.size());
+    this->isAGNFlags->resize(indexSet.size());
+    this->particleIDs->resize(indexSet.size());
+
+    std::vector<uint64_t> setVec(indexSet.begin(), indexSet.end());
+    std::sort(setVec.begin(), setVec.end());
+
+    uint64_t i = 0;
+    for (const auto id : setVec) {
+        this->positions->at(i) = inCall.GetPositions()->at(id);
+        this->velocities->at(i) = inCall.GetVelocities()->at(id);
+        this->temperatures->at(i) = inCall.GetTemperature()->at(id);
+        this->masses->at(i) = inCall.GetMass()->at(id);
+        this->internalEnergies->at(i) = inCall.GetInternalEnergy()->at(id);
+        this->smoothingLengths->at(i) = inCall.GetSmoothingLength()->at(id);
+        this->molecularWeights->at(i) = inCall.GetMolecularWeights()->at(id);
+        this->densities->at(i) = inCall.GetDensity()->at(id);
+        this->gravitationalPotentials->at(i) = inCall.GetGravitationalPotential()->at(id);
+        this->entropies->at(i) = inCall.GetEntropy()->at(i);
+        this->isBaryonFlags->at(i) = inCall.GetIsBaryonFlags()->at(id);
+        this->isStarFlags->at(i) = inCall.GetIsStarFlags()->at(id);
+        this->isWindFlags->at(i) = inCall.GetIsWindFlags()->at(id);
+        this->isStarFormingGasFlags->at(i) = inCall.GetIsStarFormingGasFlags()->at(id);
+        this->isAGNFlags->at(i) = inCall.GetIsAGNFlags()->at(id);
+        this->particleIDs->at(i) = inCall.GetParticleIDs()->at(id);
+        ++i;
+    }
+    return true;
+}
+
+/*
+ * FilamentFilter::filterFilaments
+ */
+bool FilamentFilter::filterFilaments(const AstroDataCall& call) {
+    if (call.GetPositions() == nullptr) return false;
+    std::vector<std::pair<float, uint64_t>> densityPeaks;
+    this->retrieveDensityCandidateList(call, densityPeaks);
+    std::set<uint64_t> candidateSet;
+    for (const auto& a : densityPeaks) {
+        candidateSet.insert(a.second);
+    }
+    this->initSearchStructure(call);
+    if (this->searchIndexPtr == nullptr) return false;
+
+    // the following approach is not really performant, but it should work
+    std::vector<std::set<uint64_t>> setVec;
+    std::vector<bool> calculatedFlags(call.GetPositions()->size(), false);
+
+    nanoflann::SearchParams searchParams;
+    float searchRadius = this->radiusSlot.Param<param::FloatParam>()->Value();
+    std::vector<std::pair<size_t, float>> searchResults;
+    std::set<uint64_t> toProcessSet;
+
+    while (!candidateSet.empty()) {
+        auto current = *candidateSet.begin();
+        auto position = call.GetPositions()->at(current);
+        setVec.push_back(std::set<uint64_t>());
+        setVec.back().insert(current);
+        toProcessSet.clear();
+        calculatedFlags[current] = true;
+        const auto nMatches =
+            this->searchIndexPtr->radiusSearch(&position.x, searchRadius * searchRadius, searchResults, searchParams);
+        // insert everything in the vicinity of the current candidate to the queue
+        for (const auto& v : searchResults) {
+            uint64_t index = v.first;
+            if (index == current) continue;
+            if (!calculatedFlags[index]) {
+                toProcessSet.insert(index);
+                setVec.back().insert(index);
+                calculatedFlags[index] = true;
+            }
+        }
+        while (!toProcessSet.empty()) {
+            auto cur = *toProcessSet.begin();
+            auto pos = call.GetPositions()->at(cur);
+            searchResults.clear();
+            const auto matches =
+                this->searchIndexPtr->radiusSearch(&pos.x, searchRadius * searchRadius, searchResults, searchParams);
+            for (const auto& v : searchResults) {
+                uint64_t index = v.first;
+                if (index == cur) continue;
+                if (!calculatedFlags[index]) {
+                    toProcessSet.insert(index);
+                    setVec.back().insert(index);
+                    calculatedFlags[index] = true;
+                }
+            }
+            toProcessSet.erase(cur);
+            candidateSet.erase(cur);
+        }
+        candidateSet.erase(current);
+    }
+    // erase too small clusters
+    auto minClusterSize = this->minClusterSizeSlot.Param<param::IntParam>()->Value();
+    for (auto it = setVec.begin(); it != setVec.end(); /* intentionally empty*/) {
+        if ((*it).size() < minClusterSize) {
+            it = setVec.erase(it);
+        } else {
+            ++it;
+        }
+    }
+    std::set<uint64_t> endset;
+    for (const auto& s : setVec) {
+        endset.insert(s.begin(), s.end());
+    }
+    return this->copyInCallToContent(call, endset);
+}
diff --git a/plugins/astro/src/FilamentFilter.h b/plugins/astro/src/FilamentFilter.h
new file mode 100644
index 000000000..230f9b07e
--- /dev/null
+++ b/plugins/astro/src/FilamentFilter.h
@@ -0,0 +1,159 @@
+/*
+ * FilamentFilter.h
+ *
+ * Copyright (C) 2019 by VISUS (Universitaet Stuttgart)
+ * Alle Rechte vorbehalten.
+ */
+#pragma once
+
+#include <nanoflann.hpp>
+#include <set>
+#include "astro/AstroDataCall.h"
+#include "mmcore/CalleeSlot.h"
+#include "mmcore/CallerSlot.h"
+#include "mmcore/Module.h"
+#include "mmcore/param/ParamSlot.h"
+
+
+namespace megamol {
+namespace astro {
+
+/*
+ * THIS IS THE APEX OF SHIT and a non-quality copy from nanoflann/examples/utils.h
+ * TODO: Replace it with a proper adapter instead of creating a copy to index data!
+ */
+template <typename T> struct PointCloud {
+    struct Point {
+        T x, y, z;
+    };
+
+    std::vector<Point> pts;
+
+    // Must return the number of data points
+    inline size_t kdtree_get_point_count() const { return pts.size(); }
+
+    // Returns the dim'th component of the idx'th point in the class:
+    // Since this is inlined and the "dim" argument is typically an immediate value, the
+    //  "if/else's" are actually solved at compile time.
+    inline T kdtree_get_pt(const size_t idx, const size_t dim) const {
+        if (dim == 0)
+            return pts[idx].x;
+        else if (dim == 1)
+            return pts[idx].y;
+        else
+            return pts[idx].z;
+    }
+
+    // Optional bounding-box computation: return false to default to a standard bbox computation loop.
+    //   Return true if the BBOX was already computed by the class and returned in "bb" so it can be avoided to redo it
+    //   again. Look at bb.size() to find out the expected dimensionality (e.g. 2 or 3 for point clouds)
+    template <class BBOX> bool kdtree_get_bbox(BBOX& /* bb */) const { return false; }
+};
+
+class FilamentFilter : public core::Module {
+public:
+    static const char* ClassName(void) { return "FilamentFilter"; }
+    static const char* Description(void) { return "Filters the filament particles of a AstroParticleDataCall"; }
+    static bool IsAvailable(void) { return true; }
+
+    /** Ctor. */
+    FilamentFilter(void);
+
+    /** Dtor. */
+    virtual ~FilamentFilter(void);
+
+protected:
+    virtual bool create(void);
+    virtual void release(void);
+
+private:
+    bool getData(core::Call& call);
+    bool getExtent(core::Call& call);
+
+    void initFields(void);
+    std::pair<float, float> getMinMaxDensity(const AstroDataCall& call) const;
+    void retrieveDensityCandidateList(const AstroDataCall& call, std::vector<std::pair<float, uint64_t>>& result);
+    bool filterFilaments(const AstroDataCall& call);
+    bool copyContentToOutCall(AstroDataCall& outCall);
+    bool copyInCallToContent(const AstroDataCall& inCall, const std::set<uint64_t>& indexSet);
+    void initSearchStructure(const AstroDataCall& call);
+
+    core::CalleeSlot filamentOutSlot;
+    core::CallerSlot particlesInSlot;
+
+    core::param::ParamSlot radiusSlot;
+    core::param::ParamSlot minClusterSizeSlot;
+    core::param::ParamSlot densitySeedPercentageSlot;
+    core::param::ParamSlot isActiveSlot;
+    core::param::ParamSlot maxParticlePercentageCuttoff;
+
+    typedef nanoflann::KDTreeSingleIndexAdaptor<nanoflann::L2_Simple_Adaptor<float, PointCloud<float>>,
+        PointCloud<float>, 3>
+        my_kd_tree_t;
+
+    std::shared_ptr<my_kd_tree_t> searchIndexPtr = nullptr;
+    PointCloud<float> pointCloud;
+
+    /** Pointer to the position array */
+    vec3ArrayPtr positions = nullptr;
+
+    /** Pointer to the velocity array */
+    vec3ArrayPtr velocities = nullptr;
+
+    /** Pointer to the temperature array */
+    floatArrayPtr temperatures = nullptr;
+
+    /** Pointer to the mass array */
+    floatArrayPtr masses = nullptr;
+
+    /** Pointer to the interal energy array */
+    floatArrayPtr internalEnergies = nullptr;
+
+    /** Pointer to the smoothing length array */
+    floatArrayPtr smoothingLengths = nullptr;
+
+    /** Pointer to the molecular weight array */
+    floatArrayPtr molecularWeights = nullptr;
+
+    /** Pointer to the density array */
+    floatArrayPtr densities = nullptr;
+
+    /** Pointer to the gravitational potential array */
+    floatArrayPtr gravitationalPotentials = nullptr;
+
+    /** Pointer to the entropy array */
+    floatArrayPtr entropies = nullptr;
+
+    /** Pointer to the baryon flag array */
+    boolArrayPtr isBaryonFlags = nullptr;
+
+    /** Pointer to the star flag array */
+    boolArrayPtr isStarFlags = nullptr;
+
+    /** Pointer to the wind flag array */
+    boolArrayPtr isWindFlags = nullptr;
+
+    /** Pointer to the star forming gas flag array */
+    boolArrayPtr isStarFormingGasFlags = nullptr;
+
+    /** Pointer to the AGN flag array */
+    boolArrayPtr isAGNFlags = nullptr;
+
+    /** Pointer to the particle ID array */
+    idArrayPtr particleIDs = nullptr;
+
+    /** flag determining whether the filaments have to be recalculated */
+    bool recalculateFilaments;
+
+    /** Hash of the last calculated dataset */
+    uint64_t lastDataHash;
+
+    /** Offset from the hash given by the incoming call */
+    uint64_t hashOffset;
+
+    /** ID of the last visualized timestep */
+    uint32_t lastTimestep;
+};
+
+} // namespace astro
+} // namespace megamol
diff --git a/plugins/astro/src/SimpleAstroFilter.cpp b/plugins/astro/src/SimpleAstroFilter.cpp
new file mode 100644
index 000000000..c0497ca2d
--- /dev/null
+++ b/plugins/astro/src/SimpleAstroFilter.cpp
@@ -0,0 +1,667 @@
+/*
+ * SimpleAstroFilter.h
+ *
+ * Copyright (C) 2019 by VISUS (Universitaet Stuttgart)
+ * Alle Rechte vorbehalten.
+ */
+#include "SimpleAstroFilter.h"
+
+#include <climits>
+#include <numeric>
+#include "mmcore/param/BoolParam.h"
+#include "mmcore/param/ButtonParam.h"
+#include "mmcore/param/FloatParam.h"
+
+using namespace megamol;
+using namespace megamol::astro;
+using namespace megamol::core;
+
+/*
+ * SimpleAstroFilter::SimpleAstroFilter
+ */
+SimpleAstroFilter::SimpleAstroFilter(void)
+    : Module()
+    , particlesOutSlot("particlesOut", "Output slot for the filtered astro particle data")
+    , particlesInSlot("particlesIn", "Input slot for the astro particle data")
+    , showOnlyBaryonParam("showOnlyBaryons", "")
+    , showOnlyDarkMatterParam("showOnlyDarkMatter", "")
+    , showOnlyStarsParam("showOnlyStars", "")
+    , showOnlyWindParam("showOnlyWind", "")
+    , showOnlyStarFormingGasParam("showOnlyStarFormingGas", "")
+    , showOnlyAGNsParam("showOnlyAGNs", "")
+    , minVelocityMagnitudeParam("velocityMagnitude::min", "")
+    , maxVelocityMagnitudeParam("velocityMagnitude::max", "")
+    , filterVelocityMagnitudeParam("velocityMagnitude::filter", "")
+    , minTemperatureParam("temperature::min", "")
+    , maxTemperatureParam("temperature::max", "")
+    , filterTemperatureParam("temperature::filter", "")
+    , minMassParam("mass::min", "")
+    , maxMassParam("mass::max", "")
+    , filterMassParam("mass::filter", "")
+    , minInternalEnergyParam("internalEnergy::min", "")
+    , maxInternalEnergyParam("internalEnergy::max", "")
+    , filterInternalEnergyParam("internalEnergy::filter", "")
+    , minSmoothingLengthParam("smoothingLength::min", "")
+    , maxSmoothingLengthParam("smoothingLength::max", "")
+    , filterSmoothingLengthParam("smoothingLength::filter", "")
+    , minMolecularWeightParam("molecularWeight::min", "")
+    , maxMolecularWeightParam("molecularWeight::max", "")
+    , filterMolecularWeightParam("molecularWeight::filter", "")
+    , minDensityParam("density::min", "")
+    , maxDensityParam("density::max", "")
+    , filterDensityParam("density::filter", "")
+    , minGravitationalPotentialParam("gravitationalPotential::min", "")
+    , maxGravitationalPotentialParam("gravitationalPotential::max", "")
+    , filterGravitationalPotentialParam("gravitationalPotential::filter", "")
+    , minEntropyParam("entropy::min", "")
+    , maxEntropyParam("entropy::max", "")
+    , filterEntropyParam("entropy::filter", "")
+    , minAgnDistanceParam("agndistance::min", "")
+    , maxAgnDistanceParam("agndistance::max", "")
+    , filterAgnDistanceParam("agndistance::filter", "")
+    , fillFilterButtonParam("fillValues", "")
+    , hashOffset(0)
+    , refilter(true)
+    , lastDataHash(0)
+    , lastTimestep(0) {
+
+    this->particlesInSlot.SetCompatibleCall<AstroDataCallDescription>();
+    this->MakeSlotAvailable(&this->particlesInSlot);
+
+    this->particlesOutSlot.SetCallback(AstroDataCall::ClassName(),
+        AstroDataCall::FunctionName(AstroDataCall::CallForGetData), &SimpleAstroFilter::getData);
+    this->particlesOutSlot.SetCallback(AstroDataCall::ClassName(),
+        AstroDataCall::FunctionName(AstroDataCall::CallForGetExtent), &SimpleAstroFilter::getExtent);
+    this->MakeSlotAvailable(&this->particlesOutSlot);
+
+    this->showOnlyBaryonParam.SetParameter(new param::BoolParam(false));
+    this->MakeSlotAvailable(&this->showOnlyBaryonParam);
+
+    this->showOnlyDarkMatterParam.SetParameter(new param::BoolParam(false));
+    this->MakeSlotAvailable(&this->showOnlyDarkMatterParam);
+
+    this->showOnlyStarsParam.SetParameter(new param::BoolParam(false));
+    this->MakeSlotAvailable(&this->showOnlyStarsParam);
+
+    this->showOnlyWindParam.SetParameter(new param::BoolParam(false));
+    this->MakeSlotAvailable(&this->showOnlyWindParam);
+
+    this->showOnlyStarFormingGasParam.SetParameter(new param::BoolParam(false));
+    this->MakeSlotAvailable(&this->showOnlyStarFormingGasParam);
+
+    this->showOnlyAGNsParam.SetParameter(new param::BoolParam(false));
+    this->MakeSlotAvailable(&this->showOnlyAGNsParam);
+
+    // numeric filters
+    this->minVelocityMagnitudeParam.SetParameter(new param::FloatParam(0.0f));
+    this->MakeSlotAvailable(&this->minVelocityMagnitudeParam);
+    this->maxVelocityMagnitudeParam.SetParameter(new param::FloatParam(0.0f));
+    this->MakeSlotAvailable(&this->maxVelocityMagnitudeParam);
+    this->filterVelocityMagnitudeParam.SetParameter(new param::BoolParam(false));
+    this->MakeSlotAvailable(&this->filterVelocityMagnitudeParam);
+
+    this->minTemperatureParam.SetParameter(new param::FloatParam(0.0f));
+    this->MakeSlotAvailable(&this->minTemperatureParam);
+    this->maxTemperatureParam.SetParameter(new param::FloatParam(0.0f));
+    this->MakeSlotAvailable(&this->maxTemperatureParam);
+    this->filterTemperatureParam.SetParameter(new param::BoolParam(false));
+    this->MakeSlotAvailable(&this->filterTemperatureParam);
+
+    this->minMassParam.SetParameter(new param::FloatParam(0.0f));
+    this->MakeSlotAvailable(&this->minMassParam);
+    this->maxMassParam.SetParameter(new param::FloatParam(0.0f));
+    this->MakeSlotAvailable(&this->maxMassParam);
+    this->filterMassParam.SetParameter(new param::BoolParam(false));
+    this->MakeSlotAvailable(&this->filterMassParam);
+
+    this->minInternalEnergyParam.SetParameter(new param::FloatParam(0.0f));
+    this->MakeSlotAvailable(&this->minInternalEnergyParam);
+    this->maxInternalEnergyParam.SetParameter(new param::FloatParam(0.0f));
+    this->MakeSlotAvailable(&this->maxInternalEnergyParam);
+    this->filterInternalEnergyParam.SetParameter(new param::BoolParam(false));
+    this->MakeSlotAvailable(&this->filterInternalEnergyParam);
+
+    this->minSmoothingLengthParam.SetParameter(new param::FloatParam(0.0f));
+    this->MakeSlotAvailable(&this->minSmoothingLengthParam);
+    this->maxSmoothingLengthParam.SetParameter(new param::FloatParam(0.0f));
+    this->MakeSlotAvailable(&this->maxSmoothingLengthParam);
+    this->filterSmoothingLengthParam.SetParameter(new param::BoolParam(false));
+    this->MakeSlotAvailable(&this->filterSmoothingLengthParam);
+
+    this->minMolecularWeightParam.SetParameter(new param::FloatParam(0.0f));
+    this->MakeSlotAvailable(&this->minMolecularWeightParam);
+    this->maxMolecularWeightParam.SetParameter(new param::FloatParam(0.0f));
+    this->MakeSlotAvailable(&this->maxMolecularWeightParam);
+    this->filterMolecularWeightParam.SetParameter(new param::BoolParam(false));
+    this->MakeSlotAvailable(&this->filterMolecularWeightParam);
+
+    this->minDensityParam.SetParameter(new param::FloatParam(0.0f));
+    this->MakeSlotAvailable(&this->minDensityParam);
+    this->maxDensityParam.SetParameter(new param::FloatParam(0.0f));
+    this->MakeSlotAvailable(&this->maxDensityParam);
+    this->filterDensityParam.SetParameter(new param::BoolParam(false));
+    this->MakeSlotAvailable(&this->filterDensityParam);
+
+    this->minGravitationalPotentialParam.SetParameter(new param::FloatParam(0.0f));
+    this->MakeSlotAvailable(&this->minGravitationalPotentialParam);
+    this->maxGravitationalPotentialParam.SetParameter(new param::FloatParam(0.0f));
+    this->MakeSlotAvailable(&this->maxGravitationalPotentialParam);
+    this->filterGravitationalPotentialParam.SetParameter(new param::BoolParam(false));
+    this->MakeSlotAvailable(&this->filterGravitationalPotentialParam);
+
+    this->minEntropyParam.SetParameter(new param::FloatParam(0.0f));
+    this->MakeSlotAvailable(&this->minEntropyParam);
+    this->maxEntropyParam.SetParameter(new param::FloatParam(0.0f));
+    this->MakeSlotAvailable(&this->maxEntropyParam);
+    this->filterEntropyParam.SetParameter(new param::BoolParam(false));
+    this->MakeSlotAvailable(&this->filterEntropyParam);
+
+    this->minAgnDistanceParam.SetParameter(new param::FloatParam(0.0f));
+    this->MakeSlotAvailable(&this->minAgnDistanceParam);
+    this->maxAgnDistanceParam.SetParameter(new param::FloatParam(0.0f));
+    this->MakeSlotAvailable(&this->maxAgnDistanceParam);
+    this->filterAgnDistanceParam.SetParameter(new param::BoolParam(false));
+    this->MakeSlotAvailable(&this->filterAgnDistanceParam);
+
+    this->fillFilterButtonParam.SetParameter(new param::ButtonParam(core::view::Key::KEY_F));
+    this->MakeSlotAvailable(&this->fillFilterButtonParam);
+
+    this->initFields();
+}
+
+/*
+ * SimpleAstroFilter::~SimpleAstroFilter
+ */
+SimpleAstroFilter::~SimpleAstroFilter(void) { this->Release(); }
+
+/*
+ * SimpleAstroFilter::create
+ */
+bool SimpleAstroFilter::create(void) {
+    // intentionally empty
+    return true;
+}
+
+/*
+ * SimpleAstroFilter::release
+ */
+void SimpleAstroFilter::release(void) {
+    // intentionally empty
+}
+
+/*
+ * SimpleAstroFilter::getData
+ */
+bool SimpleAstroFilter::getData(core::Call& call) {
+    AstroDataCall* adc = dynamic_cast<AstroDataCall*>(&call);
+    if (adc == nullptr) return false;
+
+    AstroDataCall* inCall = this->particlesInSlot.CallAs<AstroDataCall>();
+    if (inCall == nullptr) return false;
+
+    inCall->operator=(*adc);
+    inCall->SetUnlocker(nullptr, false);
+    if ((*inCall)(AstroDataCall::CallForGetData)) {
+        if (this->refilter) {
+            this->filter(*inCall);
+            this->refilter = false;
+        }
+        this->copyContentToOutCall(*adc);
+        if (this->fillFilterButtonParam.IsDirty()) {
+            this->setDisplayedValues(*adc);
+            this->fillFilterButtonParam.ResetDirty();
+        }
+        inCall->Unlock();
+        return true;
+    }
+    inCall->Unlock();
+    return false;
+}
+
+/*
+ * SimpleAstroFilter::getExtent
+ */
+bool SimpleAstroFilter::getExtent(core::Call& call) {
+    AstroDataCall* adc = dynamic_cast<AstroDataCall*>(&call);
+    if (adc == nullptr) return false;
+
+    AstroDataCall* inCall = this->particlesInSlot.CallAs<AstroDataCall>();
+    if (inCall == nullptr) return false;
+
+    inCall->operator=(*adc);
+    adc->SetUnlocker(nullptr, false);
+    if ((*inCall)(AstroDataCall::CallForGetExtent)) {
+        adc->operator=(*inCall);
+        if (this->lastDataHash != inCall->DataHash() || this->lastTimestep != adc->FrameID() || this->isParamDirty()) {
+            this->hashOffset++;
+            this->lastTimestep = adc->FrameID();
+            this->lastDataHash = inCall->DataHash();
+            this->refilter = true;
+            this->resetDirtyParams();
+        }
+        adc->SetDataHash(this->lastDataHash + this->hashOffset);
+        return true;
+    }
+    return false;
+}
+
+/*
+ * SimpleAstroFilter::initFields
+ */
+void SimpleAstroFilter::initFields(void) {
+    if (this->positions == nullptr) {
+        this->positions = std::make_shared<std::vector<glm::vec3>>();
+    }
+    if (this->velocities == nullptr) {
+        this->velocities = std::make_shared<std::vector<glm::vec3>>();
+    }
+    if (this->temperatures == nullptr) {
+        this->temperatures = std::make_shared<std::vector<float>>();
+    }
+    if (this->masses == nullptr) {
+        this->masses = std::make_shared<std::vector<float>>();
+    }
+    if (this->internalEnergies == nullptr) {
+        this->internalEnergies = std::make_shared<std::vector<float>>();
+    }
+    if (this->smoothingLengths == nullptr) {
+        this->smoothingLengths = std::make_shared<std::vector<float>>();
+    }
+    if (this->molecularWeights == nullptr) {
+        this->molecularWeights = std::make_shared<std::vector<float>>();
+    }
+    if (this->densities == nullptr) {
+        this->densities = std::make_shared<std::vector<float>>();
+    }
+    if (this->gravitationalPotentials == nullptr) {
+        this->gravitationalPotentials = std::make_shared<std::vector<float>>();
+    }
+    if (this->entropies == nullptr) {
+        this->entropies = std::make_shared<std::vector<float>>();
+    }
+    if (this->isBaryonFlags == nullptr) {
+        this->isBaryonFlags = std::make_shared<std::vector<bool>>();
+    }
+    if (this->isStarFlags == nullptr) {
+        this->isStarFlags = std::make_shared<std::vector<bool>>();
+    }
+    if (this->isWindFlags == nullptr) {
+        this->isWindFlags = std::make_shared<std::vector<bool>>();
+    }
+    if (this->isStarFormingGasFlags == nullptr) {
+        this->isStarFormingGasFlags = std::make_shared<std::vector<bool>>();
+    }
+    if (this->isAGNFlags == nullptr) {
+        this->isAGNFlags = std::make_shared<std::vector<bool>>();
+    }
+    if (this->particleIDs == nullptr) {
+        this->particleIDs = std::make_shared<std::vector<int64_t>>();
+    }
+    if (this->agnDistances == nullptr) {
+        this->agnDistances = std::make_shared<std::vector<float>>();
+    }
+}
+
+/*
+ * SimpleAstroFilter::filter
+ */
+bool SimpleAstroFilter::filter(const AstroDataCall& call) {
+    std::set<uint64_t> filterResult;
+    std::vector<uint64_t> help(call.GetParticleCount());
+    std::iota(help.begin(), help.end(), 0);
+    filterResult.insert(help.begin(), help.end());
+
+    for (uint64_t i = 0; i < call.GetParticleCount(); ++i) {
+        if (this->showOnlyBaryonParam.Param<param::BoolParam>()->Value() && !call.GetIsBaryonFlags()->at(i)) {
+            filterResult.erase(i);
+        }
+        if (this->showOnlyDarkMatterParam.Param<param::BoolParam>()->Value() && call.GetIsBaryonFlags()->at(i)) {
+            filterResult.erase(i);
+        }
+        if (this->showOnlyStarsParam.Param<param::BoolParam>()->Value() && !call.GetIsStarFlags()->at(i)) {
+            filterResult.erase(i);
+        }
+        if (this->showOnlyWindParam.Param<param::BoolParam>()->Value() && !call.GetIsWindFlags()->at(i)) {
+            filterResult.erase(i);
+        }
+        if (this->showOnlyStarFormingGasParam.Param<param::BoolParam>()->Value() &&
+            !call.GetIsStarFormingGasFlags()->at(i)) {
+            filterResult.erase(i);
+        }
+        if (this->showOnlyAGNsParam.Param<param::BoolParam>()->Value() && !call.GetIsAGNFlags()->at(i)) {
+            filterResult.erase(i);
+        }
+        if (this->filterVelocityMagnitudeParam.Param<param::BoolParam>()->Value()) {
+            if (glm::length(call.GetVelocities()->at(i)) <
+                    this->minVelocityMagnitudeParam.Param<param::FloatParam>()->Value() ||
+                glm::length(call.GetVelocities()->at(i)) >
+                    this->maxVelocityMagnitudeParam.Param<param::FloatParam>()->Value()) {
+                filterResult.erase(i);
+            }
+        }
+        if (this->filterTemperatureParam.Param<param::BoolParam>()->Value()) {
+            if (call.GetTemperature()->at(i) < this->minTemperatureParam.Param<param::FloatParam>()->Value() ||
+                call.GetTemperature()->at(i) > this->maxTemperatureParam.Param<param::FloatParam>()->Value()) {
+                filterResult.erase(i);
+            }
+        }
+        if (this->filterMassParam.Param<param::BoolParam>()->Value()) {
+            if (call.GetMass()->at(i) < this->minMassParam.Param<param::FloatParam>()->Value() ||
+                call.GetMass()->at(i) > this->maxMassParam.Param<param::FloatParam>()->Value()) {
+                filterResult.erase(i);
+            }
+        }
+        if (this->filterInternalEnergyParam.Param<param::BoolParam>()->Value()) {
+            if (call.GetInternalEnergy()->at(i) < this->minInternalEnergyParam.Param<param::FloatParam>()->Value() ||
+                call.GetInternalEnergy()->at(i) > this->maxInternalEnergyParam.Param<param::FloatParam>()->Value()) {
+                filterResult.erase(i);
+            }
+        }
+        if (this->filterSmoothingLengthParam.Param<param::BoolParam>()->Value()) {
+            if (call.GetSmoothingLength()->at(i) < this->minSmoothingLengthParam.Param<param::FloatParam>()->Value() ||
+                call.GetSmoothingLength()->at(i) > this->maxSmoothingLengthParam.Param<param::FloatParam>()->Value()) {
+                filterResult.erase(i);
+            }
+        }
+        if (this->filterMolecularWeightParam.Param<param::BoolParam>()->Value()) {
+            if (call.GetMolecularWeights()->at(i) < this->minMolecularWeightParam.Param<param::FloatParam>()->Value() ||
+                call.GetMolecularWeights()->at(i) > this->maxMolecularWeightParam.Param<param::FloatParam>()->Value()) {
+                filterResult.erase(i);
+            }
+        }
+        if (this->filterDensityParam.Param<param::BoolParam>()->Value()) {
+            if (call.GetDensity()->at(i) < this->minDensityParam.Param<param::FloatParam>()->Value() ||
+                call.GetDensity()->at(i) > this->maxDensityParam.Param<param::FloatParam>()->Value()) {
+                filterResult.erase(i);
+            }
+        }
+        if (this->filterGravitationalPotentialParam.Param<param::BoolParam>()->Value()) {
+            if (call.GetGravitationalPotential()->at(i) <
+                    this->minGravitationalPotentialParam.Param<param::FloatParam>()->Value() ||
+                call.GetGravitationalPotential()->at(i) >
+                    this->maxGravitationalPotentialParam.Param<param::FloatParam>()->Value()) {
+                filterResult.erase(i);
+            }
+        }
+        if (this->filterEntropyParam.Param<param::BoolParam>()->Value()) {
+            if (call.GetEntropy()->at(i) < this->minEntropyParam.Param<param::FloatParam>()->Value() ||
+                call.GetEntropy()->at(i) > this->maxEntropyParam.Param<param::FloatParam>()->Value()) {
+                filterResult.erase(i);
+            }
+        }
+        if (this->filterAgnDistanceParam.Param<param::BoolParam>()->Value()) {
+            if (call.GetAgnDistances()->at(i) < this->minAgnDistanceParam.Param<param::FloatParam>()->Value() ||
+                call.GetAgnDistances()->at(i) > this->maxAgnDistanceParam.Param<param::FloatParam>()->Value()) {
+                filterResult.erase(i);
+            }
+        }
+    }
+    return this->copyInCallToContent(call, filterResult);
+}
+
+/*
+ * SimpleAstroFilter::copyContentToOutCall
+ */
+bool SimpleAstroFilter::copyContentToOutCall(AstroDataCall& outCall) {
+    outCall.SetPositions(this->positions);
+    outCall.SetVelocities(this->velocities);
+    outCall.SetTemperature(this->temperatures);
+    outCall.SetMass(this->masses);
+    outCall.SetInternalEnergy(this->internalEnergies);
+    outCall.SetSmoothingLength(this->smoothingLengths);
+    outCall.SetMolecularWeights(this->molecularWeights);
+    outCall.SetDensity(this->densities);
+    outCall.SetGravitationalPotential(this->gravitationalPotentials);
+    outCall.SetEntropy(this->entropies);
+    outCall.SetIsBaryonFlags(this->isBaryonFlags);
+    outCall.SetIsStarFlags(this->isStarFlags);
+    outCall.SetIsWindFlags(this->isWindFlags);
+    outCall.SetIsStarFormingGasFlags(this->isStarFormingGasFlags);
+    outCall.SetIsAGNFlags(this->isAGNFlags);
+    outCall.SetParticleIDs(this->particleIDs);
+    outCall.SetAGNDistances(this->agnDistances);
+    return true;
+}
+
+/*
+ * SimpleAstroFilter::copyInCallToContent
+ */
+bool SimpleAstroFilter::copyInCallToContent(const AstroDataCall& inCall, const std::set<uint64_t>& indexSet) {
+    this->positions->resize(indexSet.size());
+    this->velocities->resize(indexSet.size());
+    this->temperatures->resize(indexSet.size());
+    this->masses->resize(indexSet.size());
+    this->internalEnergies->resize(indexSet.size());
+    this->smoothingLengths->resize(indexSet.size());
+    this->molecularWeights->resize(indexSet.size());
+    this->densities->resize(indexSet.size());
+    this->gravitationalPotentials->resize(indexSet.size());
+    this->entropies->resize(indexSet.size());
+    this->isBaryonFlags->resize(indexSet.size());
+    this->isStarFlags->resize(indexSet.size());
+    this->isWindFlags->resize(indexSet.size());
+    this->isStarFormingGasFlags->resize(indexSet.size());
+    this->isAGNFlags->resize(indexSet.size());
+    this->particleIDs->resize(indexSet.size());
+    this->agnDistances->resize(indexSet.size());
+
+    std::vector<uint64_t> setVec(indexSet.begin(), indexSet.end());
+    std::sort(setVec.begin(), setVec.end());
+
+    uint64_t i = 0;
+    for (const auto id : setVec) {
+        this->positions->at(i) = inCall.GetPositions()->at(id);
+        this->velocities->at(i) = inCall.GetVelocities()->at(id);
+        this->temperatures->at(i) = inCall.GetTemperature()->at(id);
+        this->masses->at(i) = inCall.GetMass()->at(id);
+        this->internalEnergies->at(i) = inCall.GetInternalEnergy()->at(id);
+        this->smoothingLengths->at(i) = inCall.GetSmoothingLength()->at(id);
+        this->molecularWeights->at(i) = inCall.GetMolecularWeights()->at(id);
+        this->densities->at(i) = inCall.GetDensity()->at(id);
+        this->gravitationalPotentials->at(i) = inCall.GetGravitationalPotential()->at(id);
+        this->entropies->at(i) = inCall.GetEntropy()->at(i);
+        this->isBaryonFlags->at(i) = inCall.GetIsBaryonFlags()->at(id);
+        this->isStarFlags->at(i) = inCall.GetIsStarFlags()->at(id);
+        this->isWindFlags->at(i) = inCall.GetIsWindFlags()->at(id);
+        this->isStarFormingGasFlags->at(i) = inCall.GetIsStarFormingGasFlags()->at(id);
+        this->isAGNFlags->at(i) = inCall.GetIsAGNFlags()->at(id);
+        this->particleIDs->at(i) = inCall.GetParticleIDs()->at(id);
+        this->agnDistances->at(i) = inCall.GetAgnDistances()->at(id);
+        ++i;
+    }
+    return true;
+}
+
+/*
+ * SimpleAstroFilter::isParamDirty
+ */
+bool SimpleAstroFilter::isParamDirty(void) {
+    if (this->showOnlyBaryonParam.IsDirty()) return true;
+    if (this->showOnlyDarkMatterParam.IsDirty()) return true;
+    if (this->showOnlyStarsParam.IsDirty()) return true;
+    if (this->showOnlyWindParam.IsDirty()) return true;
+    if (this->showOnlyStarFormingGasParam.IsDirty()) return true;
+    if (this->showOnlyAGNsParam.IsDirty()) return true;
+    if (this->minVelocityMagnitudeParam.IsDirty()) return true;
+    if (this->maxVelocityMagnitudeParam.IsDirty()) return true;
+    if (this->filterVelocityMagnitudeParam.IsDirty()) return true;
+    if (this->minTemperatureParam.IsDirty()) return true;
+    if (this->maxTemperatureParam.IsDirty()) return true;
+    if (this->filterTemperatureParam.IsDirty()) return true;
+    if (this->minMassParam.IsDirty()) return true;
+    if (this->maxMassParam.IsDirty()) return true;
+    if (this->filterMassParam.IsDirty()) return true;
+    if (this->minInternalEnergyParam.IsDirty()) return true;
+    if (this->maxInternalEnergyParam.IsDirty()) return true;
+    if (this->filterInternalEnergyParam.IsDirty()) return true;
+    if (this->minSmoothingLengthParam.IsDirty()) return true;
+    if (this->maxSmoothingLengthParam.IsDirty()) return true;
+    if (this->filterSmoothingLengthParam.IsDirty()) return true;
+    if (this->minMolecularWeightParam.IsDirty()) return true;
+    if (this->maxMolecularWeightParam.IsDirty()) return true;
+    if (this->filterMolecularWeightParam.IsDirty()) return true;
+    if (this->minDensityParam.IsDirty()) return true;
+    if (this->maxDensityParam.IsDirty()) return true;
+    if (this->filterDensityParam.IsDirty()) return true;
+    if (this->minGravitationalPotentialParam.IsDirty()) return true;
+    if (this->maxGravitationalPotentialParam.IsDirty()) return true;
+    if (this->filterGravitationalPotentialParam.IsDirty()) return true;
+    if (this->minEntropyParam.IsDirty()) return true;
+    if (this->maxEntropyParam.IsDirty()) return true;
+    if (this->filterEntropyParam.IsDirty()) return true;
+    if (this->minAgnDistanceParam.IsDirty()) return true;
+    if (this->maxAgnDistanceParam.IsDirty()) return true;
+    if (this->filterAgnDistanceParam.IsDirty()) return true;
+    return false;
+}
+
+/*
+ * SimpleAstroFilter::resetDirtyParams
+ */
+void SimpleAstroFilter::resetDirtyParams(void) {
+    this->showOnlyBaryonParam.ResetDirty();
+    this->showOnlyDarkMatterParam.ResetDirty();
+    this->showOnlyStarsParam.ResetDirty();
+    this->showOnlyWindParam.ResetDirty();
+    this->showOnlyStarFormingGasParam.ResetDirty();
+    this->showOnlyAGNsParam.ResetDirty();
+    this->minVelocityMagnitudeParam.ResetDirty();
+    this->maxVelocityMagnitudeParam.ResetDirty();
+    this->filterVelocityMagnitudeParam.ResetDirty();
+    this->minTemperatureParam.ResetDirty();
+    this->maxTemperatureParam.ResetDirty();
+    this->filterTemperatureParam.ResetDirty();
+    this->minMassParam.ResetDirty();
+    this->maxMassParam.ResetDirty();
+    this->filterMassParam.ResetDirty();
+    this->minInternalEnergyParam.ResetDirty();
+    this->maxInternalEnergyParam.ResetDirty();
+    this->filterInternalEnergyParam.ResetDirty();
+    this->minSmoothingLengthParam.ResetDirty();
+    this->maxSmoothingLengthParam.ResetDirty();
+    this->filterSmoothingLengthParam.ResetDirty();
+    this->minMolecularWeightParam.ResetDirty();
+    this->maxMolecularWeightParam.ResetDirty();
+    this->filterMolecularWeightParam.ResetDirty();
+    this->minDensityParam.ResetDirty();
+    this->maxDensityParam.ResetDirty();
+    this->filterDensityParam.ResetDirty();
+    this->minGravitationalPotentialParam.ResetDirty();
+    this->maxGravitationalPotentialParam.ResetDirty();
+    this->filterGravitationalPotentialParam.ResetDirty();
+    this->minEntropyParam.ResetDirty();
+    this->maxEntropyParam.ResetDirty();
+    this->filterEntropyParam.ResetDirty();
+    this->minAgnDistanceParam.ResetDirty();
+    this->maxAgnDistanceParam.ResetDirty();
+    this->filterAgnDistanceParam.ResetDirty();
+}
+
+/*
+ * SimpleAstroFilter::setDisplayedValues
+ */
+void SimpleAstroFilter::setDisplayedValues(const AstroDataCall& outCall) {
+    float minVelocity = FLT_MAX, maxVelocity = -FLT_MAX;
+    float minTemperature = FLT_MAX, maxTemperature = -FLT_MAX;
+    float minMass = FLT_MAX, maxMass = -FLT_MAX;
+    float minInternalEnergy = FLT_MAX, maxInternalEnergy = -FLT_MAX;
+    float minSmoothingLength = FLT_MAX, maxSmoothingLength = -FLT_MAX;
+    float minMolecularWeight = FLT_MAX, maxMolecularWeight = -FLT_MAX;
+    float minDensity = FLT_MAX, maxDensity = -FLT_MAX;
+    float minGravitationalPotential = FLT_MAX, maxGravitationalPotential = -FLT_MAX;
+    float minEntropy = FLT_MAX, maxEntropy = -FLT_MAX;
+    float minAGNDistance = FLT_MAX, maxAGNDistance = -FLT_MAX;
+
+    for (uint64_t i = 0; i < outCall.GetParticleCount(); ++i) {
+        if (glm::length(outCall.GetVelocities()->at(i)) < minVelocity) {
+            minVelocity = glm::length(outCall.GetVelocities()->at(i));
+        }
+        if (glm::length(outCall.GetVelocities()->at(i)) > maxVelocity) {
+            maxVelocity = glm::length(outCall.GetVelocities()->at(i));
+        }
+
+        if (outCall.GetTemperature()->at(i) < minTemperature) {
+            minTemperature = outCall.GetTemperature()->at(i);
+        }
+        if (outCall.GetTemperature()->at(i) > maxTemperature) {
+            maxTemperature = outCall.GetTemperature()->at(i);
+        }
+
+        if (outCall.GetMass()->at(i) < minMass) {
+            minMass = outCall.GetMass()->at(i);
+        }
+        if (outCall.GetMass()->at(i) > maxMass) {
+            maxMass = outCall.GetMass()->at(i);
+        }
+
+        if (outCall.GetInternalEnergy()->at(i) < minInternalEnergy) {
+            minInternalEnergy = outCall.GetInternalEnergy()->at(i);
+        }
+        if (outCall.GetInternalEnergy()->at(i) > maxInternalEnergy) {
+            maxInternalEnergy = outCall.GetInternalEnergy()->at(i);
+        }
+
+        if (outCall.GetSmoothingLength()->at(i) < minSmoothingLength) {
+            minSmoothingLength = outCall.GetSmoothingLength()->at(i);
+        }
+        if (outCall.GetSmoothingLength()->at(i) > maxSmoothingLength) {
+            maxSmoothingLength = outCall.GetSmoothingLength()->at(i);
+        }
+
+        if (outCall.GetMolecularWeights()->at(i) < minMolecularWeight) {
+            minMolecularWeight = outCall.GetMolecularWeights()->at(i);
+        }
+        if (outCall.GetMolecularWeights()->at(i) > maxMolecularWeight) {
+            maxMolecularWeight = outCall.GetMolecularWeights()->at(i);
+        }
+
+        if (outCall.GetDensity()->at(i) < minDensity) {
+            minDensity = outCall.GetDensity()->at(i);
+        }
+        if (outCall.GetDensity()->at(i) > maxDensity) {
+            maxDensity = outCall.GetDensity()->at(i);
+        }
+
+        if (outCall.GetGravitationalPotential()->at(i) < minGravitationalPotential) {
+            minGravitationalPotential = outCall.GetGravitationalPotential()->at(i);
+        }
+        if (outCall.GetGravitationalPotential()->at(i) > maxGravitationalPotential) {
+            maxGravitationalPotential = outCall.GetGravitationalPotential()->at(i);
+        }
+
+        if (outCall.GetEntropy()->at(i) < minEntropy) {
+            minEntropy = outCall.GetEntropy()->at(i);
+        }
+        if (outCall.GetEntropy()->at(i) > maxEntropy) {
+            maxEntropy = outCall.GetEntropy()->at(i);
+        }
+
+        if (outCall.GetAgnDistances()->at(i) < minAGNDistance) {
+            minAGNDistance = outCall.GetAgnDistances()->at(i);
+        }
+        if (outCall.GetAgnDistances()->at(i) > maxAGNDistance) {
+            maxAGNDistance = outCall.GetAgnDistances()->at(i);
+        }
+    }
+
+    this->minVelocityMagnitudeParam.Param<param::FloatParam>()->SetValue(minVelocity, false);
+    this->maxVelocityMagnitudeParam.Param<param::FloatParam>()->SetValue(maxVelocity, false);
+    this->minTemperatureParam.Param<param::FloatParam>()->SetValue(minTemperature, false);
+    this->maxTemperatureParam.Param<param::FloatParam>()->SetValue(maxTemperature, false);
+    this->minMassParam.Param<param::FloatParam>()->SetValue(minMass, false);
+    this->maxMassParam.Param<param::FloatParam>()->SetValue(maxMass, false);
+    this->minInternalEnergyParam.Param<param::FloatParam>()->SetValue(minInternalEnergy, false);
+    this->maxInternalEnergyParam.Param<param::FloatParam>()->SetValue(maxInternalEnergy, false);
+    this->minSmoothingLengthParam.Param<param::FloatParam>()->SetValue(minSmoothingLength, false);
+    this->maxSmoothingLengthParam.Param<param::FloatParam>()->SetValue(maxSmoothingLength, false);
+    this->minMolecularWeightParam.Param<param::FloatParam>()->SetValue(minMolecularWeight, false);
+    this->maxMolecularWeightParam.Param<param::FloatParam>()->SetValue(maxMolecularWeight, false);
+    this->minDensityParam.Param<param::FloatParam>()->SetValue(minDensity, false);
+    this->maxDensityParam.Param<param::FloatParam>()->SetValue(maxDensity, false);
+    this->minGravitationalPotentialParam.Param<param::FloatParam>()->SetValue(minGravitationalPotential, false);
+    this->maxGravitationalPotentialParam.Param<param::FloatParam>()->SetValue(maxGravitationalPotential, false);
+    this->minEntropyParam.Param<param::FloatParam>()->SetValue(minEntropy, false);
+    this->maxEntropyParam.Param<param::FloatParam>()->SetValue(maxEntropy, false);
+    this->minAgnDistanceParam.Param<param::FloatParam>()->SetValue(minAGNDistance, false);
+    this->maxAgnDistanceParam.Param<param::FloatParam>()->SetValue(maxAGNDistance, false);
+}
diff --git a/plugins/astro/src/SimpleAstroFilter.h b/plugins/astro/src/SimpleAstroFilter.h
new file mode 100644
index 000000000..52bb897e5
--- /dev/null
+++ b/plugins/astro/src/SimpleAstroFilter.h
@@ -0,0 +1,164 @@
+/*
+ * SimpleAstroFilter.h
+ *
+ * Copyright (C) 2019 by VISUS (Universitaet Stuttgart)
+ * Alle Rechte vorbehalten.
+ */
+#pragma once
+
+#include <set>
+#include "astro/AstroDataCall.h"
+#include "mmcore/CalleeSlot.h"
+#include "mmcore/CallerSlot.h"
+#include "mmcore/Module.h"
+#include "mmcore/param/ParamSlot.h"
+
+namespace megamol {
+namespace astro {
+
+class SimpleAstroFilter : public core::Module {
+public:
+    static const char* ClassName(void) { return "SimpleAstroFilter"; }
+    static const char* Description(void) { return "Filters the filament particles of a AstroParticleDataCall"; }
+    static bool IsAvailable(void) { return true; }
+
+    /** Ctor. */
+    SimpleAstroFilter(void);
+
+    /** Dtor. */
+    virtual ~SimpleAstroFilter(void);
+
+protected:
+    virtual bool create(void);
+    virtual void release(void);
+
+private:
+    bool getData(core::Call& call);
+    bool getExtent(core::Call& call);
+
+    void initFields(void);
+    bool filter(const AstroDataCall& call);
+    bool copyContentToOutCall(AstroDataCall& outCall);
+    bool copyInCallToContent(const AstroDataCall& inCall, const std::set<uint64_t>& indexSet);
+    bool isParamDirty(void);
+    void resetDirtyParams(void);
+    void setDisplayedValues(const AstroDataCall& outCall);
+
+    core::CalleeSlot particlesOutSlot;
+    core::CallerSlot particlesInSlot;
+
+    core::param::ParamSlot showOnlyBaryonParam;
+    core::param::ParamSlot showOnlyDarkMatterParam;
+    core::param::ParamSlot showOnlyStarsParam;
+    core::param::ParamSlot showOnlyWindParam;
+    core::param::ParamSlot showOnlyStarFormingGasParam;
+    core::param::ParamSlot showOnlyAGNsParam;
+
+    core::param::ParamSlot minVelocityMagnitudeParam;
+    core::param::ParamSlot maxVelocityMagnitudeParam;
+    core::param::ParamSlot filterVelocityMagnitudeParam;
+
+    core::param::ParamSlot minTemperatureParam;
+    core::param::ParamSlot maxTemperatureParam;
+    core::param::ParamSlot filterTemperatureParam;
+
+    core::param::ParamSlot minMassParam;
+    core::param::ParamSlot maxMassParam;
+    core::param::ParamSlot filterMassParam;
+
+    core::param::ParamSlot minInternalEnergyParam;
+    core::param::ParamSlot maxInternalEnergyParam;
+    core::param::ParamSlot filterInternalEnergyParam;
+
+    core::param::ParamSlot minSmoothingLengthParam;
+    core::param::ParamSlot maxSmoothingLengthParam;
+    core::param::ParamSlot filterSmoothingLengthParam;
+
+    core::param::ParamSlot minMolecularWeightParam;
+    core::param::ParamSlot maxMolecularWeightParam;
+    core::param::ParamSlot filterMolecularWeightParam;
+
+    core::param::ParamSlot minDensityParam;
+    core::param::ParamSlot maxDensityParam;
+    core::param::ParamSlot filterDensityParam;
+
+    core::param::ParamSlot minGravitationalPotentialParam;
+    core::param::ParamSlot maxGravitationalPotentialParam;
+    core::param::ParamSlot filterGravitationalPotentialParam;
+
+    core::param::ParamSlot minEntropyParam;
+    core::param::ParamSlot maxEntropyParam;
+    core::param::ParamSlot filterEntropyParam;
+
+    core::param::ParamSlot minAgnDistanceParam;
+    core::param::ParamSlot maxAgnDistanceParam;
+    core::param::ParamSlot filterAgnDistanceParam;
+
+    core::param::ParamSlot fillFilterButtonParam;
+
+    /** Pointer to the position array */
+    vec3ArrayPtr positions = nullptr;
+
+    /** Pointer to the velocity array */
+    vec3ArrayPtr velocities = nullptr;
+
+    /** Pointer to the temperature array */
+    floatArrayPtr temperatures = nullptr;
+
+    /** Pointer to the mass array */
+    floatArrayPtr masses = nullptr;
+
+    /** Pointer to the interal energy array */
+    floatArrayPtr internalEnergies = nullptr;
+
+    /** Pointer to the smoothing length array */
+    floatArrayPtr smoothingLengths = nullptr;
+
+    /** Pointer to the molecular weight array */
+    floatArrayPtr molecularWeights = nullptr;
+
+    /** Pointer to the density array */
+    floatArrayPtr densities = nullptr;
+
+    /** Pointer to the gravitational potential array */
+    floatArrayPtr gravitationalPotentials = nullptr;
+
+    /** Pointer to the entropy array */
+    floatArrayPtr entropies = nullptr;
+
+    /** Pointer to the baryon flag array */
+    boolArrayPtr isBaryonFlags = nullptr;
+
+    /** Pointer to the star flag array */
+    boolArrayPtr isStarFlags = nullptr;
+
+    /** Pointer to the wind flag array */
+    boolArrayPtr isWindFlags = nullptr;
+
+    /** Pointer to the star forming gas flag array */
+    boolArrayPtr isStarFormingGasFlags = nullptr;
+
+    /** Pointer to the AGN flag array */
+    boolArrayPtr isAGNFlags = nullptr;
+
+    /** Pointer to the particle ID array */
+    idArrayPtr particleIDs = nullptr;
+    
+    /** Pointer to the agn distance array */
+    floatArrayPtr agnDistances = nullptr;
+
+    /** flag determining whether the filaments have to be recalculated */
+    bool refilter;
+
+    /** Hash of the last calculated dataset */
+    uint64_t lastDataHash;
+
+    /** Offset from the hash given by the incoming call */
+    uint64_t hashOffset;
+
+    /** ID of the last visualized timestep */
+    uint32_t lastTimestep;
+};
+
+} // namespace astro
+} // namespace megamol
diff --git a/plugins/astro/src/SpectralIntensityVolume.cpp b/plugins/astro/src/SpectralIntensityVolume.cpp
new file mode 100644
index 000000000..d05e904d7
--- /dev/null
+++ b/plugins/astro/src/SpectralIntensityVolume.cpp
@@ -0,0 +1,1184 @@
+#include "stdafx.h"
+#include "SpectralIntensityVolume.h"
+
+#define _USE_MATH_DEFINES
+#include <math.h>
+
+#include <atomic>
+#include <fstream>
+#include <random>
+
+#include "mmcore/param/BoolParam.h"
+#include "mmcore/param/FloatParam.h"
+#include "mmcore/param/IntParam.h"
+
+#include "vislib/sys/ConsoleProgressBar.h"
+
+#include "omp.h"
+
+#include "simultaneous_sort.h"
+
+#include "mmcore/thecam/math/quaternion.h"
+
+
+megamol::astro::SpectralIntensityVolume::SpectralIntensityVolume()
+    : volume_in_slot_("volumeIn", "Input of volume containing optical depth")
+    , temp_in_slot_("tempIn", "Input of volume containing temperature")
+    , mass_in_slot_("massIn", "Input of volume containing mass")
+    , mw_in_slot_("mwIn", "Input of volume containing molecular weight")
+    , astro_in_slot_("astroIn", "Input of astro particles")
+    , volume_out_slot_("volumeOut", "Output of spectral intensity volume")
+    , lsu_out_slot_("lsuOut", "Output of Bremsstrahlungs volume")
+    , absorption_out_slot_("absorptionOut", "Output of Absorption volume")
+    , xResSlot("sizex", "The size of the volume in numbers of voxels")
+    , yResSlot("sizey", "The size of the volume in numbers of voxels")
+    , zResSlot("sizez", "The size of the volume in numbers of voxels")
+    , cyclXSlot("cyclX", "Considers cyclic boundary conditions in X direction")
+    , cyclYSlot("cyclY", "Considers cyclic boundary conditions in Y direction")
+    , cyclZSlot("cyclZ", "Considers cyclic boundary conditions in Z direction")
+    , normalizeSlot("normalize", "Normalize the output volume")
+    //, wavelength_slot_("wavelength", "Set the wavelength for the spectral intensity (in nm)")
+    , numSamplesSlot("numSamples", "Number of samples per particle in the darth volume case")
+    , absorptionBiasSlot("absorptionBias", "Determines influence of absorption coefficient in the darth volume case")
+    , coneSampleNumSlot("coneNumSamples", "Number of samples for cone tracing in darth volume case")
+    , coneAngleSlot("coneAngle", "Angle of the cone in the darth volume case (degree)") {
+    volume_in_slot_.SetCompatibleCall<core::misc::VolumetricDataCallDescription>();
+    MakeSlotAvailable(&volume_in_slot_);
+
+    temp_in_slot_.SetCompatibleCall<core::misc::VolumetricDataCallDescription>();
+    MakeSlotAvailable(&temp_in_slot_);
+
+    mass_in_slot_.SetCompatibleCall<core::misc::VolumetricDataCallDescription>();
+    MakeSlotAvailable(&mass_in_slot_);
+
+    mw_in_slot_.SetCompatibleCall<core::misc::VolumetricDataCallDescription>();
+    MakeSlotAvailable(&mw_in_slot_);
+
+    astro_in_slot_.SetCompatibleCall<AstroDataCallDescription>();
+    MakeSlotAvailable(&astro_in_slot_);
+
+    this->volume_out_slot_.SetCallback(core::misc::VolumetricDataCall::ClassName(),
+        core::misc::VolumetricDataCall::FunctionName(core::misc::VolumetricDataCall::IDX_GET_DATA),
+        &SpectralIntensityVolume::getDataCallback);
+    this->volume_out_slot_.SetCallback(core::misc::VolumetricDataCall::ClassName(),
+        core::misc::VolumetricDataCall::FunctionName(core::misc::VolumetricDataCall::IDX_GET_EXTENTS),
+        &SpectralIntensityVolume::getExtentCallback);
+    this->volume_out_slot_.SetCallback(core::misc::VolumetricDataCall::ClassName(),
+        core::misc::VolumetricDataCall::FunctionName(core::misc::VolumetricDataCall::IDX_GET_METADATA),
+        &SpectralIntensityVolume::getExtentCallback);
+    this->volume_out_slot_.SetCallback(core::misc::VolumetricDataCall::ClassName(),
+        core::misc::VolumetricDataCall::FunctionName(core::misc::VolumetricDataCall::IDX_START_ASYNC),
+        &SpectralIntensityVolume::dummyCallback);
+    this->volume_out_slot_.SetCallback(core::misc::VolumetricDataCall::ClassName(),
+        core::misc::VolumetricDataCall::FunctionName(core::misc::VolumetricDataCall::IDX_STOP_ASYNC),
+        &SpectralIntensityVolume::dummyCallback);
+    this->volume_out_slot_.SetCallback(core::misc::VolumetricDataCall::ClassName(),
+        core::misc::VolumetricDataCall::FunctionName(core::misc::VolumetricDataCall::IDX_TRY_GET_DATA),
+        &SpectralIntensityVolume::dummyCallback);
+    this->MakeSlotAvailable(&this->volume_out_slot_);
+
+    this->lsu_out_slot_.SetCallback(core::misc::VolumetricDataCall::ClassName(),
+        core::misc::VolumetricDataCall::FunctionName(core::misc::VolumetricDataCall::IDX_GET_DATA),
+        &SpectralIntensityVolume::getLSUDataCallback);
+    this->lsu_out_slot_.SetCallback(core::misc::VolumetricDataCall::ClassName(),
+        core::misc::VolumetricDataCall::FunctionName(core::misc::VolumetricDataCall::IDX_GET_EXTENTS),
+        &SpectralIntensityVolume::getExtentCallback);
+    this->lsu_out_slot_.SetCallback(core::misc::VolumetricDataCall::ClassName(),
+        core::misc::VolumetricDataCall::FunctionName(core::misc::VolumetricDataCall::IDX_GET_METADATA),
+        &SpectralIntensityVolume::getExtentCallback);
+    this->lsu_out_slot_.SetCallback(core::misc::VolumetricDataCall::ClassName(),
+        core::misc::VolumetricDataCall::FunctionName(core::misc::VolumetricDataCall::IDX_START_ASYNC),
+        &SpectralIntensityVolume::dummyCallback);
+    this->lsu_out_slot_.SetCallback(core::misc::VolumetricDataCall::ClassName(),
+        core::misc::VolumetricDataCall::FunctionName(core::misc::VolumetricDataCall::IDX_STOP_ASYNC),
+        &SpectralIntensityVolume::dummyCallback);
+    this->lsu_out_slot_.SetCallback(core::misc::VolumetricDataCall::ClassName(),
+        core::misc::VolumetricDataCall::FunctionName(core::misc::VolumetricDataCall::IDX_TRY_GET_DATA),
+        &SpectralIntensityVolume::dummyCallback);
+    this->MakeSlotAvailable(&this->lsu_out_slot_);
+
+    this->absorption_out_slot_.SetCallback(core::misc::VolumetricDataCall::ClassName(),
+        core::misc::VolumetricDataCall::FunctionName(core::misc::VolumetricDataCall::IDX_GET_DATA),
+        &SpectralIntensityVolume::getAbsorptionDataCallback);
+    this->absorption_out_slot_.SetCallback(core::misc::VolumetricDataCall::ClassName(),
+        core::misc::VolumetricDataCall::FunctionName(core::misc::VolumetricDataCall::IDX_GET_EXTENTS),
+        &SpectralIntensityVolume::getExtentCallback);
+    this->absorption_out_slot_.SetCallback(core::misc::VolumetricDataCall::ClassName(),
+        core::misc::VolumetricDataCall::FunctionName(core::misc::VolumetricDataCall::IDX_GET_METADATA),
+        &SpectralIntensityVolume::getExtentCallback);
+    this->absorption_out_slot_.SetCallback(core::misc::VolumetricDataCall::ClassName(),
+        core::misc::VolumetricDataCall::FunctionName(core::misc::VolumetricDataCall::IDX_START_ASYNC),
+        &SpectralIntensityVolume::dummyCallback);
+    this->absorption_out_slot_.SetCallback(core::misc::VolumetricDataCall::ClassName(),
+        core::misc::VolumetricDataCall::FunctionName(core::misc::VolumetricDataCall::IDX_STOP_ASYNC),
+        &SpectralIntensityVolume::dummyCallback);
+    this->absorption_out_slot_.SetCallback(core::misc::VolumetricDataCall::ClassName(),
+        core::misc::VolumetricDataCall::FunctionName(core::misc::VolumetricDataCall::IDX_TRY_GET_DATA),
+        &SpectralIntensityVolume::dummyCallback);
+    this->MakeSlotAvailable(&this->absorption_out_slot_);
+
+    this->xResSlot << new core::param::IntParam(16);
+    this->MakeSlotAvailable(&this->xResSlot);
+    this->yResSlot << new core::param::IntParam(16);
+    this->MakeSlotAvailable(&this->yResSlot);
+    this->zResSlot << new core::param::IntParam(16);
+    this->MakeSlotAvailable(&this->zResSlot);
+
+    this->cyclXSlot.SetParameter(new core::param::BoolParam(true));
+    this->MakeSlotAvailable(&this->cyclXSlot);
+    this->cyclYSlot.SetParameter(new core::param::BoolParam(true));
+    this->MakeSlotAvailable(&this->cyclYSlot);
+    this->cyclZSlot.SetParameter(new core::param::BoolParam(true));
+    this->MakeSlotAvailable(&this->cyclZSlot);
+
+    this->normalizeSlot << new core::param::BoolParam(true);
+    this->MakeSlotAvailable(&this->normalizeSlot);
+
+    /*this->wavelength_slot_ << new core::param::FloatParam(1.0f, std::numeric_limits<float>::min(), 1000.f);
+    MakeSlotAvailable(&wavelength_slot_);*/
+
+    numSamplesSlot << new core::param::IntParam(256, 1);
+    MakeSlotAvailable(&numSamplesSlot);
+
+    absorptionBiasSlot << new core::param::FloatParam(1.0f, -1.0f, 1.0f);
+    MakeSlotAvailable(&absorptionBiasSlot);
+
+    coneSampleNumSlot << new core::param::IntParam(4, 1);
+    MakeSlotAvailable(&coneSampleNumSlot);
+
+    coneAngleSlot << new core::param::FloatParam(2.0f, 0.001f, 90.0f);
+    MakeSlotAvailable(&coneAngleSlot);
+}
+
+
+megamol::astro::SpectralIntensityVolume::~SpectralIntensityVolume() { this->Release(); }
+
+
+bool megamol::astro::SpectralIntensityVolume::create() { return true; }
+
+
+void megamol::astro::SpectralIntensityVolume::release(void) {
+    delete[] this->metadata.MinValues;
+    delete[] this->metadata.MaxValues;
+    delete[] this->metadata.SliceDists[0];
+    delete[] this->metadata.SliceDists[1];
+    delete[] this->metadata.SliceDists[2];
+}
+
+
+bool megamol::astro::SpectralIntensityVolume::getExtentCallback(core::Call& c) {
+    auto* out = dynamic_cast<core::misc::VolumetricDataCall*>(&c);
+    if (out == nullptr) return false;
+
+    auto* ast = this->astro_in_slot_.CallAs<AstroDataCall>();
+    if (ast == nullptr) return false;
+
+    // if (!this->assertData(inMpdc, outDpdc)) return false;
+    ast->SetFrameID(out->FrameID(), true);
+    if (!(*ast)(1)) {
+        vislib::sys::Log::DefaultLog.WriteError(
+            "SpectralIntensityVolume: could not get current frame extents (%u)", time - 1);
+        return false;
+    }
+    out->AccessBoundingBoxes().SetObjectSpaceBBox(ast->GetBoundingBoxes().ObjectSpaceBBox());
+    out->AccessBoundingBoxes().SetObjectSpaceClipBox(ast->GetBoundingBoxes().ObjectSpaceClipBox());
+    out->SetFrameCount(ast->FrameCount());
+
+    return true;
+}
+
+
+bool megamol::astro::SpectralIntensityVolume::getDataCallback(core::Call& c) {
+    auto* ast = this->astro_in_slot_.CallAs<AstroDataCall>();
+    if (ast == nullptr) return false;
+
+    auto* vdc = this->volume_in_slot_.CallAs<core::misc::VolumetricDataCall>();
+    if (vdc == nullptr) return false;
+
+    auto* tdc = this->temp_in_slot_.CallAs<core::misc::VolumetricDataCall>();
+    if (tdc == nullptr) return false;
+
+    auto* mdc = this->mass_in_slot_.CallAs<core::misc::VolumetricDataCall>();
+    if (mdc == nullptr) return false;
+
+    auto* mwdc = this->mw_in_slot_.CallAs<core::misc::VolumetricDataCall>();
+    if (mwdc == nullptr) return false;
+
+    auto* outVol = dynamic_cast<core::misc::VolumetricDataCall*>(&c);
+    if (outVol == nullptr) return false;
+
+    ast->SetFrameID(outVol->FrameID(), true);
+    vdc->SetFrameID(outVol->FrameID(), true);
+    tdc->SetFrameID(outVol->FrameID(), true);
+    mdc->SetFrameID(outVol->FrameID(), true);
+    mwdc->SetFrameID(outVol->FrameID(), true);
+    if (!(*ast)(1)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get extents.");
+        return false;
+    }
+    if (!(*ast)(0)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get data.");
+        return false;
+    }
+    if (!(*vdc)(core::misc::VolumetricDataCall::IDX_GET_METADATA)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get volume metadata.");
+        return false;
+    }
+    if (!(*vdc)(core::misc::VolumetricDataCall::IDX_GET_EXTENTS)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get volume extents.");
+        return false;
+    }
+    if (!(*vdc)(core::misc::VolumetricDataCall::IDX_GET_DATA)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get volume data.");
+        return false;
+    }
+    if (!(*tdc)(core::misc::VolumetricDataCall::IDX_GET_METADATA)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get temperature volume metadata.");
+        return false;
+    }
+    if (!(*tdc)(core::misc::VolumetricDataCall::IDX_GET_EXTENTS)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get temperature volume extents.");
+        return false;
+    }
+    if (!(*tdc)(core::misc::VolumetricDataCall::IDX_GET_DATA)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get temperature volume data.");
+        return false;
+    }
+    if (!(*mdc)(core::misc::VolumetricDataCall::IDX_GET_METADATA)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get mass volume metadata.");
+        return false;
+    }
+    if (!(*mdc)(core::misc::VolumetricDataCall::IDX_GET_EXTENTS)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get mass volume extents.");
+        return false;
+    }
+    if (!(*mdc)(core::misc::VolumetricDataCall::IDX_GET_DATA)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get mass volume data.");
+        return false;
+    }
+
+    if (!(*mwdc)(core::misc::VolumetricDataCall::IDX_GET_METADATA)) {
+        vislib::sys::Log::DefaultLog.WriteError(
+            "SpectralIntensityVolume: Unable to get molecular weight volume metadata.");
+        return false;
+    }
+    if (!(*mwdc)(core::misc::VolumetricDataCall::IDX_GET_EXTENTS)) {
+        vislib::sys::Log::DefaultLog.WriteError(
+            "SpectralIntensityVolume: Unable to get molecular weight volume extents.");
+        return false;
+    }
+    if (!(*mwdc)(core::misc::VolumetricDataCall::IDX_GET_DATA)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get molecular weight volume data.");
+        return false;
+    }
+    if (this->time != ast->FrameID() || this->time != vdc->FrameID() || this->time != tdc->FrameID() ||
+        this->time != mdc->FrameID() || this->time != mwdc->FrameID() || this->in_datahash != ast->DataHash() ||
+        this->anythingDirty()) {
+        if (!this->createVolumeCPU(*vdc, *tdc, *mdc, *mwdc, *ast)) return false;
+        this->time = ast->FrameID();
+        this->in_datahash = ast->DataHash();
+        ++this->datahash;
+        this->resetDirty();
+    }
+
+    // TODO set data
+    outVol->SetData(this->vol_[0].data());
+    metadata.Components = 1; //< TODO Maybe we want several wavelengths simultaneously
+    metadata.GridType = core::misc::GridType_t::CARTESIAN;
+    metadata.Resolution[0] = static_cast<size_t>(this->xResSlot.Param<core::param::IntParam>()->Value());
+    metadata.Resolution[1] = static_cast<size_t>(this->yResSlot.Param<core::param::IntParam>()->Value());
+    metadata.Resolution[2] = static_cast<size_t>(this->zResSlot.Param<core::param::IntParam>()->Value());
+    metadata.ScalarType = core::misc::ScalarType_t::FLOATING_POINT;
+    metadata.ScalarLength = sizeof(float);
+    metadata.MinValues = new double[1];
+    metadata.MinValues[0] = this->min_dens_;
+    metadata.MaxValues = new double[1];
+    metadata.MaxValues[0] = this->max_dens_;
+    auto const bbox = ast->AccessBoundingBoxes().ObjectSpaceBBox();
+    metadata.Extents[0] = bbox.Width();
+    metadata.Extents[1] = bbox.Height();
+    metadata.Extents[2] = bbox.Depth();
+    metadata.NumberOfFrames = 1;
+    metadata.SliceDists[0] = new float[1];
+    metadata.SliceDists[0][0] = metadata.Extents[0] / static_cast<float>(metadata.Resolution[0] - 1);
+    metadata.SliceDists[1] = new float[1];
+    metadata.SliceDists[1][0] = metadata.Extents[1] / static_cast<float>(metadata.Resolution[1] - 1);
+    metadata.SliceDists[2] = new float[1];
+    metadata.SliceDists[2][0] = metadata.Extents[2] / static_cast<float>(metadata.Resolution[2] - 1);
+
+    metadata.Origin[0] = bbox.Left();
+    metadata.Origin[1] = bbox.Bottom();
+    metadata.Origin[2] = bbox.Back();
+
+    metadata.IsUniform[0] = true;
+    metadata.IsUniform[1] = true;
+    metadata.IsUniform[2] = true;
+    outVol->SetMetadata(&metadata);
+
+    outVol->SetDataHash(this->datahash);
+
+    return true;
+}
+
+
+bool megamol::astro::SpectralIntensityVolume::getLSUDataCallback(core::Call& c) {
+    auto* ast = this->astro_in_slot_.CallAs<AstroDataCall>();
+    if (ast == nullptr) return false;
+
+    auto* vdc = this->volume_in_slot_.CallAs<core::misc::VolumetricDataCall>();
+    if (vdc == nullptr) return false;
+
+    auto* tdc = this->temp_in_slot_.CallAs<core::misc::VolumetricDataCall>();
+    if (tdc == nullptr) return false;
+
+    auto* mdc = this->mass_in_slot_.CallAs<core::misc::VolumetricDataCall>();
+    if (mdc == nullptr) return false;
+
+    auto* mwdc = this->mw_in_slot_.CallAs<core::misc::VolumetricDataCall>();
+    if (mwdc == nullptr) return false;
+
+    auto* outVol = dynamic_cast<core::misc::VolumetricDataCall*>(&c);
+    if (outVol == nullptr) return false;
+
+    ast->SetFrameID(outVol->FrameID(), true);
+    vdc->SetFrameID(outVol->FrameID(), true);
+    tdc->SetFrameID(outVol->FrameID(), true);
+    mdc->SetFrameID(outVol->FrameID(), true);
+    mwdc->SetFrameID(outVol->FrameID(), true);
+    if (!(*ast)(1)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get extents.");
+        return false;
+    }
+    if (!(*ast)(0)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get data.");
+        return false;
+    }
+    if (!(*vdc)(core::misc::VolumetricDataCall::IDX_GET_METADATA)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get volume metadata.");
+        return false;
+    }
+    if (!(*vdc)(core::misc::VolumetricDataCall::IDX_GET_EXTENTS)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get volume extents.");
+        return false;
+    }
+    if (!(*vdc)(core::misc::VolumetricDataCall::IDX_GET_DATA)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get volume data.");
+        return false;
+    }
+    if (!(*tdc)(core::misc::VolumetricDataCall::IDX_GET_METADATA)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get temperature volume metadata.");
+        return false;
+    }
+    if (!(*tdc)(core::misc::VolumetricDataCall::IDX_GET_EXTENTS)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get temperature volume extents.");
+        return false;
+    }
+    if (!(*tdc)(core::misc::VolumetricDataCall::IDX_GET_DATA)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get temperature volume data.");
+        return false;
+    }
+    if (!(*mdc)(core::misc::VolumetricDataCall::IDX_GET_METADATA)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get mass volume metadata.");
+        return false;
+    }
+    if (!(*mdc)(core::misc::VolumetricDataCall::IDX_GET_EXTENTS)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get mass volume extents.");
+        return false;
+    }
+    if (!(*mdc)(core::misc::VolumetricDataCall::IDX_GET_DATA)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get mass volume data.");
+        return false;
+    }
+
+    if (!(*mwdc)(core::misc::VolumetricDataCall::IDX_GET_METADATA)) {
+        vislib::sys::Log::DefaultLog.WriteError(
+            "SpectralIntensityVolume: Unable to get molecular weight volume metadata.");
+        return false;
+    }
+    if (!(*mwdc)(core::misc::VolumetricDataCall::IDX_GET_EXTENTS)) {
+        vislib::sys::Log::DefaultLog.WriteError(
+            "SpectralIntensityVolume: Unable to get molecular weight volume extents.");
+        return false;
+    }
+    if (!(*mwdc)(core::misc::VolumetricDataCall::IDX_GET_DATA)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get molecular weight volume data.");
+        return false;
+    }
+    if (this->time != ast->FrameID() || this->time != vdc->FrameID() || this->time != tdc->FrameID() ||
+        this->time != mdc->FrameID() || this->time != mwdc->FrameID() || this->in_datahash != ast->DataHash() ||
+        this->anythingDirty()) {
+        if (!this->createBremsstrahlungVolume(*vdc, *tdc, *mdc, *mwdc, *ast)) return false;
+        this->time = ast->FrameID();
+        this->in_datahash = ast->DataHash();
+        ++this->datahash;
+        this->resetDirty();
+    }
+
+    // TODO set data
+    outVol->SetData(this->vol_[0].data());
+    metadata.Components = 1; //< TODO Maybe we want several wavelengths simultaneously
+    metadata.GridType = core::misc::GridType_t::CARTESIAN;
+    metadata.Resolution[0] = static_cast<size_t>(this->xResSlot.Param<core::param::IntParam>()->Value());
+    metadata.Resolution[1] = static_cast<size_t>(this->yResSlot.Param<core::param::IntParam>()->Value());
+    metadata.Resolution[2] = static_cast<size_t>(this->zResSlot.Param<core::param::IntParam>()->Value());
+    metadata.ScalarType = core::misc::ScalarType_t::FLOATING_POINT;
+    metadata.ScalarLength = sizeof(float);
+    metadata.MinValues = new double[1];
+    metadata.MinValues[0] = this->min_dens_;
+    metadata.MaxValues = new double[1];
+    metadata.MaxValues[0] = this->max_dens_;
+    auto const bbox = ast->AccessBoundingBoxes().ObjectSpaceBBox();
+    metadata.Extents[0] = bbox.Width();
+    metadata.Extents[1] = bbox.Height();
+    metadata.Extents[2] = bbox.Depth();
+    metadata.NumberOfFrames = 1;
+    metadata.SliceDists[0] = new float[1];
+    metadata.SliceDists[0][0] = metadata.Extents[0] / static_cast<float>(metadata.Resolution[0] - 1);
+    metadata.SliceDists[1] = new float[1];
+    metadata.SliceDists[1][0] = metadata.Extents[1] / static_cast<float>(metadata.Resolution[1] - 1);
+    metadata.SliceDists[2] = new float[1];
+    metadata.SliceDists[2][0] = metadata.Extents[2] / static_cast<float>(metadata.Resolution[2] - 1);
+
+    metadata.Origin[0] = bbox.Left();
+    metadata.Origin[1] = bbox.Bottom();
+    metadata.Origin[2] = bbox.Back();
+
+    metadata.IsUniform[0] = true;
+    metadata.IsUniform[1] = true;
+    metadata.IsUniform[2] = true;
+    outVol->SetMetadata(&metadata);
+
+    outVol->SetDataHash(this->datahash);
+
+    return true;
+}
+
+
+bool megamol::astro::SpectralIntensityVolume::getAbsorptionDataCallback(core::Call& c) {
+    auto* ast = this->astro_in_slot_.CallAs<AstroDataCall>();
+    if (ast == nullptr) return false;
+
+    auto* vdc = this->volume_in_slot_.CallAs<core::misc::VolumetricDataCall>();
+    if (vdc == nullptr) return false;
+
+    auto* tdc = this->temp_in_slot_.CallAs<core::misc::VolumetricDataCall>();
+    if (tdc == nullptr) return false;
+
+    auto* mdc = this->mass_in_slot_.CallAs<core::misc::VolumetricDataCall>();
+    if (mdc == nullptr) return false;
+
+    auto* mwdc = this->mw_in_slot_.CallAs<core::misc::VolumetricDataCall>();
+    if (mwdc == nullptr) return false;
+
+    auto* outVol = dynamic_cast<core::misc::VolumetricDataCall*>(&c);
+    if (outVol == nullptr) return false;
+
+    ast->SetFrameID(outVol->FrameID(), true);
+    vdc->SetFrameID(outVol->FrameID(), true);
+    tdc->SetFrameID(outVol->FrameID(), true);
+    mdc->SetFrameID(outVol->FrameID(), true);
+    mwdc->SetFrameID(outVol->FrameID(), true);
+    if (!(*ast)(1)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get extents.");
+        return false;
+    }
+    if (!(*ast)(0)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get data.");
+        return false;
+    }
+    if (!(*vdc)(core::misc::VolumetricDataCall::IDX_GET_METADATA)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get volume metadata.");
+        return false;
+    }
+    if (!(*vdc)(core::misc::VolumetricDataCall::IDX_GET_EXTENTS)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get volume extents.");
+        return false;
+    }
+    if (!(*vdc)(core::misc::VolumetricDataCall::IDX_GET_DATA)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get volume data.");
+        return false;
+    }
+    if (!(*tdc)(core::misc::VolumetricDataCall::IDX_GET_METADATA)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get temperature volume metadata.");
+        return false;
+    }
+    if (!(*tdc)(core::misc::VolumetricDataCall::IDX_GET_EXTENTS)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get temperature volume extents.");
+        return false;
+    }
+    if (!(*tdc)(core::misc::VolumetricDataCall::IDX_GET_DATA)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get temperature volume data.");
+        return false;
+    }
+    if (!(*mdc)(core::misc::VolumetricDataCall::IDX_GET_METADATA)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get mass volume metadata.");
+        return false;
+    }
+    if (!(*mdc)(core::misc::VolumetricDataCall::IDX_GET_EXTENTS)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get mass volume extents.");
+        return false;
+    }
+    if (!(*mdc)(core::misc::VolumetricDataCall::IDX_GET_DATA)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get mass volume data.");
+        return false;
+    }
+
+    if (!(*mwdc)(core::misc::VolumetricDataCall::IDX_GET_METADATA)) {
+        vislib::sys::Log::DefaultLog.WriteError(
+            "SpectralIntensityVolume: Unable to get molecular weight volume metadata.");
+        return false;
+    }
+    if (!(*mwdc)(core::misc::VolumetricDataCall::IDX_GET_EXTENTS)) {
+        vislib::sys::Log::DefaultLog.WriteError(
+            "SpectralIntensityVolume: Unable to get molecular weight volume extents.");
+        return false;
+    }
+    if (!(*mwdc)(core::misc::VolumetricDataCall::IDX_GET_DATA)) {
+        vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Unable to get molecular weight volume data.");
+        return false;
+    }
+    if (this->time != ast->FrameID() || this->time != vdc->FrameID() || this->time != tdc->FrameID() ||
+        this->time != mdc->FrameID() || this->time != mwdc->FrameID() || this->in_datahash != ast->DataHash() ||
+        this->anythingDirty()) {
+        if (!this->createAbsorptionVolume(*vdc, *tdc, *mdc, *mwdc, *ast)) return false;
+        this->time = ast->FrameID();
+        this->in_datahash = ast->DataHash();
+        ++this->datahash;
+        this->resetDirty();
+    }
+
+    // TODO set data
+    outVol->SetData(this->vol_[0].data());
+    metadata.Components = 1; //< TODO Maybe we want several wavelengths simultaneously
+    metadata.GridType = core::misc::GridType_t::CARTESIAN;
+    metadata.Resolution[0] = static_cast<size_t>(this->xResSlot.Param<core::param::IntParam>()->Value());
+    metadata.Resolution[1] = static_cast<size_t>(this->yResSlot.Param<core::param::IntParam>()->Value());
+    metadata.Resolution[2] = static_cast<size_t>(this->zResSlot.Param<core::param::IntParam>()->Value());
+    metadata.ScalarType = core::misc::ScalarType_t::FLOATING_POINT;
+    metadata.ScalarLength = sizeof(float);
+    metadata.MinValues = new double[1];
+    metadata.MinValues[0] = this->min_dens_;
+    metadata.MaxValues = new double[1];
+    metadata.MaxValues[0] = this->max_dens_;
+    auto const bbox = ast->AccessBoundingBoxes().ObjectSpaceBBox();
+    metadata.Extents[0] = bbox.Width();
+    metadata.Extents[1] = bbox.Height();
+    metadata.Extents[2] = bbox.Depth();
+    metadata.NumberOfFrames = 1;
+    metadata.SliceDists[0] = new float[1];
+    metadata.SliceDists[0][0] = metadata.Extents[0] / static_cast<float>(metadata.Resolution[0] - 1);
+    metadata.SliceDists[1] = new float[1];
+    metadata.SliceDists[1][0] = metadata.Extents[1] / static_cast<float>(metadata.Resolution[1] - 1);
+    metadata.SliceDists[2] = new float[1];
+    metadata.SliceDists[2][0] = metadata.Extents[2] / static_cast<float>(metadata.Resolution[2] - 1);
+
+    metadata.Origin[0] = bbox.Left();
+    metadata.Origin[1] = bbox.Bottom();
+    metadata.Origin[2] = bbox.Back();
+
+    metadata.IsUniform[0] = true;
+    metadata.IsUniform[1] = true;
+    metadata.IsUniform[2] = true;
+    outVol->SetMetadata(&metadata);
+
+    outVol->SetDataHash(this->datahash);
+
+    return true;
+}
+
+
+bool megamol::astro::SpectralIntensityVolume::createVolumeCPU(core::misc::VolumetricDataCall const& volumeIn,
+    core::misc::VolumetricDataCall const& tempIn, core::misc::VolumetricDataCall const& massIn,
+    core::misc::VolumetricDataCall const& mwIn, AstroDataCall& astroIn) {
+    vislib::sys::Log::DefaultLog.WriteInfo("SpectralIntensityVolume: Starting volume creation.");
+
+    auto const sx = this->xResSlot.Param<core::param::IntParam>()->Value();
+    auto const sy = this->yResSlot.Param<core::param::IntParam>()->Value();
+    auto const sz = this->zResSlot.Param<core::param::IntParam>()->Value();
+
+    // float const wl = this->wavelength_slot_.Param<core::param::FloatParam>()->Value() / 1000000000.0f;
+
+    auto const numSamples = numSamplesSlot.Param<core::param::IntParam>()->Value();
+    double const bias = absorptionBiasSlot.Param<core::param::FloatParam>()->Value();
+
+    auto const numConeSamples = coneSampleNumSlot.Param<core::param::IntParam>()->Value();
+    auto const coneAngleDeg = coneAngleSlot.Param<core::param::FloatParam>()->Value();
+
+    auto const numCells = sx * sy * sz;
+
+    vol_.resize(omp_get_max_threads());
+#pragma omp parallel for
+    for (int init = 0; init < omp_get_max_threads(); ++init) {
+        vol_[init].resize(numCells);
+        std::fill(vol_[init].begin(), vol_[init].end(), 0.0f);
+    }
+
+    auto const cycl_x = this->cyclXSlot.Param<core::param::BoolParam>()->Value();
+    auto const cycl_y = this->cyclYSlot.Param<core::param::BoolParam>()->Value();
+    auto const cycl_z = this->cyclZSlot.Param<core::param::BoolParam>()->Value();
+
+    auto const minOSx = astroIn.AccessBoundingBoxes().ObjectSpaceBBox().Left();
+    auto const minOSy = astroIn.AccessBoundingBoxes().ObjectSpaceBBox().Bottom();
+    auto const minOSz = astroIn.AccessBoundingBoxes().ObjectSpaceBBox().Back();
+    auto const rangeOSx = astroIn.AccessBoundingBoxes().ObjectSpaceBBox().Width();
+    auto const rangeOSy = astroIn.AccessBoundingBoxes().ObjectSpaceBBox().Height();
+    auto const rangeOSz = astroIn.AccessBoundingBoxes().ObjectSpaceBBox().Depth();
+    auto const halfRangeOSx = 0.5f * rangeOSx;
+    auto const halfRangeOSy = 0.5f * rangeOSy;
+    auto const halfRangeOSz = 0.5f * rangeOSz;
+
+    auto const sliceDistX = rangeOSx / static_cast<float>(sx - 1);
+    auto const sliceDistY = rangeOSy / static_cast<float>(sy - 1);
+    auto const sliceDistZ = rangeOSz / static_cast<float>(sz - 1);
+
+    auto const max_spec_dist = std::max(sliceDistX, std::max(sliceDistY, sliceDistZ));
+    // auto const cut_off = 10.0f * max_spec_dist;
+    auto constexpr cut_off = std::numeric_limits<float>::max();
+
+
+    auto positions = *astroIn.GetPositions().get();
+    auto velo = *astroIn.GetVelocities().get();
+    auto dens_f = *astroIn.GetDensity().get();
+    auto sl = *astroIn.GetSmoothingLength().get();
+    auto temps_f = *astroIn.GetTemperature().get();
+
+    auto isBaryon = astroIn.GetIsBaryonFlags();
+    std::vector<char> ib(isBaryon->size());
+    for (size_t idx = 0; idx < isBaryon->size(); ++idx) {
+        if (isBaryon->operator[](idx)) {
+            ib[idx] = 1;
+        } else {
+            ib[idx] = 0;
+        }
+    }
+
+    sort_with([](auto a, auto b) { return a > b; }, ib, positions, velo, dens_f, sl, temps_f);
+
+    auto it = std::find(ib.cbegin(), ib.cend(), false);
+    auto idx = std::distance(ib.cbegin(), it);
+
+    positions.erase(positions.begin() + idx, positions.end());
+    velo.erase(velo.begin() + idx, velo.end());
+    dens_f.erase(dens_f.begin() + idx, dens_f.end());
+    sl.erase(sl.begin() + idx, sl.end());
+    temps_f.erase(temps_f.begin() + idx, temps_f.end());
+
+    std::vector<double> dens(dens_f.size());
+    std::copy(dens_f.cbegin(), dens_f.cend(), dens.begin());
+    std::vector<double> temps(temps_f.size());
+    std::copy(temps_f.cbegin(), temps_f.cend(), temps.begin());
+
+    auto const minmax_dens = std::minmax_element(dens.begin(), dens.end());
+    auto const min_dens = *minmax_dens.first;
+    auto const minmax_dens_rcp = 1.0 / ((*minmax_dens.second) - min_dens);
+    auto const minmax_temp = std::minmax_element(temps.begin(), temps.end());
+    auto const min_temp = *minmax_temp.first;
+    auto const minmax_temp_rcp = 1.0 / ((*minmax_temp.second) - min_temp);
+
+    // normalize attributes
+    /*std::transform(dens.cbegin(), dens.cend(), dens.begin(),
+        [min_dens, minmax_dens_rcp](auto& val) { return (val - min_dens) * minmax_dens_rcp; });
+    std::transform(temps.cbegin(), temps.cend(), temps.begin(),
+        [min_temp, minmax_temp_rcp](auto& val) { return (val - min_temp) * minmax_temp_rcp; });*/
+
+    std::vector<double> radiance(dens.size());
+    std::transform(dens.cbegin(), dens.cend(), temps.cbegin(), radiance.begin(),
+        [](double d, double t) { return d * d * std::sqrt(t); });
+    std::transform(sl.cbegin(), sl.cend(), radiance.cbegin(), radiance.begin(),
+        [](float r, double rad) { return 4.0 * 0.333333333 * M_PI * rad * static_cast<double>(r * r * r); });
+    auto const minmax_rad = std::minmax_element(radiance.cbegin(), radiance.cend());
+    auto const min_rad = *minmax_rad.first;
+    auto const minmax_rad_rcp = 1.0 / ((*minmax_rad.second) - min_rad);
+    std::transform(radiance.cbegin(), radiance.cend(), radiance.begin(),
+        [min_rad, minmax_rad_rcp](auto& val) { return (val - min_rad) * minmax_rad_rcp; });
+
+
+    // prepare input volume
+    auto metadata = volumeIn.GetMetadata();
+    auto volume = reinterpret_cast<float const*>(volumeIn.GetData());
+
+    auto vol_min = metadata->MinValues[0];
+    auto vol_max = metadata->MaxValues[0];
+
+    auto vol_sx = metadata->Resolution[0];
+    auto vol_sy = metadata->Resolution[1];
+    auto vol_sz = metadata->Resolution[2];
+
+    auto vol_disx = metadata->SliceDists[0][0];
+    auto vol_disy = metadata->SliceDists[1][0];
+    auto vol_disz = metadata->SliceDists[2][0];
+
+    float min_vol_dis = std::min(vol_disx, std::min(vol_disy, vol_disz));
+
+    auto vol_orgx = metadata->Origin[0];
+    auto vol_orgy = metadata->Origin[1];
+    auto vol_orgz = metadata->Origin[2];
+
+    // prepare input temperature
+    metadata = tempIn.GetMetadata();
+    auto temperature = reinterpret_cast<float const*>(tempIn.GetData());
+
+    auto temp_vol_min = metadata->MinValues[0];
+    auto temp_vol_max = metadata->MaxValues[0];
+
+    auto temp_vol_sx = metadata->Resolution[0];
+    auto temp_vol_sy = metadata->Resolution[1];
+    auto temp_vol_sz = metadata->Resolution[2];
+
+    auto temp_vol_disx = metadata->SliceDists[0][0];
+    auto temp_vol_disy = metadata->SliceDists[1][0];
+    auto temp_vol_disz = metadata->SliceDists[2][0];
+
+    float temp_min_vol_dis = std::min(temp_vol_disx, std::min(temp_vol_disy, temp_vol_disz));
+
+    auto temp_vol_orgx = metadata->Origin[0];
+    auto temp_vol_orgy = metadata->Origin[1];
+    auto temp_vol_orgz = metadata->Origin[2];
+
+    // prepare input mass
+    metadata = massIn.GetMetadata();
+    auto mass = reinterpret_cast<float const*>(massIn.GetData());
+
+    auto mass_vol_min = metadata->MinValues[0];
+    auto mass_vol_max = metadata->MaxValues[0];
+
+    auto mass_vol_sx = metadata->Resolution[0];
+    auto mass_vol_sy = metadata->Resolution[1];
+    auto mass_vol_sz = metadata->Resolution[2];
+
+    auto mass_vol_disx = metadata->SliceDists[0][0];
+    auto mass_vol_disy = metadata->SliceDists[1][0];
+    auto mass_vol_disz = metadata->SliceDists[2][0];
+
+    float mass_min_vol_dis = std::min(mass_vol_disx, std::min(mass_vol_disy, mass_vol_disz));
+
+    auto mass_vol_orgx = metadata->Origin[0];
+    auto mass_vol_orgy = metadata->Origin[1];
+    auto mass_vol_orgz = metadata->Origin[2];
+
+    // prepare input molecular weight
+    metadata = mwIn.GetMetadata();
+    auto mw = reinterpret_cast<float const*>(mwIn.GetData());
+
+    auto mw_vol_min = metadata->MinValues[0];
+    auto mw_vol_max = metadata->MaxValues[0];
+
+    auto mw_vol_sx = metadata->Resolution[0];
+    auto mw_vol_sy = metadata->Resolution[1];
+    auto mw_vol_sz = metadata->Resolution[2];
+
+    auto mw_vol_disx = metadata->SliceDists[0][0];
+    auto mw_vol_disy = metadata->SliceDists[1][0];
+    auto mw_vol_disz = metadata->SliceDists[2][0];
+
+    float mw_min_vol_dis = std::min(mw_vol_disx, std::min(mw_vol_disy, mw_vol_disz));
+
+    auto mw_vol_orgx = metadata->Origin[0];
+    auto mw_vol_orgy = metadata->Origin[1];
+    auto mw_vol_orgz = metadata->Origin[2];
+
+    if (vol_sx != temp_vol_sx || vol_sx != mass_vol_sx || vol_sx != mw_vol_sx || vol_sy != temp_vol_sy ||
+        vol_sy != mass_vol_sy || vol_sy != mw_vol_sy || vol_sz != temp_vol_sz || vol_sz != mass_vol_sz ||
+        vol_sz != mw_vol_sz) {
+        vislib::sys::Log::DefaultLog.WriteError(
+            "SpectralIntensityVolume: Input volume size not compatible to requested output.");
+        return false;
+    }
+
+    auto const cell_vol = vol_disx * vol_disy * vol_disz;
+    auto const num_cells = vol_sx * vol_sy * vol_sz;
+
+    std::vector<double> optical(num_cells);
+    std::transform(volume, volume + numCells, temperature, optical.begin(), [](float d, float t) {
+        // offensive formula
+        //return 0.018 * std::pow(static_cast<double>(t), -1.5) * 0.0134 * 0.0134 * static_cast<double>(mw) * 1.2;
+        // correct formula?
+        return 0.018 * std::pow(static_cast<double>(t), -1.5) * 1.4 * static_cast<double>(d) * static_cast<double>(d) * 1.2;
+        // return 1.7 * 10e-25 * std::pow(static_cast<double>(t), -3.5) * 0.0134 * 0.0134 * static_cast<double>(mw)
+        // * 1.2;
+    });
+    std::transform(mass, mass + numCells, optical.cbegin(), optical.begin(), [](float m, double o) {
+        // offensive formula
+        //return o / m;
+        // correct formula
+        return o / (static_cast<double>(m) * static_cast<double>(m));
+    });
+    auto const minmax_optical = std::minmax_element(optical.cbegin(), optical.cend());
+    auto const min_optical = *minmax_optical.first;
+    auto const minmax_optical_rcp = 1.0 / (*minmax_optical.second - min_optical);
+    std::transform(optical.cbegin(), optical.cend(), optical.begin(),
+        [min_optical, minmax_optical_rcp](float o) { return (o - min_optical) * minmax_optical_rcp; });
+
+    // constexpr double kb = 1.380649e-23; // [J/K]
+    // constexpr double hp = 6.626070e-34; // [J*s]
+    // constexpr double c = 299792458.0;   // [m/s] (vacuum)
+    // constexpr double c_pc = 0.307;      // [pc/y] (vacuum)
+
+    // constexpr double pref = 2.0 * hp * c * c;
+    // constexpr double suff = hp * c;
+
+    // auto plank = [kb, hp, c, pref, suff](double wl, double t) -> double {
+    //    auto const a0 = pref / std::pow(wl, 5);
+    //    auto const b0 = std::exp(suff / (wl * kb * t)) - 1.0;
+    //    return a0 / b0;
+    //};
+
+    // auto bremsstrahlung = [](double rad, double d, double t) -> double {
+    //    // return d * d * std::sqrt(t) * 4.0 * 0.333 * 3.14 * rad * rad * rad;
+    //    return d * d * std::sqrt(t) * 4.0 * 3.14 * rad * rad * rad;
+    //};
+
+    // auto absorption = [kb, hp](double d, double t) -> double {
+    //    // if (hp * 10e17 < kb * t)
+    //    // return 0.018 * std::pow(t, -1.5) * 0.0134 * 0.0134 * d;//*10e-34;
+    //    return std::pow((t * 1e-9), -1.5) * d * d * 1e-20;
+    //};
+
+    vislib::sys::ConsoleProgressBar cpb;
+    std::atomic<int> counter(0);
+
+    std::vector<glm::i32vec3> voxel_idx(positions.size());
+    std::transform(positions.cbegin(), positions.cend(), voxel_idx.begin(),
+        [minOSx, minOSy, minOSz, sliceDistX, sliceDistY, sliceDistZ](auto const& pos) {
+            return glm::i32vec3(static_cast<int>((pos.x - minOSx) / sliceDistX),
+                static_cast<int>((pos.y - minOSy) / sliceDistY), static_cast<int>((pos.z - minOSz) / sliceDistZ));
+        });
+
+    /*std::vector<glm::vec3> voxel_pos(numCells);
+    for (int vz = 0; vz < sz; ++vz) {
+        for (int vy = 0; vy < sy; ++vy) {
+            for (int vx = 0; vx < sx; ++vx) {
+                auto const idx = (vz * sy + vy) * sx + vx;
+                voxel_pos[idx].x = static_cast<float>(vx) * sliceDistX + minOSx;
+                voxel_pos[idx].y = static_cast<float>(vy) * sliceDistY + minOSy;
+                voxel_pos[idx].z = static_cast<float>(vz) * sliceDistZ + minOSz;
+            }
+        }
+    }*/
+
+    std::uniform_real_distribution<> distr(0.0, 1.0);
+    std::mt19937_64 rng(42);
+
+    // Implements the Bump Function from
+    // https://en.wikipedia.org/wiki/Radial_basis_function
+    auto rbf = [](float const dist, float const epsilon) -> float {
+        if (dist >= epsilon) return 0.0f;
+        return std::exp(-1.0f / (1.0f - std::pow((1.0f / epsilon) * dist, 2.0f)));
+    };
+
+#if 1
+    cpb.Start("Volume Creation", positions.size());
+    auto const cone_factor = std::tan(coneAngleDeg * M_PI / 180.0f);
+    auto const cone_angle = coneAngleDeg * M_PI / 180.0;
+
+#    pragma omp parallel for
+    for (int64_t idx = 0; idx < positions.size(); ++idx) {
+        auto const pos = positions[idx];
+        /*auto x_base = pos.x;
+        auto x = voxel_idx[idx].x;
+        auto y_base = pos.y;
+        auto y = voxel_idx[idx].y;
+        auto z_base = pos.z;
+        auto z = voxel_idx[idx].z;*/
+        auto const rad = sl[idx];
+
+        
+
+        for (int iter = 0; iter < numSamples; ++iter) {
+            // https://corysimon.github.io/articles/uniformdistn-on-sphere/
+            auto phi = 2.0 * M_PI * distr(rng);
+            auto theta = std::acos(1.0 - 2.0 * distr(rng));
+            glm::vec3 dir = glm::vec3(
+                rad * std::sin(theta) * std::cos(phi), rad * std::sin(theta) * std::sin(phi), rad * std::cos(theta));
+            glm::vec3 org = pos + dir;
+            dir = glm::normalize(dir);
+            auto org_dir = dir;
+
+            for (int cone_idx = 0; cone_idx < numConeSamples; ++cone_idx) {
+                auto e = radiance[idx];
+
+                // modify dir
+                // https://stackoverflow.com/questions/38997302/create-random-unit-vector-inside-a-defined-conical-region
+                try {
+                    auto const z = distr(rng) * (1.0 - std::cos(cone_angle)) + std::cos(cone_angle);
+                    auto const phi = distr(rng) * 2.0 * M_PI;
+                    auto const y = std::sqrt(1.0 - z * z) * sin(phi);
+                    auto const x = std::sqrt(1.0 - z * z) * cos(phi);
+                    glm::vec3 rand(x, y, z);
+                    glm::vec3 base(0, 0, 1);
+                    auto const quat = core::thecam::math::quaternion<glm::quat>::from_vectors(base, org_dir);
+                    dir = core::thecam::math::rotate(rand, quat);
+                } catch (...) {
+                    vislib::sys::Log::DefaultLog.WriteError("SpectralIntensityVolume: Math gone wrong");
+                }
+
+                //double att = 0.0;
+                float t = 0.0f;
+                float t_max = std::sqrt(rangeOSx * rangeOSx + rangeOSy * rangeOSy + rangeOSz * rangeOSz);
+                float t_step = min_vol_dis;
+                while (t <= t_max && e > 0.0) {
+                    glm::vec3 const curr = org + t * dir;
+
+                    auto ax = static_cast<int>((curr.x - vol_orgx) / vol_disx);
+                    auto ay = static_cast<int>((curr.y - vol_orgy) / vol_disy);
+                    auto az = static_cast<int>((curr.z - vol_orgz) / vol_disz);
+
+                    ax = (ax + 4 * vol_sx) % vol_sx;
+                    ay = (ay + 4 * vol_sy) % vol_sy;
+                    az = (az + 4 * vol_sz) % vol_sz;
+
+                    double aps = optical[(az * vol_sy + ay) * vol_sx + ax];
+
+                    auto vx = static_cast<int>((curr.x - minOSx) / sliceDistX);
+                    auto vy = static_cast<int>((curr.y - minOSy) / sliceDistY);
+                    auto vz = static_cast<int>((curr.z - minOSz) / sliceDistZ);
+
+                    vx = (vx + 4 * sx) % sx;
+                    vy = (vy + 4 * sy) % sy;
+                    vz = (vz + 4 * sz) % sz;
+
+                    e -= e * aps;
+                    // att += aps * (1.0 - att);
+
+                    vol_[omp_get_thread_num()][(vz * sy + vy) * sx + vx] += e;
+
+                    /*auto const cone = cone_factor * t;
+                    auto const voxel_diff_x = static_cast<int>(cone / sliceDistX);
+                    auto const voxel_diff_y = static_cast<int>(cone / sliceDistY);
+                    auto const voxel_diff_z = static_cast<int>(cone / sliceDistZ);
+                    for (int vvz = vz - voxel_diff_z; vvz < vz + voxel_diff_z; ++vvz) {
+                        for (int vvy = vy - voxel_diff_y; vvy < vy + voxel_diff_y; ++vvy) {
+                            for (int vvx = vx - voxel_diff_x; vvx < vx + voxel_diff_x; ++vvx) {
+                                float const tmp_dis_x = sliceDistX * static_cast<float>(std::abs(vvx - vx));
+                                float const tmp_dis_y = sliceDistY * static_cast<float>(std::abs(vvy - vy));
+                                float const tmp_dis_z = sliceDistZ * static_cast<float>(std::abs(vvz - vz));
+                                auto const distance =
+                                    std::sqrt(tmp_dis_x * tmp_dis_x + tmp_dis_y * tmp_dis_y + tmp_dis_z * tmp_dis_z);
+                                auto const hvx = (vvx + 2 * sx) % sx;
+                                auto const hvy = (vvy + 2 * sy) % sy;
+                                auto const hvz = (vvz + 2 * sz) % sz;
+                                vol_[omp_get_thread_num()][(hvz * sy + hvy) * sx + hvx] += e * rbf(distance, cone);
+                            }
+                        }
+                    }*/
+
+                    t += t_step;
+                }
+            }
+        }
+
+        ++counter;
+        if (omp_get_thread_num() == 0) {
+            cpb.Set(counter.load());
+        }
+    }
+    cpb.Stop();
+#endif
+
+    for (int i = 1; i < omp_get_max_threads(); ++i) {
+        std::transform(vol_[i].begin(), vol_[i].end(), vol_[0].begin(), vol_[0].begin(), std::plus<>());
+    }
+
+    max_dens_ = *std::max_element(vol_[0].begin(), vol_[0].end());
+    min_dens_ = *std::min_element(vol_[0].begin(), vol_[0].end());
+    vislib::sys::Log::DefaultLog.WriteInfo(
+        "SpectralIntensityVolume: Captured intensity %f -> %f", min_dens_, max_dens_);
+
+    if (this->normalizeSlot.Param<core::param::BoolParam>()->Value()) {
+        auto const rcpValRange = 1.0f / (max_dens_ - min_dens_);
+        std::transform(vol_[0].begin(), vol_[0].end(), vol_[0].begin(),
+            [this, rcpValRange](float const& a) { return (a - min_dens_) * rcpValRange; });
+        min_dens_ = 0.0f;
+        max_dens_ = 1.0f;
+    }
+
+//#define SIV_DEBUG_OUTPUT
+#ifdef SIV_DEBUG_OUTPUT
+    std::ofstream raw_file{"int.raw", std::ios::binary};
+    raw_file.write(reinterpret_cast<char const*>(vol_[0].data()), vol_[0].size() * sizeof(float));
+    raw_file.close();
+    vislib::sys::Log::DefaultLog.WriteInfo("SpectralIntensityVolume: Debug file written\n");
+#endif
+
+    // Cleanup
+    vol_.resize(1);
+
+    return true;
+}
+
+
+bool megamol::astro::SpectralIntensityVolume::createBremsstrahlungVolume(core::misc::VolumetricDataCall const& volumeIn,
+    core::misc::VolumetricDataCall const& tempIn, core::misc::VolumetricDataCall const& massIn,
+    core::misc::VolumetricDataCall const& mwIn, AstroDataCall& astroIn) {
+    vislib::sys::Log::DefaultLog.WriteInfo("SpectralIntensityVolume: Starting volume creation.");
+
+    sx = this->xResSlot.Param<core::param::IntParam>()->Value();
+    sy = this->yResSlot.Param<core::param::IntParam>()->Value();
+    sz = this->zResSlot.Param<core::param::IntParam>()->Value();
+
+    auto numCells = sx * sy * sz;
+
+
+    // prepare input volume
+    auto metadata = volumeIn.GetMetadata();
+    auto density = reinterpret_cast<float const*>(volumeIn.GetData());
+
+    auto vol_min = metadata->MinValues[0];
+    auto vol_max = metadata->MaxValues[0];
+
+    auto vol_sx = metadata->Resolution[0];
+    auto vol_sy = metadata->Resolution[1];
+    auto vol_sz = metadata->Resolution[2];
+
+    auto vol_disx = metadata->SliceDists[0][0];
+    auto vol_disy = metadata->SliceDists[1][0];
+    auto vol_disz = metadata->SliceDists[2][0];
+
+    // prepare input temperature
+    metadata = tempIn.GetMetadata();
+    auto temperature = reinterpret_cast<float const*>(tempIn.GetData());
+
+    auto temp_vol_min = metadata->MinValues[0];
+    auto temp_vol_max = metadata->MaxValues[0];
+
+    auto temp_vol_sx = metadata->Resolution[0];
+    auto temp_vol_sy = metadata->Resolution[1];
+    auto temp_vol_sz = metadata->Resolution[2];
+
+
+    if (vol_sx != temp_vol_sx || vol_sy != temp_vol_sy || vol_sz != temp_vol_sz) {
+        vislib::sys::Log::DefaultLog.WriteError(
+            "SpectralIntensityVolume: Density and temperature volume are not compatible. Aborting.");
+        return false;
+    }
+
+    if (vol_sx != sx || vol_sy != sy || vol_sz != sz) {
+        vislib::sys::Log::DefaultLog.WriteError(
+            "SpectralIntensityVolume: Selected resolution not compatible to input. Resetting to %d %d %d.", vol_sx,
+            vol_sy, vol_sz);
+        sx = vol_sx;
+        sy = vol_sy;
+        sz = vol_sz;
+    }
+
+    numCells = vol_sx * vol_sy * vol_sz;
+
+    auto const cell_vol = vol_disx * vol_disy * vol_disz;
+    vol_.resize(1);
+    vol_[0].resize(numCells);
+    std::transform(density, density + numCells, temperature, vol_[0].begin(),
+        [cell_vol](float d, float t) { return d * d * std::sqrt(t) * cell_vol; });
+
+    max_dens_ = *std::max_element(vol_[0].begin(), vol_[0].end());
+    min_dens_ = *std::min_element(vol_[0].begin(), vol_[0].end());
+    vislib::sys::Log::DefaultLog.WriteInfo(
+        "SpectralIntensityVolume: Captured intensity %f -> %f", min_dens_, max_dens_);
+
+    if (this->normalizeSlot.Param<core::param::BoolParam>()->Value()) {
+        auto const rcpValRange = 1.0f / (max_dens_ - min_dens_);
+        std::transform(vol_[0].begin(), vol_[0].end(), vol_[0].begin(),
+            [this, rcpValRange](float const& a) { return (a - min_dens_) * rcpValRange; });
+        min_dens_ = 0.0f;
+        max_dens_ = 1.0f;
+    }
+
+    return true;
+}
+
+
+bool megamol::astro::SpectralIntensityVolume::createAbsorptionVolume(core::misc::VolumetricDataCall const& volumeIn,
+    core::misc::VolumetricDataCall const& tempIn, core::misc::VolumetricDataCall const& massIn,
+    core::misc::VolumetricDataCall const& mwIn, AstroDataCall& astroIn) {
+    vislib::sys::Log::DefaultLog.WriteInfo("SpectralIntensityVolume: Starting volume creation.");
+
+    sx = this->xResSlot.Param<core::param::IntParam>()->Value();
+    sy = this->yResSlot.Param<core::param::IntParam>()->Value();
+    sz = this->zResSlot.Param<core::param::IntParam>()->Value();
+
+    auto numCells = sx * sy * sz;
+
+
+    // prepare input mass
+    auto metadata = massIn.GetMetadata();
+    auto mass = reinterpret_cast<float const*>(massIn.GetData());
+
+    auto vol_min = metadata->MinValues[0];
+    auto vol_max = metadata->MaxValues[0];
+
+    auto vol_sx = metadata->Resolution[0];
+    auto vol_sy = metadata->Resolution[1];
+    auto vol_sz = metadata->Resolution[2];
+
+    auto vol_disx = metadata->SliceDists[0][0];
+    auto vol_disy = metadata->SliceDists[1][0];
+    auto vol_disz = metadata->SliceDists[2][0];
+
+    // prepare input temperature
+    metadata = tempIn.GetMetadata();
+    auto temperature = reinterpret_cast<float const*>(tempIn.GetData());
+
+    auto temp_vol_min = metadata->MinValues[0];
+    auto temp_vol_max = metadata->MaxValues[0];
+
+    auto temp_vol_sx = metadata->Resolution[0];
+    auto temp_vol_sy = metadata->Resolution[1];
+    auto temp_vol_sz = metadata->Resolution[2];
+
+    // prepare input molecular weight
+    metadata = tempIn.GetMetadata();
+    auto mw = reinterpret_cast<float const*>(tempIn.GetData());
+
+    auto mw_vol_min = metadata->MinValues[0];
+    auto mw_vol_max = metadata->MaxValues[0];
+
+    auto mw_vol_sx = metadata->Resolution[0];
+    auto mw_vol_sy = metadata->Resolution[1];
+    auto mw_vol_sz = metadata->Resolution[2];
+
+
+    if (vol_sx != temp_vol_sx || vol_sy != temp_vol_sy || vol_sz != temp_vol_sz || vol_sx != mw_vol_sx ||
+        vol_sy != mw_vol_sy || vol_sz != mw_vol_sz) {
+        vislib::sys::Log::DefaultLog.WriteError(
+            "SpectralIntensityVolume: Density and temperature volume are not compatible. Aborting.");
+        return false;
+    }
+
+    if (vol_sx != sx || vol_sy != sy || vol_sz != sz) {
+        vislib::sys::Log::DefaultLog.WriteError(
+            "SpectralIntensityVolume: Selected resolution not compatible to input. Resetting to %d %d %d.", vol_sx,
+            vol_sy, vol_sz);
+        sx = vol_sx;
+        sy = vol_sy;
+        sz = vol_sz;
+    }
+
+    numCells = vol_sx * vol_sy * vol_sz;
+
+    auto const cell_vol = vol_disx * vol_disy * vol_disz;
+    vol_.resize(1);
+    vol_[0].resize(numCells);
+    std::transform(mw, mw + numCells, temperature, vol_[0].begin(), [](float mw, float t) {
+        return 0.018 * std::pow(static_cast<double>(t), -1.5) * 0.0134 * 0.0134 * static_cast<double>(mw) * 1.2;
+    });
+    std::transform(mass, mass + numCells, vol_[0].cbegin(), vol_[0].begin(), [](float m, double o) { return o / m; });
+    auto const minmax_optical = std::minmax_element(vol_[0].cbegin(), vol_[0].cend());
+    auto const min_optical = *minmax_optical.first;
+    auto const minmax_optical_rcp = 1.0 / (*minmax_optical.second - min_optical);
+    std::transform(vol_[0].cbegin(), vol_[0].cend(), vol_[0].begin(),
+        [min_optical, minmax_optical_rcp](float o) { return (o - min_optical) * minmax_optical_rcp; });
+
+    max_dens_ = *std::max_element(vol_[0].begin(), vol_[0].end());
+    min_dens_ = *std::min_element(vol_[0].begin(), vol_[0].end());
+    vislib::sys::Log::DefaultLog.WriteInfo(
+        "SpectralIntensityVolume: Captured intensity %f -> %f", min_dens_, max_dens_);
+
+    if (this->normalizeSlot.Param<core::param::BoolParam>()->Value()) {
+        auto const rcpValRange = 1.0f / (max_dens_ - min_dens_);
+        std::transform(vol_[0].begin(), vol_[0].end(), vol_[0].begin(),
+            [this, rcpValRange](float const& a) { return (a - min_dens_) * rcpValRange; });
+        min_dens_ = 0.0f;
+        max_dens_ = 1.0f;
+    }
+
+    return true;
+}
diff --git a/plugins/astro/src/SpectralIntensityVolume.h b/plugins/astro/src/SpectralIntensityVolume.h
new file mode 100644
index 000000000..cac01d8e1
--- /dev/null
+++ b/plugins/astro/src/SpectralIntensityVolume.h
@@ -0,0 +1,131 @@
+#pragma once
+
+#include <vector>
+
+#include "mmcore/Call.h"
+#include "mmcore/CalleeSlot.h"
+#include "mmcore/CallerSlot.h"
+#include "mmcore/Module.h"
+#include "mmcore/param/ParamSlot.h"
+
+#include "vislib/sys/Log.h"
+
+#include "astro/AstroDataCall.h"
+#include "mmcore/misc/VolumetricDataCall.h"
+
+namespace megamol {
+namespace astro {
+
+class SpectralIntensityVolume : public core::Module {
+public:
+    static const char* ClassName(void) { return "SpectralIntensityVolume"; }
+
+    static const char* Description(void) { return "Creates of volume capturing spectral intensity."; }
+
+    static bool IsAvailable(void) { return true; }
+
+    SpectralIntensityVolume();
+
+    virtual ~SpectralIntensityVolume();
+
+protected:
+    bool create() override;
+
+    void release() override;
+
+private:
+    bool getExtentCallback(core::Call& c);
+
+    bool getDataCallback(core::Call& c);
+
+    bool getLSUDataCallback(core::Call& c);
+
+    bool getAbsorptionDataCallback(core::Call& c);
+
+    bool dummyCallback(megamol::core::Call& c) { return true; }
+
+    bool createVolumeCPU(core::misc::VolumetricDataCall const& volumeIn, core::misc::VolumetricDataCall const& tempIn,
+        core::misc::VolumetricDataCall const& massIn, core::misc::VolumetricDataCall const& mwIn,
+        AstroDataCall& astroIn);
+
+    bool createBremsstrahlungVolume(core::misc::VolumetricDataCall const& volumeIn,
+        core::misc::VolumetricDataCall const& tempIn, core::misc::VolumetricDataCall const& massIn,
+        core::misc::VolumetricDataCall const& mwIn, AstroDataCall& astroIn);
+
+    bool createAbsorptionVolume(core::misc::VolumetricDataCall const& volumeIn,
+        core::misc::VolumetricDataCall const& tempIn, core::misc::VolumetricDataCall const& massIn,
+        core::misc::VolumetricDataCall const& mwIn, AstroDataCall& astroIn);
+
+    bool anythingDirty() const {
+        return this->xResSlot.IsDirty() || this->yResSlot.IsDirty() || this->zResSlot.IsDirty() ||
+               this->cyclXSlot.IsDirty() || this->cyclYSlot.IsDirty() || this->cyclZSlot.IsDirty() ||
+               this->normalizeSlot.IsDirty() /*|| wavelength_slot_.IsDirty()*/ || numSamplesSlot.IsDirty() || absorptionBiasSlot.IsDirty();
+    }
+
+    void resetDirty() {
+        this->xResSlot.ResetDirty();
+        this->yResSlot.ResetDirty();
+        this->zResSlot.ResetDirty();
+        this->cyclXSlot.ResetDirty();
+        this->cyclYSlot.ResetDirty();
+        this->cyclZSlot.ResetDirty();
+        this->normalizeSlot.ResetDirty();
+        //wavelength_slot_.ResetDirty();
+        numSamplesSlot.ResetDirty();
+        absorptionBiasSlot.ResetDirty();
+    }
+
+    core::CallerSlot volume_in_slot_;
+
+    core::CallerSlot temp_in_slot_;
+
+    core::CallerSlot mass_in_slot_;
+
+    core::CallerSlot mw_in_slot_;
+
+    core::CallerSlot astro_in_slot_;
+
+    core::CalleeSlot volume_out_slot_;
+
+    core::CalleeSlot lsu_out_slot_;
+
+    core::CalleeSlot absorption_out_slot_;
+
+    core::param::ParamSlot xResSlot;
+    core::param::ParamSlot yResSlot;
+    core::param::ParamSlot zResSlot;
+
+    core::param::ParamSlot cyclXSlot;
+    core::param::ParamSlot cyclYSlot;
+    core::param::ParamSlot cyclZSlot;
+
+    core::param::ParamSlot normalizeSlot;
+
+    core::param::ParamSlot numSamplesSlot;
+
+    core::param::ParamSlot absorptionBiasSlot;
+
+    core::param::ParamSlot coneSampleNumSlot;
+
+    core::param::ParamSlot coneAngleSlot;
+
+    // core::param::ParamSlot wavelength_slot_;
+
+    std::vector<std::vector<float>> vol_;
+
+    float max_dens_ = 0.0f;
+    float min_dens_ = std::numeric_limits<float>::max();
+
+    size_t in_datahash = std::numeric_limits<size_t>::max();
+    size_t datahash = 0;
+    unsigned int time = std::numeric_limits<unsigned int>::max();
+
+    core::misc::VolumetricDataCall::Metadata metadata;
+
+    int sx = 0;
+    int sy = 0;
+    int sz = 0;
+}; // end class SpectralIntensityVolume
+
+} // end namespace astro
+} // end namespace megamol
\ No newline at end of file
diff --git a/plugins/astro/src/SurfaceLICRenderer.cpp b/plugins/astro/src/SurfaceLICRenderer.cpp
new file mode 100644
index 000000000..9e502dfdc
--- /dev/null
+++ b/plugins/astro/src/SurfaceLICRenderer.cpp
@@ -0,0 +1,503 @@
+#include "SurfaceLICRenderer.h"
+
+#include "mmcore/Call.h"
+#include "mmcore/CoreInstance.h"
+#include "mmcore/misc/VolumetricDataCall.h"
+#include "mmcore/param/BoolParam.h"
+#include "mmcore/param/ColorParam.h"
+#include "mmcore/param/EnumParam.h"
+#include "mmcore/param/FloatParam.h"
+#include "mmcore/param/IntParam.h"
+#include "mmcore/utility/ScaledBoundingBoxes.h"
+#include "mmcore/view/AbstractCallRender3D.h"
+#include "mmcore/view/CallGetTransferFunction.h"
+#include "mmcore/view/TransferFunction.h"
+
+#include "vislib/graphics/gl/GLSLComputeShader.h"
+#include "vislib/graphics/gl/GLSLShader.h"
+#include "vislib/graphics/gl/ShaderSource.h"
+#include "vislib/sys/Log.h"
+
+#include "glowl/Texture.hpp"
+#include "glowl/Texture2D.hpp"
+#include "glowl/Texture3D.hpp"
+
+#include <algorithm>
+#include <array>
+#include <cmath>
+#include <memory>
+#include <random>
+
+namespace megamol {
+namespace astro {
+
+SurfaceLICRenderer::SurfaceLICRenderer()
+    : input_renderer("input_renderer", "Renderer producing the surface and depth used for drawing the LIC upon")
+    , input_velocities("input_velocities", "Grid with velocities")
+    , input_transfer_function(
+          "m_input_transfer_function", "Transfer function to color the LIC according to the velocity magnitude")
+    , arc_length("arc_length", "Length of the streamlines relative to the domain size")
+    , num_advections("num_advections", "Number of advections for reaching the desired arc length")
+    , epsilon("epsilon", "Threshold for detecting coherent structures")
+    , noise_bands("noise_bands", "Number of noise bands for LOD noise")
+    , noise_scale("noise_scale", "Noise scalar for fine-tuning LOD noise")
+    , coloring("coloring", "Different options on velocity coloring")
+    , ka("lighting::ka", "Ambient part for Phong lighting")
+    , kd("lighting::kd", "Diffuse part for Phong lighting")
+    , ks("lighting::ks", "Specular part for Phong lighting")
+    , shininess("lighting::shininess", "Shininess for Phong lighting")
+    , ambient_color("lighting::ambient color", "Ambient color")
+    , specular_color("lighting::specular color", "Specular color")
+    , light_color("lighting::light color", "Light color")
+    , hash(-1) {
+
+    this->input_renderer.SetCompatibleCall<core::view::CallRender3DDescription>();
+    this->MakeSlotAvailable(&this->input_renderer);
+
+    this->input_velocities.SetCompatibleCall<core::misc::VolumetricDataCallDescription>();
+    this->MakeSlotAvailable(&this->input_velocities);
+
+    this->input_transfer_function.SetCompatibleCall<core::view::CallGetTransferFunctionDescription>();
+    this->MakeSlotAvailable(&this->input_transfer_function);
+
+    this->arc_length << new core::param::FloatParam(0.03f);
+    this->MakeSlotAvailable(&this->arc_length);
+
+    this->num_advections << new core::param::IntParam(100, 1);
+    this->MakeSlotAvailable(&this->num_advections);
+
+    this->noise_bands << new core::param::IntParam(2, 1);
+    this->MakeSlotAvailable(&this->noise_bands);
+
+    this->noise_scale << new core::param::FloatParam(5.0f);
+    this->MakeSlotAvailable(&this->noise_scale);
+
+    this->epsilon << new core::param::FloatParam(0.03f);
+    this->MakeSlotAvailable(&this->epsilon);
+
+    this->coloring << new core::param::EnumParam(0);
+    this->coloring.Param<core::param::EnumParam>()->SetTypePair(0, "Original");
+    this->coloring.Param<core::param::EnumParam>()->SetTypePair(1, "Projected");
+    this->coloring.Param<core::param::EnumParam>()->SetTypePair(2, "Difference");
+    this->MakeSlotAvailable(&this->coloring);
+
+    this->ka << new core::param::FloatParam(0.2f, 0.0f);
+    this->MakeSlotAvailable(&this->ka);
+
+    this->kd << new core::param::FloatParam(0.6f, 0.0f);
+    this->MakeSlotAvailable(&this->kd);
+
+    this->ks << new core::param::FloatParam(0.2f, 0.0f);
+    this->MakeSlotAvailable(&this->ks);
+
+    this->shininess << new core::param::FloatParam(10.0f, 0.0f);
+    this->MakeSlotAvailable(&this->shininess);
+
+    this->ambient_color << new core::param::ColorParam(1.0f, 1.0f, 1.0f, 1.0f);
+    this->MakeSlotAvailable(&this->ambient_color);
+
+    this->specular_color << new core::param::ColorParam(1.0f, 1.0f, 1.0f, 1.0f);
+    this->MakeSlotAvailable(&this->specular_color);
+
+    this->light_color << new core::param::ColorParam(1.0f, 1.0f, 1.0f, 1.0f);
+    this->MakeSlotAvailable(&this->light_color);
+}
+
+SurfaceLICRenderer::~SurfaceLICRenderer() { this->Release(); }
+
+bool SurfaceLICRenderer::create() {
+    try {
+        // create shader program
+        vislib::graphics::gl::ShaderSource precompute_shader_src;
+        vislib::graphics::gl::ShaderSource compute_shader_src;
+        vislib::graphics::gl::ShaderSource vertex_shader_src;
+        vislib::graphics::gl::ShaderSource fragment_shader_src;
+
+        if (!instance()->ShaderSourceFactory().MakeShaderSource(
+                "SurfaceLICRenderer::precompute", precompute_shader_src))
+            return false;
+        if (!this->pre_compute_shdr.Compile(precompute_shader_src.Code(), precompute_shader_src.Count())) return false;
+        if (!this->pre_compute_shdr.Link()) return false;
+
+        if (!instance()->ShaderSourceFactory().MakeShaderSource("SurfaceLICRenderer::compute", compute_shader_src))
+            return false;
+        if (!this->lic_compute_shdr.Compile(compute_shader_src.Code(), compute_shader_src.Count())) return false;
+        if (!this->lic_compute_shdr.Link()) return false;
+
+        if (!instance()->ShaderSourceFactory().MakeShaderSource("RaycastVolumeRenderer::vert", vertex_shader_src))
+            return false;
+        if (!instance()->ShaderSourceFactory().MakeShaderSource("RaycastVolumeRenderer::frag", fragment_shader_src))
+            return false;
+        if (!this->render_to_framebuffer_shdr.Compile(vertex_shader_src.Code(), vertex_shader_src.Count(),
+                fragment_shader_src.Code(), fragment_shader_src.Count()))
+            return false;
+        if (!this->render_to_framebuffer_shdr.Link()) return false;
+    } catch (vislib::graphics::gl::AbstractOpenGLShader::CompileException ce) {
+        vislib::sys::Log::DefaultLog.WriteMsg(vislib::sys::Log::LEVEL_ERROR, "Unable to compile shader (@%s): %s\n",
+            vislib::graphics::gl::AbstractOpenGLShader::CompileException::CompileActionName(ce.FailedAction()),
+            ce.GetMsgA());
+        return false;
+    } catch (vislib::Exception e) {
+        vislib::sys::Log::DefaultLog.WriteMsg(
+            vislib::sys::Log::LEVEL_ERROR, "Unable to compile shader: %s\n", e.GetMsgA());
+        return false;
+    } catch (...) {
+        vislib::sys::Log::DefaultLog.WriteMsg(
+            vislib::sys::Log::LEVEL_ERROR, "Unable to compile shader: Unknown exception\n");
+        return false;
+    }
+}
+
+void SurfaceLICRenderer::release() {
+}
+
+bool SurfaceLICRenderer::GetExtents(core::Call& call) {
+    auto cr = dynamic_cast<core::view::CallRender3D*>(&call);
+    auto ci = this->input_renderer.CallAs<core::view::CallRender3D>();
+    auto cd = this->input_velocities.CallAs<core::misc::VolumetricDataCall>();
+
+    if (cr == nullptr) return false;
+    if (ci == nullptr) return false;
+    if (cd == nullptr) return false;
+
+    int const req_frame = static_cast<int>(cr->Time());
+
+    ci->SetTime(req_frame);
+    cd->SetFrameID(req_frame, true);
+
+    *ci = *cr;
+
+    if (!(*ci)(core::view::CallRender3D::FnGetExtents)) return false;
+    if (!(*cd)(core::misc::VolumetricDataCall::IDX_GET_EXTENTS)) return false;
+
+    cr->SetTimeFramesCount(cd->FrameCount());
+    cr->AccessBoundingBoxes() =
+        core::utility::combineAndMagicScaleBoundingBoxes({cd->GetBoundingBoxes(), ci->GetBoundingBoxes()});
+
+    *cr = *ci;
+
+    return true;
+}
+
+bool SurfaceLICRenderer::Render(core::Call& call) {
+    auto cr = dynamic_cast<core::view::CallRender3D*>(&call);
+    if (cr == nullptr) return false;
+
+    const auto req_frame = cr->Time();
+
+    // Get input rendering
+    auto ci = this->input_renderer.CallAs<core::view::CallRender3D>();
+    if (ci == nullptr) return false;
+
+    ci->SetTime(req_frame);
+    ci->SetCameraParameters(cr->GetCameraParameters());
+
+    if (this->fbo.GetWidth() != ci->GetViewport().Width() || this->fbo.GetHeight() != ci->GetViewport().Height()) {
+        if (this->fbo.IsValid()) this->fbo.Release();
+
+        std::array<vislib::graphics::gl::FramebufferObject::ColourAttachParams, 2> cap;
+        cap[0].internalFormat = GL_RGBA8;
+        cap[0].format = GL_RGBA;
+        cap[0].type = GL_UNSIGNED_BYTE;
+        cap[1].internalFormat = GL_RGBA32F;
+        cap[1].format = GL_RGBA;
+        cap[1].type = GL_FLOAT;
+
+        vislib::graphics::gl::FramebufferObject::DepthAttachParams dap;
+        dap.format = GL_DEPTH_COMPONENT24;
+        dap.state = vislib::graphics::gl::FramebufferObject::ATTACHMENT_TEXTURE;
+
+        vislib::graphics::gl::FramebufferObject::StencilAttachParams sap;
+        sap.format = GL_STENCIL_INDEX;
+        sap.state = vislib::graphics::gl::FramebufferObject::ATTACHMENT_DISABLED;
+
+        this->fbo.Create(ci->GetViewport().Width(), ci->GetViewport().Height(), cap.size(), cap.data(), dap, sap);
+    }
+
+    this->fbo.Enable();
+
+    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+    if (!(*ci)(core::view::CallRender3D::FnRender)) return false;
+    cr->SetTimeFramesCount(ci->TimeFramesCount());
+
+    this->fbo.Disable();
+
+    // Get input velocities
+    auto cd = this->input_velocities.CallAs<core::misc::VolumetricDataCall>();
+    if (cd == nullptr) return false;
+
+    if (!(*cd)(core::misc::VolumetricDataCall::IDX_GET_DATA)) return false;
+
+    cd->SetFrameID(req_frame, true);
+
+    if (cd->GetComponents() != 3) {
+        vislib::sys::Log::DefaultLog.WriteError("Input velocities must be vectors with 3 components");
+        return false;
+    }
+
+    if (this->velocity_texture == nullptr || this->velocity_texture->getWidth() != cd->GetResolution(0) ||
+        this->velocity_texture->getHeight() != cd->GetResolution(1) ||
+        this->velocity_texture->getDepth() != cd->GetResolution(2) || this->hash != cd->DataHash()) {
+
+        this->hash = cd->DataHash();
+
+        glowl::TextureLayout velocity_layout(GL_RGB32F, cd->GetResolution(0), cd->GetResolution(1),
+            cd->GetResolution(2), GL_RGB, GL_FLOAT, 1,
+            {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
+                {GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_MIN_FILTER, GL_LINEAR},
+                {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
+            {});
+
+        this->velocity_texture = std::make_unique<glowl::Texture3D>("velocity_texture", velocity_layout, cd->GetData());
+    }
+
+    // Get input transfer function
+    auto ct = this->input_transfer_function.CallAs<core::view::CallGetTransferFunction>();
+
+    GLuint tf_texture = 0;
+
+    if (ct != nullptr && (*ct)()) {
+        tf_texture = ct->OpenGLTexture();
+    }
+
+    // Create velocity target texture
+    if (this->velocity_target == nullptr || this->velocity_target->getWidth() != cr->GetViewport().Width() ||
+        this->velocity_target->getHeight() != cr->GetViewport().Height()) {
+
+        glowl::TextureLayout velocity_tgt_layout(GL_RGBA32F, cr->GetViewport().Width(), cr->GetViewport().Height(), 1,
+            GL_RGBA, GL_FLOAT, 1,
+            {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
+                {GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_MIN_FILTER, GL_LINEAR},
+                {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
+            {});
+
+        this->velocity_target = std::make_unique<glowl::Texture2D>("velocity_target", velocity_tgt_layout, nullptr);
+    }
+
+    // Create render target texture
+    if (this->render_target == nullptr || this->render_target->getWidth() != cr->GetViewport().Width() ||
+        this->render_target->getHeight() != cr->GetViewport().Height()) {
+
+        glowl::TextureLayout render_tgt_layout(GL_RGBA8, cr->GetViewport().Width(), cr->GetViewport().Height(), 1,
+            GL_RGBA, GL_UNSIGNED_BYTE, 1,
+            {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
+                {GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_MIN_FILTER, GL_LINEAR},
+                {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
+            {});
+
+        this->render_target = std::make_unique<glowl::Texture2D>("render_target", render_tgt_layout, nullptr);
+    }
+
+    // Create noise texture
+    if (this->noise_texture == nullptr) {
+        glowl::TextureLayout noise_layout(GL_R32F, 64, 64, 64, GL_RED, GL_FLOAT, 1,
+            {{GL_TEXTURE_WRAP_S, GL_REPEAT}, {GL_TEXTURE_WRAP_T, GL_REPEAT}, {GL_TEXTURE_WRAP_R, GL_REPEAT},
+                {GL_TEXTURE_MIN_FILTER, GL_LINEAR},
+                {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
+            {});
+
+        this->noise.resize(64 * 64 * 64);
+
+        std::random_device r;
+        std::seed_seq seed{r(), r(), r(), r(), r(), r(), r(), r()};
+        std::mt19937 engine(seed);
+        //std::normal_distribution<float> normal_dist(0.0f, 0.5f);
+        std::uniform_real_distribution<float> normal_dist(0.0f, 1.0f);
+
+        auto random = [&engine, &normal_dist](
+                          float& value) { value = std::min(std::max(normal_dist(engine), 0.0f), 1.0f); };
+
+        std::for_each(this->noise.begin(), this->noise.end(), random);
+
+        this->noise_texture = std::make_unique<glowl::Texture3D>("noise_texture", noise_layout, this->noise.data());
+    }
+
+    // Get camera
+    core::utility::glMagicScale scaling;
+    scaling.apply(cr->GetBoundingBoxes());
+
+    std::array<GLfloat, 16> mv_matrix, proj_matrix;
+    glGetFloatv(GL_MODELVIEW_MATRIX, mv_matrix.data());
+    glGetFloatv(GL_PROJECTION_MATRIX, proj_matrix.data());
+
+    const auto cam_near = cr->GetCameraParameters()->NearClip();
+    const auto cam_far = cr->GetCameraParameters()->FarClip();
+
+    const std::array<float, 2> rt_resolution{
+        static_cast<float>(this->render_target->getWidth()), static_cast<float>(this->render_target->getHeight())};
+
+    const std::array<float, 3> origin{cr->GetBoundingBoxes().ObjectSpaceBBox().Left(),
+        cr->GetBoundingBoxes().ObjectSpaceBBox().Bottom(), cr->GetBoundingBoxes().ObjectSpaceBBox().Back()};
+    const std::array<float, 3> resolution{cr->GetBoundingBoxes().ObjectSpaceBBox().Width(),
+        cr->GetBoundingBoxes().ObjectSpaceBBox().Height(), cr->GetBoundingBoxes().ObjectSpaceBBox().Depth()};
+
+    std::array<float, 4> light = {0.0f, 0.0f, 1.0f, 1.0f};
+    glGetLightfv(GL_LIGHT0, GL_POSITION, light.data());
+
+    // Transform velocities to 2D in a pre-computation step
+    this->pre_compute_shdr.Enable();
+
+    glUniformMatrix4fv(this->pre_compute_shdr.ParameterLocation("view_mx"), 1, GL_FALSE, mv_matrix.data());
+    glUniformMatrix4fv(this->pre_compute_shdr.ParameterLocation("proj_mx"), 1, GL_FALSE, proj_matrix.data());
+
+    glUniform2fv(this->pre_compute_shdr.ParameterLocation("rt_resolution"), 1, rt_resolution.data());
+
+    glUniform3fv(this->pre_compute_shdr.ParameterLocation("origin"), 1, origin.data());
+    glUniform3fv(this->pre_compute_shdr.ParameterLocation("resolution"), 1, resolution.data());
+
+    glActiveTexture(GL_TEXTURE0);
+    this->fbo.BindDepthTexture();
+    glUniform1i(this->pre_compute_shdr.ParameterLocation("depth_tx2D"), 0);
+
+    glActiveTexture(GL_TEXTURE1);
+    this->fbo.BindColourTexture(1);
+    glUniform1i(this->pre_compute_shdr.ParameterLocation("normal_tx2D"), 1);
+
+    glActiveTexture(GL_TEXTURE2);
+    this->velocity_texture->bindTexture();
+    glUniform1i(this->pre_compute_shdr.ParameterLocation("velocity_tx3D"), 2);
+
+    this->velocity_target->bindImage(0, GL_WRITE_ONLY);
+
+    this->pre_compute_shdr.Dispatch(
+        static_cast<int>(std::ceil(rt_resolution[0] / 8.0f)), static_cast<int>(std::ceil(rt_resolution[1] / 8.0f)), 1);
+
+    glBindImageTexture(0, 0, 0, GL_TRUE, 0, GL_WRITE_ONLY, GL_R8);
+
+    glActiveTexture(GL_TEXTURE2);
+    glBindTexture(GL_TEXTURE_3D, 0);
+
+    glActiveTexture(GL_TEXTURE1);
+    glBindTexture(GL_TEXTURE_2D, 0);
+
+    glActiveTexture(GL_TEXTURE0);
+    glBindTexture(GL_TEXTURE_2D, 0);
+
+    this->pre_compute_shdr.Disable();
+
+    glMemoryBarrier(GL_TEXTURE_FETCH_BARRIER_BIT);
+
+    // Compute surface LIC
+    this->lic_compute_shdr.Enable();
+
+    glUniformMatrix4fv(this->lic_compute_shdr.ParameterLocation("view_mx"), 1, GL_FALSE, mv_matrix.data());
+    glUniformMatrix4fv(this->lic_compute_shdr.ParameterLocation("proj_mx"), 1, GL_FALSE, proj_matrix.data());
+
+    glUniform1f(this->lic_compute_shdr.ParameterLocation("cam_near"), cam_near);
+    glUniform1f(this->lic_compute_shdr.ParameterLocation("cam_far"), cam_far);
+
+    glUniform2fv(this->lic_compute_shdr.ParameterLocation("rt_resolution"), 1, rt_resolution.data());
+
+    glUniform3fv(this->lic_compute_shdr.ParameterLocation("origin"), 1, origin.data());
+    glUniform3fv(this->lic_compute_shdr.ParameterLocation("resolution"), 1, resolution.data());
+
+    glUniform1i(this->lic_compute_shdr.ParameterLocation("noise_bands"),
+        this->noise_bands.Param<core::param::IntParam>()->Value());
+    glUniform1f(this->lic_compute_shdr.ParameterLocation("noise_scale"),
+        this->noise_scale.Param<core::param::FloatParam>()->Value());
+    glUniform1f(this->lic_compute_shdr.ParameterLocation("arc_length"),
+        this->arc_length.Param<core::param::FloatParam>()->Value());
+    glUniform1i(this->lic_compute_shdr.ParameterLocation("num_advections"),
+        this->num_advections.Param<core::param::IntParam>()->Value());
+    glUniform1f(
+        this->lic_compute_shdr.ParameterLocation("epsilon"), this->epsilon.Param<core::param::FloatParam>()->Value());
+
+    glUniform1i(
+        this->lic_compute_shdr.ParameterLocation("coloring"), this->coloring.Param<core::param::EnumParam>()->Value());
+
+    glUniform1f(this->lic_compute_shdr.ParameterLocation("max_magnitude"),
+        static_cast<float>(cd->GetMetadata()->MaxValues[0]));
+
+    glUniform1f(this->lic_compute_shdr.ParameterLocation("ka"), this->ka.Param<core::param::FloatParam>()->Value());
+    glUniform1f(this->lic_compute_shdr.ParameterLocation("kd"), this->kd.Param<core::param::FloatParam>()->Value());
+    glUniform1f(this->lic_compute_shdr.ParameterLocation("ks"), this->ks.Param<core::param::FloatParam>()->Value());
+    glUniform1f(this->lic_compute_shdr.ParameterLocation("shininess"),
+        this->shininess.Param<core::param::FloatParam>()->Value());
+    glUniform3fv(this->lic_compute_shdr.ParameterLocation("light"), 1, light.data());
+    glUniform3fv(this->lic_compute_shdr.ParameterLocation("ambient_col"), 1,
+        this->ambient_color.Param<core::param::ColorParam>()->Value().data());
+    glUniform3fv(this->lic_compute_shdr.ParameterLocation("specular_col"), 1,
+        this->specular_color.Param<core::param::ColorParam>()->Value().data());
+    glUniform3fv(this->lic_compute_shdr.ParameterLocation("light_col"), 1,
+        this->light_color.Param<core::param::ColorParam>()->Value().data());
+
+    glActiveTexture(GL_TEXTURE0);
+    this->fbo.BindDepthTexture();
+    glUniform1i(this->lic_compute_shdr.ParameterLocation("depth_tx2D"), 0);
+
+    glActiveTexture(GL_TEXTURE1);
+    this->velocity_target->bindTexture();
+    glUniform1i(this->lic_compute_shdr.ParameterLocation("velocity_tx2D"), 1);
+
+    glActiveTexture(GL_TEXTURE2);
+    this->fbo.BindColourTexture(1);
+    glUniform1i(this->lic_compute_shdr.ParameterLocation("normal_tx2D"), 2);
+
+    glActiveTexture(GL_TEXTURE3);
+    this->noise_texture->bindTexture();
+    glUniform1i(this->lic_compute_shdr.ParameterLocation("noise_tx3D"), 3);
+
+    glActiveTexture(GL_TEXTURE4);
+    glBindTexture(GL_TEXTURE_1D, tf_texture);
+    glUniform1i(this->lic_compute_shdr.ParameterLocation("tf_tx1D"), 4);
+
+    this->render_target->bindImage(0, GL_WRITE_ONLY);
+
+    this->lic_compute_shdr.Dispatch(
+        static_cast<int>(std::ceil(rt_resolution[0] / 8.0f)), static_cast<int>(std::ceil(rt_resolution[1] / 8.0f)), 1);
+
+    glBindImageTexture(0, 0, 0, GL_TRUE, 0, GL_WRITE_ONLY, GL_R8);
+
+    glActiveTexture(GL_TEXTURE4);
+    glBindTexture(GL_TEXTURE_1D, 0);
+
+    glActiveTexture(GL_TEXTURE3);
+    glBindTexture(GL_TEXTURE_3D, 0);
+
+    glActiveTexture(GL_TEXTURE2);
+    glBindTexture(GL_TEXTURE_2D, 0);
+
+    glActiveTexture(GL_TEXTURE1);
+    glBindTexture(GL_TEXTURE_2D, 0);
+
+    glActiveTexture(GL_TEXTURE0);
+    glBindTexture(GL_TEXTURE_2D, 0);
+
+    this->lic_compute_shdr.Disable();
+
+    glMemoryBarrier(GL_TEXTURE_FETCH_BARRIER_BIT);
+
+    // Render to framebuffer
+    bool state_depth_test = glIsEnabled(GL_DEPTH_TEST);
+    bool state_blend = glIsEnabled(GL_BLEND);
+
+    if (!state_depth_test) glEnable(GL_DEPTH_TEST);
+    if (state_blend) glDisable(GL_BLEND);
+
+    this->render_to_framebuffer_shdr.Enable();
+
+    glActiveTexture(GL_TEXTURE0);
+    this->render_target->bindTexture();
+    glUniform1i(this->render_to_framebuffer_shdr.ParameterLocation("src_tx2D"), 0);
+
+    glActiveTexture(GL_TEXTURE1);
+    this->fbo.BindDepthTexture();
+    glUniform1i(this->render_to_framebuffer_shdr.ParameterLocation("depth_tx2D"), 1);
+
+    glDrawArrays(GL_TRIANGLES, 0, 6);
+
+    glActiveTexture(GL_TEXTURE1);
+    glBindTexture(GL_TEXTURE_2D, 0);
+
+    glActiveTexture(GL_TEXTURE0);
+    glBindTexture(GL_TEXTURE_2D, 0);
+
+    this->render_to_framebuffer_shdr.Disable();
+
+    if (state_blend) glEnable(GL_BLEND);
+    if (!state_depth_test) glDisable(GL_DEPTH_TEST);
+}
+
+} // namespace astro
+} // namespace megamol
diff --git a/plugins/astro/src/SurfaceLICRenderer.h b/plugins/astro/src/SurfaceLICRenderer.h
new file mode 100644
index 000000000..60f29080d
--- /dev/null
+++ b/plugins/astro/src/SurfaceLICRenderer.h
@@ -0,0 +1,135 @@
+/*
+ * SurfaceLICRenderer.h
+ *
+ * Copyright (C) 2019 by Universitaet Stuttgart (VISUS).
+ * All rights reserved.
+ */
+
+#ifndef ASTRO_SURFACELICRENDERER_H_INCLUDED
+#define ASTRO_SURFACELICRENDERER_H_INCLUDED
+#pragma once
+
+#include "mmcore/Call.h"
+#include "mmcore/CallerSlot.h"
+#include "mmcore/param/ParamSlot.h"
+#include "mmcore/view/Renderer3DModule.h"
+
+#include "vislib/graphics/gl/FramebufferObject.h"
+#include "vislib/graphics/gl/GLSLComputeShader.h"
+#include "vislib/graphics/gl/GLSLShader.h"
+
+#include "glowl/Texture2D.hpp"
+#include "glowl/Texture3D.hpp"
+
+#include <memory>
+#include <vector>
+
+namespace megamol {
+namespace astro {
+
+class SurfaceLICRenderer : public megamol::core::view::Renderer3DModule {
+public:
+    /**
+     * Answer the name of this module.
+     *
+     * @return The name of this module.
+     */
+    static const char* ClassName(void) { return "SurfaceLICRenderer"; }
+
+    /**
+     * Answer a human readable description of this module.
+     *
+     * @return A human readable description of this module.
+     */
+    static const char* Description(void) { return "Renderer for surface LIC"; }
+
+    /**
+     * Answers whether this module is available on the current system.
+     *
+     * @return 'true' if the module is available, 'false' otherwise.
+     */
+    static bool IsAvailable(void) { return true; }
+
+    SurfaceLICRenderer();
+    ~SurfaceLICRenderer();
+
+protected:
+    /**
+     * Implementation of 'Create'.
+     *
+     * @return 'true' on success, 'false' otherwise.
+     */
+    virtual bool create() override;
+
+    /**
+     * Implementation of 'Release'.
+     */
+    virtual void release() override;
+
+    /**
+     * The get extents callback. The module should set the members of
+     * 'call' to tell the caller the extents of its data (bounding boxes
+     * and times).
+     *
+     * @param call The calling call.
+     *
+     * @return The return value of the function.
+     */
+    virtual bool GetExtents(core::Call& call) override;
+
+    /**
+     * The render callback.
+     *
+     * @param call The calling call.
+     *
+     * @return The return value of the function.
+     */
+    virtual bool Render(core::Call& call) override;
+
+private:
+    /** caller slot */
+    core::CallerSlot input_renderer;
+    core::CallerSlot input_velocities;
+    core::CallerSlot input_transfer_function;
+
+    /** Parameters */
+    core::param::ParamSlot arc_length;
+    core::param::ParamSlot num_advections;
+    core::param::ParamSlot epsilon;
+    core::param::ParamSlot noise_bands;
+    core::param::ParamSlot noise_scale;
+    core::param::ParamSlot coloring;
+
+    core::param::ParamSlot ka;
+    core::param::ParamSlot kd;
+    core::param::ParamSlot ks;
+    core::param::ParamSlot shininess;
+    core::param::ParamSlot ambient_color;
+    core::param::ParamSlot specular_color;
+    core::param::ParamSlot light_color;
+
+    /** Input data hash */
+    SIZE_T hash;
+
+    /** Shader */
+    vislib::graphics::gl::GLSLComputeShader pre_compute_shdr;
+    vislib::graphics::gl::GLSLComputeShader lic_compute_shdr;
+    vislib::graphics::gl::GLSLShader render_to_framebuffer_shdr;
+
+    /** Textures */
+    std::unique_ptr<glowl::Texture2D> velocity_target;
+    std::unique_ptr<glowl::Texture2D> render_target;
+    std::unique_ptr<glowl::Texture3D> velocity_texture;
+    std::unique_ptr<glowl::Texture3D> noise_texture;
+
+    /** FBO for input */
+    vislib::graphics::gl::FramebufferObject fbo;
+
+    /** Noise texture data */
+    std::vector<float> noise;
+};
+
+}
+}
+
+#endif /* ASTRO_SURFACELICRENDERER_H_INCLUDED */
\ No newline at end of file
diff --git a/plugins/astro/src/VolumetricGlobalMinMax.cpp b/plugins/astro/src/VolumetricGlobalMinMax.cpp
new file mode 100644
index 000000000..d398ceaf9
--- /dev/null
+++ b/plugins/astro/src/VolumetricGlobalMinMax.cpp
@@ -0,0 +1,157 @@
+/*
+ * VolumetricGlobalMinMax.cpp
+ *
+ * Copyright (C) 2019 by VISUS (Universitaet Stuttgart)
+ * All rights reserved.
+ */
+
+#include "stdafx.h"
+#include "VolumetricGlobalMinMax.h"
+
+#include "vislib/sys/Log.h"
+
+/*
+ * megamol::astro::VolumetricGlobalMinMax::VolumetricGlobalMinMax
+ */
+megamol::astro::VolumetricGlobalMinMax::VolumetricGlobalMinMax(void) : Module(),
+        hash(0),
+        slotVolumetricDataIn("volumetricDataIn", "Input slot for volumetric data"),
+        slotVolumetricDataOut("volumetricDataOut", "Output slot for volumetric data") {
+    // Publish the slots.
+    this->slotVolumetricDataIn.SetCompatibleCall<megamol::core::misc::VolumetricDataCallDescription>();
+    this->MakeSlotAvailable(&this->slotVolumetricDataIn);
+
+    this->slotVolumetricDataOut.SetCallback(megamol::core::misc::VolumetricDataCall::ClassName(),
+            megamol::core::misc::VolumetricDataCall::FunctionName(megamol::core::misc::VolumetricDataCall::IDX_GET_DATA), &VolumetricGlobalMinMax::onGetData);
+    this->slotVolumetricDataOut.SetCallback(megamol::core::misc::VolumetricDataCall::ClassName(),
+            megamol::core::misc::VolumetricDataCall::FunctionName(megamol::core::misc::VolumetricDataCall::IDX_GET_EXTENTS), &VolumetricGlobalMinMax::onGetExtents);
+    this->slotVolumetricDataOut.SetCallback(megamol::core::misc::VolumetricDataCall::ClassName(),
+            megamol::core::misc::VolumetricDataCall::FunctionName(megamol::core::misc::VolumetricDataCall::IDX_GET_METADATA), &VolumetricGlobalMinMax::onGetMetadata);
+    this->slotVolumetricDataOut.SetCallback(megamol::core::misc::VolumetricDataCall::ClassName(),
+            megamol::core::misc::VolumetricDataCall::FunctionName(megamol::core::misc::VolumetricDataCall::IDX_START_ASYNC), &VolumetricGlobalMinMax::onUnsupportedCallback);
+    this->slotVolumetricDataOut.SetCallback(megamol::core::misc::VolumetricDataCall::ClassName(),
+            megamol::core::misc::VolumetricDataCall::FunctionName(megamol::core::misc::VolumetricDataCall::IDX_STOP_ASYNC), &VolumetricGlobalMinMax::onUnsupportedCallback);
+    this->slotVolumetricDataOut.SetCallback(megamol::core::misc::VolumetricDataCall::ClassName(),
+            megamol::core::misc::VolumetricDataCall::FunctionName(megamol::core::misc::VolumetricDataCall::IDX_TRY_GET_DATA), &VolumetricGlobalMinMax::onUnsupportedCallback);
+    this->MakeSlotAvailable(&this->slotVolumetricDataOut);
+}
+
+/*
+ * megamol::astro::VolumetricGlobalMinMax::~VolumetricGlobalMinMax
+ */
+megamol::astro::VolumetricGlobalMinMax::~VolumetricGlobalMinMax(void) {
+    this->Release();
+}
+
+/*
+ * megamol::astro::VolumetricGlobalMinMax::create
+ */
+bool megamol::astro::VolumetricGlobalMinMax::create(void) {
+    return true;
+}
+
+/*
+ * megamol::astro::VolumetricGlobalMinMax::release
+ */
+void megamol::astro::VolumetricGlobalMinMax::release(void) { }
+
+bool megamol::astro::VolumetricGlobalMinMax::onGetData(megamol::core::Call &call) {
+    return pipeVolumetricDataCall(call, megamol::core::misc::VolumetricDataCall::IDX_GET_DATA);
+}
+
+bool megamol::astro::VolumetricGlobalMinMax::onGetExtents(megamol::core::Call &call) {
+    return pipeVolumetricDataCall(call, megamol::core::misc::VolumetricDataCall::IDX_GET_EXTENTS);
+}
+
+bool megamol::astro::VolumetricGlobalMinMax::onGetMetadata(megamol::core::Call &call) {
+    return pipeVolumetricDataCall(call, megamol::core::misc::VolumetricDataCall::IDX_GET_METADATA);
+}
+
+bool megamol::astro::VolumetricGlobalMinMax::onUnsupportedCallback(megamol::core::Call &call) {
+    return false;
+}
+
+bool megamol::astro::VolumetricGlobalMinMax::pipeVolumetricDataCall(megamol::core::Call &call, unsigned int funcIdx) {
+    using megamol::core::misc::VolumetricDataCall;
+    using vislib::sys::Log;
+
+    auto dst = dynamic_cast<VolumetricDataCall*>(&call);
+    auto src = this->slotVolumetricDataIn.CallAs<VolumetricDataCall>();
+
+    if (dst == nullptr) {
+        Log::DefaultLog.WriteError(L"Call %hs of %hs received a wrong request.",
+                                   VolumetricDataCall::FunctionName(funcIdx),
+                                   VolumetricGlobalMinMax::ClassName());
+        return false;
+    }
+    if (src == nullptr) {
+        Log::DefaultLog.WriteError(L"Call %hs of %hs has a wrong source.",
+                                   VolumetricDataCall::FunctionName(funcIdx),
+                                   VolumetricGlobalMinMax::ClassName());
+        return false;
+    }
+
+    *src = *dst;
+    if (!(*src)(funcIdx)) {
+        Log::DefaultLog.WriteError(L"%hs failed to call %hs.",
+                                   VolumetricGlobalMinMax::ClassName(),
+                                   VolumetricDataCall::FunctionName(funcIdx));
+
+        return false;
+    }
+    *dst = *src;
+
+    if (src->DataHash() != this->hash || this->hash == 0) {
+        this->hash = src->DataHash();
+        this->minValues.clear();
+        this->maxValues.clear();
+
+        auto frames = src->FrameCount();
+        for (unsigned int i = 0; i < frames; ++i) {
+            src->SetFrameID(i, true);
+            VolumetricDataCall::GetMetadata(*src);
+            const auto metadata = src->GetMetadata();
+            if (i == 0) {
+                this->minValues.resize(metadata->Components, std::numeric_limits<double>::max());
+                this->maxValues.resize(metadata->Components, std::numeric_limits<double>::lowest());
+            } else {
+                if (this->minValues.size() != metadata->Components) {
+                    Log::DefaultLog.WriteError(L"Unexpected number of components.");
+                    return false;
+                }
+            }
+
+            for (size_t j = 0; j < metadata->Components; ++j) {
+                if (metadata->MinValues[j] < this->minValues[j]) {
+                    this->minValues[j] = metadata->MinValues[j];
+                }
+                if (metadata->MaxValues[j] > this->maxValues[j]) {
+                    this->maxValues[j] = metadata->MaxValues[j];
+                }
+            }
+        }
+        Log::DefaultLog.WriteInfo("Min/Max Update");
+        Log::DefaultLog.WriteInfo("Min:");
+        for (const auto &m : this->minValues) {
+            Log::DefaultLog.WriteInfo("    %f", m);
+        }
+        Log::DefaultLog.WriteInfo("Max:");
+        for (const auto &m : this->maxValues) {
+            Log::DefaultLog.WriteInfo("    %f", m);
+        }
+    }
+
+    auto metadata = dst->GetMetadata();
+    if (metadata != nullptr) {
+        if (this->minValues.size() != metadata->Components) {
+            Log::DefaultLog.WriteError(L"Unexpected number of components.");
+            return false;
+        }
+        for (size_t i = 0; i < this->minValues.size(); ++i) {
+            metadata->MinValues[i] = this->minValues[i];
+            metadata->MaxValues[i] = this->maxValues[i];
+        }
+    }
+
+    return true;
+}
diff --git a/plugins/astro/src/VolumetricGlobalMinMax.h b/plugins/astro/src/VolumetricGlobalMinMax.h
new file mode 100644
index 000000000..898cbe957
--- /dev/null
+++ b/plugins/astro/src/VolumetricGlobalMinMax.h
@@ -0,0 +1,79 @@
+/*
+ * VolumetricGlobalMinMax.h
+ *
+ * Copyright (C) 2019 by VISUS (Universitaet Stuttgart)
+ * Alle Rechte vorbehalten.
+ */
+
+#ifndef MEGAMOL_ASTRO_VOLUMETRICGLOBALMINMAX_H_INCLUDED
+#define MEGAMOL_ASTRO_VOLUMETRICGLOBALMINMAX_H_INCLUDED
+#if (defined(_MSC_VER) && (_MSC_VER > 1000))
+#pragma once
+#endif /* (defined(_MSC_VER) && (_MSC_VER > 1000)) */
+
+#include <array>
+
+#include "mmcore/CalleeSlot.h"
+#include "mmcore/CallerSlot.h"
+#include "mmcore/Module.h"
+
+#include "mmcore/misc/VolumetricDataCall.h"
+
+
+namespace megamol {
+namespace astro {
+
+    /// <summary>
+    /// Gets min/max values on a <see cref="VolumetricDataCall" />.
+    /// </summary>
+    class VolumetricGlobalMinMax : public core::Module {
+
+    public:
+
+        static inline const char *ClassName(void) {
+            return "VolumetricGlobalMinMax";
+        }
+
+        static inline const char *Description(void) {
+            return "Gets min/max values over all frames of a VolumetricDataCall";
+        }
+
+        static bool IsAvailable(void) {
+            return true;
+        }
+
+        /** Ctor. */
+        VolumetricGlobalMinMax(void);
+
+        /** Dtor. */
+        virtual ~VolumetricGlobalMinMax(void);
+
+    protected:
+
+        virtual bool create(void);
+
+        virtual void release(void);
+
+        bool onGetData(core::Call& call);
+
+        bool onGetExtents(core::Call& call);
+
+        bool onGetMetadata(core::Call& call);
+
+        bool onUnsupportedCallback(core::Call& call);
+
+        bool pipeVolumetricDataCall(core::Call& call, unsigned int funcIdx);
+
+    private:
+
+        core::CallerSlot slotVolumetricDataIn;
+        core::CalleeSlot slotVolumetricDataOut;
+        size_t hash;
+        std::vector<double> minValues;
+        std::vector<double> maxValues;
+    };
+
+} /* end namespace astro */
+} /* end namespace megamol */
+
+#endif /* MEGAMOL_ASTRO_VOLUMETRICGLOBALMINMAX_H_INCLUDED */
diff --git a/plugins/astro/src/astro.cpp b/plugins/astro/src/astro.cpp
new file mode 100644
index 000000000..7358b2f52
--- /dev/null
+++ b/plugins/astro/src/astro.cpp
@@ -0,0 +1,165 @@
+/*
+ * astro.cpp
+ * Copyright (C) 2009-2015 by MegaMol Team
+ * Alle Rechte vorbehalten.
+ */
+
+#include "stdafx.h"
+#include "astro/astro.h"
+
+#include "mmcore/api/MegaMolCore.std.h"
+#include "mmcore/utility/plugins/Plugin200Instance.h"
+#include "mmcore/versioninfo.h"
+#include "vislib/vislibversion.h"
+
+#include "astro/AstroDataCall.h"
+#include "AstroParticleConverter.h"
+#include "AstroSchulz.h"
+#include "Contest2019DataLoader.h"
+#include "DirectionToColour.h"
+#include "FilamentFilter.h"
+#include "SimpleAstroFilter.h"
+#include "SurfaceLICRenderer.h"
+#include "SpectralIntensityVolume.h"
+#include "VolumetricGlobalMinMax.h"
+
+
+/* anonymous namespace hides this type from any other object files */
+namespace {
+    /** Implementing the instance class of this plugin */
+    class plugin_instance : public ::megamol::core::utility::plugins::Plugin200Instance {
+    public:
+        /** ctor */
+        plugin_instance(void)
+            : ::megamol::core::utility::plugins::Plugin200Instance(
+
+                /* machine-readable plugin assembly name */
+                "astro",
+
+                /* human-readable plugin description */
+                "Describing astro (TODO: Change this!)") {
+
+            // here we could perform addition initialization
+        };
+        /** Dtor */
+        virtual ~plugin_instance(void) {
+            // here we could perform addition de-initialization
+        }
+        /** Registers modules and calls */
+        virtual void registerClasses(void) {
+
+            // register modules here:
+
+            //
+            // TODO: Register your plugin's modules here
+            // like:
+            //   this->module_descriptions.RegisterAutoDescription<megamol::astro::MyModule1>();
+            //   this->module_descriptions.RegisterAutoDescription<megamol::astro::MyModule2>();
+            //   ...
+            //
+            this->module_descriptions.RegisterAutoDescription<megamol::astro::Contest2019DataLoader>();
+			this->module_descriptions.RegisterAutoDescription<megamol::astro::AstroParticleConverter>();
+            this->module_descriptions.RegisterAutoDescription<megamol::astro::FilamentFilter>();
+            this->module_descriptions.RegisterAutoDescription<megamol::astro::AstroSchulz>();
+            this->module_descriptions.RegisterAutoDescription<megamol::astro::DirectionToColour>();
+            this->module_descriptions.RegisterAutoDescription<megamol::astro::SimpleAstroFilter>();
+            this->module_descriptions.RegisterAutoDescription<megamol::astro::SurfaceLICRenderer>();
+            this->module_descriptions.RegisterAutoDescription<megamol::astro::SpectralIntensityVolume>();
+            this->module_descriptions.RegisterAutoDescription<megamol::astro::VolumetricGlobalMinMax>();
+
+            // register calls here:
+
+            //
+            // TODO: Register your plugin's calls here
+            // like:
+            //   this->call_descriptions.RegisterAutoDescription<megamol::astro::MyCall1>();
+            //   this->call_descriptions.RegisterAutoDescription<megamol::astro::MyCall2>();
+            //   ...
+            //
+            this->call_descriptions.RegisterAutoDescription<megamol::astro::AstroDataCall>();
+        }
+        MEGAMOLCORE_PLUGIN200UTIL_IMPLEMENT_plugininstance_connectStatics
+    };
+}
+
+
+/*
+ * mmplgPluginAPIVersion
+ */
+ASTRO_API int mmplgPluginAPIVersion(void) {
+    MEGAMOLCORE_PLUGIN200UTIL_IMPLEMENT_mmplgPluginAPIVersion
+}
+
+
+/*
+ * mmplgGetPluginCompatibilityInfo
+ */
+ASTRO_API
+::megamol::core::utility::plugins::PluginCompatibilityInfo *
+mmplgGetPluginCompatibilityInfo(
+        ::megamol::core::utility::plugins::ErrorCallback onError) {
+    // compatibility information with core and vislib
+    using ::megamol::core::utility::plugins::PluginCompatibilityInfo;
+    using ::megamol::core::utility::plugins::LibraryVersionInfo;
+
+    PluginCompatibilityInfo *ci = new PluginCompatibilityInfo;
+    ci->libs_cnt = 2;
+    ci->libs = new LibraryVersionInfo[2];
+
+    SetLibraryVersionInfo(ci->libs[0], "MegaMolCore",
+        MEGAMOL_CORE_MAJOR_VER, MEGAMOL_CORE_MINOR_VER, MEGAMOL_CORE_COMP_REV, 0
+#if defined(DEBUG) || defined(_DEBUG)
+        | MEGAMOLCORE_PLUGIN200UTIL_FLAGS_DEBUG_BUILD
+#endif
+#if defined(MEGAMOL_CORE_DIRTY) && (MEGAMOL_CORE_DIRTY != 0)
+        | MEGAMOLCORE_PLUGIN200UTIL_FLAGS_DIRTY_BUILD
+#endif
+        );
+
+    SetLibraryVersionInfo(ci->libs[1], "vislib",
+        vislib::VISLIB_VERSION_MAJOR, vislib::VISLIB_VERSION_MINOR, vislib::VISLIB_VERSION_REVISION, 0
+#if defined(DEBUG) || defined(_DEBUG)
+        | MEGAMOLCORE_PLUGIN200UTIL_FLAGS_DEBUG_BUILD
+#endif
+#if defined(VISLIB_DIRTY_BUILD) && (VISLIB_DIRTY_BUILD != 0)
+        | MEGAMOLCORE_PLUGIN200UTIL_FLAGS_DIRTY_BUILD
+#endif
+        );
+    //
+    // If you want to test additional compatibilties, add the corresponding versions here
+    //
+
+    return ci;
+}
+
+
+/*
+ * mmplgReleasePluginCompatibilityInfo
+ */
+ASTRO_API
+void mmplgReleasePluginCompatibilityInfo(
+        ::megamol::core::utility::plugins::PluginCompatibilityInfo* ci) {
+    // release compatiblity data on the correct heap
+    MEGAMOLCORE_PLUGIN200UTIL_IMPLEMENT_mmplgReleasePluginCompatibilityInfo(ci)
+}
+
+
+/*
+ * mmplgGetPluginInstance
+ */
+ASTRO_API
+::megamol::core::utility::plugins::AbstractPluginInstance*
+mmplgGetPluginInstance(
+        ::megamol::core::utility::plugins::ErrorCallback onError) {
+    MEGAMOLCORE_PLUGIN200UTIL_IMPLEMENT_mmplgGetPluginInstance(plugin_instance, onError)
+}
+
+
+/*
+ * mmplgReleasePluginInstance
+ */
+ASTRO_API
+void mmplgReleasePluginInstance(
+        ::megamol::core::utility::plugins::AbstractPluginInstance* pi) {
+    MEGAMOLCORE_PLUGIN200UTIL_IMPLEMENT_mmplgReleasePluginInstance(pi)
+}
diff --git a/plugins/astro/src/dllmain.cpp b/plugins/astro/src/dllmain.cpp
new file mode 100644
index 000000000..69eb23914
--- /dev/null
+++ b/plugins/astro/src/dllmain.cpp
@@ -0,0 +1,30 @@
+/*
+ * dllmain.cpp
+ * Copyright (C) 2010-2015 by MegaMol Team
+ * Alle Rechte vorbehalten.
+ */
+#include "stdafx.h"
+
+/*
+ * This file is used under Windows only!
+ */
+#ifdef _WIN32
+
+// dllmain.cpp : Defines the entry point for the DLL application.
+BOOL APIENTRY DllMain( HMODULE hModule,
+                       DWORD  ul_reason_for_call,
+                       LPVOID lpReserved
+					 )
+{
+	switch (ul_reason_for_call)
+	{
+	case DLL_PROCESS_ATTACH:
+	case DLL_THREAD_ATTACH:
+	case DLL_THREAD_DETACH:
+	case DLL_PROCESS_DETACH:
+		break;
+	}
+	return TRUE;
+}
+
+#endif /* _WIN32 */
diff --git a/plugins/astro/src/stdafx.cpp b/plugins/astro/src/stdafx.cpp
new file mode 100644
index 000000000..0ee6720b0
--- /dev/null
+++ b/plugins/astro/src/stdafx.cpp
@@ -0,0 +1,15 @@
+/*
+ * stdafx.cpp
+ * Copyright (C) 2006-2015 by MegaMol Team
+ * Alle Rechte vorbehalten.
+ */
+
+#include "stdafx.h"
+
+/*
+ * Intentionally empty
+ *
+ * reference any additional headers you need in STDAFX.H
+ * and not in this file
+ */
+
diff --git a/plugins/astro/src/stdafx.h b/plugins/astro/src/stdafx.h
new file mode 100644
index 000000000..c55a14512
--- /dev/null
+++ b/plugins/astro/src/stdafx.h
@@ -0,0 +1,36 @@
+/*
+ * stdafx.h
+ * Copyright (C) 2006-2015 by MegaMol Team
+ * Alle Rechte vorbehalten.
+ */
+
+#ifndef ASTRO_STDAFX_H_INCLUDED
+#define ASTRO_STDAFX_H_INCLUDED
+#if (defined(_MSC_VER) && (_MSC_VER > 1000))
+#pragma once
+#endif /* (defined(_MSC_VER) && (_MSC_VER > 1000)) */
+
+#ifdef _WIN32
+/* Windows includes */
+
+#include "targetver.h"
+
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#undef min
+#undef max
+
+#else /* _WIN32 */
+/* Linux includes */
+
+#include <memory.h>
+
+#ifndef NULL
+#   define NULL 0
+#endif
+
+#endif /* _WIN32 */
+
+#include "vislib/types.h"
+
+#endif /* ASTRO_STDAFX_H_INCLUDED */
diff --git a/plugins/astro/src/targetver.h b/plugins/astro/src/targetver.h
new file mode 100644
index 000000000..231c0cd27
--- /dev/null
+++ b/plugins/astro/src/targetver.h
@@ -0,0 +1,37 @@
+/*
+ * targetver.h
+ * Copyright (C) 2010-2015 by MegaMol Team
+ * Alle Rechte vorbehalten.
+ */
+
+/*
+ * This file is used under Windows only!
+ */
+#ifdef _WIN32
+
+#pragma once
+
+// The following macros define the minimum required platform.  The minimum required platform
+// is the earliest version of Windows, Internet Explorer etc. that has the necessary features to run 
+// your application.  The macros work by enabling all features available on platform versions up to and 
+// including the version specified.
+
+// Modify the following defines if you have to target a platform prior to the ones specified below.
+// Refer to MSDN for the latest info on corresponding values for different platforms.
+#ifndef WINVER                          // Specifies that the minimum required platform is Windows Vista.
+#define WINVER 0x0600           // Change this to the appropriate value to target other versions of Windows.
+#endif
+
+#ifndef _WIN32_WINNT            // Specifies that the minimum required platform is Windows Vista.
+#define _WIN32_WINNT 0x0600     // Change this to the appropriate value to target other versions of Windows.
+#endif
+
+#ifndef _WIN32_WINDOWS          // Specifies that the minimum required platform is Windows 98.
+#define _WIN32_WINDOWS 0x0410 // Change this to the appropriate value to target Windows Me or later.
+#endif
+
+#ifndef _WIN32_IE                       // Specifies that the minimum required platform is Internet Explorer 7.0.
+#define _WIN32_IE 0x0700        // Change this to the appropriate value to target other versions of IE.
+#endif
+
+#endif /* _WIN32 */
diff --git a/plugins/infovis/src/ScatterplotMatrixRenderer2D.cpp b/plugins/infovis/src/ScatterplotMatrixRenderer2D.cpp
index f52ba2747..4fbb167db 100644
--- a/plugins/infovis/src/ScatterplotMatrixRenderer2D.cpp
+++ b/plugins/infovis/src/ScatterplotMatrixRenderer2D.cpp
@@ -114,7 +114,7 @@ ScatterplotMatrixRenderer2D::ScatterplotMatrixRenderer2D()
     , axisFont("Evolventa-SansSerif", core::utility::SDFFont::RenderType::RENDERTYPE_FILL)
     , textFont("Evolventa-SansSerif", core::utility::SDFFont::RenderType::RENDERTYPE_FILL)
     , textValid(false)
-    , dataTime(0)
+    , dataTime((std::numeric_limits<unsigned int>::max)())
     , flagsBufferVersion(0) {
     this->floatTableInSlot.SetCompatibleCall<table::TableDataCallDescription>();
     this->MakeSlotAvailable(&this->floatTableInSlot);
@@ -361,9 +361,11 @@ bool ScatterplotMatrixRenderer2D::validate(core::view::CallRender2D& call, bool
     this->floatTable = this->floatTableInSlot.CallAs<table::TableDataCall>();
 
     if (this->floatTable == nullptr || !(*this->floatTable)(1)) return false;
-    auto ts = this->floatTable->GetFrameCount();
-    call.SetTimeFramesCount(ts);
-    this->floatTable->SetFrameID(static_cast<unsigned int>(call.Time()));
+    const auto cntFrames = this->floatTable->GetFrameCount();
+    call.SetTimeFramesCount(cntFrames);    // Tell view about the data set size.
+
+    const auto now = static_cast<unsigned int>(call.Time());    // 
+    this->floatTable->SetFrameID(now);
 
     if (this->floatTable == nullptr || !(*(this->floatTable))(0)) return false;
     if (this->floatTable->GetColumnsCount() == 0) return false;
@@ -389,7 +391,7 @@ bool ScatterplotMatrixRenderer2D::validate(core::view::CallRender2D& call, bool
         this->transferFunction->ResetDirty();
     }
 
-    if (this->dataHash == this->floatTable->DataHash() && ts == this->dataTime && !hasDirtyData()) return true;
+    if (this->dataHash == this->floatTable->DataHash() && now == this->dataTime && !hasDirtyData()) return true;
 
     auto columnInfos = this->floatTable->GetColumnsInfos();
     const size_t colCount = this->floatTable->GetColumnsCount();
@@ -416,7 +418,7 @@ bool ScatterplotMatrixRenderer2D::validate(core::view::CallRender2D& call, bool
     this->updateColumns();
 
     this->dataHash = this->floatTable->DataHash();
-    this->dataTime = ts;
+    this->dataTime = now;
     this->resetDirtyData();
 
     return true;
diff --git a/plugins/infovis/src/ScatterplotMatrixRenderer2D.h b/plugins/infovis/src/ScatterplotMatrixRenderer2D.h
index 569193665..c74368022 100644
--- a/plugins/infovis/src/ScatterplotMatrixRenderer2D.h
+++ b/plugins/infovis/src/ScatterplotMatrixRenderer2D.h
@@ -117,10 +117,9 @@ private:
 
     struct SPLOMPoints {
         SPLOMPoints(const std::vector<PlotInfo>& plots, const stdplugin::datatools::table::TableDataCall* floatTable)
-            : plots(plots)
-            , floatTable(floatTable){}
+            : plots(plots), floatTable(floatTable) {}
 
-                  [[nodiscard]] inline size_t idx_to_row(size_t idx) const {
+        [[nodiscard]] inline size_t idx_to_row(size_t idx) const {
             const size_t rowCount = floatTable->GetRowsCount();
             return idx % rowCount;
         }
diff --git a/plugins/mmstd_datatools/CMakeLists.txt b/plugins/mmstd_datatools/CMakeLists.txt
index 9f6d40d3a..bf44d5c83 100644
--- a/plugins/mmstd_datatools/CMakeLists.txt
+++ b/plugins/mmstd_datatools/CMakeLists.txt
@@ -55,6 +55,7 @@ if(BUILD_MMSTD_DATATOOLS_PLUGIN)
   # Add externals.
   require_external(Eigen)
   require_external(nanoflann)
+  require_external(sim_sort)
 
   file(GLOB_RECURSE public_header_files RELATIVE "${CMAKE_CURRENT_SOURCE_DIR}" "include/*.h")
   file(GLOB_RECURSE source_files RELATIVE "${CMAKE_CURRENT_SOURCE_DIR}" "src/*.cpp" "3rd/min_sphere_of_spheres/*.cpp")
@@ -83,11 +84,11 @@ if(BUILD_MMSTD_DATATOOLS_PLUGIN)
   # Target definition
   add_library(${PROJECT_NAME} SHARED ${public_header_files} ${header_files} ${source_files})
   # Set target naming conventions for different build types
-  set_target_properties(${PROJECT_NAME} PROPERTIES SUFFIX ".mmplg")
+  set_target_properties(${PROJECT_NAME} PROPERTIES SUFFIX ".mmplg" CXX_STANDARD 17 CXX_STANDARD_REQUIRED ON)
   target_compile_definitions(${PROJECT_NAME} PRIVATE ${EXPORT_NAME}_EXPORTS)
   target_include_directories(${PROJECT_NAME} PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include> "include" "src"
     "3rd/min_sphere_of_spheres")
-  target_link_libraries(${PROJECT_NAME} PRIVATE core geometry_calls tinyply Eigen nanoflann mmpld_io)
+  target_link_libraries(${PROJECT_NAME} PRIVATE core geometry_calls tinyply Eigen nanoflann sim_sort mmpld_io)
 
   if(MPI_C_FOUND)
     target_include_directories(${PROJECT_NAME} PUBLIC ${MPI_C_INCLUDE_PATH})
diff --git a/plugins/mmstd_datatools/src/ParticlesToDensity.cpp b/plugins/mmstd_datatools/src/ParticlesToDensity.cpp
index 5bc1de6a9..dc7696e89 100644
--- a/plugins/mmstd_datatools/src/ParticlesToDensity.cpp
+++ b/plugins/mmstd_datatools/src/ParticlesToDensity.cpp
@@ -6,21 +6,34 @@
  */
 #include "stdafx.h"
 #include "ParticlesToDensity.h"
-#include <algorithm>
-#include <cassert>
-#include <cstdint>
-#include <fstream>
+
+#define _USE_MATH_DEFINES
+
 #include "mmcore/misc/VolumetricDataCall.h"
 #include "mmcore/param/BoolParam.h"
 #include "mmcore/param/EnumParam.h"
 #include "mmcore/param/IntParam.h"
-#include "omp.h"
+#include "mmcore/param/FloatParam.h"
+
+#include "mmstd_datatools/table/TableDataCall.h"
+
 #include "vislib/sys/Log.h"
-#define _USE_MATH_DEFINES
+
+#include "simultaneous_sort.h"
+
+#include "omp.h"
+
+#include <algorithm>
 #include <chrono>
+#include <cmath>
 #include <functional>
-#include <math.h>
-#include "mmcore/param/FloatParam.h"
+#include <fstream>
+#include <iostream>
+#include <iterator>
+#include <limits>
+#include <numeric>
+#include <utility>
+#include <vector>
 
 using namespace megamol;
 using namespace megamol::stdplugin;
@@ -56,15 +69,18 @@ datatools::ParticlesToDensity::ParticlesToDensity(void)
     , cyclZSlot("cyclZ", "Considers cyclic boundary conditions in Z direction")
     , normalizeSlot("normalize", "Normalize the output volume")
     , sigmaSlot("sigma", "Sigma for Gauss in multiple of rad")
-    //, datahash(std::numeric_limits<size_t>::max())
     , datahash(0)
     , time(std::numeric_limits<unsigned int>::max())
+    , has_data(false)
     , outDataSlot("outData", "Provides a density volume for the particles")
-    , inDataSlot("inData", "takes the particle data") {
+    , outParticlesSlot("outParticles", "Provides particles forming a regular grid with the sampled values")
+    , outInfoSlot("outInfo", "Provides information which can be used for visualization and filtering")
+    , inDataSlot("inData", "Takes the particle data") {
 
     auto* ep = new core::param::EnumParam(0);
     ep->SetTypePair(0, "PosToSingleCell_Volume");
     ep->SetTypePair(1, "IColToSingleCell_Volume");
+    ep->SetTypePair(2, "IVecToSingleCell_Volume");
     this->aggregatorSlot << ep;
     this->MakeSlotAvailable(&this->aggregatorSlot);
 
@@ -97,6 +113,18 @@ datatools::ParticlesToDensity::ParticlesToDensity(void)
         &ParticlesToDensity::dummyCallback);
     this->MakeSlotAvailable(&this->outDataSlot);
 
+    this->outParticlesSlot.SetCallback(core::moldyn::MultiParticleDataCall::ClassName(),
+        core::moldyn::MultiParticleDataCall::FunctionName(0), &ParticlesToDensity::getDataCallback);
+    this->outParticlesSlot.SetCallback(core::moldyn::MultiParticleDataCall::ClassName(),
+        core::moldyn::MultiParticleDataCall::FunctionName(1), &ParticlesToDensity::getExtentCallback);
+    this->MakeSlotAvailable(&this->outParticlesSlot);
+
+    this->outInfoSlot.SetCallback(stdplugin::datatools::table::TableDataCall::ClassName(),
+        stdplugin::datatools::table::TableDataCall::FunctionName(0), &ParticlesToDensity::getDataCallback);
+    this->outInfoSlot.SetCallback(stdplugin::datatools::table::TableDataCall::ClassName(),
+        stdplugin::datatools::table::TableDataCall::FunctionName(1), &ParticlesToDensity::getExtentCallback);
+    this->MakeSlotAvailable(&this->outInfoSlot);
+
     this->xResSlot << new core::param::IntParam(16);
     this->MakeSlotAvailable(&this->xResSlot);
     this->yResSlot << new core::param::IntParam(16);
@@ -133,21 +161,41 @@ bool datatools::ParticlesToDensity::getExtentCallback(megamol::core::Call& c) {
     using megamol::core::moldyn::MultiParticleDataCall;
 
     auto* out = dynamic_cast<core::misc::VolumetricDataCall*>(&c);
-    if (out == nullptr) return false;
+    auto* outGrid = dynamic_cast<core::moldyn::MultiParticleDataCall*>(&c);
+    auto* outInfo = dynamic_cast<stdplugin::datatools::table::TableDataCall*>(&c);
 
     auto* inMpdc = this->inDataSlot.CallAs<MultiParticleDataCall>();
     if (inMpdc == nullptr) return false;
 
-    // if (!this->assertData(inMpdc, outDpdc)) return false;
-    inMpdc->SetFrameID(out->FrameID(), true);
+    auto frameID = out != nullptr ? out->FrameID() : (outGrid != nullptr ? outGrid->FrameID() : 0);
+    //vislib::sys::Log::DefaultLog.WriteInfo(L"ParticleToDensity requests frame %u.", frameID);
+    inMpdc->SetFrameID(frameID, true);
     if (!(*inMpdc)(1)) {
         vislib::sys::Log::DefaultLog.WriteError(
             "ParticlesToDensity: could not get current frame extents (%u)", time - 1);
         return false;
     }
-    out->AccessBoundingBoxes().SetObjectSpaceBBox(inMpdc->GetBoundingBoxes().ObjectSpaceBBox());
-    out->AccessBoundingBoxes().SetObjectSpaceClipBox(inMpdc->GetBoundingBoxes().ObjectSpaceClipBox());
-    out->SetFrameCount(inMpdc->FrameCount());
+
+    if (out != nullptr) {
+        out->AccessBoundingBoxes().SetObjectSpaceBBox(inMpdc->GetBoundingBoxes().ObjectSpaceBBox());
+        out->AccessBoundingBoxes().SetObjectSpaceClipBox(inMpdc->GetBoundingBoxes().ObjectSpaceClipBox());
+        out->AccessBoundingBoxes().MakeScaledWorld(1.0f);
+        out->SetFrameCount(inMpdc->FrameCount());
+    }
+
+    if (outGrid != nullptr) {
+        outGrid->AccessBoundingBoxes().SetObjectSpaceBBox(inMpdc->GetBoundingBoxes().ObjectSpaceBBox());
+        outGrid->AccessBoundingBoxes().SetObjectSpaceClipBox(inMpdc->GetBoundingBoxes().ObjectSpaceClipBox());
+        outGrid->AccessBoundingBoxes().MakeScaledWorld(1.0f);
+        outGrid->SetFrameCount(inMpdc->FrameCount());
+    }
+
+    if (outInfo != nullptr) {
+        outInfo->SetDataHash(this->datahash);
+        outInfo->SetUnlocker(nullptr);
+        outInfo->SetFrameCount(inMpdc->FrameCount());
+    }
+
     // TODO: what am I actually doing here
     // inMpdc->SetUnlocker(nullptr, false);
     // inMpdc->Unlock();
@@ -161,71 +209,162 @@ bool datatools::ParticlesToDensity::getDataCallback(megamol::core::Call& c) {
     if (inMpdc == nullptr) return false;
 
     auto* outVol = dynamic_cast<core::misc::VolumetricDataCall*>(&c);
-    if (outVol == nullptr) return false;
-
-    inMpdc->SetFrameID(outVol->FrameID(), true);
-    if (!(*inMpdc)(1)) {
-        vislib::sys::Log::DefaultLog.WriteError("ParticlesToDensity: Unable to get extents.");
-        return false;
+    auto* outGrid = dynamic_cast<core::moldyn::MultiParticleDataCall*>(&c);
+    auto* outInfo = dynamic_cast<stdplugin::datatools::table::TableDataCall*>(&c);
+
+    if (outVol != nullptr || outGrid != nullptr) {
+        auto frameID = outVol != nullptr ? outVol->FrameID() : (outGrid != nullptr ? outGrid->FrameID() : 0);
+        inMpdc->SetFrameID(frameID, true);
+        if (!(*inMpdc)(1)) {
+            vislib::sys::Log::DefaultLog.WriteError("ParticlesToDensity: Unable to get extents.");
+            return false;
+        }
+        if (!(*inMpdc)(0)) {
+            vislib::sys::Log::DefaultLog.WriteError("ParticlesToDensity: Unable to get data.");
+            return false;
+        }
+        if (this->time != inMpdc->FrameID() || this->in_datahash != inMpdc->DataHash() || this->anythingDirty()) {
+            if (!this->createVolumeCPU(inMpdc)) return false;
+            this->time = inMpdc->FrameID();
+            this->in_datahash = inMpdc->DataHash();
+            ++this->datahash;
+            this->resetDirty();
+            this->has_data = true;
+        }
     }
-    if (!(*inMpdc)(0)) {
-        vislib::sys::Log::DefaultLog.WriteError("ParticlesToDensity: Unable to get data.");
-        return false;
+
+    const bool is_vector = this->aggregatorSlot.Param<core::param::EnumParam>()->Value() == 2;
+
+    // TODO set data
+    if (outVol != nullptr) {
+        outVol->SetFrameID(this->time);
+        outVol->SetData(this->vol[0].data());
+        metadata.Components = is_vector ? 3 : 1;
+        metadata.GridType = core::misc::GridType_t::CARTESIAN;
+        metadata.Resolution[0] = static_cast<size_t>(this->xResSlot.Param<core::param::IntParam>()->Value());
+        metadata.Resolution[1] = static_cast<size_t>(this->yResSlot.Param<core::param::IntParam>()->Value());
+        metadata.Resolution[2] = static_cast<size_t>(this->zResSlot.Param<core::param::IntParam>()->Value());
+        metadata.ScalarType = core::misc::ScalarType_t::FLOATING_POINT;
+        metadata.ScalarLength = sizeof(float);
+        metadata.MinValues = new double[is_vector ? 3 : 1];
+        metadata.MinValues[0] = this->minDens;
+        if (is_vector) metadata.MinValues[1] = this->minDens;
+        if (is_vector) metadata.MinValues[2] = this->minDens;
+        metadata.MaxValues = new double[is_vector ? 3 : 1];
+        metadata.MaxValues[0] = this->maxDens;
+        if (is_vector) metadata.MaxValues[1] = this->maxDens;
+        if (is_vector) metadata.MaxValues[2] = this->maxDens;
+        auto bbox = inMpdc->AccessBoundingBoxes().ObjectSpaceBBox();
+        metadata.Extents[0] = bbox.Width();
+        metadata.Extents[1] = bbox.Height();
+        metadata.Extents[2] = bbox.Depth();
+        metadata.NumberOfFrames = 1;
+        metadata.SliceDists[0] = new float[1];
+        metadata.SliceDists[0][0] = metadata.Extents[0] / static_cast<float>(metadata.Resolution[0] - 1);
+        metadata.SliceDists[1] = new float[1];
+        metadata.SliceDists[1][0] = metadata.Extents[1] / static_cast<float>(metadata.Resolution[1] - 1);
+        metadata.SliceDists[2] = new float[1];
+        metadata.SliceDists[2][0] = metadata.Extents[2] / static_cast<float>(metadata.Resolution[2] - 1);
+
+        metadata.Origin[0] = bbox.Left();
+        //-metadata.SliceDists[0][0] / 4.0f;
+        metadata.Origin[1] = bbox.Bottom();
+        //-metadata.SliceDists[1][0] / 4.0f;
+        metadata.Origin[2] = bbox.Back();
+        //-metadata.SliceDists[2][0] / 4.0f;
+
+        metadata.IsUniform[0] = true;
+        metadata.IsUniform[1] = true;
+        metadata.IsUniform[2] = true;
+        outVol->SetMetadata(&metadata);
+
+        outVol->SetDataHash(this->datahash);
+
+        /*outVol->SetVolumeDimension(this->xResSlot.Param<core::param::IntParam>()->Value(),
+            this->yResSlot.Param<core::param::IntParam>()->Value(),
+        this->zResSlot.Param<core::param::IntParam>()->Value()); outVol->SetComponents(1);
+        outVol->SetMinimumDensity(0.0f);
+        outVol->SetMaximumDensity(this->maxDens);
+        outVol->SetVoxelMapPointer(this->vol[0].data());*/
+        // inMpdc->Unlock();
     }
-    if (this->time != inMpdc->FrameID() || this->in_datahash != inMpdc->DataHash() || this->anythingDirty()) {
-        if (!this->createVolumeCPU(inMpdc)) return false;
-        this->time = inMpdc->FrameID();
-        this->in_datahash = inMpdc->DataHash();
-        ++this->datahash;
-        this->resetDirty();
+
+    if (outGrid != nullptr && is_vector) {
+        outGrid->SetFrameID(this->time);
+        outGrid->SetDataHash(this->datahash);
+        outGrid->SetParticleListCount(1);
+
+        core::moldyn::MultiParticleDataCall::Particles& p = outGrid->AccessParticles(0);
+
+        p.SetCount(this->colors.size());
+
+        if (p.GetCount() > 0) {
+            p.SetVertexData(core::moldyn::MultiParticleDataCall::Particles::VERTDATA_FLOAT_XYZ, this->grid.data());
+            p.SetDirData(
+                core::moldyn::SimpleSphericalParticles::DirDataType::DIRDATA_FLOAT_XYZ, this->directions.data());
+            p.SetColourData(core::moldyn::SimpleSphericalParticles::COLDATA_FLOAT_I, this->colors.data());
+
+            p.SetGlobalRadius(inMpdc->AccessBoundingBoxes().ObjectSpaceBBox().Width() /
+                              static_cast<float>(this->xResSlot.Param<core::param::IntParam>()->Value()) / 5.0f);
+        }
     }
 
-    // TODO set data
-    outVol->SetData(this->vol[0].data());
-    metadata.Components = 1;
-    metadata.GridType = core::misc::GridType_t::CARTESIAN;
-    metadata.Resolution[0] = static_cast<size_t>(this->xResSlot.Param<core::param::IntParam>()->Value());
-    metadata.Resolution[1] = static_cast<size_t>(this->yResSlot.Param<core::param::IntParam>()->Value());
-    metadata.Resolution[2] = static_cast<size_t>(this->zResSlot.Param<core::param::IntParam>()->Value());
-    metadata.ScalarType = core::misc::ScalarType_t::FLOATING_POINT;
-    metadata.ScalarLength = sizeof(float);
-    metadata.MinValues = new double[1];
-    metadata.MinValues[0] = this->minDens;
-    metadata.MaxValues = new double[1];
-    metadata.MaxValues[0] = this->maxDens;
-    auto bbox = inMpdc->AccessBoundingBoxes().ObjectSpaceBBox();
-    metadata.Extents[0] = bbox.Width();
-    metadata.Extents[1] = bbox.Height();
-    metadata.Extents[2] = bbox.Depth();
-    metadata.NumberOfFrames = 1;
-    metadata.SliceDists[0] = new float[1];
-    metadata.SliceDists[0][0] = metadata.Extents[0] / static_cast<float>(metadata.Resolution[0] - 1);
-    metadata.SliceDists[1] = new float[1];
-    metadata.SliceDists[1][0] = metadata.Extents[1] / static_cast<float>(metadata.Resolution[1] - 1);
-    metadata.SliceDists[2] = new float[1];
-    metadata.SliceDists[2][0] = metadata.Extents[2] / static_cast<float>(metadata.Resolution[2] - 1);
-
-    metadata.Origin[0] = bbox.Left();
-    //-metadata.SliceDists[0][0] / 4.0f;
-    metadata.Origin[1] = bbox.Bottom();
-    //-metadata.SliceDists[1][0] / 4.0f;
-    metadata.Origin[2] = bbox.Back();
-    //-metadata.SliceDists[2][0] / 4.0f;
-
-    metadata.IsUniform[0] = true;
-    metadata.IsUniform[1] = true;
-    metadata.IsUniform[2] = true;
-    outVol->SetMetadata(&metadata);
-
-    outVol->SetDataHash(this->datahash);
-
-    /*outVol->SetVolumeDimension(this->xResSlot.Param<core::param::IntParam>()->Value(),
-        this->yResSlot.Param<core::param::IntParam>()->Value(), this->zResSlot.Param<core::param::IntParam>()->Value());
-    outVol->SetComponents(1);
-    outVol->SetMinimumDensity(0.0f);
-    outVol->SetMaximumDensity(this->maxDens);
-    outVol->SetVoxelMapPointer(this->vol[0].data());*/
-    // inMpdc->Unlock();
+    if (outInfo != nullptr && is_vector) {
+
+        this->info[0].SetName("PositionX");
+        this->info[0].SetType(stdplugin::datatools::table::TableDataCall::ColumnType::QUANTITATIVE);
+
+        this->info[1].SetName("PositionY");
+        this->info[1].SetType(stdplugin::datatools::table::TableDataCall::ColumnType::QUANTITATIVE);
+
+        this->info[2].SetName("PositionZ");
+        this->info[2].SetType(stdplugin::datatools::table::TableDataCall::ColumnType::QUANTITATIVE);
+
+        this->info[3].SetName("VelocityX");
+        this->info[3].SetType(stdplugin::datatools::table::TableDataCall::ColumnType::QUANTITATIVE);
+
+        this->info[4].SetName("VelocityY");
+        this->info[4].SetType(stdplugin::datatools::table::TableDataCall::ColumnType::QUANTITATIVE);
+
+        this->info[5].SetName("VelocityZ");
+        this->info[5].SetType(stdplugin::datatools::table::TableDataCall::ColumnType::QUANTITATIVE);
+
+        this->info[6].SetName("VelocityMag");
+        this->info[6].SetType(stdplugin::datatools::table::TableDataCall::ColumnType::QUANTITATIVE);
+
+        if (!this->has_data) {
+            this->infoData.reserve(1);
+            this->infoData.resize(0);
+
+            outInfo->SetDataHash(0);
+        } else {
+            this->info[0].SetMinimumValue(inMpdc->AccessBoundingBoxes().ObjectSpaceBBox().Left());
+            this->info[0].SetMaximumValue(inMpdc->AccessBoundingBoxes().ObjectSpaceBBox().Right());
+
+            this->info[1].SetMinimumValue(inMpdc->AccessBoundingBoxes().ObjectSpaceBBox().Bottom());
+            this->info[1].SetMaximumValue(inMpdc->AccessBoundingBoxes().ObjectSpaceBBox().Top());
+
+            this->info[2].SetMinimumValue(inMpdc->AccessBoundingBoxes().ObjectSpaceBBox().Back());
+            this->info[2].SetMaximumValue(inMpdc->AccessBoundingBoxes().ObjectSpaceBBox().Front());
+
+            this->info[3].SetMinimumValue(-1.0f);
+            this->info[3].SetMaximumValue(1.0f);
+
+            this->info[4].SetMinimumValue(-1.0f);
+            this->info[4].SetMaximumValue(1.0f);
+
+            this->info[5].SetMinimumValue(-1.0f);
+            this->info[5].SetMaximumValue(1.0f);
+
+            this->info[6].SetMinimumValue(this->minDens);
+            this->info[6].SetMaximumValue(this->maxDens);
+
+            outInfo->SetDataHash(this->datahash);
+        }
+
+        outInfo->Set(
+            this->info.size(), this->infoData.size() / this->info.size(), this->info.data(), this->infoData.data());
+    }
 
     return true;
 }
@@ -244,11 +383,17 @@ bool datatools::ParticlesToDensity::createVolumeCPU(class megamol::core::moldyn:
     auto const sy = this->yResSlot.Param<core::param::IntParam>()->Value();
     auto const sz = this->zResSlot.Param<core::param::IntParam>()->Value();
 
+    bool const is_vector = this->aggregatorSlot.Param<core::param::EnumParam>()->Value() == 2;
+
     vol.resize(omp_get_max_threads());
+    std::vector<std::vector<float>> weights(omp_get_max_threads());
 #pragma omp parallel for
     for (int init = 0; init < omp_get_max_threads(); ++init) {
-        vol[init].resize(sx * sy * sz);
+        vol[init].resize(sx * sy * sz * (is_vector ? 3 : 1));
         std::fill(vol[init].begin(), vol[init].end(), 0.0f);
+
+        weights[init].resize(sx * sy * sz);
+        std::fill(weights[init].begin(), weights[init].end(), 0.0f);
     }
 
     // TODO: the whole code is wrong since we might not have the bounding box for the actual cyclic boundary conditions.
@@ -269,13 +414,34 @@ bool datatools::ParticlesToDensity::createVolumeCPU(class megamol::core::moldyn:
     auto const halfRangeOSy = c2->AccessBoundingBoxes().ObjectSpaceBBox().Height() * 0.5;
     auto const halfRangeOSz = c2->AccessBoundingBoxes().ObjectSpaceBBox().Depth() * 0.5;
 
-
     float const sliceDistX = rangeOSx / static_cast<float>(sx - 1);
     float const sliceDistY = rangeOSy / static_cast<float>(sy - 1);
     float const sliceDistZ = rangeOSz / static_cast<float>(sz - 1);
 
     float const maxCellSize = std::max(sliceDistX, std::max(sliceDistY, sliceDistZ));
 
+    this->grid.resize(sx * sy * sz * 3);
+    this->infoData.resize(this->info.size() * sx * sy * sz);
+    for (std::size_t z = 0; z < sz; ++z) {
+        for (std::size_t y = 0; y < sy; ++y) {
+            for (std::size_t x = 0; x < sx; ++x) {
+                const float pos_x = minOSx + sliceDistX * x;
+                const float pos_y = minOSy + sliceDistY * y;
+                const float pos_z = minOSz + sliceDistZ * z;
+
+                const auto i = x + (y + z * sy) * sx;
+
+                this->grid[i * 3 + 0] = pos_x;
+                this->grid[i * 3 + 1] = pos_y;
+                this->grid[i * 3 + 2] = pos_z;
+
+                this->infoData[i * this->info.size() + 0] = pos_x;
+                this->infoData[i * this->info.size() + 1] = pos_y;
+                this->infoData[i * this->info.size() + 2] = pos_z;
+            }
+        }
+    }
+
     for (unsigned int i = 0; i < c2->GetParticleListCount(); ++i) {
         megamol::core::moldyn::MultiParticleDataCall::Particles& parts = c2->AccessParticles(i);
         const float globRad = parts.GetGlobalRadius();
@@ -289,8 +455,9 @@ bool datatools::ParticlesToDensity::createVolumeCPU(class megamol::core::moldyn:
 
         totalParticles += parts.GetCount();
 
-        // https : // en.wikipedia.org/wiki/Radial_basis_function
-        auto gauss = [](float const dist, float const epsilon) -> float {
+        // Implements the Bump Function from
+        // https://en.wikipedia.org/wiki/Radial_basis_function
+        auto rbf = [](float const dist, float const epsilon) -> float {
             if (dist >= epsilon) return 0.0f;
             return std::exp(-1.0f / (1.0f - std::pow((1.0f / epsilon) * dist, 2.0f)));
         };
@@ -301,25 +468,46 @@ bool datatools::ParticlesToDensity::createVolumeCPU(class megamol::core::moldyn:
         auto const& zAcc = parStore.GetZAcc();
         auto const& rAcc = parStore.GetRAcc();
         auto const& iAcc = parStore.GetCRAcc();
+        auto const& dxAcc = parStore.GetDXAcc();
+        auto const& dyAcc = parStore.GetDYAcc();
+        auto const& dzAcc = parStore.GetDZAcc();
 
         auto const sigma = this->sigmaSlot.Param<core::param::FloatParam>()->Value();
 
         std::function<void(int, int, int, int, float, float)> volOp;
         switch (this->aggregatorSlot.Param<core::param::EnumParam>()->Value()) {
+        case 2: {
+            volOp = [this, &rbf, &weights, dxAcc, dyAcc, dzAcc, sx, sy, sigma](int const pidx, int const x,
+                        int const y, int const z, float const dis, float const rad) -> void {
+                if (rad == 0.0f) return;
+
+                auto const val_x = dxAcc->Get_f(pidx);
+                auto const val_y = dyAcc->Get_f(pidx);
+                auto const val_z = dzAcc->Get_f(pidx);
+
+                vol[omp_get_thread_num()][(x + (y + z * sy) * sx) * 3 + 0] += rbf(dis, sigma * rad) * val_x;
+                vol[omp_get_thread_num()][(x + (y + z * sy) * sx) * 3 + 1] += rbf(dis, sigma * rad) * val_y;
+                vol[omp_get_thread_num()][(x + (y + z * sy) * sx) * 3 + 2] += rbf(dis, sigma * rad) * val_z;
+
+                weights[omp_get_thread_num()][x + (y + z * sy) * sx] += rbf(dis, sigma * rad);
+            };
+        } break;
         case 1: {
-            volOp = [this, &gauss, iAcc, sx, sy, sigma](int const pidx, int const x, int const y, int const z,
+            volOp = [this, &rbf, iAcc, sx, sy, sigma](int const pidx, int const x, int const y, int const z,
                         float const dis, float const rad) -> void {
+                if (rad == 0.0f) return;
+
                 auto const val = iAcc->Get_f(pidx);
-                vol[omp_get_thread_num()][x + (y + z * sy) * sx] +=
-                    gauss(dis, sigma * rad) * val;
+                vol[omp_get_thread_num()][x + (y + z * sy) * sx] += rbf(dis, sigma * rad) * val;
             };
         } break;
         default:
         case 0: {
-            volOp = [this, &gauss, sx, sy, sigma](int const pidx, int const x, int const y, int const z, float const dis,
-                        float const rad) -> void {
-                vol[omp_get_thread_num()][x + (y + z * sy) * sx] +=
-                    gauss(dis, sigma * rad);
+            volOp = [this, &rbf, sx, sy, sigma](int const pidx, int const x, int const y, int const z,
+                        float const dis, float const rad) -> void {
+                if (rad == 0.0f) return;
+
+                vol[omp_get_thread_num()][x + (y + z * sy) * sx] += rbf(dis, sigma * rad);
             };
         }
         }
@@ -417,20 +605,109 @@ bool datatools::ParticlesToDensity::createVolumeCPU(class megamol::core::moldyn:
 
     for (int i = 1; i < omp_get_max_threads(); ++i) {
         std::transform(vol[i].begin(), vol[i].end(), vol[0].begin(), vol[0].begin(), std::plus<>());
+        std::transform(weights[i].begin(), weights[i].end(), weights[0].begin(), weights[0].begin(), std::plus<>());
+    }
+
+    if (is_vector) {
+        this->directions.resize(vol[0].size());
+        this->colors.resize(vol[0].size() / 3);
+        this->densities.resize(vol[0].size() / 3);
+        maxDens = 0.0f;
+        minDens = std::numeric_limits<float>::max();
+        for (std::size_t i = 0; i < vol[0].size() / 3; ++i) {
+            vol[0][i * 3 + 0] /= weights[0][i] == 0.0f ? 1.0f : weights[0][i];
+            vol[0][i * 3 + 1] /= weights[0][i] == 0.0f ? 1.0f : weights[0][i];
+            vol[0][i * 3 + 2] /= weights[0][i] == 0.0f ? 1.0f : weights[0][i];
+
+            const float density =
+                std::sqrt(vol[0][i * 3 + 0] * vol[0][i * 3 + 0] + vol[0][i * 3 + 1] * vol[0][i * 3 + 1] +
+                          vol[0][i * 3 + 2] * vol[0][i * 3 + 2]);
+
+            this->directions[i * 3 + 0] = density == 0.0f ? 0.0f : vol[0][i * 3 + 0] / density;
+            this->directions[i * 3 + 1] = density == 0.0f ? 0.0f : vol[0][i * 3 + 1] / density;
+            this->directions[i * 3 + 2] = density == 0.0f ? 0.0f : vol[0][i * 3 + 2] / density;
+
+            this->infoData[i * this->info.size() + 3] = this->directions[i * 3 + 0];
+            this->infoData[i * this->info.size() + 4] = this->directions[i * 3 + 1];
+            this->infoData[i * this->info.size() + 5] = this->directions[i * 3 + 2];
+
+            maxDens = std::max(maxDens, density);
+            minDens = std::min(minDens, density);
+        }
+        for (std::size_t i = 0; i < vol[0].size() / 3; ++i) {
+            const float density =
+                std::sqrt(vol[0][i * 3 + 0] * vol[0][i * 3 + 0] + vol[0][i * 3 + 1] * vol[0][i * 3 + 1] +
+                          vol[0][i * 3 + 2] * vol[0][i * 3 + 2]);
+
+            this->colors[i] = (density - minDens) / (maxDens - minDens);
+            this->densities[i] = density;
+
+            if (this->normalizeSlot.Param<core::param::BoolParam>()->Value()) {
+                this->infoData[i * this->info.size() + 6] = (density - minDens) / (maxDens - minDens);
+            } else {
+                this->infoData[i * this->info.size() + 6] = density;
+            }
+        }
+    } else {
+        maxDens = *std::max_element(vol[0].begin(), vol[0].end());
+        minDens = *std::min_element(vol[0].begin(), vol[0].end());
     }
 
-    maxDens = *std::max_element(vol[0].begin(), vol[0].end());
-    minDens = *std::min_element(vol[0].begin(), vol[0].end());
     vislib::sys::Log::DefaultLog.WriteInfo("ParticlesToDensity: Captured density %f -> %f", minDens, maxDens);
 
     if (this->normalizeSlot.Param<core::param::BoolParam>()->Value()) {
         auto const rcpValRange = 1.0f / (maxDens - minDens);
-        std::transform(
-            vol[0].begin(), vol[0].end(), vol[0].begin(), [this, rcpValRange](float const& a) { return (a - minDens) * rcpValRange; });
+        std::transform(vol[0].begin(), vol[0].end(), vol[0].begin(),
+            [this, rcpValRange](float const& a) { return (a - minDens) * rcpValRange; });
         minDens = 0.0f;
         maxDens = 1.0f;
     }
 
+    // Remove elements which represent zero-sized vectors
+    if (is_vector) {
+        std::vector<std::size_t> indices(this->densities.size());
+        std::iota(indices.begin(), indices.end(), 0);
+
+        sort_with(std::greater<float>(), this->densities, indices);
+
+        const auto cut_pos = std::find(this->densities.begin(), this->densities.end(), 0.0f);
+        const auto new_size = std::distance(this->densities.begin(), cut_pos);
+
+        std::vector<float> new_colors(this->colors.size());
+        std::vector<float> new_directions(this->directions.size());
+        std::vector<float> new_grid(this->grid.size());
+        std::vector<float> new_infoData(this->infoData.size());
+
+        for (std::size_t new_index = 0; new_index < indices.size(); ++new_index) {
+            const std::size_t old_index = indices[new_index];
+
+            std::swap(this->colors[old_index], new_colors[new_index]);
+
+            std::swap(this->directions[old_index * 3 + 0], new_directions[new_index * 3 + 0]);
+            std::swap(this->directions[old_index * 3 + 1], new_directions[new_index * 3 + 1]);
+            std::swap(this->directions[old_index * 3 + 2], new_directions[new_index * 3 + 2]);
+
+            std::swap(this->grid[old_index * 3 + 0], new_grid[new_index * 3 + 0]);
+            std::swap(this->grid[old_index * 3 + 1], new_grid[new_index * 3 + 1]);
+            std::swap(this->grid[old_index * 3 + 2], new_grid[new_index * 3 + 2]);
+
+            for (std::size_t comp = 0; comp < this->info.size(); ++comp) {
+                std::swap(this->infoData[old_index * this->info.size() + comp],
+                    new_infoData[new_index * this->info.size() + comp]);
+            }
+        }
+
+        new_colors.resize(new_size);
+        new_directions.resize(3 * new_size);
+        new_grid.resize(3 * new_size);
+        new_infoData.resize(this->info.size() * new_size);
+
+        this->colors = std::move(new_colors);
+        this->directions = std::move(new_directions);
+        this->grid = std::move(new_grid);
+        this->infoData = std::move(new_infoData);
+    }
+
 //#define PTD_DEBUG_OUTPUT
 #ifdef PTD_DEBUG_OUTPUT
     std::ofstream raw_file{"bolla.raw", std::ios::binary};
diff --git a/plugins/mmstd_datatools/src/ParticlesToDensity.h b/plugins/mmstd_datatools/src/ParticlesToDensity.h
index ec95b7c2a..e3a176de4 100644
--- a/plugins/mmstd_datatools/src/ParticlesToDensity.h
+++ b/plugins/mmstd_datatools/src/ParticlesToDensity.h
@@ -9,16 +9,20 @@
 #define MMSTD_DATATOOLS_PARTICLESTODENSITY_H_INCLUDED
 #pragma once
 
-#include <map>
-#include <vector>
 #include "mmcore/CalleeSlot.h"
 #include "mmcore/CallerSlot.h"
 #include "mmcore/Module.h"
 #include "mmcore/misc/VolumetricDataCall.h"
 #include "mmcore/moldyn/MultiParticleDataCall.h"
 #include "mmcore/param/ParamSlot.h"
+
+#include "mmstd_datatools/table/TableDataCall.h"
+
 #include "vislib/math/Vector.h"
 
+#include <array>
+#include <limits>
+#include <vector>
 
 namespace megamol {
 namespace stdplugin {
@@ -109,6 +113,11 @@ private:
     core::param::ParamSlot sigmaSlot;
 
     std::vector<std::vector<float>> vol;
+    std::vector<float> directions, colors, densities;
+    std::vector<float> grid;
+
+    std::array<stdplugin::datatools::table::TableDataCall::ColumnInfo, 7> info;
+    std::vector<float> infoData;
 
     size_t in_datahash = std::numeric_limits<size_t>::max();
     size_t datahash = 0;
@@ -116,8 +125,12 @@ private:
     float maxDens = 0.0f;
     float minDens = std::numeric_limits<float>::max();
 
+    bool has_data;
+
     /** The slot providing access to the manipulated data */
     megamol::core::CalleeSlot outDataSlot;
+    megamol::core::CalleeSlot outParticlesSlot;
+    megamol::core::CalleeSlot outInfoSlot;
 
     /** The slot accessing the original data */
     megamol::core::CallerSlot inDataSlot;
diff --git a/plugins/mmstd_datatools/src/mmstd_datatools.cpp b/plugins/mmstd_datatools/src/mmstd_datatools.cpp
index 1d9541d60..692419c00 100644
--- a/plugins/mmstd_datatools/src/mmstd_datatools.cpp
+++ b/plugins/mmstd_datatools/src/mmstd_datatools.cpp
@@ -82,6 +82,8 @@
 #include "table/TableColumnScaler.h"
 #include "table/TableJoin.h"
 #include "table/TableObserverPlane.h"
+#include "table/TableSort.h"
+#include "table/TableWhere.h"
 #include "table/TableToLines.h"
 #include "table/TableToParticles.h"
 
@@ -212,6 +214,8 @@ public:
         this->module_descriptions.RegisterAutoDescription<megamol::stdplugin::datatools::table::TableObserverPlane>();
         this->module_descriptions.RegisterAutoDescription<megamol::stdplugin::datatools::table::TableJoin>();
         this->module_descriptions.RegisterAutoDescription<megamol::stdplugin::datatools::table::TableColumnFilter>();
+            this->module_descriptions.RegisterAutoDescription<megamol::stdplugin::datatools::table::TableSort>();
+            this->module_descriptions.RegisterAutoDescription<megamol::stdplugin::datatools::table::TableWhere>();
         this->module_descriptions.RegisterAutoDescription<megamol::stdplugin::datatools::ParticleVelocities>();
         this->module_descriptions.RegisterAutoDescription<megamol::stdplugin::datatools::ParticleNeighborhood>();
         this->module_descriptions.RegisterAutoDescription<megamol::stdplugin::datatools::ParticleThermodyn>();
diff --git a/plugins/mmstd_datatools/src/table/TableProcessorBase.cpp b/plugins/mmstd_datatools/src/table/TableProcessorBase.cpp
new file mode 100644
index 000000000..fc6371832
--- /dev/null
+++ b/plugins/mmstd_datatools/src/table/TableProcessorBase.cpp
@@ -0,0 +1,122 @@
+/*
+ * TableProcessorBase.cpp
+ *
+ * Copyright (C) 2019 Visualisierungsinstitut der Universität Stuttgart
+ * Alle Rechte vorbehalten.
+ */
+
+#include "stdafx.h"
+#include "TableProcessorBase.h"
+
+#include <cassert>
+#include <limits>
+
+#include "vislib/sys/Log.h"
+
+
+
+/*
+ * megamol::stdplugin::datatools::table::TableProcessorBase::TableProcessorBase
+ */
+megamol::stdplugin::datatools::table::TableProcessorBase::TableProcessorBase(void)
+        : frameID((std::numeric_limits<unsigned int>::max)()),
+        inputHash(0),
+        localHash(0),
+        slotInput("input", "The input slot providing the unfiltered data."),
+        slotOutput("output", "The input slot for the filtered data.") {
+    /* Export the calls. */
+    this->slotInput.SetCompatibleCall<TableDataCallDescription>();
+    this->MakeSlotAvailable(&this->slotInput);
+
+    this->slotOutput.SetCallback(TableDataCall::ClassName(),
+        TableDataCall::FunctionName(0),
+        &TableProcessorBase::getData);
+    this->slotOutput.SetCallback(TableDataCall::ClassName(),
+        TableDataCall::FunctionName(1),
+        &TableProcessorBase::getHash);
+    this->MakeSlotAvailable(&this->slotOutput);
+}
+
+
+/*
+ * megamol::stdplugin::datatools::table::TableProcessorBase::getData
+ */
+bool megamol::stdplugin::datatools::table::TableProcessorBase::getData(
+        core::Call& call) {
+    using namespace core::param;
+    using vislib::sys::Log;
+
+    auto src = this->slotInput.CallAs<TableDataCall>();
+    auto dst = dynamic_cast<TableDataCall *>(&call);
+
+    /* Sanity checks. */
+    if (src == nullptr) {
+        Log::DefaultLog.WriteError(_T("The input slot of %hs is invalid"),
+            TableDataCall::ClassName());
+        return false;
+    }
+
+    if (dst == nullptr) {
+        Log::DefaultLog.WriteError(_T("The output slot of %hs is invalid"),
+            TableDataCall::ClassName());
+        return false;
+    }
+
+    if (!this->prepareData(*src, dst->GetFrameID())) { 
+        return false;
+    }
+
+    dst->SetFrameCount(src->GetFrameCount());
+    dst->SetFrameID(this->frameID);
+    dst->SetDataHash(this->getHash());
+    dst->Set(this->columns.size(),
+        this->values.size() / this->columns.size(),
+        this->columns.data(),
+        this->values.data());
+
+    return true;
+}
+
+
+/*
+ * megamol::stdplugin::datatools::table::TableProcessorBase::getHash
+ */
+bool megamol::stdplugin::datatools::table::TableProcessorBase::getHash(
+        core::Call& call) {
+    using vislib::sys::Log;
+    auto src = this->slotInput.CallAs<TableDataCall>();
+    auto dst = dynamic_cast<TableDataCall *>(&call);
+
+    /* Sanity checks. */
+    if (src == nullptr) {
+        Log::DefaultLog.WriteError(L"The input slot of type %hs is invalid",
+            TableDataCall::ClassName());
+        return false;
+    }
+
+    if (dst == nullptr) {
+        Log::DefaultLog.WriteError("The output slot of type %hs is invalid",
+            TableDataCall::ClassName());
+        return false;
+    }
+
+    /* Obtain extents and hash of the source data. */
+    src->SetFrameID(dst->GetFrameID());
+    if (!(*src)(1)) {
+        Log::DefaultLog.WriteError(L"The call to %hs of %hs failed.",
+            TableDataCall::FunctionName(1), TableDataCall::ClassName());
+        return false;
+    }
+
+    // I don't know why the getHash call passes on the frame count, but it seems
+    // to be the expected behaviour ...
+    {
+        auto cnt = src->GetFrameCount();
+        dst->SetFrameCount(cnt);
+    }
+
+    dst->SetDataHash(this->getHash());
+    dst->SetUnlocker(nullptr);
+
+    return true;
+}
diff --git a/plugins/mmstd_datatools/src/table/TableProcessorBase.h b/plugins/mmstd_datatools/src/table/TableProcessorBase.h
new file mode 100644
index 000000000..e006cb122
--- /dev/null
+++ b/plugins/mmstd_datatools/src/table/TableProcessorBase.h
@@ -0,0 +1,102 @@
+/*
+ * TableProcessorBase.h
+ *
+ * Copyright (C) 2019 Visualisierungsinstitut der Universität Stuttgart
+ * Alle Rechte vorbehalten.
+ */
+
+#pragma once
+
+#include "mmcore/CalleeSlot.h"
+#include "mmcore/CallerSlot.h"
+#include "mmcore/Module.h"
+
+#include "mmcore/param/ParamSlot.h"
+
+#include "mmstd_datatools/table/TableDataCall.h"
+
+
+namespace megamol {
+namespace stdplugin {
+namespace datatools {
+namespace table {
+
+    /**
+     * A base class for modules processing table data.
+     */
+    class TableProcessorBase : public core::Module {
+
+    public:
+
+        /**
+         * Finalises an instance.
+         */
+        virtual ~TableProcessorBase(void) = default;
+
+    protected:
+
+        typedef megamol::stdplugin::datatools::table::TableDataCall::ColumnInfo
+            ColumnInfo;
+
+        /**
+         * Initialises a new instance.
+         */
+        TableProcessorBase(void);
+
+        /**
+         * Computes the combined hash from the hash of the local state and the
+         * hash of the input
+         *
+         * @return The hash of the data currently stored in the module.
+         */
+        inline std::size_t getHash(void) {
+            auto retval = this->inputHash;
+            retval ^= this->localHash + 0x9e3779b9 + (retval << 6)
+                + (retval >> 2);
+            return retval;
+        }
+
+        /**
+         * Prepares the data requested by 'call'.
+         *
+         * @param src     The call providing the data.
+         * @param frameID The ID of the frame requested by the caller.
+         *
+         * @return true in case of suceess, false otherwise.
+         */
+        virtual bool prepareData(TableDataCall& src,
+            const unsigned int frameID) = 0;
+
+        /** Holds the columns of the (filtered) table. */
+        std::vector<ColumnInfo> columns;
+
+        /** Holds the ID of the current frame. */
+        unsigned int frameID;
+
+        /** Holds the hash of the data as reported by the input module. */
+        std::size_t inputHash;
+
+        /** Holds a hash representing the current state of the processor. */
+        std::size_t localHash;
+
+        /** The slot providing the input data. */
+        core::CallerSlot slotInput;
+
+        /** The slot allowing for retrieval of the output data. */
+        core::CalleeSlot slotOutput;
+
+        /** The actual values. */
+        std::vector<float> values;
+
+    private:
+
+        bool getData(core::Call& call);
+
+        bool getHash(core::Call& call);
+
+    };
+
+} /* end namespace table */
+} /* end namespace datatools */
+} /* end namespace stdplugin */
+} /* end namespace megamol */
diff --git a/plugins/mmstd_datatools/src/table/TableSort.cpp b/plugins/mmstd_datatools/src/table/TableSort.cpp
new file mode 100644
index 000000000..f54cdebc8
--- /dev/null
+++ b/plugins/mmstd_datatools/src/table/TableSort.cpp
@@ -0,0 +1,164 @@
+/*
+ * TableSort.cpp
+ *
+ * Copyright (C) 2019 Visualisierungsinstitut der Universität Stuttgart
+ * Alle Rechte vorbehalten.
+ */
+
+#include "stdafx.h"
+#include "TableSort.h"
+
+#include <algorithm>
+#include <cassert>
+#include <functional>
+#include <limits>
+#include <numeric>
+
+#include "mmcore/param/BoolParam.h"
+#include "mmcore/param/FlexEnumParam.h"
+
+
+/*
+ * megamol::stdplugin::datatools::table::TableSort::TableSort
+ */
+megamol::stdplugin::datatools::table::TableSort::TableSort(void) 
+        : paramColumn("column", "The column to be filtered."),
+        paramIsDescending("descending", "Sort in descending instead of ascending order."),
+        paramIsStable("stableSort", "Use a stable sorting algorithm.") {
+    /* Configure and export the parameters. */
+    this->paramColumn << new core::param::FlexEnumParam("");
+    this->MakeSlotAvailable(&this->paramColumn);
+
+    this->paramIsDescending << new core::param::BoolParam(false);
+    this->MakeSlotAvailable(&this->paramIsDescending);
+
+    this->paramIsStable << new core::param::BoolParam(false);
+    this->MakeSlotAvailable(&this->paramIsStable);
+}
+
+
+/*
+ * megamol::stdplugin::datatools::table::TableSort::~TableSort
+ */
+megamol::stdplugin::datatools::table::TableSort::~TableSort(void) {
+    // TODO: this is toxic
+    this->Release();
+}
+
+
+/*
+ * megamol::stdplugin::datatools::table::TableSort::create
+ */
+bool megamol::stdplugin::datatools::table::TableSort::create(void) {
+    return true;
+}
+
+
+/*
+ * megamol::stdplugin::datatools::table::TableSort::prepareData
+ */
+bool megamol::stdplugin::datatools::table::TableSort::prepareData(
+        TableDataCall& src, const unsigned int frameID) {
+    using namespace core::param;
+    using vislib::sys::Log;
+
+    /* Request the source data. */
+    src.SetFrameID(frameID);
+    if (!(src)(0)) {
+        Log::DefaultLog.WriteError(_T("The call to %hs failed in %hs."),
+            TableDataCall::FunctionName(0), TableDataCall::ClassName());
+        return false;
+    }
+
+    auto isParamsChanged = this->paramColumn.IsDirty()
+        || this->paramColumn.IsDirty()
+        || this->paramIsDescending.IsDirty()
+        || this->paramIsStable.IsDirty();
+
+    /* (Re-) Generate the data. */
+    if (isParamsChanged || (this->inputHash != src.DataHash())
+            || (this->frameID != src.GetFrameID())) {
+        auto column = 0;
+        const auto data = src.GetData();
+        std::vector<std::size_t> proxy(src.GetRowsCount());
+
+        /* Copy the column descriptors. */
+        this->columns.resize(src.GetColumnsCount());
+        std::copy(src.GetColumnsInfos(),
+            src.GetColumnsInfos() + this->columns.size(),
+            this->columns.begin());
+
+        /* Update the column selector. */
+        {
+            auto param = this->paramColumn.Param<FlexEnumParam>();
+            param->ClearValues();
+            for (auto& c : this->columns) {
+                param->AddValue(c.Name());
+            }
+        }
+
+        /* Determine the index of the reference column. */
+        {
+            auto c = this->paramColumn.Param<FlexEnumParam>()->Value();
+            for (auto& ci : this->columns) {
+                if (ci.Name() == c) {
+                    break;
+                }
+                ++column;
+            }
+
+            if (column == this->columns.size()) {
+                Log::DefaultLog.WriteError(L"The column \"hs\" cannot be used for "
+                    L"sorting, because it does not exist in the source data.",
+                    c.c_str());
+            }
+        }
+
+        /* Sort the index proxy. */
+        std::iota(proxy.begin(), proxy.end(), 0);
+
+        const auto isDesc = this->paramIsDescending.Param<BoolParam>()->Value();
+        auto pred = [this, column, data, isDesc](const std::size_t l,
+                const std::size_t r) {
+            auto lhs = data[l * this->columns.size() + column];
+            auto rhs = data[r * this->columns.size() + column];
+            return isDesc ? (rhs < lhs) : (lhs < rhs);
+        };
+
+        if (this->paramIsStable.Param<BoolParam>()->Value()) {
+            std::stable_sort(proxy.begin(), proxy.end(), pred);
+        } else {
+            std::sort(proxy.begin(), proxy.end(), pred);
+        }
+
+        /* Copy the data in sorted order. */
+        this->values.resize(src.GetRowsCount() * src.GetColumnsCount());
+        auto dst = this->values.data();
+
+        for (auto r : proxy) {
+            std::copy(data + r * this->columns.size(),
+                data + (r + 1) * this->columns.size(),
+                dst);
+            dst += this->columns.size();
+        }
+
+        /* Persist the state of the data. */
+        this->frameID = frameID;
+        this->inputHash = src.DataHash();
+
+        if (isParamsChanged) {
+            ++this->localHash;
+            this->paramColumn.ResetDirty();
+            this->paramIsDescending.ResetDirty();
+            this->paramIsStable.ResetDirty();
+        }
+    } /* end if (selector || (this->inputHash != src->DataHash()) ... */
+
+    return true;
+}
+
+
+/*
+ * megamol::stdplugin::datatools::table::TableSort::release
+ */
+void megamol::stdplugin::datatools::table::TableSort::release(void) { }
diff --git a/plugins/mmstd_datatools/src/table/TableSort.h b/plugins/mmstd_datatools/src/table/TableSort.h
new file mode 100644
index 000000000..bfa847b7d
--- /dev/null
+++ b/plugins/mmstd_datatools/src/table/TableSort.h
@@ -0,0 +1,82 @@
+/*
+ * TableSort.h
+ *
+ * Copyright (C) 2019 Visualisierungsinstitut der Universität Stuttgart
+ * Alle Rechte vorbehalten.
+ */
+
+#pragma once
+
+#include "TableProcessorBase.h"
+
+
+namespace megamol {
+namespace stdplugin {
+namespace datatools {
+namespace table {
+
+    /**
+     * This module sorts tabular data according to the specified column.
+     */
+    class TableSort : public TableProcessorBase {
+
+    public:
+
+        /**
+         * Answer the name of this module.
+         *
+         * @return The name of this module.
+         */
+        static inline const char *ClassName(void) {
+            return "TableSort";
+        }
+
+        /**
+         * Answer a human readable description of this module.
+         *
+         * @return A human readable description of this module.
+         */
+        static inline const char *Description(void) {
+            return "Selects rows from a data table";
+        }
+
+        /**
+         * Answers whether this module is available on the current system.
+         *
+         * @return 'true' if the module is available, 'false' otherwise.
+         */
+        static inline bool IsAvailable(void) {
+            return true;
+        }
+
+        /**
+         * Initialises a new instance.
+         */
+        TableSort(void);
+
+        /**
+         * Finalises an instance.
+         */
+        virtual ~TableSort(void);
+
+    protected:
+
+        virtual bool create(void);
+
+        virtual bool prepareData(TableDataCall& src,
+            const unsigned int frameID) override;
+
+        virtual void release(void);
+
+    private:
+
+        core::param::ParamSlot paramColumn;
+        core::param::ParamSlot paramIsDescending;
+        core::param::ParamSlot paramIsStable;
+
+    };
+
+} /* end namespace table */
+} /* end namespace datatools */
+} /* end namespace stdplugin */
+} /* end namespace megamol */
diff --git a/plugins/mmstd_datatools/src/table/TableToParticles.cpp b/plugins/mmstd_datatools/src/table/TableToParticles.cpp
index dfd87b882..b4dd518fb 100644
--- a/plugins/mmstd_datatools/src/table/TableToParticles.cpp
+++ b/plugins/mmstd_datatools/src/table/TableToParticles.cpp
@@ -39,6 +39,7 @@ TableToParticles::TableToParticles(void)
     , slotColumnVZ("vzcolumnname", "The name of the column holding the vz-coordinate.")
     , inputHash(0)
     , myHash(0)
+	, lastTimeStep(0)
     , columnIndex() {
 
     /* Register parameters. */
@@ -180,8 +181,8 @@ bool TableToParticles::pushColumnIndex(std::vector<size_t>& cols, const vislib::
     }
 }
 
-bool TableToParticles::assertData(table::TableDataCall* ft) {
-    if (this->inputHash == ft->DataHash() && !anythingDirty()) return true;
+bool TableToParticles::assertData(table::TableDataCall* ft, unsigned int frameID) {
+    if (this->inputHash == ft->DataHash() && !anythingDirty() && this->lastTimeStep == frameID) return true;
 
     if (this->inputHash != ft->DataHash()) {
         vislib::sys::Log::DefaultLog.WriteInfo("TableToParticles: Dataset changed -> Updating EnumParams\n");
@@ -316,7 +317,10 @@ bool TableToParticles::assertData(table::TableDataCall* ft) {
         this->bboxMax[i] = ft->GetColumnsInfos()[indicesToCollect[i]].MaximumValue();
     }
 
-    this->myHash++;
+	this->lastTimeStep = frameID;
+    if (anythingDirty() || this->inputHash != ft->DataHash()) {
+        this->myHash++;
+    }
     this->resetAllDirty();
     this->inputHash = ft->DataHash();
     return retValue;
@@ -330,15 +334,17 @@ bool TableToParticles::getMultiParticleData(core::Call& call) {
         core::moldyn::MultiParticleDataCall& c = dynamic_cast<core::moldyn::MultiParticleDataCall&>(call);
         table::TableDataCall* ft = this->slotCallTable.CallAs<table::TableDataCall>();
         if (ft == NULL) return false;
-        (*ft)();
 
-        if (!assertData(ft)) return false;
+		ft->SetFrameID(c.FrameID());
+        (*ft)(1);
+		(*ft)(0);
+
+        if (!assertData(ft, c.FrameID())) return false;
 
-        c.SetFrameCount(1);
-        c.SetFrameID(0);
+        c.SetFrameCount(ft->GetFrameCount());
         c.SetDataHash(this->myHash);
 
-        c.SetExtent(1, this->bboxMin[0], this->bboxMin[1], this->bboxMin[2], this->bboxMax[0], this->bboxMax[1],
+        c.SetExtent(ft->GetFrameCount(), this->bboxMin[0], this->bboxMin[1], this->bboxMin[2], this->bboxMax[0], this->bboxMax[1],
             this->bboxMax[2]);
         c.SetParticleListCount(1);
         c.AccessParticles(0).SetCount(ft->GetRowsCount());
@@ -412,15 +418,16 @@ bool TableToParticles::getMultiparticleExtent(core::Call& call) {
         core::moldyn::MultiParticleDataCall& c = dynamic_cast<core::moldyn::MultiParticleDataCall&>(call);
         table::TableDataCall* ft = this->slotCallTable.CallAs<table::TableDataCall>();
         if (ft == NULL) return false;
-        (*ft)();
 
-        if (!assertData(ft)) return false;
+		ft->SetFrameID(c.FrameID());
+		(*ft)(1);
+		(*ft)(0); // the bounding box is calculated from the data, so we have to call getData here
 
-        c.SetFrameCount(1);
-        c.SetFrameID(0);
+        if (!assertData(ft, c.FrameID())) return false;
+        c.SetFrameCount(ft->GetFrameCount());
         c.SetDataHash(this->myHash);
 
-        c.SetExtent(1, this->bboxMin[0], this->bboxMin[1], this->bboxMin[2], this->bboxMax[0], this->bboxMax[1],
+        c.SetExtent(ft->GetFrameCount(), this->bboxMin[0], this->bboxMin[1], this->bboxMin[2], this->bboxMax[0], this->bboxMax[1],
             this->bboxMax[2]);
         c.SetUnlocker(NULL);
         return true;
diff --git a/plugins/mmstd_datatools/src/table/TableToParticles.h b/plugins/mmstd_datatools/src/table/TableToParticles.h
index eb1a3fc4b..b76786cd1 100644
--- a/plugins/mmstd_datatools/src/table/TableToParticles.h
+++ b/plugins/mmstd_datatools/src/table/TableToParticles.h
@@ -81,7 +81,7 @@ namespace datatools {
 
     private:
 
-		bool assertData(table::TableDataCall *ft);
+		bool assertData(table::TableDataCall *ft, unsigned int frameID = 0);
 
 		bool anythingDirty();
 
@@ -157,6 +157,9 @@ namespace datatools {
         /** The name of the float column holding the vz-coordinate. */
         core::param::ParamSlot slotColumnVZ;
 
+		/** The lastly calculated time step */
+		unsigned int lastTimeStep;
+
 		std::vector<float> everything;
 
         bool haveVelocities = false;
diff --git a/plugins/mmstd_datatools/src/table/TableWhere.cpp b/plugins/mmstd_datatools/src/table/TableWhere.cpp
new file mode 100644
index 000000000..604202aa2
--- /dev/null
+++ b/plugins/mmstd_datatools/src/table/TableWhere.cpp
@@ -0,0 +1,373 @@
+/*
+ * TableWhere.cpp
+ *
+ * Copyright (C) 2019 Visualisierungsinstitut der Universität Stuttgart
+ * Alle Rechte vorbehalten.
+ */
+
+#include "stdafx.h"
+#include "TableWhere.h"
+
+#include <algorithm>
+#include <cassert>
+#include <functional>
+#include <limits>
+#include <numeric>
+
+#include "mmcore/param/BoolParam.h"
+#include "mmcore/param/EnumParam.h"
+#include "mmcore/param/FlexEnumParam.h"
+#include "mmcore/param/FloatParam.h"
+#include "mmcore/param/StringParam.h"
+
+
+/// <summary>
+/// The list of possible comparison operators.
+/// <summary>
+enum Operator : int {
+    Less = -2,
+    LessOrEqual = -1,
+    Equal = 0,
+    GreaterOrEqual = 1,
+    Greater = 2,
+    NotEqual,
+    LowerRange,
+    MiddleRange,
+    UpperRange,
+    LowerPercentile,
+    MiddlePercentile,
+    UpperPercentile
+};
+
+
+/*
+ * megamol::stdplugin::datatools::table::TableWhere::TableWhere
+ */
+megamol::stdplugin::datatools::table::TableWhere::TableWhere(void) 
+        : paramColumn("column", "The column to be filtered."),
+        paramEpsilon("epsilon", "The epsilon value for testing (in-) equality."),
+        paramOperator("operator", "The comparison operator."),
+        paramReference("reference", "The reference value to compare to."),
+        paramUpdateRange("updateRange", "Update the min/max range as the filter changes.") {
+    /* Configure and export the parameters. */
+    this->paramColumn << new core::param::FlexEnumParam("");
+    this->MakeSlotAvailable(&this->paramColumn);
+
+    this->paramEpsilon << new core::param::FloatParam(0.0f);
+    this->MakeSlotAvailable(&this->paramEpsilon);
+
+    {
+        auto param = new core::param::EnumParam(0);
+        param->SetTypePair(Operator::Less, "less than");
+        param->SetTypePair(Operator::LessOrEqual, "less or equal than");
+        param->SetTypePair(Operator::Equal, "equals");
+        param->SetTypePair(Operator::GreaterOrEqual, "greater or equal than");
+        param->SetTypePair(Operator::Greater, "greater than");
+        param->SetTypePair(Operator::NotEqual, "does not equal");
+        param->SetTypePair(Operator::LowerRange, "relative less than");
+        param->SetTypePair(Operator::MiddleRange, "around mean");
+        param->SetTypePair(Operator::UpperRange, "relative greater than");
+        param->SetTypePair(Operator::LowerPercentile, "in bottom percentile");
+        param->SetTypePair(Operator::MiddlePercentile, "around median");
+        param->SetTypePair(Operator::UpperPercentile, "in top percentile");
+        this->paramOperator << param;
+        this->MakeSlotAvailable(&this->paramOperator);
+    }
+
+    this->paramReference << new core::param::FloatParam(0.0f);
+    this->MakeSlotAvailable(&this->paramReference);
+
+    this->paramUpdateRange << new core::param::BoolParam(false);
+    this->MakeSlotAvailable(&this->paramUpdateRange);
+}
+
+
+/*
+ * megamol::stdplugin::datatools::table::TableWhere::~TableWhere
+ */
+megamol::stdplugin::datatools::table::TableWhere::~TableWhere(void) {
+    // TODO: this is toxic
+    this->Release();
+}
+
+
+/*
+ * megamol::stdplugin::datatools::table::TableWhere::create
+ */
+bool megamol::stdplugin::datatools::table::TableWhere::create(void) {
+    return true;
+}
+
+
+/*
+ * megamol::stdplugin::datatools::table::TableWhere::release
+ */
+void megamol::stdplugin::datatools::table::TableWhere::release(void) { }
+
+
+/*
+ * megamol::stdplugin::datatools::table::TableWhere::prepareData
+ */
+bool megamol::stdplugin::datatools::table::TableWhere::prepareData(
+        TableDataCall& src, const unsigned int frameID) {
+    using namespace core::param;
+    using vislib::sys::Log;
+
+    /* Request the source data. */
+    src.SetFrameID(frameID);
+    if (!(src)(0)) {
+        Log::DefaultLog.WriteError(_T("The call to %hs failed in %hs."),
+            TableDataCall::FunctionName(0), TableDataCall::ClassName());
+        return false;
+    }
+
+    auto isParamsChanged = this->paramUpdateRange.IsDirty()
+        || this->paramColumn.IsDirty()
+        || this->paramOperator.IsDirty()
+        || this->paramReference.IsDirty();
+
+    /* (Re-) Generate the data. */
+    if (isParamsChanged || (this->inputHash != src.DataHash())
+            || (this->frameID != src.GetFrameID())) {
+        auto column = 0;
+        const auto data = src.GetData();
+        auto isSort = false;
+        std::function<bool(const float)> selector;
+
+        /* Process updates in the configuration. */
+        {
+            auto c = this->paramColumn.Param<FlexEnumParam>()->Value();
+            auto e = this->paramEpsilon.Param<FloatParam>()->Value();
+            auto o = this->paramOperator.Param<EnumParam>()->Value();
+            auto r = this->paramReference.Param<FloatParam>()->Value();
+
+            this->columns.resize(src.GetColumnsCount());
+            std::copy(src.GetColumnsInfos(),
+                src.GetColumnsInfos() + this->columns.size(),
+                this->columns.begin());
+
+            {
+                auto param = this->paramColumn.Param<FlexEnumParam>();
+                param->ClearValues();
+                for (auto& c : this->columns) {
+                    param->AddValue(c.Name());
+                }
+            }
+
+            for (auto& ci : this->columns) {
+                if (ci.Name() == c) {
+                    break;
+                }
+                ++column;
+            }
+
+            if (column != this->columns.size()) {
+                auto range = std::make_pair(this->columns[column].MinimumValue(),
+                    this->columns[column].MaximumValue());
+
+                switch (o) {
+                case Operator::Less:
+                    selector = [r](const float v) { return (v < r); };
+                    break;
+
+                case Operator::LessOrEqual:
+                    selector = [r](const float v) { return (v <= r); };
+                    break;
+
+                case Operator::Equal:
+                    selector = [r, e](const float v) {
+                        return (std::abs(v - r) <= e);
+                    };
+                    break;
+
+                case Operator::GreaterOrEqual:
+                    selector = [r](const float v) { return (v >= r); };
+                    break;
+
+                case Operator::Greater:
+                    selector = [r](const float v) { return (v > r); };
+                    break;
+
+                case Operator::NotEqual:
+                    selector = [r, e](const float v) {
+                        return (std::abs(v - r) > e);
+                    };
+                    break;
+
+                case Operator::LowerRange:
+                    selector = [r, range](const float v) {
+                        assert(range.second >= range.first);
+                        auto d = (range.second - range.first) * r;
+                        return (v <= (range.first + d));
+
+                    };
+                    break;
+
+                case Operator::MiddleRange:
+                    selector = [r, range](const float v) {
+                        assert(range.second >= range.first);
+                        auto d = 1.0f - 0.5f * (range.second - range.first) * r;
+                        return ((v >= (range.first + d))
+                            && (v <= (range.second - d)));
+
+                    };
+                    break;
+
+                case Operator::UpperRange:
+                    selector = [r, range](const float v) {
+                        assert(range.second >= range.first);
+                        auto d = (range.second - range.first) * r;
+                        return (v >= (range.second - d));
+
+                    };
+                    break;
+
+                case Operator::LowerPercentile:
+                case Operator::MiddlePercentile:
+                case Operator::UpperPercentile:
+                    isSort = true;
+                    break;
+
+                default:
+                    Log::DefaultLog.WriteError(_T("The comparison operator %d ")
+                        _T("is unsupported."), o);
+                    break;
+                }
+
+            } else {
+                Log::DefaultLog.WriteWarn(_T("The column \"%hs\" to be filtered ")
+                    _T("was not found in the data set. The %hs module will copy ")
+                    _T("all input rows."), c.c_str(), TableWhere::ClassName());
+            }
+        }
+        assert(((column >= 0) && (column < this->columns.size())) || !selector);
+
+        if (selector || isSort) {
+            // Copy selection.
+            std::vector<std::size_t> selection;
+            selection.reserve(src.GetRowsCount());
+
+            if (selector) {
+                // Selection is based on predicate.
+                for (auto r = 0; r < src.GetRowsCount(); ++r) {
+                    if (selector(data[r * this->columns.size() + column])) {
+                        selection.push_back(r);
+                    }
+                }
+            } else {
+                // Selection requires sorting.
+                const auto o = this->paramOperator.Param<EnumParam>()->Value();
+                const auto r = vislib::math::Clamp(
+                    this->paramReference.Param<FloatParam>()->Value(),
+                    0.0f, 1.0f);
+
+                selection.resize(src.GetRowsCount());
+                std::iota(selection.begin(), selection.end(), 0);
+
+                std::stable_sort(selection.begin(), selection.end(),
+                    [this, data, column](const std::size_t l, const std::size_t r) {
+                    auto lhs = data[l * this->columns.size() + column];
+                    auto rhs = data[r * this->columns.size() + column];
+                    return (lhs < rhs);
+                });
+
+                // Compute the number of elements we want to retain.
+                const auto cnt = static_cast<std::size_t>(static_cast<double>(r)
+                    * src.GetRowsCount());
+
+                switch (o) {
+                    case Operator::LowerPercentile:
+                        // Take first 'cnt' values.
+                        selection.resize(cnt);
+                        if (!selection.empty()) {
+                            Log::DefaultLog.WriteWarn(_T("Selected range is ")
+                                _T("within [%f, %f]."),
+                                data[selection.front() * this->columns.size() + column],
+                                data[selection.back() * this->columns.size() + column]);
+                        }
+                        break;
+
+                    case Operator::MiddlePercentile: {
+                        auto c = (src.GetRowsCount() - cnt) / 2;
+                        selection.erase(selection.begin(), selection.begin() + c);
+                        selection.resize(cnt);
+                        if (!selection.empty()) {
+                            Log::DefaultLog.WriteWarn(_T("Selected range is ")
+                                _T("within [%f, %f]."),
+                                data[selection.front() * this->columns.size() + column],
+                                data[selection.back() * this->columns.size() + column]);
+                        }
+                        } break;
+
+                    case Operator::UpperPercentile:
+                        // Remove everything up to last 'cnt' values.
+                        selection.erase(selection.begin(), selection.end() - cnt);
+                        if (!selection.empty()) {
+                            Log::DefaultLog.WriteWarn(_T("Selected range is ")
+                                _T("within [%f, %f]."),
+                                data[selection.front() * this->columns.size() + column],
+                                data[selection.back() * this->columns.size() + column]);
+                        }
+                        break;
+
+                default:
+                    assert(false);
+                    break;
+                }
+            }
+
+            /* Copy the data. */
+            this->values.resize(selection.size() * this->columns.size());
+            auto d = this->values.data();
+            for (auto r : selection) {
+                std::copy(data + r * this->columns.size(),
+                    data + (r + 1) * this->columns.size(),
+                    d);
+                d += this->columns.size();
+            }
+
+            /* Update the min/max range if requested. */
+            if (this->paramUpdateRange.Param<BoolParam>()->Value()) {
+                const auto rows = this->values.size() / this->columns.size();
+
+                for (std::size_t c = 0; c < this->columns.size(); ++c) {
+                    auto minimum = (std::numeric_limits<float>::max)();
+                    auto maximum = (std::numeric_limits<float>::min)();
+
+                    for (std::size_t r = 0; r < rows; ++r) {
+                        auto value = this->values[r * this->columns.size() + c];
+                        if (value < minimum) {
+                            minimum = value;
+                        }
+                        if (value > maximum) {
+                            maximum = value;
+                        }
+
+                        this->columns[c].SetMinimumValue(minimum);
+                        this->columns[c].SetMaximumValue(maximum);
+                    }
+                }
+            } /* end if (this->paramUpdateRange.Param<BoolParam>()->Value()) */
+
+        } else {
+            // Copy everything.
+            this->values.resize(src.GetRowsCount() * this->columns.size());
+            std::copy(src.GetData(), src.GetData() + this->values.size(),
+                this->values.begin());
+        } /* end if (selector || isSort) */
+
+        /* Persist the state of the data. */
+        this->frameID = frameID;
+        this->inputHash = src.DataHash();
+
+        if (isParamsChanged) {
+            ++this->localHash;
+            this->paramColumn.ResetDirty();
+            this->paramOperator.ResetDirty();
+            this->paramReference.ResetDirty();
+            this->paramUpdateRange.ResetDirty();
+        }
+    } /* end if (selector || (this->inputHash != src->DataHash()) ... */
+
+    return true;
+}
diff --git a/plugins/mmstd_datatools/src/table/TableWhere.h b/plugins/mmstd_datatools/src/table/TableWhere.h
new file mode 100644
index 000000000..f02d11847
--- /dev/null
+++ b/plugins/mmstd_datatools/src/table/TableWhere.h
@@ -0,0 +1,84 @@
+/*
+ * TableWhere.h
+ *
+ * Copyright (C) 2019 Visualisierungsinstitut der Universität Stuttgart
+ * Alle Rechte vorbehalten.
+ */
+
+#pragma once
+
+#include "TableProcessorBase.h"
+
+
+namespace megamol {
+namespace stdplugin {
+namespace datatools {
+namespace table {
+
+    /**
+     * This module selects rows from a table based on a filter.
+     */
+    class TableWhere : public TableProcessorBase {
+
+    public:
+
+        /**
+         * Answer the name of this module.
+         *
+         * @return The name of this module.
+         */
+        static inline const char *ClassName(void) {
+            return "TableWhere";
+        }
+
+        /**
+         * Answer a human readable description of this module.
+         *
+         * @return A human readable description of this module.
+         */
+        static inline const char *Description(void) {
+            return "Selects rows from a data table";
+        }
+
+        /**
+         * Answers whether this module is available on the current system.
+         *
+         * @return 'true' if the module is available, 'false' otherwise.
+         */
+        static inline bool IsAvailable(void) {
+            return true;
+        }
+
+        /**
+         * Initialises a new instance.
+         */
+        TableWhere(void);
+
+        /**
+         * Finalises an instance.
+         */
+        virtual ~TableWhere(void);
+
+    protected:
+
+        virtual bool create(void);
+
+        virtual bool prepareData(TableDataCall& src,
+            const unsigned int frameID) override;
+
+        virtual void release(void);
+
+    private:
+
+        core::param::ParamSlot paramColumn;
+        core::param::ParamSlot paramEpsilon;
+        core::param::ParamSlot paramOperator;
+        core::param::ParamSlot paramReference;
+        core::param::ParamSlot paramUpdateRange;
+
+    };
+
+} /* end namespace table */
+} /* end namespace datatools */
+} /* end namespace stdplugin */
+} /* end namespace megamol */
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Aggr.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Aggr.glsl
new file mode 100644
index 000000000..6544616b3
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Aggr.glsl
@@ -0,0 +1,59 @@
+/* opacity threshold for integration */
+uniform float opacityThreshold;
+
+/* texture containing transfer function */
+uniform highp sampler1D tf_tx1D;
+
+/* texture containing a depth buffer */
+uniform highp sampler2D color_tx2D;
+uniform highp sampler2D depth_tx2D;
+uniform int use_depth_tx;
+
+/* main function for computation */
+void compute(float t, const float tfar, const Ray ray, const float rayStep, const ivec2 pixel_coords) {
+    // Get pixel texture coordinates and depth value at original position
+    vec2 pixel_tex_coords = vec2(pixel_coords.x / rt_resolution.x, pixel_coords.y / rt_resolution.y);
+    const float input_depth = texture(depth_tx2D, pixel_tex_coords).x;
+
+    // Initialize results
+    vec4 result = vec4(0.0f);
+
+    float att = 0.0f;
+
+    while (t < tfar) {
+        vec3 pos = ray.o + t * ray.d;
+
+        // Compute volume tex coordinates in [0,1] range.
+        vec3 texCoords = (pos - boxMin) / (boxMax - boxMin);
+        texCoords *= 1.0 - 2.0 * halfVoxelSize;
+        texCoords += halfVoxelSize;
+
+        if (use_depth_tx != 0) {
+            // Compare depth values and decide to abort
+            const float depth = calculate_depth(pos);
+
+            if (depth > input_depth) {
+                const vec4 color = texture(color_tx2D, pixel_tex_coords);
+
+                result = color;
+
+                break;
+            }
+        }
+
+        // Get sample
+        att += (texture(volume_tx3D, texCoords).x - valRange.x) / (valRange.y - valRange.x);
+
+        t += rayStep;
+    }
+
+    // Write results
+    result = result.w * result + background * (1.0f - result.w);
+
+    imageStore(render_target_tx2D, pixel_coords, vec4(result.xyz, att));
+}
+
+/* function for storing default output values */
+void storeDefaults(const ivec2 pixel_coords) {
+    imageStore(render_target_tx2D, pixel_coords, vec4(0.0f));
+}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-DVR.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-DVR.glsl
new file mode 100644
index 000000000..19d7c8fc1
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-DVR.glsl
@@ -0,0 +1,68 @@
+/* opacity threshold for integration */
+uniform float opacityThreshold;
+
+/* texture containing transfer function */
+uniform highp sampler1D tf_tx1D;
+
+/* texture containing a depth buffer */
+uniform highp sampler2D color_tx2D;
+uniform highp sampler2D depth_tx2D;
+uniform int use_depth_tx;
+
+/* main function for computation */
+void compute(float t, const float tfar, const Ray ray, const float rayStep, const ivec2 pixel_coords) {
+    // Get pixel texture coordinates and depth value at original position
+    vec2 pixel_tex_coords = vec2(pixel_coords.x / rt_resolution.x, pixel_coords.y / rt_resolution.y);
+    const float input_depth = texture(depth_tx2D, pixel_tex_coords).x;
+
+    // Initialize results
+    vec4 result = vec4(0.0f);
+
+    while (t < tfar && result.w < opacityThreshold) {
+        vec3 pos = ray.o + t * ray.d;
+
+        // Compute volume tex coordinates in [0,1] range.
+        vec3 texCoords = (pos - boxMin) / (boxMax - boxMin);
+        texCoords *= 1.0 - 2.0 * halfVoxelSize;
+        texCoords += halfVoxelSize;
+
+        if (use_depth_tx != 0) {
+            // Compare depth values and decide to abort
+            const float depth = calculate_depth(pos);
+
+            if (depth > input_depth) {
+                const vec4 color = texture(color_tx2D, pixel_tex_coords);
+
+                result += (1.0f - result.w) * color;
+
+                break;
+            }
+        }
+
+        // Get sample
+        vec4 vol_sample = texture(tf_tx1D, (texture(volume_tx3D, texCoords).x - valRange.x) / (valRange.y-valRange.x));
+
+        // Calculate lighting
+        if (use_lighting) {
+            vol_sample.xyz = phong(vol_sample.xyz, calculate_normal(texCoords), -ray.d, light - pos);
+        }
+
+        // Opacity correction.
+        vol_sample.w = (1.0f - pow(1.0f - vol_sample.w, rayStepRatio));
+        vol_sample.xyz *= vol_sample.w;
+
+        result += (1.0f - result.w) * vol_sample;
+
+        t += rayStep;
+    }
+
+    // Write results
+    result = result.w * result + background * (1.0f - result.w);
+
+    imageStore(render_target_tx2D, pixel_coords, result);
+}
+
+/* function for storing default output values */
+void storeDefaults(const ivec2 pixel_coords) {
+    imageStore(render_target_tx2D, pixel_coords, vec4(0.0f));
+}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Functions.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Functions.glsl
new file mode 100644
index 000000000..9394f3e9c
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Functions.glsl
@@ -0,0 +1,89 @@
+struct Ray {
+    vec3 o;
+    vec3 d;
+};
+
+Ray generateRay(ivec2 pixel_coords) {
+    Ray ray;
+
+    // Transform pixel to clip coordinates
+    vec2 clip_space_pixel_coords =
+        vec2((pixel_coords.x / rt_resolution.x) * 2.0f - 1.0f, (pixel_coords.y / rt_resolution.y) * 2.0f - 1.0f);
+
+    // Unproject a point on the near plane and use as an origin
+    mat4 inv_view_proj_mx = inverse(proj_mx * view_mx);
+    vec4 unproj = inv_view_proj_mx * vec4(clip_space_pixel_coords, -1.0f, 1.0f);
+
+    ray.o = unproj.xyz / unproj.w;
+
+    // Unproject a point at the same pixel, but further away from the near plane
+    // to compute a ray direction in world space
+    unproj = inv_view_proj_mx * vec4(clip_space_pixel_coords, 0.0f, 1.0f);
+
+    ray.d = normalize((unproj.xyz / unproj.w) - ray.o);
+
+    return ray;
+}
+
+bool intersectBox(Ray r, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar) {
+    vec3 invR = vec3(1.0f) / r.d;
+    vec3 tbot = invR * (boxmin - r.o);
+    vec3 ttop = invR * (boxmax - r.o);
+
+    // Special case for a ray lying in a bounding plane.
+    if (r.d.x == 0.0f && r.o.x == boxmax.x) {
+        ttop.x = -FLT_MAX;
+        tbot.x = FLT_MAX;
+    }
+    if (r.d.y == 0.0f && r.o.y == boxmax.y) {
+        ttop.y = -FLT_MAX;
+        tbot.y = FLT_MAX;
+    }
+    if (r.d.z == 0.0f && r.o.z == boxmax.z) {
+        ttop.z = -FLT_MAX;
+        tbot.z = FLT_MAX;
+    }
+
+    vec3 tmin = min(ttop, tbot);
+    vec3 tmax = max(ttop, tbot);
+
+    float largest_tmin = max(max(tmin.x, tmin.y), max(tmin.x, tmin.z));
+    float smallest_tmax = min(min(tmax.x, tmax.y), min(tmax.x, tmax.z));
+
+    tnear = largest_tmin;
+    tfar = smallest_tmax;
+
+    return smallest_tmax > largest_tmin;
+}
+
+float wang_hash(uint seed) {
+    seed = (seed ^ 61) ^ (seed >> 16);
+    seed *= 9;
+    seed = seed ^ (seed >> 4);
+    seed *= 0x27d4eb2d;
+    seed = seed ^ (seed >> 15);
+
+    return float(seed) / 4294967296.0;
+}
+
+float calculate_depth(vec3 pos) {
+    vec4 clip_pos = proj_mx * view_mx * vec4(pos, 1.0f);
+
+    return ((clip_pos.z / clip_pos.w) + 1.0f) / 2.0f;
+}
+
+vec3 calculate_normal(vec3 texCoords) {
+    const float left = textureOffset(volume_tx3D, texCoords, ivec3(-1, 0, 0)).x;
+    const float right = textureOffset(volume_tx3D, texCoords, ivec3(1, 0, 0)).x;
+
+    const float bottom = textureOffset(volume_tx3D, texCoords, ivec3(0, -1, 0)).x;
+    const float top = textureOffset(volume_tx3D, texCoords, ivec3(0, 1, 0)).x;
+
+    const float front = textureOffset(volume_tx3D, texCoords, ivec3(0, 0, -1)).x;
+    const float back = textureOffset(volume_tx3D, texCoords, ivec3(0, 0, 1)).x;
+
+    return normalize(vec3(
+        (left - right) / halfVoxelSize.x,
+        (bottom - top) / halfVoxelSize.y,
+        (front - back) / halfVoxelSize.z));
+}
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Input.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Input.glsl
new file mode 100644
index 000000000..0e2ebba40
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Input.glsl
@@ -0,0 +1,35 @@
+#extension GL_ARB_compute_shader: enable
+#define FLT_MAX 3.402823466e+38
+#define FLT_MIN 1.175494351e-38
+#define PI      3.14159265
+
+/* matrices */
+uniform mat4 view_mx;
+uniform mat4 proj_mx;
+
+/* render targete resolution*/
+uniform vec2 rt_resolution;
+
+/* bounding box size */
+uniform vec3 boxMin;
+uniform vec3 boxMax;
+
+/* voxel size */
+uniform float voxelSize;
+uniform vec3 halfVoxelSize;
+
+/* sampling frequency */
+uniform float rayStepRatio;
+
+/* value range */
+uniform vec2 valRange;
+
+/* background color */
+uniform vec4 background;
+
+/* lighting */
+uniform bool use_lighting;
+uniform vec3 material_col;
+
+/* texture that houses the volume data */
+uniform highp sampler3D volume_tx3D;
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Iso.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Iso.glsl
new file mode 100644
index 000000000..108eae488
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Iso.glsl
@@ -0,0 +1,82 @@
+/* isovalue used for isosurface reconstruction */
+uniform float isoValue;
+
+/* opacity */
+uniform float opacity;
+
+/* output normal */
+layout(rgba32f, binding = 1) writeonly uniform highp image2D normal_target_tx2D;
+
+/* output depth */
+layout(r32f, binding = 2) writeonly uniform highp image2D depth_target_tx2D;
+
+/* main function for computation */
+void compute(float t, const float tfar, const Ray ray, const float rayStep, const ivec2 pixel_coords) {
+    // Initialize results
+    vec4 result = vec4(0.0f);
+
+    // Initialize output depth and normal value
+    float depth = FLT_MAX;
+    vec3 normal = vec3(0.0f);
+
+    // Store value and position from previous step
+    vec3 old_pos = ray.o + t * ray.d;
+    float old_value = 0.0f;
+
+    while (t < tfar) {
+        vec3 pos = ray.o + t * ray.d;
+
+        // Compute volume tex coordinates in [0,1] range.
+        vec3 texCoords = (pos - boxMin) / (boxMax - boxMin);
+        texCoords *= 1.0 - 2.0 * halfVoxelSize;
+        texCoords += halfVoxelSize;
+
+        // Get volume sample
+        float vol_sample = texture(volume_tx3D, texCoords).x;
+
+        if (vol_sample > isoValue) {
+            // Compute relative position between sample positions
+            const vec3 direction = pos - old_pos;
+            const float distance = (isoValue - old_value) / (vol_sample - old_value);
+
+            const vec3 surface_pos = old_pos + distance * direction;
+
+            depth = calculate_depth(surface_pos);
+
+            // Compute normal
+            normal = calculate_normal(texCoords);
+
+            // Compute illumination from fixed light
+            if (use_lighting) {
+                result = vec4(phong(material_col, normal, -ray.d, light - surface_pos), opacity);
+            } else {
+                result = vec4(material_col, opacity);
+            }
+
+            break;
+        }
+
+        // Store value and position for new "previous" step
+        old_pos = pos;
+        old_value = vol_sample;
+
+        // Adaptive step size
+        if (vol_sample / isoValue < 0.5f) {
+            t += rayStep;
+        } else {
+            t += rayStep * (1.0f + (rayStep / 10.0f) - vol_sample / isoValue);
+        }
+    }
+
+    // Write results
+    imageStore(render_target_tx2D, pixel_coords, result);
+    imageStore(normal_target_tx2D, pixel_coords, vec4(normal, 1.0f));
+    imageStore(depth_target_tx2D, pixel_coords, vec4(depth));
+}
+
+/* function for storing default output values */
+void storeDefaults(const ivec2 pixel_coords) {
+    imageStore(render_target_tx2D, pixel_coords, vec4(0.0f));
+    imageStore(normal_target_tx2D, pixel_coords, vec4(0.0f));
+    imageStore(depth_target_tx2D, pixel_coords, vec4(FLT_MAX));
+}
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Output.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Output.glsl
new file mode 100644
index 000000000..402e9f949
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Output.glsl
@@ -0,0 +1,2 @@
+/* output image */
+layout(rgba32f, binding = 0) writeonly uniform highp image2D render_target_tx2D;
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute.glsl
new file mode 100644
index 000000000..1a380996d
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute.glsl
@@ -0,0 +1,31 @@
+/* main routine */
+layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
+
+void main() {
+    // Get pixel coordinates
+    vec3 gID = gl_GlobalInvocationID.xyz;
+    if (gID.x >= rt_resolution.x || gID.y >= rt_resolution.y) return;
+
+    ivec2 pixel_coords = ivec2(gID.xy);
+
+    // Generate ray
+    Ray ray = generateRay(pixel_coords);
+    float rayStep = voxelSize * rayStepRatio;
+    float rayOffset = wang_hash(pixel_coords.x + pixel_coords.y * uint(rt_resolution.x)) * rayStep;
+
+    // Require tnear or tfar to be positive, so that we can renderer from inside the box,
+    // but do not render if the box is completely behind the camera.
+    float tnear, tfar;
+
+    if (intersectBox(ray, boxMin, boxMax, tnear, tfar) && (tnear > 0.0f || tfar > 0.0f)) {
+        // Initialize ray start and randomly offset it to prevent ringing artifacts
+        float t = tnear >= 0.0f ? tnear : 0.0f;
+        t += rayOffset;
+
+        // Start computation by calling the function from the specialized shader
+        compute(t, tfar, ray, rayStep, pixel_coords);
+    } else {
+        // Store default values by calling the function from the specialized shader
+        storeDefaults(pixel_coords);
+    }
+}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Fragment-Aggr.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Fragment-Aggr.glsl
new file mode 100644
index 000000000..de953c336
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Fragment-Aggr.glsl
@@ -0,0 +1,22 @@
+uniform sampler2D src_tx2D;
+uniform sampler2D normal_tx2D;
+uniform sampler2D depth_tx2D;
+uniform sampler1D tf_tx1D;
+
+uniform vec2 valRange;
+
+in vec2 uv_coord;
+
+layout (location = 0) out vec4 frag_out;
+layout (location = 1) out vec4 normal_out;
+
+void main()
+{
+    frag_out = texture(src_tx2D, uv_coord);
+    vec4 vol_sample = texture(tf_tx1D, (frag_out.w - valRange.x) / (valRange.y - valRange.x));
+    frag_out = vec4(frag_out.xyz * (1.0f - vol_sample.w) + vol_sample.xyz * vol_sample.w, 1.0f);
+
+    normal_out = texture(normal_tx2D, uv_coord);
+
+    gl_FragDepth = texture(depth_tx2D, uv_coord).x;
+}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Fragment.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Fragment.glsl
new file mode 100644
index 000000000..7cde99f50
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Fragment.glsl
@@ -0,0 +1,16 @@
+uniform sampler2D src_tx2D;
+uniform sampler2D normal_tx2D;
+uniform sampler2D depth_tx2D;
+
+in vec2 uv_coord;
+
+layout (location = 0) out vec4 frag_out;
+layout (location = 1) out vec4 normal_out;
+
+void main()
+{
+    frag_out = texture(src_tx2D, uv_coord);
+    normal_out = texture(normal_tx2D, uv_coord);
+
+    gl_FragDepth = texture(depth_tx2D, uv_coord).x;
+}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Vertex.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Vertex.glsl
new file mode 100644
index 000000000..946885b57
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Vertex.glsl
@@ -0,0 +1,17 @@
+out vec2 uv_coord;
+
+void main()
+{
+    const vec4 vertices[6] = vec4[6](
+        vec4(-1.0, -1.0, 0.0, 0.0),
+        vec4( 1.0,  1.0, 1.0, 1.0),
+        vec4(-1.0,  1.0, 0.0, 1.0),
+        vec4( 1.0,  1.0, 1.0, 1.0),
+        vec4(-1.0, -1.0, 0.0, 0.0),
+        vec4( 1.0, -1.0, 1.0, 0.0));
+
+    const vec4 vertex = vertices[gl_VertexID];
+
+    uv_coord = vertex.zw;
+    gl_Position =  vec4(vertex.xy, -1.0, 1.0);
+}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer.btf b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer.btf
index 101b27261..eae925923 100644
--- a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer.btf
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer.btf
@@ -1,20 +1,48 @@
 <?xml version="1.0" encoding="utf-8"?>
 <btf type="MegaMolGLSLShader" version="1.0" namespace="RaycastVolumeRenderer">
-    <include file="common"/>
 
     <shader name="compute">
         <snippet type="version">430</snippet>
-        <snippet name="body" type="file">raycast_volume/raycast_volume_c.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Input.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Output.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Functions.glsl</snippet>
+        <snippet type="file">phong.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-DVR.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute.glsl</snippet>
+    </shader>
+
+    <shader name="compute_aggr">
+        <snippet type="version">430</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Input.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Output.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Functions.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Aggr.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute.glsl</snippet>
+    </shader>
+
+    <shader name="compute_iso">
+        <snippet type="version">430</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Input.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Output.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Functions.glsl</snippet>
+        <snippet type="file">phong.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Iso.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute.glsl</snippet>
     </shader>
 
     <shader name="vert">
         <snippet type="version">430</snippet>
-        <snippet name="body" type="file">raycast_volume/render_to_framebuffer_v.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Vertex.glsl</snippet>
     </shader>
 
     <shader name="frag">
         <snippet type="version">430</snippet>
-        <snippet name="body" type="file">raycast_volume/render_to_framebuffer_f.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Fragment.glsl</snippet>
+    </shader>
+
+    <shader name="frag_aggr">
+        <snippet type="version">430</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Fragment-Aggr.glsl</snippet>
     </shader>
 
 </btf>
diff --git a/plugins/mmstd_volume/Shaders/raycast_volume/raycast_volume_c.glsl b/plugins/mmstd_volume/Shaders/raycast_volume/raycast_volume_c.glsl
deleted file mode 100644
index ee82f5907..000000000
--- a/plugins/mmstd_volume/Shaders/raycast_volume/raycast_volume_c.glsl
+++ /dev/null
@@ -1,183 +0,0 @@
-#extension GL_ARB_compute_shader: enable
-#define FLT_MAX 3.402823466e+38
-#define FLT_MIN 1.175494351e-38
-
-/* matrix that transforms a set of coordinates from world space to volume texture space */
-uniform mat4 volume_model_mx;
-/* camera inverse view projection matrix */
-//uniform mat4 camera_inv_view_proj_mx;
-
-uniform mat4 view_mx;
-uniform mat4 proj_mx;
-
-/* render targete resolution*/
-uniform vec2 rt_resolution;
-/**/
-uniform vec3 boxMin;
-/**/
-uniform vec3 boxMax;
-/**/
-uniform float voxelSize;
-/**/
-uniform vec3 halfVoxelSize;
-uniform float rayStepRatio;
-/**/
-uniform float opacityThreshold;
-
-uniform vec2 valRange;
-
-/*	texture that houses the volume data */
-uniform highp sampler3D volume_tx3D;
-/* texture containing scene depth */
-uniform highp sampler2D depth_tx2D;
-/* texture containing transfer function */
-//uniform highp sampler2D transfer_function_tx2D;
-uniform highp sampler1D tf_tx1D;
-
-layout(rgba32f, binding = 0) writeonly uniform highp image2D render_target_tx2D;
-
-struct Ray {
-    vec3 o;
-    vec3 d;
-};
-
-bool intersectBox(Ray r, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar) {
-    vec3 invR = vec3(1.0f) / r.d;
-    vec3 tbot = invR * (boxmin - r.o);
-    vec3 ttop = invR * (boxmax - r.o);
-
-    // Special case for a ray lying in a bounding plane.
-    if (r.d.x == 0.0f && r.o.x == boxmax.x) {
-        ttop.x = -FLT_MAX;
-        tbot.x = FLT_MAX;
-    }
-    if (r.d.y == 0.0f && r.o.y == boxmax.y) {
-        ttop.y = -FLT_MAX;
-        tbot.y = FLT_MAX;
-    }
-    if (r.d.z == 0.0f && r.o.z == boxmax.z) {
-        ttop.z = -FLT_MAX;
-        tbot.z = FLT_MAX;
-    }
-
-    vec3 tmin = min(ttop, tbot);
-    vec3 tmax = max(ttop, tbot);
-
-    float largest_tmin = max(max(tmin.x, tmin.y), max(tmin.x, tmin.z));
-    float smallest_tmax = min(min(tmax.x, tmax.y), min(tmax.x, tmax.z));
-
-    tnear = largest_tmin;
-    tfar = smallest_tmax;
-
-    return smallest_tmax > largest_tmin;
-}
-
-/////////////////////////////// Random Number Generator
-float wang_hash(uint seed) {
-    seed = (seed ^ 61) ^ (seed >> 16);
-    seed *= 9;
-    seed = seed ^ (seed >> 4);
-    seed *= 0x27d4eb2d;
-    seed = seed ^ (seed >> 15);
-
-    return float(seed) / 4294967296.0;
-}
-/////////////////////////////// End - Random Number Generator
-
-layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
-
-void main() {
-    vec3 gID = gl_GlobalInvocationID.xyz;
-
-    if (gID.x >= rt_resolution.x || gID.y >= rt_resolution.y) return;
-
-    ivec2 pixel_coords = ivec2(gID.xy);
-
-    vec2 clip_space_pixel_coords =
-        vec2((gID.x / rt_resolution.x) * 2.0f - 1.0f, (gID.y / rt_resolution.y) * 2.0f - 1.0f);
-
-    Ray ray;
-    // Unproject a point on the near plane and use as an origin.
-    mat4 inv_view_proj_mx = inverse(proj_mx * view_mx);
-    vec4 unproj = inv_view_proj_mx * vec4(clip_space_pixel_coords, -1.0f, 1.0f);
-    ray.o = unproj.xyz / unproj.w;
-    // Unproject a point at the same pixel, but further away from the near plane
-    // to compute a ray direction in world space.
-    unproj = inv_view_proj_mx * vec4(clip_space_pixel_coords, 0.0f, 1.0f);
-    ray.d = normalize((unproj.xyz / unproj.w) - ray.o);
-
-    // Just for safety.
-    // Box diagonal is sqrt(3) times longer.
-    float rayStep = voxelSize * rayStepRatio;
-    vec3 box_range = boxMax - boxMin;
-    float max_bbox_length = max(max(box_range.x, box_range.y), box_range.z);
-    //int maxSteps = int((1.0f / rayStep) * 1.74f * 2.0f * max_bbox_length); // todo
-
-    // Generate a random value in [0, 1] range.
-    // float randomTemp = sin(dot(vec2(pixel_coords.y * rt_resolution.x + pixel_coords.x), vec2(12.9898f, 78.233f))) *
-    // 43758.5453f; float random = abs(randomTemp - floor(randomTemp));
-    float random = wang_hash(pixel_coords.x + pixel_coords.y * uint(rt_resolution.x));
-
-    float tnear, tfar;
-
-    // Require tnear or tfar to be positive, so that we can renderer from inside the box,
-    // but do not render if the box is completely behind the camera.
-    if (intersectBox(ray, boxMin, boxMax, tnear, tfar) && (tnear > 0.0f || tfar > 0.0f)) {
-        float t = tnear >= 0.0f ? tnear : 0.0f;
-        t += random * rayStep; // Randomly offset the ray origin to prevent ringing artifacts
-        vec4 result = vec4(0.0f);
-        int steps = 0;
-
-        while (t < tfar && result.w < opacityThreshold /*&& steps < maxSteps*/) {
-            vec3 pos = ray.o + t * ray.d;
-            // Compute volume tex coordinates in [0,1] range.
-            vec3 texCoords = (pos - boxMin) / (boxMax - boxMin);
-            texCoords *= 1.0 - 2.0 * halfVoxelSize;
-            texCoords += halfVoxelSize;
-
-            //vec4 vol_sample = texture(transfer_function_tx2D, vec2(texture(volume_tx3D, texCoords).x, 1));
-            vec4 vol_sample = texture(tf_tx1D, (texture(volume_tx3D, texCoords).x - valRange.x)/valRange.y);
-            
-            // vec4 vol_sample = texture(volume_tx3D,texCoords);
-            // vol_sample.w = vol_sample.x;
-
-            // Opacity correction.
-            vol_sample.w = (1.0f - pow(1.0f - vol_sample.w, rayStepRatio));
-            // TF "Brightness". Make sure to not over-saturate the opacity.
-            // (Which will lead to color oversaturation.)
-            // vol_sample.w = min(vol_sample.w * cSeriesDesc.BrightnessPerSeries[series], 1.0f)
-            vol_sample.xyz *= vol_sample.w;
-            // if (useLighting)
-            //{
-            //    vec3 gradient = fetchGradientEstimate(cVolumesToRender.List[series],
-            //                                            cSeriesDesc.ComponentsPerSeries[series],
-            //                                            cTfs.List[series],
-            // texCoords,
-                //                                            rayStep * 8.0f);
-                //    float3 normal = normalize(-gradient);
-                //    float3 lightDir = normalize(cLightDesc.Pos - pos);
-                //    float lambert = max(0.0f, dot(normal, lightDir));
-                //    float3 lightColorContribution = cLightDesc.Color * cLightDesc.Intensity * lambert;
-                //    float3 surfaceColor = make_float3(mappedSample)
-                //    mappedSample += make_float4(surfaceColor * lightColorContribution, 0.0f);
-                //}
-
-                result += (1.0f - result.w) * vol_sample;
-
-            steps++;
-            t += rayStep;
-        }
-
-        // Blend with white background. (Helps to make the renderings look more consistent.)
-        // todo Is this correct? What if bg was transparent? The result would change with this formula.
-        // result = (result.w) * result + vec4(1.0f,0.0,0.0,0.0) * (1.0f - result.w);
-        // result.w = 1.0f;
-        imageStore(render_target_tx2D, pixel_coords, result);
-
-        // debug
-        // imageStore(render_target_tx2D,pixel_coords,vec4(1.0));
-    } else {
-        // Always write out to make sure that data from the previous frame is overwritten.
-        imageStore(render_target_tx2D, pixel_coords, vec4(0.0));
-    }
-}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/Shaders/raycast_volume/render_to_framebuffer_f.glsl b/plugins/mmstd_volume/Shaders/raycast_volume/render_to_framebuffer_f.glsl
deleted file mode 100644
index 65a761c90..000000000
--- a/plugins/mmstd_volume/Shaders/raycast_volume/render_to_framebuffer_f.glsl
+++ /dev/null
@@ -1,10 +0,0 @@
-uniform sampler2D src_tx2D;
-
-in vec2 uv_coord;
-
-out vec4 frag_out;
-
-void main()
-{
-    frag_out = texture(src_tx2D,uv_coord);
-}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/Shaders/raycast_volume/render_to_framebuffer_v.glsl b/plugins/mmstd_volume/Shaders/raycast_volume/render_to_framebuffer_v.glsl
deleted file mode 100644
index e036f7b3a..000000000
--- a/plugins/mmstd_volume/Shaders/raycast_volume/render_to_framebuffer_v.glsl
+++ /dev/null
@@ -1,16 +0,0 @@
-out vec2 uv_coord;
-
-void main()
-{
-	const vec4 vertices[6] = vec4[6]( vec4( -1.0,-1.0,0.0,0.0 ),
-									vec4( 1.0,1.0,1.0,1.0 ),
-									vec4( -1.0,1.0,0.0,1.0 ),
-									vec4( 1.0,1.0,1.0,1.0 ),
-									vec4( -1.0,-1.0,0.0,0.0 ),
-                                	vec4( 1.0,-1.0,1.0,0.0 ) );
-
-	vec4 vertex = vertices[gl_VertexID];
-	
-	uv_coord = vertex.zw;
-	gl_Position =  vec4(vertex.xy, -1.0, 1.0);
-}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/src/DifferenceVolume.cpp b/plugins/mmstd_volume/src/DifferenceVolume.cpp
new file mode 100644
index 000000000..8247d8a7f
--- /dev/null
+++ b/plugins/mmstd_volume/src/DifferenceVolume.cpp
@@ -0,0 +1,514 @@
+/*
+ * DifferenceVolume.cpp
+ *
+ * Copyright (C) 2019 by Visualisierungsinstitut der UniversitÃ¤t Stuttgart.
+ * Alle rechte vorbehalten.
+ */
+
+#include "stdafx.h"
+#include "DifferenceVolume.h"
+
+#include <limits>
+
+#include "mmcore/param/BoolParam.h"
+
+#include "vislib/sys/Log.h"
+
+
+/*
+ * megamol::stdplugin::volume::DifferenceVolume::DifferenceVolume
+ */
+megamol::stdplugin::volume::DifferenceVolume::DifferenceVolume(void)
+        : frameID((std::numeric_limits<unsigned int>::max)()),
+        frameIdx(0),
+        hashData((std::numeric_limits<std::size_t>::max)()),
+        hashState((std::numeric_limits<std::size_t>::max)()),
+        paramIgnoreInputHash("ignoreInputHash", "Instructs the module not to honour the input hash when checking for updates."),
+        slotIn("in", "The input slot providing the volume data."),
+        slotOut("out", "The output slot receiving the difference.") {
+    using core::misc::VolumetricDataCall;
+
+    this->slotIn.SetCompatibleCall<
+        core::factories::CallAutoDescription<VolumetricDataCall>>();
+    this->MakeSlotAvailable(&this->slotIn);
+
+    this->slotOut.SetCallback(VolumetricDataCall::ClassName(),
+        VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_DATA),
+        &DifferenceVolume::onGetData);
+    this->slotOut.SetCallback(VolumetricDataCall::ClassName(),
+        VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_EXTENTS),
+        &DifferenceVolume::onGetExtents);
+    this->slotOut.SetCallback(VolumetricDataCall::ClassName(),
+        VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_METADATA),
+        &DifferenceVolume::onGetMetadata);
+    this->slotOut.SetCallback(VolumetricDataCall::ClassName(),
+        VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_START_ASYNC),
+        &DifferenceVolume::onUnsupported);
+    this->slotOut.SetCallback(VolumetricDataCall::ClassName(),
+        VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_STOP_ASYNC),
+        &DifferenceVolume::onUnsupported);
+    this->slotOut.SetCallback(VolumetricDataCall::ClassName(),
+        VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_TRY_GET_DATA),
+        &DifferenceVolume::onUnsupported);
+    this->MakeSlotAvailable(&this->slotOut);
+
+    this->paramIgnoreInputHash << new core::param::BoolParam(false);
+    this->MakeSlotAvailable(&this->paramIgnoreInputHash);
+}
+
+
+/*
+ * megamol::stdplugin::volume::DifferenceVolume::~DifferenceVolume
+ */
+megamol::stdplugin::volume::DifferenceVolume::~DifferenceVolume(void) {
+    this->Release();
+}
+
+
+/*
+ * megamol::stdplugin::volume::DifferenceVolume::getFrameSize
+ */
+std::size_t megamol::stdplugin::volume::DifferenceVolume::getFrameSize(
+        const core::misc::VolumetricMetadata_t& md) {
+    auto retval = md.Resolution[0] * md.Resolution[1] * md.Resolution[2];
+    retval *= md.ScalarLength;
+    retval *= md.Components;
+    return retval;
+}
+
+
+/*
+ * megamol::stdplugin::volume::DifferenceVolume::getDifferenceType
+ */
+megamol::core::misc::ScalarType_t
+megamol::stdplugin::volume::DifferenceVolume::getDifferenceType(
+        const core::misc::VolumetricMetadata_t& md) {
+    switch (md.ScalarType) {
+        case core::misc::SIGNED_INTEGER:
+        case core::misc::FLOATING_POINT:
+            // Can be used as it is.
+            return md.ScalarType;
+
+        case core::misc::UNSIGNED_INTEGER:
+            // unsigned must become signed.
+            return core::misc::SIGNED_INTEGER;
+
+        default:
+            // Anything else is unsupported.
+            return core::misc::UNKNOWN;
+    }
+}
+
+
+/*
+ * megamol::stdplugin::volume::DifferenceVolume::checkCompatibility
+ */
+bool megamol::stdplugin::volume::DifferenceVolume::checkCompatibility(
+        const core::misc::VolumetricMetadata_t& md) const {
+    using vislib::sys::Log;
+    auto reqType = getDifferenceType(md);
+
+    if (getFrameSize(this->metadata) != getFrameSize(md)) {
+        Log::DefaultLog.WriteError(L"The volume resolution must not change "
+            "over time in order for %hs to work.",
+            DifferenceVolume::ClassName());
+        return false;
+    }
+
+    if ((this->metadata.ScalarLength != md.ScalarLength)
+            && (md.ScalarType == reqType)) {
+        Log::DefaultLog.WriteError(L"The scalar size must not change over time "
+            "in order for %hs to work.",
+            DifferenceVolume::ClassName());
+        return false;
+    }
+
+    if (this->metadata.ScalarType != reqType) {
+        Log::DefaultLog.WriteError(L"The scalar type must not change over time "
+            "in order for %hs to work.",
+            DifferenceVolume::ClassName());
+        return false;
+    }
+
+    return true;
+}
+
+
+/*
+ * megamol::stdplugin::volume::DifferenceVolume::create
+ */
+bool megamol::stdplugin::volume::DifferenceVolume::create(void) {
+    return true;
+}
+
+
+/*
+ * megamol::stdplugin::volume::DifferenceVolume::onGetData
+ */
+bool megamol::stdplugin::volume::DifferenceVolume::onGetData(core::Call& call) {
+    using core::misc::VolumetricDataCall;
+    using core::param::BoolParam;
+    using vislib::sys::Log;
+
+    auto dst = dynamic_cast<VolumetricDataCall *>(&call);
+    auto src = this->slotIn.CallAs<VolumetricDataCall>();
+    const auto localUpdate = this->paramIgnoreInputHash.IsDirty();
+    const auto ignoreHash = this->paramIgnoreInputHash.Param<BoolParam>()->Value();
+
+    /* Sanity checks. */
+    if (dst == nullptr) {
+        Log::DefaultLog.WriteError(L"Call %hs of %hs received a wrong request.",
+            VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_DATA),
+            DifferenceVolume::ClassName());
+        return false;
+    }
+
+    if (src == nullptr) {
+        Log::DefaultLog.WriteError(L"Call %hs of %hs has a wrong source.",
+            VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_DATA),
+            DifferenceVolume::ClassName());
+        return false;
+    }
+
+    /* Retrieve info about incoming data and pass it on to the caller. */
+    *src = *dst;
+    src->SetFrameID(dst->FrameID(), true);  // Use the force!
+    assert(src->IsFrameForced());
+    if (!VolumetricDataCall::GetMetadata(*src)) {
+        return false;
+    }
+    *dst = *src;
+
+    /* Establish what acceptable data are if the source changed. */
+    if (localUpdate || (!ignoreHash && (this->hashData != src->DataHash()))) {
+        Log::DefaultLog.WriteInfo(L"Volume data or local configuration have "
+            L"changed, resetting reference for difference computation.");
+
+        /* Check for compatibility of the incoming data. */
+        if (src->GetMetadata()->GridType != core::misc::CARTESIAN) {
+            Log::DefaultLog.WriteError(L"%hs is only supported for Cartesian "
+                L"grids.", DifferenceVolume::ClassName());
+            return false;
+        }
+
+        switch (src->GetMetadata()->ScalarType) {
+            case core::misc::SIGNED_INTEGER:
+            case core::misc::UNSIGNED_INTEGER:
+            case core::misc::FLOATING_POINT:
+                break;
+
+            default:
+                Log::DefaultLog.WriteError(L"%hs is not supported for scalar "
+                    "type %u.", DifferenceVolume::ClassName(),
+                    src->GetMetadata()->ScalarType);
+                return false;
+        }
+
+        /* Everything is OK at this point, save the reference data. */
+        this->metadata = *src->GetMetadata();
+
+        /* Reset the caching state. */
+        this->frameID = (std::numeric_limits<unsigned int>::max)();
+        this->frameIdx = 0;
+        this->hashData = src->DataHash();
+
+        /* Mark local state as unchanged. */
+        if (localUpdate) {
+            this->paramIgnoreInputHash.ResetDirty();
+        }
+    }
+
+    /* If the data we have need an update, compute it. */
+    if (this->frameID != src->FrameID()) {
+        Log::DefaultLog.WriteInfo(L"%hs is rebuilding the volume.",
+            DifferenceVolume::ClassName());
+
+        if (!VolumetricDataCall::GetMetadata(*src)) {
+            return false;
+        }
+
+        /* Check that the format is the same. */
+        if (!this->checkCompatibility(*src->GetMetadata())) {
+            return false;
+        }
+
+        if (!(*src)(VolumetricDataCall::IDX_GET_DATA)) {
+            Log::DefaultLog.WriteError(L"%hs failed to call %hs.",
+                DifferenceVolume::ClassName(),
+                VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_DATA));
+            return false;
+        }
+
+        /* Prepare a cache location for the current frame. */
+        auto& cur = this->cache[this->frameIdx];
+        cur.resize(src->GetFrameSize());
+        ::memcpy(cur.data(), src->GetData(), src->GetFrameSize());
+
+        /* Select the potential previous frame. */
+        auto& prev = this->cache[increment(this->frameIdx)];
+
+        /* Prepare the data storage. */
+        this->data.resize(cur.size());
+
+        if (src->FrameID() < 1) {
+            /* There is no predecessor, so the frame is the difference. */
+            Log::DefaultLog.WriteInfo(L"The data provided to %hs do not have a "
+                L"predecessor. The previous volume is considered to be zero.",
+                DifferenceVolume::ClassName());
+            auto& prev = this->cache[increment(this->frameIdx)];
+            prev.resize(cur.size());
+            ::memset(prev.data(), 0, prev.size());
+
+        } else if (src->FrameID() - 1 != this->frameID) {
+            /* We do not have the previous frame cached, so get it. */
+            Log::DefaultLog.WriteInfo(L"Load previous frame %u to compute the "
+                L"difference to the current one.", src->FrameID() - 1);
+            src->SetFrameID(src->FrameID() - 1, true);
+            if (!VolumetricDataCall::GetMetadata(*src)) {
+                return false;
+            }
+
+            /* Check that the format is the same. */
+            if (!this->checkCompatibility(*src->GetMetadata())) {
+                return false;
+            }
+
+            assert(src->IsFrameForced());
+            if (!(*src)(VolumetricDataCall::IDX_GET_DATA)) {
+                Log::DefaultLog.WriteError(L"%hs failed to call %hs.",
+                    DifferenceVolume::ClassName(),
+                    VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_DATA));
+                    return false;
+            }
+
+            prev.resize(src->GetFrameSize());
+            ::memcpy(cur.data(), src->GetData(), src->GetFrameSize());
+        }
+        /* At this point, 'prev' contains the previous frame. */
+        assert(cur.size() == this->data.size());
+        assert(prev.size() == this->data.size());
+
+        /* Do the conversion depending on the type of the data.*/
+        switch (this->metadata.ScalarType) {
+            case core::misc::SIGNED_INTEGER:
+                switch (this->metadata.ScalarLength) {
+                    case 1: {
+                        auto c = reinterpret_cast<std::int8_t *>(cur.data());
+                        auto p = reinterpret_cast<std::int8_t *>(prev.data());
+                        auto d = reinterpret_cast<std::int8_t *>(this->data.data());
+                        this->calcDifference(d, c, p, cur.size() / sizeof(*c));
+                        } break;
+
+                    case 2: {
+                        auto c = reinterpret_cast<std::int16_t *>(cur.data());
+                        auto p = reinterpret_cast<std::int16_t *>(prev.data());
+                        auto d = reinterpret_cast<std::int16_t *>(this->data.data());
+                        this->calcDifference(d, c, p, cur.size() / sizeof(*c));
+                        } break;
+
+                    case 4: {
+                        auto c = reinterpret_cast<std::int32_t *>(cur.data());
+                        auto p = reinterpret_cast<std::int32_t *>(prev.data());
+                        auto d = reinterpret_cast<std::int32_t *>(this->data.data());
+                        this->calcDifference(d, c, p, cur.size() / sizeof(*c));
+                        } break;
+
+                    case 8: {
+                        auto c = reinterpret_cast<std::int64_t *>(cur.data());
+                        auto p = reinterpret_cast<std::int64_t *>(prev.data());
+                        auto d = reinterpret_cast<std::int64_t *>(this->data.data());
+                        this->calcDifference(d, c, p, cur.size() / sizeof(*c));
+                        } break;
+
+                    default:
+                        Log::DefaultLog.WriteError(L"%hs cannot process "
+                            L"%u-byte SIGNED_INTEGER data.",
+                            DifferenceVolume::ClassName(),
+                            this->metadata.ScalarLength);
+                        return false;
+                }
+                break;
+
+            case core::misc::UNSIGNED_INTEGER:
+                // HAZARD: unsigned-to-signed conversion is untested!
+                switch (this->metadata.ScalarLength) {
+                    case 1: {
+                        auto c = (cur.data());
+                        auto p = (prev.data());
+                        this->data.resize(2 * this->data.size());
+                        this->metadata.ScalarLength = 2 * src->GetMetadata()->ScalarLength;
+                        auto d = reinterpret_cast<std::int16_t *>(this->data.data());
+                        this->calcDifference(d, c, p, cur.size() / sizeof(*c));
+                        } break;
+
+                    case 2: {
+                        auto c = reinterpret_cast<std::uint16_t *>(cur.data());
+                        auto p = reinterpret_cast<std::uint16_t *>(prev.data());
+                        this->data.resize(2 * this->data.size());
+                        this->metadata.ScalarLength = 2 * src->GetMetadata()->ScalarLength;
+                        auto d = reinterpret_cast<std::int32_t *>(this->data.data());
+                        this->calcDifference(d, c, p, cur.size() / sizeof(*c));
+                        } break;
+
+                    case 4: {
+                        auto c = reinterpret_cast<std::uint32_t *>(cur.data());
+                        auto p = reinterpret_cast<std::uint32_t *>(prev.data());
+                        this->data.resize(2 * this->data.size());
+                        this->metadata.ScalarLength = 2 * src->GetMetadata()->ScalarLength;
+                        auto d = reinterpret_cast<std::int64_t *>(this->data.data());
+                        this->calcDifference(d, c, p, cur.size() / sizeof(*c));
+                        } break;
+
+                    case 8: {
+                        Log::DefaultLog.WriteWarn(L"Conversion from UINT64 "
+                            L"to INT64 in %hs might cause data truncation.",
+                            DifferenceVolume::ClassName());
+                        auto c = reinterpret_cast<std::uint64_t *>(cur.data());
+                        auto p = reinterpret_cast<std::uint64_t *>(prev.data());
+                        auto d = reinterpret_cast<std::int64_t *>(this->data.data());
+                        this->calcDifference(d, c, p, cur.size() / sizeof(*c));
+                        } break;
+
+                    default:
+                        Log::DefaultLog.WriteError(L"%hs cannot process "
+                            L"%u-byte UNSIGNED_INTEGER data.",
+                            DifferenceVolume::ClassName(),
+                            this->metadata.ScalarLength);
+                        return false;
+                }
+                break;
+
+            case core::misc::FLOATING_POINT:
+                switch (this->metadata.ScalarLength) {
+                    case 4: {
+                        auto c = reinterpret_cast<float *>(cur.data());
+                        auto p = reinterpret_cast<float *>(prev.data());
+                        auto d = reinterpret_cast<float *>(this->data.data());
+                        this->calcDifference(d, c, p, cur.size() / sizeof(*c));
+                        } break;
+
+                    case 8: {
+                        auto c = reinterpret_cast<double *>(cur.data());
+                        auto p = reinterpret_cast<double *>(prev.data());
+                        auto d = reinterpret_cast<double *>(this->data.data());
+                        this->calcDifference(d, c, p, cur.size() / sizeof(*c));
+                        } break;
+
+                    default:
+                        Log::DefaultLog.WriteError(L"%hs cannot process "
+                            L"%u-byte FLOATING_POINT data.",
+                            DifferenceVolume::ClassName(),
+                            this->metadata.ScalarLength);
+                        return false;
+                }
+                break;
+
+            default:
+                assert(false);  // This should not be reachable.
+                return false;
+        }
+
+        this->frameID = src->FrameID();
+        this->frameIdx = increment(this->frameIdx);
+    } /* end if (this->frameID != src->FrameID()) */
+
+    dst->SetData(this->data.data());
+    dst->SetMetadata(&this->metadata);
+
+    dst->SetDataHash(this->getHash());
+    return true;
+}
+
+
+/*
+ * megamol::stdplugin::volume::DifferenceVolume::onGetExtents
+ */
+bool megamol::stdplugin::volume::DifferenceVolume::onGetExtents(core::Call& call) {
+    using core::misc::VolumetricDataCall;
+    using vislib::sys::Log;
+
+    auto dst = dynamic_cast<VolumetricDataCall *>(&call);
+    auto src = this->slotIn.CallAs<VolumetricDataCall>();
+
+    if (dst == nullptr) {
+        Log::DefaultLog.WriteError(L"Call %hs of %hs received a wrong request.",
+            VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_EXTENTS),
+            DifferenceVolume::ClassName());
+        return false;
+    }
+
+    if (src == nullptr) {
+        Log::DefaultLog.WriteError(L"Call %hs of %hs has a wrong source.",
+            VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_EXTENTS),
+            DifferenceVolume::ClassName());
+        return false;
+    }
+
+    *src = *dst;
+    if (!(*src)(VolumetricDataCall::IDX_GET_EXTENTS)) {
+        Log::DefaultLog.WriteError(L"%hs failed to call %hs.",
+            DifferenceVolume::ClassName(),
+            VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_EXTENTS));
+        return false;
+    }
+    *dst = *src;
+
+    dst->SetDataHash(this->getHash());
+    return true;
+}
+
+
+/*
+ * megamol::stdplugin::volume::DifferenceVolume::onGetMetadata
+ */
+bool megamol::stdplugin::volume::DifferenceVolume::onGetMetadata(
+        core::Call& call) {
+    using core::misc::VolumetricDataCall;
+    using vislib::sys::Log;
+
+    auto dst = dynamic_cast<VolumetricDataCall *>(&call);
+    auto src = this->slotIn.CallAs<VolumetricDataCall>();
+
+    if (dst == nullptr) {
+        Log::DefaultLog.WriteError(L"Call %hs of %hs received a wrong request.",
+            VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_METADATA),
+            DifferenceVolume::ClassName());
+        return false;
+    }
+
+    if (src == nullptr) {
+        Log::DefaultLog.WriteError(L"Call %hs of %hs has a wrong source.",
+            VolumetricDataCall::FunctionName(VolumetricDataCall::IDX_GET_METADATA),
+            DifferenceVolume::ClassName());
+        return false;
+    }
+
+    *src = *dst;
+    if (!VolumetricDataCall::GetMetadata(*src)) {
+        return false;
+    }
+    *dst = *src;
+
+    dst->SetDataHash(this->getHash());
+    return true;
+}
+
+
+/*
+ * megamol::stdplugin::volume::DifferenceVolume::onUnsupported
+ */
+bool megamol::stdplugin::volume::DifferenceVolume::onUnsupported(
+        core::Call& call) {
+    return false;
+}
+
+
+/*
+ * megamol::stdplugin::volume::DifferenceVolume::release
+ */
+void megamol::stdplugin::volume::DifferenceVolume::release(void) {
+    for (auto& c : this->cache) {
+        c.clear();
+    }
+    this->data.clear();
+}
diff --git a/plugins/mmstd_volume/src/DifferenceVolume.h b/plugins/mmstd_volume/src/DifferenceVolume.h
new file mode 100644
index 000000000..97b350cb7
--- /dev/null
+++ b/plugins/mmstd_volume/src/DifferenceVolume.h
@@ -0,0 +1,182 @@
+/*
+ * DifferenceVolume.h
+ *
+ * Copyright (C) 2019 by Visualisierungsinstitut der Universität Stuttgart.
+ * Alle Rechte vorbehalten.
+ */
+
+#pragma once
+
+#include <array>
+#include <vector>
+
+#include "mmcore/misc/VolumetricDataCall.h"
+#include "mmcore/misc/VolumetricMetadataStore.h"
+
+#include "mmcore/param/ParamSlot.h"
+
+#include "mmcore/Call.h"
+#include "mmcore/CalleeSlot.h"
+#include "mmcore/CallerSlot.h"
+#include "mmcore/Module.h"
+
+
+namespace megamol {
+namespace stdplugin {
+namespace volume {
+
+    /**
+     * Computes the difference between two time steps of a volumetric data
+     * source.
+     */
+    class DifferenceVolume : public core::Module {
+
+    public:
+
+        /**
+         * Answer the name of this module.
+         *
+         * @return The name of this module.
+         */
+        static inline constexpr const char* ClassName(void) {
+            return "DifferenceVolume";
+        }
+
+        /**
+         * Answer a human readable description of this module.
+         *
+         * @return A human readable description of this module.
+         */
+        static inline constexpr const char* Description(void) {
+            return "Computes the difference between volumes.";
+        }
+
+        /**
+         * Answers whether this module is available on the current system.
+         *
+         * @return 'true' if the module is available, 'false' otherwise.
+         */
+        static inline constexpr bool IsAvailable(void) {
+            return true;
+        }
+
+        /**
+         * Initialises a new instance.
+         */
+        DifferenceVolume(void);
+
+        /**
+         * Finalises an instance.
+         */
+        virtual ~DifferenceVolume(void);
+
+    protected:
+
+        /**
+         * Compute the size of a single frame in bytes.
+         */
+        static std::size_t getFrameSize(
+            const core::misc::VolumetricMetadata_t& md);
+
+        /**
+         * Gets the scalar type to be used for the difference volume.
+         */
+        static core::misc::ScalarType_t getDifferenceType(
+            const core::misc::VolumetricMetadata_t& md);
+
+        /**
+         * Increment the cache ring index.
+         */
+        static inline std::size_t increment(std::size_t frameIdx) {
+            return (++frameIdx % 2);
+        }
+
+        /**
+         * Compute the difference from 'prev' to 'cur' into 'dst'.
+         */
+        template<class D, class S>
+        void calcDifference(D *dst, const S *cur, const S *prev,
+            const std::size_t cnt);
+
+        /**
+         * Check whether the given metadata are compatible with the cache state
+         * of the module.
+         */
+        bool checkCompatibility(const core::misc::VolumetricMetadata_t& md) const;
+
+        /**
+         * Implementation of 'Create'.
+         *
+         * @return 'true' on success, 'false' otherwise.
+         */
+        virtual bool create(void);
+
+        /**
+         * Computes the hash of 'data'.
+         *
+         * @return The hash of the currently available data.
+         */
+        inline std::size_t getHash(void) {
+            auto retval = this->hashData;
+            retval ^= this->hashState + 0x9e3779b9 + (retval << 6)
+                + (retval >> 2);
+            return retval;
+        }
+
+        /**
+         * Gets the data from the source.
+         *
+         * @param caller The calling call.
+         *
+         * @return 'true' on success, 'false' on failure.
+         */
+        bool onGetData(core::Call& call);
+
+        /**
+         * Gets the data extents.
+         *
+         * @param caller The calling call.
+         *
+         * @return 'true' on success, 'false' on failure.
+         */
+        bool onGetExtents(core::Call& call);
+
+        /**
+         * Gets the meta data.
+         *
+         * @param caller The calling call.
+         *
+         * @return 'true' on success, 'false' on failure.
+         */
+        bool onGetMetadata(core::Call& call);
+
+        /**
+         * Callback for all unsupported operations.
+         */
+        bool onUnsupported(core::Call& call);
+
+        /**
+         * Clean up module.
+         */
+        virtual void release(void) override;
+
+    private:
+
+        std::array<std::vector<std::uint8_t>, 2> cache;
+        std::vector<std::uint8_t> data;
+        unsigned int frameID;
+        std::size_t frameIdx;
+        std::size_t hashData;
+        std::size_t hashState;
+        core::misc::VolumetricMetadataStore metadata;
+        core::param::ParamSlot paramIgnoreInputHash;
+        core::CallerSlot slotIn;
+        core::CalleeSlot slotOut;
+
+    };
+
+} /* end namespace volume */
+} /* namespace stdplugin */
+} /* namespace megamol */
+
+#include "DifferenceVolume.inl"
diff --git a/plugins/mmstd_volume/src/DifferenceVolume.inl b/plugins/mmstd_volume/src/DifferenceVolume.inl
new file mode 100644
index 000000000..4a06a0d54
--- /dev/null
+++ b/plugins/mmstd_volume/src/DifferenceVolume.inl
@@ -0,0 +1,36 @@
+/*
+ * DifferenceVolume.inl
+ *
+ * Copyright (C) 2019 by Visualisierungsinstitut der Universität Stuttgart.
+ * Alle Rechte vorbehalten.
+ */
+
+
+/*
+ * megamol::stdplugin::volume::DifferenceVolume::calcDifference
+ */
+template<class D, class S>
+void megamol::stdplugin::volume::DifferenceVolume::calcDifference(D *dst,
+        const S *cur, const S *prev, const std::size_t cnt) {
+//#pragma omp parallel for
+//    for (std::size_t i = 0; i < cnt; ++i) {
+//        dst[i] = static_cast<D>(cur[i]) - static_cast<D>(prev[i]);
+//    }
+
+    const auto components = this->metadata.Components;
+
+    for (std::size_t i = 0; i < components; ++i) {
+        this->metadata.MinValues[i] = (std::numeric_limits<double>::max)();
+        this->metadata.MaxValues[i] = std::numeric_limits<double>::lowest();
+    }
+
+    for (std::size_t i = 0; i < cnt; ++i) {
+        dst[i] = static_cast<D>(cur[i]) - static_cast<D>(prev[i]);
+        if (dst[i] < this->metadata.MinValues[i % components]) {
+            this->metadata.MinValues[i % components] = dst[i];
+        }
+        if (dst[i] > this->metadata.MaxValues[i % components]) {
+            this->metadata.MaxValues[i % components] = dst[i];
+        }
+    }
+}
diff --git a/plugins/mmstd_volume/src/RaycastVolumeRenderer.cpp b/plugins/mmstd_volume/src/RaycastVolumeRenderer.cpp
index 4386318fe..c3381bfe9 100644
--- a/plugins/mmstd_volume/src/RaycastVolumeRenderer.cpp
+++ b/plugins/mmstd_volume/src/RaycastVolumeRenderer.cpp
@@ -7,33 +7,120 @@
 
 #include "RaycastVolumeRenderer.h"
 
-#include <array>
-
-#include "vislib/graphics/gl/ShaderSource.h"
+#include "linmath.h"
 
 #include "mmcore/CoreInstance.h"
 #include "mmcore/misc/VolumetricDataCall.h"
+#include "mmcore/param/BoolParam.h"
+#include "mmcore/param/ColorParam.h"
+#include "mmcore/param/EnumParam.h"
 #include "mmcore/param/FloatParam.h"
+#include "mmcore/utility/ScaledBoundingBoxes.h"
+#include "mmcore/view/AbstractRenderingView.h"
 #include "mmcore/view/CallGetTransferFunction.h"
+#include "mmcore/view/CallRender3D.h"
 
-#include "linmath.h"
+#include "vislib/graphics/gl/ShaderSource.h"
+
+#include "glowl/Texture.hpp"
+#include "glowl/Texture2D.hpp"
+#include "glowl/Texture3D.hpp"
+
+#include <algorithm>
+#include <array>
+#include <cmath>
+#include <limits>
+#include <memory>
+#include <vector>
+#include <iostream>
 
 using namespace megamol::stdplugin::volume;
 
 RaycastVolumeRenderer::RaycastVolumeRenderer()
     : Renderer3DModule()
+    , m_mode("mode", "Mode changing the behavior for the raycaster")
+    , m_ray_step_ratio_param("ray step ratio", "Adjust sampling rate")
+    , m_use_lighting_slot("lighting::use lighting", "Enable simple volumetric illumination")
+    , m_ka_slot("lighting::ka", "Ambient part for Phong lighting")
+    , m_kd_slot("lighting::kd", "Diffuse part for Phong lighting")
+    , m_ks_slot("lighting::ks", "Specular part for Phong lighting")
+    , m_shininess_slot("lighting::shininess", "Shininess for Phong lighting")
+    , m_ambient_color("lighting::ambient color", "Ambient color")
+    , m_specular_color("lighting::specular color", "Specular color")
+    , m_light_color("lighting::light color", "Light color")
+    , m_material_color("lighting::material color", "Material color")
+    , m_opacity_threshold("opacity threshold", "Opacity threshold for integrative rendering")
+    , m_iso_value("isovalue", "Isovalue for isosurface rendering")
+    , m_opacity("opacity", "Surface opacity for blending")
+    , paramOverride("override::enable", "Enable override of range")
+    , paramMinOverride("override::min", "Override the minimum value provided by the data set")
+    , paramMaxOverride("override::max", "Override the maximum value provided by the data set")
+    , m_renderer_callerSlot("Renderer", "Renderer for chaining")
     , m_volumetricData_callerSlot("getData", "Connects the volume renderer with a voluemtric data source")
-    , m_transferFunction_callerSlot("getTranfserFunction", "Connects the volume renderer with a transfer function")
-    , m_ray_step_ratio_param("ray step ratio", "") {
+    , m_transferFunction_callerSlot("getTranfserFunction", "Connects the volume renderer with a transfer function") {
+
+    this->m_renderer_callerSlot.SetCompatibleCall<megamol::core::view::CallRender3DDescription>();
+    this->MakeSlotAvailable(&this->m_renderer_callerSlot);
+
     this->m_volumetricData_callerSlot.SetCompatibleCall<megamol::core::misc::VolumetricDataCallDescription>();
     this->MakeSlotAvailable(&this->m_volumetricData_callerSlot);
 
     this->m_transferFunction_callerSlot.SetCompatibleCall<megamol::core::view::CallGetTransferFunctionDescription>();
     this->MakeSlotAvailable(&this->m_transferFunction_callerSlot);
 
-    auto* ep = new megamol::core::param::FloatParam(1.0);
-    this->m_ray_step_ratio_param << ep;
+    this->m_mode << new megamol::core::param::EnumParam(0);
+    this->m_mode.Param<megamol::core::param::EnumParam>()->SetTypePair(0, "Integration");
+    this->m_mode.Param<megamol::core::param::EnumParam>()->SetTypePair(1, "Isosurface");
+    this->m_mode.Param<core::param::EnumParam>()->SetTypePair(2, "Aggregate");
+    this->MakeSlotAvailable(&this->m_mode);
+
+    this->m_ray_step_ratio_param << new megamol::core::param::FloatParam(1.0f);
     this->MakeSlotAvailable(&this->m_ray_step_ratio_param);
+
+    this->m_opacity_threshold << new megamol::core::param::FloatParam(1.0f);
+    this->MakeSlotAvailable(&this->m_opacity_threshold);
+
+    this->m_iso_value << new megamol::core::param::FloatParam(0.5f);
+    this->MakeSlotAvailable(&this->m_iso_value);
+
+    this->m_opacity << new megamol::core::param::FloatParam(1.0f);
+    this->MakeSlotAvailable(&this->m_opacity);
+
+    this->m_use_lighting_slot << new core::param::BoolParam(false);
+    this->MakeSlotAvailable(&this->m_use_lighting_slot);
+
+    this->m_ka_slot << new core::param::FloatParam(0.1f, 0.0f);
+    this->MakeSlotAvailable(&this->m_ka_slot);
+
+    this->m_kd_slot << new core::param::FloatParam(0.5f, 0.0f);
+    this->MakeSlotAvailable(&this->m_kd_slot);
+
+    this->m_ks_slot << new core::param::FloatParam(0.4f, 0.0f);
+    this->MakeSlotAvailable(&this->m_ks_slot);
+
+    this->m_shininess_slot << new core::param::FloatParam(10.0f, 0.0f);
+    this->MakeSlotAvailable(&this->m_shininess_slot);
+
+    this->m_ambient_color << new core::param::ColorParam(1.0f, 1.0f, 1.0f, 1.0f);
+    this->MakeSlotAvailable(&this->m_ambient_color);
+
+    this->m_specular_color << new core::param::ColorParam(1.0f, 1.0f, 1.0f, 1.0f);
+    this->MakeSlotAvailable(&this->m_specular_color);
+
+    this->m_light_color << new core::param::ColorParam(1.0f, 1.0f, 1.0f, 1.0f);
+    this->MakeSlotAvailable(&this->m_light_color);
+
+    this->m_material_color << new core::param::ColorParam(0.95f, 0.67f, 0.47f, 1.0f);
+    this->MakeSlotAvailable(&this->m_material_color);
+
+    this->paramOverride << new megamol::core::param::BoolParam(false);
+    this->MakeSlotAvailable(&this->paramOverride);
+
+    this->paramMinOverride << new megamol::core::param::FloatParam(0.0f);
+    this->MakeSlotAvailable(&this->paramMinOverride);
+
+    this->paramMaxOverride << new megamol::core::param::FloatParam(1.0f);
+    this->MakeSlotAvailable(&this->paramMaxOverride);
 }
 
 RaycastVolumeRenderer::~RaycastVolumeRenderer() { this->Release(); }
@@ -41,27 +128,48 @@ RaycastVolumeRenderer::~RaycastVolumeRenderer() { this->Release(); }
 bool RaycastVolumeRenderer::create() {
     try {
         // create shader program
-        m_raycast_volume_compute_shdr = std::make_unique<vislib::graphics::gl::GLSLComputeShader>();
-        m_render_to_framebuffer_shdr = std::make_unique<vislib::graphics::gl::GLSLShader>();
-
         vislib::graphics::gl::ShaderSource compute_shader_src;
+        vislib::graphics::gl::ShaderSource compute_iso_shader_src;
+        vislib::graphics::gl::ShaderSource compute_aggr_shader_src;
         vislib::graphics::gl::ShaderSource vertex_shader_src;
         vislib::graphics::gl::ShaderSource fragment_shader_src;
+        vislib::graphics::gl::ShaderSource fragment_shader_aggr_src;
 
         if (!instance()->ShaderSourceFactory().MakeShaderSource("RaycastVolumeRenderer::compute", compute_shader_src))
             return false;
-        if (!m_raycast_volume_compute_shdr->Compile(compute_shader_src.Code(), compute_shader_src.Count()))
+        if (!m_raycast_volume_compute_shdr.Compile(compute_shader_src.Code(), compute_shader_src.Count()))
             return false;
-        if (!m_raycast_volume_compute_shdr->Link()) return false;
+        if (!m_raycast_volume_compute_shdr.Link()) return false;
+
+        if (!instance()->ShaderSourceFactory().MakeShaderSource(
+                "RaycastVolumeRenderer::compute_iso", compute_iso_shader_src))
+            return false;
+        if (!m_raycast_volume_compute_iso_shdr.Compile(compute_iso_shader_src.Code(), compute_iso_shader_src.Count()))
+            return false;
+        if (!m_raycast_volume_compute_iso_shdr.Link()) return false;
+
+        if (!instance()->ShaderSourceFactory().MakeShaderSource(
+                "RaycastVolumeRenderer::compute_aggr", compute_aggr_shader_src))
+            return false;
+        if (!m_raycast_volume_compute_aggr_shdr.Compile(compute_aggr_shader_src.Code(), compute_aggr_shader_src.Count()))
+            return false;
+        if (!m_raycast_volume_compute_aggr_shdr.Link()) return false;
 
         if (!instance()->ShaderSourceFactory().MakeShaderSource("RaycastVolumeRenderer::vert", vertex_shader_src))
             return false;
         if (!instance()->ShaderSourceFactory().MakeShaderSource("RaycastVolumeRenderer::frag", fragment_shader_src))
             return false;
-        if (!m_render_to_framebuffer_shdr->Compile(vertex_shader_src.Code(), vertex_shader_src.Count(),
+        if (!instance()->ShaderSourceFactory().MakeShaderSource("RaycastVolumeRenderer::frag_aggr", fragment_shader_aggr_src))
+            return false;
+        if (!m_render_to_framebuffer_shdr.Compile(vertex_shader_src.Code(), vertex_shader_src.Count(),
                 fragment_shader_src.Code(), fragment_shader_src.Count()))
             return false;
-        if (!m_render_to_framebuffer_shdr->Link()) return false;
+        if (!m_render_to_framebuffer_shdr.Link()) return false;
+
+        if (!m_render_to_framebuffer_aggr_shdr.Compile(vertex_shader_src.Code(), vertex_shader_src.Count(),
+                fragment_shader_aggr_src.Code(), fragment_shader_aggr_src.Count()))
+            return false;
+        if (!m_render_to_framebuffer_aggr_shdr.Link()) return false;
     } catch (vislib::graphics::gl::AbstractOpenGLShader::CompileException ce) {
         vislib::sys::Log::DefaultLog.WriteMsg(vislib::sys::Log::LEVEL_ERROR, "Unable to compile shader (@%s): %s\n",
             vislib::graphics::gl::AbstractOpenGLShader::CompileException::CompileActionName(ce.FailedAction()),
@@ -77,41 +185,16 @@ bool RaycastVolumeRenderer::create() {
         return false;
     }
 
-
-    // create render target texture
-    TextureLayout render_tgt_layout(GL_RGBA8, 1920, 1080, 1, GL_RGBA, GL_UNSIGNED_BYTE, 1,
-        {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
-            {GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_MIN_FILTER, GL_LINEAR},
-            {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
-        {});
-    m_render_target = std::make_unique<Texture2D>("raycast_volume_render_target", render_tgt_layout, nullptr);
-
-
-    // create empty volume texture
-    TextureLayout volume_layout(GL_R32F, 1, 1, 1, GL_RED, GL_FLOAT, 1,
-        {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
-            {GL_TEXTURE_MIN_FILTER, GL_LINEAR}, {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
-        {});
-    m_volume_texture = std::make_unique<Texture3D>("raycast_volume_texture", volume_layout, nullptr);
-
-    // create empty transfer function texture
-    TextureLayout tf(GL_RGBA8, 1, 1, 1, GL_RGBA, GL_UNSIGNED_BYTE, 1,
-        {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
-            {GL_TEXTURE_MIN_FILTER, GL_LINEAR}, {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
-        {});
-    m_transfer_function = std::make_unique<Texture2D>("raycast_volume_texture", tf, nullptr);
-
     return true;
 }
 
 void RaycastVolumeRenderer::release() {
-    m_raycast_volume_compute_shdr.reset(nullptr);
-    m_render_target.reset(nullptr);
 }
 
 bool RaycastVolumeRenderer::GetExtents(megamol::core::Call& call) {
     auto cr = dynamic_cast<core::view::CallRender3D*>(&call);
     auto cd = m_volumetricData_callerSlot.CallAs<megamol::core::misc::VolumetricDataCall>();
+    auto ci = m_renderer_callerSlot.CallAs<megamol::core::view::CallRender3D>();
 
     if (cr == nullptr) return false;
     if (cd == nullptr) return false;
@@ -126,8 +209,18 @@ bool RaycastVolumeRenderer::GetExtents(megamol::core::Call& call) {
     if (!(*cd)(core::misc::VolumetricDataCall::IDX_GET_METADATA)) return false;
 
     cr->SetTimeFramesCount(cd->FrameCount());
-    cr->AccessBoundingBoxes() = cd->GetBoundingBoxes();
-    cr->AccessBoundingBoxes().MakeScaledWorld(1.0f);
+
+    std::vector<core::BoundingBoxes> bbs{cd->GetBoundingBoxes()};
+
+    if (ci != nullptr) {
+        *ci = *cr;
+
+        if (!(*ci)(core::view::CallRender3D::FnGetExtents)) return false;
+
+        bbs.push_back(ci->GetBoundingBoxes());
+    }
+
+    cr->AccessBoundingBoxes() = core::utility::combineAndMagicScaleBoundingBoxes(bbs);
 
     return true;
 }
@@ -136,30 +229,108 @@ bool RaycastVolumeRenderer::Render(megamol::core::Call& call) {
     megamol::core::view::CallRender3D* cr = dynamic_cast<core::view::CallRender3D*>(&call);
     if (cr == NULL) return false;
 
+    // Chain renderer
+    auto ci = m_renderer_callerSlot.CallAs<megamol::core::view::CallRender3D>();
+
+    if (ci != nullptr) {
+        ci->SetCameraParameters(cr->GetCameraParameters());
+
+        if (this->m_mode.Param<core::param::EnumParam>()->Value() == 0 ||
+            this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+            if (this->fbo.IsValid()) this->fbo.Release();
+            this->fbo.Create(ci->GetViewport().Width(), ci->GetViewport().Height(), GL_RGBA8, GL_RGBA, GL_UNSIGNED_BYTE,
+                vislib::graphics::gl::FramebufferObject::ATTACHMENT_TEXTURE);
+            this->fbo.Enable();
+        }
+
+        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+        ci->SetTime(cr->Time());
+        if (!(*ci)(core::view::CallRender3D::FnRender)) return false;
+
+        if (this->m_mode.Param<core::param::EnumParam>()->Value() == 0 ||
+            this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+            this->fbo.Disable();
+        }
+    }
+
+    // create render target texture
+    if (this->m_render_target == nullptr || this->m_render_target->getWidth() != cr->GetViewport().Width() ||
+        this->m_render_target->getHeight() != cr->GetViewport().Height()) {
+
+        glowl::TextureLayout render_tgt_layout(GL_RGBA8, cr->GetViewport().Width(), cr->GetViewport().Height(), 1,
+            GL_RGBA, GL_UNSIGNED_BYTE, 1,
+            {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
+                {GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_MIN_FILTER, GL_LINEAR},
+                {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
+            {});
+        m_render_target =
+            std::make_unique<glowl::Texture2D>("raycast_volume_render_target", render_tgt_layout, nullptr);
+
+        // create normal target texture
+        glowl::TextureLayout normal_tgt_layout(GL_RGBA32F, cr->GetViewport().Width(), cr->GetViewport().Height(), 1,
+            GL_RGBA, GL_FLOAT, 1,
+            {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
+                {GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_MIN_FILTER, GL_LINEAR},
+                {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
+            {});
+        m_normal_target =
+            std::make_unique<glowl::Texture2D>("raycast_volume_normal_target", normal_tgt_layout, nullptr);
+
+        // create depth target texture
+        glowl::TextureLayout depth_tgt_layout(GL_R32F, cr->GetViewport().Width(), cr->GetViewport().Height(), 1, GL_R,
+            GL_FLOAT, 1,
+            {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
+                {GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_MIN_FILTER, GL_LINEAR},
+                {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
+            {});
+        m_depth_target = std::make_unique<glowl::Texture2D>("raycast_volume_depth_target", depth_tgt_layout, nullptr);
+    }
 
     // this is the apex of suck and must die
+    core::utility::glMagicScale scaling;
+    scaling.apply(cr->GetBoundingBoxes());
+
     GLfloat modelViewMatrix_column[16];
     glGetFloatv(GL_MODELVIEW_MATRIX, modelViewMatrix_column);
     GLfloat projMatrix_column[16];
     glGetFloatv(GL_PROJECTION_MATRIX, projMatrix_column);
+
+    std::array<float, 4> light = {0.0f, 0.0f, 1.0f, 1.0f};
+    glGetLightfv(GL_LIGHT0, GL_POSITION, light.data());
     // end suck
 
-    if (!updateVolumeData()) return false;
-    if (!updateTransferFunction()) return false;
+    if (!updateVolumeData(cr->Time())) return false;
 
     // enable raycast volume rendering program
-    m_raycast_volume_compute_shdr->Enable();
+    vislib::graphics::gl::GLSLComputeShader* compute_shdr;
+
+    // pick shader based on selected mode
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 0) {
+        if (!updateTransferFunction()) return false;
+
+        compute_shdr = &this->m_raycast_volume_compute_shdr;
+    } else if (this->m_mode.Param<core::param::EnumParam>()->Value() == 1) {
+        compute_shdr = &this->m_raycast_volume_compute_iso_shdr;
+    } else if (this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+        if (!updateTransferFunction()) return false;
+        compute_shdr = &this->m_raycast_volume_compute_aggr_shdr;
+    } else {
+        vislib::sys::Log::DefaultLog.WriteError("Unknown raycast mode.");
+        return false;
+    }
+
+    // setup
+    compute_shdr->Enable();
 
-    glUniformMatrix4fv(
-        m_raycast_volume_compute_shdr->ParameterLocation("view_mx"), 1, GL_FALSE, modelViewMatrix_column);
-    glUniformMatrix4fv(m_raycast_volume_compute_shdr->ParameterLocation("proj_mx"), 1, GL_FALSE, projMatrix_column);
+    glUniformMatrix4fv(compute_shdr->ParameterLocation("view_mx"), 1, GL_FALSE, modelViewMatrix_column);
+    glUniformMatrix4fv(compute_shdr->ParameterLocation("proj_mx"), 1, GL_FALSE, projMatrix_column);
 
     vec2 rt_resolution;
     rt_resolution[0] = static_cast<float>(m_render_target->getWidth());
     rt_resolution[1] = static_cast<float>(m_render_target->getHeight());
-    glUniform2fv(m_raycast_volume_compute_shdr->ParameterLocation("rt_resolution"), 1, rt_resolution);
+    glUniform2fv(compute_shdr->ParameterLocation("rt_resolution"), 1, rt_resolution);
 
-    // bbox sizes
     vec3 box_min;
     box_min[0] = m_volume_origin[0];
     box_min[1] = m_volume_origin[1];
@@ -168,88 +339,266 @@ bool RaycastVolumeRenderer::Render(megamol::core::Call& call) {
     box_max[0] = m_volume_origin[0] + m_volume_extents[0];
     box_max[1] = m_volume_origin[1] + m_volume_extents[1];
     box_max[2] = m_volume_origin[2] + m_volume_extents[2];
-    glUniform3fv(m_raycast_volume_compute_shdr->ParameterLocation("boxMin"), 1, box_min);
-    glUniform3fv(m_raycast_volume_compute_shdr->ParameterLocation("boxMax"), 1, box_max);
+    glUniform3fv(compute_shdr->ParameterLocation("boxMin"), 1, box_min);
+    glUniform3fv(compute_shdr->ParameterLocation("boxMax"), 1, box_max);
 
-    glUniform3f(m_raycast_volume_compute_shdr->ParameterLocation("halfVoxelSize"),
-        1.0f / (2.0f * (m_volume_resolution[0] - 1)), 1.0f / (2.0f * (m_volume_resolution[1] - 1)),
-        1.0f / (2.0f * (m_volume_resolution[2] - 1)));
+    glUniform3f(compute_shdr->ParameterLocation("halfVoxelSize"), 1.0f / (2.0f * (m_volume_resolution[0] - 1)),
+        1.0f / (2.0f * (m_volume_resolution[1] - 1)), 1.0f / (2.0f * (m_volume_resolution[2] - 1)));
     auto const maxResolution =
-        std::fmax(m_volume_resolution[0], std::fmax(m_volume_resolution[1], m_volume_resolution[2]));
-    auto const maxExtents = std::fmax(m_volume_extents[0], std::fmax(m_volume_extents[1], m_volume_extents[2]));
-    glUniform1f(m_raycast_volume_compute_shdr->ParameterLocation("voxelSize"), maxExtents / (maxResolution - 1.0f));
-    glUniform2fv(m_raycast_volume_compute_shdr->ParameterLocation("valRange"), 1, valRange.data());
-    glUniform1f(m_raycast_volume_compute_shdr->ParameterLocation("rayStepRatio"),
+        std::max(m_volume_resolution[0], std::max(m_volume_resolution[1], m_volume_resolution[2]));
+    auto const maxExtents = std::max(m_volume_extents[0], std::max(m_volume_extents[1], m_volume_extents[2]));
+    glUniform1f(compute_shdr->ParameterLocation("voxelSize"), maxExtents / (maxResolution - 1.0f));
+
+    // Force value range to user-defined range if requested.
+    if (this->paramOverride.Param<core::param::BoolParam>()->Value()) {
+        std::array<float, 2> overrideRange = {
+            this->paramMinOverride.Param<core::param::FloatParam>()->Value(),
+            this->paramMaxOverride.Param<core::param::FloatParam>()->Value()
+        };
+        glUniform2fv(compute_shdr->ParameterLocation("valRange"), 1, overrideRange.data());
+
+    } else {
+        glUniform2fv(compute_shdr->ParameterLocation("valRange"), 1, valRange.data());
+    }
+
+    glUniform1f(compute_shdr->ParameterLocation("rayStepRatio"),
         this->m_ray_step_ratio_param.Param<core::param::FloatParam>()->Value());
-    glUniform1f(m_raycast_volume_compute_shdr->ParameterLocation("opacityThreshold"), 1.0);
+
+    glUniform1i(compute_shdr->ParameterLocation("use_lighting"),
+        this->m_use_lighting_slot.Param<core::param::BoolParam>()->Value());
+    glUniform1f(compute_shdr->ParameterLocation("ka"),
+        this->m_ka_slot.Param<core::param::FloatParam>()->Value());
+    glUniform1f(compute_shdr->ParameterLocation("kd"),
+        this->m_kd_slot.Param<core::param::FloatParam>()->Value());
+    glUniform1f(compute_shdr->ParameterLocation("ks"),
+        this->m_ks_slot.Param<core::param::FloatParam>()->Value());
+    glUniform1f(compute_shdr->ParameterLocation("shininess"),
+        this->m_shininess_slot.Param<core::param::FloatParam>()->Value());
+    glUniform3fv(compute_shdr->ParameterLocation("light"), 1, light.data());
+    glUniform3fv(compute_shdr->ParameterLocation("ambient_col"), 1,
+        this->m_ambient_color.Param<core::param::ColorParam>()->Value().data());
+    glUniform3fv(compute_shdr->ParameterLocation("specular_col"), 1,
+        this->m_specular_color.Param<core::param::ColorParam>()->Value().data());
+    glUniform3fv(compute_shdr->ParameterLocation("light_col"), 1,
+        this->m_light_color.Param<core::param::ColorParam>()->Value().data());
+    glUniform3fv(compute_shdr->ParameterLocation("material_col"), 1,
+        this->m_material_color.Param<core::param::ColorParam>()->Value().data());
+
+    auto const arv = std::dynamic_pointer_cast<core::view::AbstractRenderingView const>(cr->PeekCallerSlot()->Parent());
+    std::array<float, 4> bkgndCol = {1.0f, 1.0f, 1.0f, 1.0f};
+    if (arv != nullptr) {
+        auto const ptr = arv->BkgndColour();
+        bkgndCol[0] = ptr[0];
+        bkgndCol[1] = ptr[1];
+        bkgndCol[2] = ptr[2];
+        bkgndCol[3] = 1.0f;
+    }
+    glUniform3fv(compute_shdr->ParameterLocation("background"), 1, bkgndCol.data());
+
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 0) {
+        glUniform1f(compute_shdr->ParameterLocation("opacityThreshold"),
+            this->m_opacity_threshold.Param<core::param::FloatParam>()->Value());
+    } else if (this->m_mode.Param<core::param::EnumParam>()->Value() == 1) {
+        glUniform1f(
+            compute_shdr->ParameterLocation("isoValue"), this->m_iso_value.Param<core::param::FloatParam>()->Value());
+
+        glUniform1f(
+            compute_shdr->ParameterLocation("opacity"), this->m_opacity.Param<core::param::FloatParam>()->Value());
+    }
+
+    this->m_opacity_threshold.Parameter()->SetGUIVisible(this->m_mode.Param<core::param::EnumParam>()->Value() == 0);
+    this->m_iso_value.Parameter()->SetGUIVisible(this->m_mode.Param<core::param::EnumParam>()->Value() == 1);
+    this->m_opacity.Parameter()->SetGUIVisible(this->m_mode.Param<core::param::EnumParam>()->Value() == 1);
 
     // bind volume texture
     glActiveTexture(GL_TEXTURE0);
     m_volume_texture->bindTexture();
-    glUniform1i(m_raycast_volume_compute_shdr->ParameterLocation("volume_tx3D"), 0);
+    glUniform1i(compute_shdr->ParameterLocation("volume_tx3D"), 0);
+
     // bind the transfer function
-    glActiveTexture(GL_TEXTURE1);
-    glBindTexture(GL_TEXTURE_1D, tf_texture);
-    glUniform1i(m_raycast_volume_compute_shdr->ParameterLocation("tf_tx1D"), 1);
-    /*m_transfer_function->bindTexture();
-    glUniform1i(m_raycast_volume_compute_shdr->ParameterLocation("transfer_function_tx2D"), 1);*/
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 0) {
+        glActiveTexture(GL_TEXTURE1);
+        glBindTexture(GL_TEXTURE_1D, tf_texture);
+        glUniform1i(compute_shdr->ParameterLocation("tf_tx1D"), 1);
+
+        if (ci != nullptr) {
+            glActiveTexture(GL_TEXTURE2);
+            this->fbo.BindColourTexture();
+            glUniform1i(compute_shdr->ParameterLocation("color_tx2D"), 2);
+
+            glActiveTexture(GL_TEXTURE3);
+            this->fbo.BindDepthTexture();
+            glUniform1i(compute_shdr->ParameterLocation("depth_tx2D"), 3);
+
+            glUniform1i(compute_shdr->ParameterLocation("use_depth_tx"), 1);
+        } else {
+            glUniform1i(compute_shdr->ParameterLocation("use_depth_tx"), 0);
+        }
+    }
+
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+        if (ci != nullptr) {
+            glActiveTexture(GL_TEXTURE2);
+            this->fbo.BindColourTexture();
+            glUniform1i(compute_shdr->ParameterLocation("color_tx2D"), 2);
+
+            glActiveTexture(GL_TEXTURE3);
+            this->fbo.BindDepthTexture();
+            glUniform1i(compute_shdr->ParameterLocation("depth_tx2D"), 3);
+
+            glUniform1i(compute_shdr->ParameterLocation("use_depth_tx"), 1);
+        } else {
+            glUniform1i(compute_shdr->ParameterLocation("use_depth_tx"), 0);
+        }
+    }
 
     // bind image texture
     m_render_target->bindImage(0, GL_WRITE_ONLY);
 
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 1) {
+        m_normal_target->bindImage(1, GL_WRITE_ONLY);
+        m_depth_target->bindImage(2, GL_WRITE_ONLY);
+    }
+
     // dispatch compute
-    m_raycast_volume_compute_shdr->Dispatch(
+    compute_shdr->Dispatch(
         static_cast<int>(std::ceil(rt_resolution[0] / 8.0f)), static_cast<int>(std::ceil(rt_resolution[1] / 8.0f)), 1);
 
-    m_raycast_volume_compute_shdr->Disable();
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 1) {
+        glBindImageTexture(2, 0, 0, GL_TRUE, 0, GL_WRITE_ONLY, GL_R8);
+        glBindImageTexture(1, 0, 0, GL_TRUE, 0, GL_WRITE_ONLY, GL_R8);
+    }
+
+    glBindImageTexture(0, 0, 0, GL_TRUE, 0, GL_WRITE_ONLY, GL_R8);
+
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 0 ||
+        this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+        glActiveTexture(GL_TEXTURE3);
+        glBindTexture(GL_TEXTURE_2D, 0);
+        glActiveTexture(GL_TEXTURE2);
+        glBindTexture(GL_TEXTURE_2D, 0);
+    }
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 0) {
+        glActiveTexture(GL_TEXTURE1);
+        glBindTexture(GL_TEXTURE_1D, 0);
+    }
+    glActiveTexture(GL_TEXTURE0);
+    glBindTexture(GL_TEXTURE_3D, 0);
+
+    compute_shdr->Disable();
 
     glMemoryBarrier(GL_TEXTURE_FETCH_BARRIER_BIT);
 
-    ////////
+    // read image back to determine min max
+    float rndr_min = std::numeric_limits<float>::max();
+    float rndr_max = std::numeric_limits<float>::lowest();
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+        glActiveTexture(GL_TEXTURE0);
+        m_render_target->bindTexture();
+        int width = 0;
+        int height = 0;
+        glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_WIDTH, &width);
+        glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_HEIGHT, &height);
+        std::vector<float> tmp_data(width*height*4);
+        glGetTexImage(GL_TEXTURE_2D, 0, GL_RGBA, GL_FLOAT, tmp_data.data());
+
+        for (size_t idx = 0; idx < tmp_data.size() / 4; ++idx) {
+            auto const val = tmp_data[idx * 4 + 3];
+            if (val < rndr_min) rndr_min = val;
+            if (val > rndr_max) rndr_max = val;
+        }
+
+        glBindTexture(GL_TEXTURE_2D, 0);
+    }
+
     // copy image to framebuffer
-    ///////
-    // TODO query gl state and reset to previous state?
-    glDisable(GL_DEPTH_TEST);
-    glEnable(GL_BLEND);
+    bool state_depth_test = glIsEnabled(GL_DEPTH_TEST);
+    bool state_blend = glIsEnabled(GL_BLEND);
+
+    GLint state_blend_src_rgb, state_blend_src_alpha, state_blend_dst_rgb, state_blend_dst_alpha;
+    glGetIntegerv(GL_BLEND_SRC_RGB, &state_blend_src_rgb);
+    glGetIntegerv(GL_BLEND_SRC_ALPHA, &state_blend_src_alpha);
+    glGetIntegerv(GL_BLEND_DST_RGB, &state_blend_dst_rgb);
+    glGetIntegerv(GL_BLEND_DST_ALPHA, &state_blend_dst_alpha);
+
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 0 ||
+        this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+        if (state_depth_test) glDisable(GL_DEPTH_TEST);
+    } else if (this->m_mode.Param<core::param::EnumParam>()->Value() == 1) {
+        if (!state_depth_test) glEnable(GL_DEPTH_TEST);
+    }
+
+    if (!state_blend) glEnable(GL_BLEND);
     glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
-    m_render_to_framebuffer_shdr->Enable();
+    auto fbo_shdr = &m_render_to_framebuffer_shdr;
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+        fbo_shdr = &m_render_to_framebuffer_aggr_shdr;
+    }
+
+    fbo_shdr->Enable();
 
-    glActiveTexture(GL_TEXTURE1);
+    glActiveTexture(GL_TEXTURE0);
     m_render_target->bindTexture();
-    glUniform1i(m_render_to_framebuffer_shdr->ParameterLocation("src_tx2D"), 1);
+    glUniform1i(fbo_shdr->ParameterLocation("src_tx2D"), 0);
 
-    glDrawArrays(GL_TRIANGLES, 0, 6);
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 1) {
+        glActiveTexture(GL_TEXTURE1);
+        m_normal_target->bindTexture();
+        glUniform1i(fbo_shdr->ParameterLocation("normal_tx2D"), 1);
 
-    m_render_to_framebuffer_shdr->Disable();
+        glActiveTexture(GL_TEXTURE2);
+        m_depth_target->bindTexture();
+        glUniform1i(fbo_shdr->ParameterLocation("depth_tx2D"), 2);
 
+        GLenum buffers[] = {GL_COLOR_ATTACHMENT0_EXT, GL_COLOR_ATTACHMENT1_EXT};
+        glDrawBuffers(2, buffers);
+    }
 
-    glUseProgram(0);
-    // glBindVertexArray(0);
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+        glActiveTexture(GL_TEXTURE1);
+        glBindTexture(GL_TEXTURE_1D, tf_texture);
+        glUniform1i(fbo_shdr->ParameterLocation("tf_tx1D"), 1);
+
+        glUniform2f(fbo_shdr->ParameterLocation("valRange"), rndr_min, rndr_max);
+    }
+
+    glDrawArrays(GL_TRIANGLES, 0, 6);
+
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 1) {
+        glActiveTexture(GL_TEXTURE2);
+        glBindTexture(GL_TEXTURE_2D, 0);
+        glActiveTexture(GL_TEXTURE1);
+        glBindTexture(GL_TEXTURE_2D, 0);
+    }
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+        glActiveTexture(GL_TEXTURE1);
+        glBindTexture(GL_TEXTURE_1D, 0);
+    }
     glActiveTexture(GL_TEXTURE0);
-    glBindTexture(GL_TEXTURE_3D, 0);
-    glActiveTexture(GL_TEXTURE1);
     glBindTexture(GL_TEXTURE_2D, 0);
 
-    glBindBuffer(GL_ARRAY_BUFFER, 0);
-    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
-    glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
-    glBindBuffer(GL_DRAW_INDIRECT_BUFFER, 0);
+    fbo_shdr->Disable();
 
-    glEnable(GL_DEPTH_TEST);
-    glDisable(GL_BLEND);
+    glBlendFuncSeparate(state_blend_src_rgb, state_blend_dst_rgb, state_blend_src_alpha, state_blend_dst_alpha);
+    if (!state_blend) glDisable(GL_BLEND);
+    if (state_depth_test) glEnable(GL_DEPTH_TEST); else glDisable(GL_DEPTH_TEST);
 
     return true;
 }
 
-bool RaycastVolumeRenderer::updateVolumeData() {
+bool RaycastVolumeRenderer::updateVolumeData(const unsigned int frameID) {
     auto* cd = this->m_volumetricData_callerSlot.CallAs<megamol::core::misc::VolumetricDataCall>();
 
     if (cd == nullptr) return false;
 
-    if (!(*cd)(core::misc::VolumetricDataCall::IDX_GET_EXTENTS)) return false;
-    if (!(*cd)(core::misc::VolumetricDataCall::IDX_GET_METADATA)) return false;
-    if (!(*cd)(core::misc::VolumetricDataCall::IDX_GET_DATA)) return false;
+    // Use the force
+    cd->SetFrameID(frameID, true);
+    do {
+        if (!(*cd)(core::misc::VolumetricDataCall::IDX_GET_EXTENTS)) return false;
+        if (!(*cd)(core::misc::VolumetricDataCall::IDX_GET_METADATA)) return false;
+        if (!(*cd)(core::misc::VolumetricDataCall::IDX_GET_DATA)) return false;
+    } while (cd->FrameID() != frameID);
 
     // TODO check time and frame id or whatever else
     if (this->m_volume_datahash != cd->DataHash() || this->m_frame_id != cd->FrameID()) {
@@ -328,47 +677,24 @@ bool RaycastVolumeRenderer::updateVolumeData() {
 
     // TODO if/else data already on GPU
 
-    // debug using dummy-data
-    std::array<uint8_t, 8> debug_volume_data = {255, 0, 255, 0, 255, 255, 0, 0};
-    TextureLayout debug_volume_layout(GL_R8, 2, 2, 2, GL_RED, GL_UNSIGNED_BYTE, 1,
-        {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
-            {GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_MIN_FILTER, GL_NEAREST},
-            {GL_TEXTURE_MAG_FILTER, GL_NEAREST}},
-        {});
-
-    TextureLayout volume_layout(internal_format, metadata->Resolution[0], metadata->Resolution[1],
+    glowl::TextureLayout volume_layout(internal_format, metadata->Resolution[0], metadata->Resolution[1],
         metadata->Resolution[2], format, type, 1,
         {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
             {GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_MIN_FILTER, GL_LINEAR},
             {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
         {});
 
-    m_volume_texture->reload(volume_layout, volumedata);
+    m_volume_texture = std::make_unique<glowl::Texture3D>("raycast_volume_texture", volume_layout, volumedata);
+
+    return true;
 }
 
 bool RaycastVolumeRenderer::updateTransferFunction() {
     core::view::CallGetTransferFunction* ct =
         this->m_transferFunction_callerSlot.CallAs<core::view::CallGetTransferFunction>();
-    //ct->SetRange(valRange);
+
     if (ct != NULL && ((*ct)())) {
         tf_texture = ct->OpenGLTexture();
-        /*float const* tf_tex = ct->GetTextureData();
-        unsigned int tf_size = ct->TextureSize();
-        auto tf_format = ct->OpenGLTextureFormat();
-
-        GLenum internal_format = tf_format == GL_RGB ? GL_RGB32F : GL_RGBA32F;
-        GLenum format = tf_format;
-        GLenum type = GL_FLOAT;
-
-        TextureLayout tf_layout(internal_format, tf_size, 1, 1, format, type, 1,
-            {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
-                {GL_TEXTURE_MIN_FILTER, GL_LINEAR}, {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
-            {});
-
-        m_transfer_function->reload(tf_layout, tf_tex);*/
-        // this->colorTransferGray(allColor, tf_tex, tex_size, processedColor, 3);
-    } else {
-        // this->colorTransferGray(allColor, NULL, 0, processedColor, 3);
     }
 
     return true;
diff --git a/plugins/mmstd_volume/src/RaycastVolumeRenderer.h b/plugins/mmstd_volume/src/RaycastVolumeRenderer.h
index 554bff170..b65e57765 100644
--- a/plugins/mmstd_volume/src/RaycastVolumeRenderer.h
+++ b/plugins/mmstd_volume/src/RaycastVolumeRenderer.h
@@ -7,20 +7,23 @@
 
 #ifndef RAYCAST_VOLUME_RENDERER_H_INCLUDED
 #define RAYCAST_VOLUME_RENDERER_H_INCLUDED
-#if (defined(_MSC_VER) && (_MSC_VER > 1000))
-#    pragma once
-#endif /* (defined(_MSC_VER) && (_MSC_VER > 1000)) */
-
-#include <array>
-
-#include "vislib/graphics/gl/GLSLComputeShader.h"
-#include "vislib/graphics/gl/OpenGLTexture2D.h"
+#pragma once
 
+#include "mmcore/Call.h"
 #include "mmcore/CallerSlot.h"
 #include "mmcore/param/ParamSlot.h"
-#include "mmcore/view/CallRender3D.h"
 #include "mmcore/view/Renderer3DModule.h"
 
+#include "vislib/graphics/gl/FramebufferObject.h"
+#include "vislib/graphics/gl/GLSLComputeShader.h"
+#include "vislib/graphics/gl/GLSLShader.h"
+
+#include "glowl/Texture2D.hpp"
+#include "glowl/Texture3D.hpp"
+
+#include <array>
+#include <limits>
+#include <memory>
 
 namespace megamol {
 namespace stdplugin {
@@ -95,355 +98,22 @@ protected:
      */
     bool Render(core::Call& call);
 
-    bool updateVolumeData();
+    bool updateVolumeData(const unsigned int frameID);
 
     bool updateTransferFunction();
 
 private:
-    /* OpenGL TextureLayout, Texture and Texture2D classes courtesy of glOwl by Michael Becher. */
-
-    struct TextureLayout {
-        TextureLayout() : width(0), internal_format(0), height(0), depth(0), format(0), type(0), levels(0) {}
-        /**
-         * \param internal_format Specifies the (sized) internal format of a texture (e.g. GL_RGBA32F)
-         * \param width Specifies the width of the texture in pixels.
-         * \param height Specifies the height of the texture in pixels. Will be ignored by Texture1D.
-         * \param depth Specifies the depth of the texture in pixels. Will be ignored by Texture1D and Texture2D.
-         * \param format Specifies the format of the texture (e.g. GL_RGBA)
-         * \param type Specifies the type of the texture (e.g. GL_FLOAT)
-         */
-        TextureLayout(
-            GLint internal_format, int width, int height, int depth, GLenum format, GLenum type, GLsizei levels)
-            : internal_format(internal_format)
-            , width(width)
-            , height(height)
-            , depth(depth)
-            , format(format)
-            , type(type)
-            , levels(levels) {}
-
-        /**
-         * \param internal_format Specifies the (sized) internal format of a texture (e.g. GL_RGBA32F)
-         * \param width Specifies the width of the texture in pixels.
-         * \param height Specifies the height of the texture in pixels. Will be ignored by Texture1D.
-         * \param depth Specifies the depth of the texture in pixels. Will be ignored by Texture1D and Texture2D.
-         * \param format Specifies the format of the texture (e.g. GL_RGBA)
-         * \param type Specifies the type of the texture (e.g. GL_FLOAT)
-         * \param int_parameters A list of integer texture parameters, each given by a pair of name and value (e.g.
-         * {{GL_TEXTURE_SPARSE_ARB,GL_TRUE},{...},...} \param int_parameters A list of float texture parameters, each
-         * given by a pair of name and value (e.g. {{GL_TEXTURE_MAX_ANISOTROPY_EX,4.0f},{...},...}
-         */
-        TextureLayout(GLint internal_format, int width, int height, int depth, GLenum format, GLenum type,
-            GLsizei levels, std::vector<std::pair<GLenum, GLint>> const& int_parameters,
-            std::vector<std::pair<GLenum, GLfloat>> const& float_parameters)
-            : internal_format(internal_format)
-            , width(width)
-            , height(height)
-            , depth(depth)
-            , format(format)
-            , type(type)
-            , levels(levels)
-            , int_parameters(int_parameters)
-            , float_parameters(float_parameters) {}
-        TextureLayout(GLint internal_format, int width, int height, int depth, GLenum format, GLenum type,
-            GLsizei levels, std::vector<std::pair<GLenum, GLint>>&& int_parameters,
-            std::vector<std::pair<GLenum, GLfloat>>&& float_parameters)
-            : internal_format(internal_format)
-            , width(width)
-            , height(height)
-            , depth(depth)
-            , format(format)
-            , type(type)
-            , levels(levels)
-            , int_parameters(int_parameters)
-            , float_parameters(float_parameters) {}
-
-        GLint internal_format;
-        int width;
-        int height;
-        int depth;
-        GLenum format;
-        GLenum type;
-
-        GLsizei levels;
-
-        std::vector<std::pair<GLenum, GLint>> int_parameters;
-        std::vector<std::pair<GLenum, GLfloat>> float_parameters;
-    };
-
-    class Texture {
-    protected:
-        std::string m_id; ///< Identifier set by application to help identifying textures
-
-        GLuint m_name;             ///< OpenGL texture name given by glGenTextures
-        GLuint64 m_texture_handle; ///< Actual OpenGL texture handle (used for bindless)
-
-        GLenum m_internal_format;
-        GLenum m_format;
-        GLenum m_type;
-
-        GLsizei m_levels;
-
-        // TODO: Store texture parameters as well ?
-    public:
-        Texture(std::string id, GLint internal_format, GLenum format, GLenum type, GLsizei levels)
-            : m_id(id), m_internal_format(internal_format), m_format(format), m_type(type), m_levels(levels) {}
-        virtual ~Texture() { glDeleteTextures(1, &m_name); }
-        Texture(const Texture&) = delete;
-
-        virtual void bindTexture() const = 0;
-
-        void bindImage(GLuint location, GLenum access) const {
-            glBindImageTexture(location, m_name, 0, GL_TRUE, 0, access, m_internal_format);
-        }
-
-        void makeResident() { glMakeTextureHandleResidentARB(m_texture_handle); }
-        void makeNonResident() { glMakeTextureHandleNonResidentARB(m_texture_handle); }
-
-        virtual void updateMipmaps() = 0;
-
-        virtual TextureLayout getTextureLayout() const = 0;
-
-        std::string getId() const { return m_id; }
-
-        GLuint getName() const { return m_name; }
-        GLuint64 getTextureHandle() const { return m_texture_handle; }
-        GLuint64 getImageHandle(GLint level, GLboolean layered, GLint layer) const {
-            return glGetImageHandleARB(m_name, level, layered, layer, m_internal_format);
-        }
-
-        GLenum getInternalFormat() const { return m_internal_format; }
-        GLenum getFormat() const { return m_format; }
-        GLenum getType() const { return m_type; }
-    };
-
-    class Texture2D : public Texture {
-    public:
-        /**
-         * \brief Constructor that creates and loads a 2D texture.
-         *
-         * \param id A identifier given to the texture object
-         * \param layout A TextureLayout struct that specifies size, format and parameters for the texture
-         * \param data Pointer to the actual texture data.
-         * \param generateMipmap Specifies whether a mipmap will be created for the texture
-         */
-        Texture2D(std::string id, TextureLayout const& layout, GLvoid* data, bool generateMipmap = false)
-            : Texture(id, layout.internal_format, layout.format, layout.type, layout.levels)
-            , m_width(layout.width)
-            , m_height(layout.height) {
-            glGenTextures(1, &m_name);
-
-            glBindTexture(GL_TEXTURE_2D, m_name);
-
-            for (auto& pname_pvalue : layout.int_parameters)
-                glTexParameteri(GL_TEXTURE_2D, pname_pvalue.first, pname_pvalue.second);
-
-            for (auto& pname_pvalue : layout.float_parameters)
-                glTexParameterf(GL_TEXTURE_2D, pname_pvalue.first, pname_pvalue.second);
-
-            GLsizei levels = 1;
-
-            if (generateMipmap) levels = 1 + floor(log2(std::max(m_width, m_height)));
-
-            glTexStorage2D(GL_TEXTURE_2D, levels, m_internal_format, m_width, m_height);
-
-            if (data != nullptr) glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, m_width, m_height, m_format, m_type, data);
-
-            if (generateMipmap) glGenerateMipmap(GL_TEXTURE_2D);
-
-            glBindTexture(GL_TEXTURE_2D, 0);
-
-            m_texture_handle = glGetTextureHandleARB(m_name);
-
-            GLenum err = glGetError();
-            if (err != GL_NO_ERROR) {
-                // "Do something cop!"
-                // std::cerr << "GL error during texture (id: " << id << ") creation: " << err << std::endl;
-            }
-        }
-        Texture2D(const Texture2D&) = delete;
-        Texture2D(Texture2D&& other) = delete;
-        Texture2D& operator=(const Texture2D& rhs) = delete;
-        Texture2D& operator=(Texture2D&& rhs) = delete;
-
-        /**
-         * \brief Bind the texture.
-         */
-        void bindTexture() const { glBindTexture(GL_TEXTURE_2D, m_name); }
-
-        void updateMipmaps() {
-            glBindTexture(GL_TEXTURE_2D, m_name);
-            glGenerateMipmap(GL_TEXTURE_2D);
-            glBindTexture(GL_TEXTURE_2D, 0);
-        }
-
-        /**
-         * \brief Reload the texture with any new format, type and size.
-         *
-         * \param layout A TextureLayout struct that specifies size, format and parameters for the texture
-         * \param data Pointer to the actual texture data.
-         * \param generateMipmap Specifies whether a mipmap will be created for the texture
-         */
-        void reload(TextureLayout const& layout, GLvoid const* data, bool generateMipmap = false) {
-            m_width = layout.width;
-            m_height = layout.height;
-            m_internal_format = layout.internal_format;
-            m_format = layout.format;
-            m_type = layout.type;
-
-            glDeleteTextures(1, &m_name);
-
-            glGenTextures(1, &m_name);
-
-            glBindTexture(GL_TEXTURE_2D, m_name);
-
-            for (auto& pname_pvalue : layout.int_parameters)
-                glTexParameteri(GL_TEXTURE_2D, pname_pvalue.first, pname_pvalue.second);
+    vislib::graphics::gl::GLSLComputeShader m_raycast_volume_compute_shdr;
+    vislib::graphics::gl::GLSLComputeShader m_raycast_volume_compute_iso_shdr;
+    vislib::graphics::gl::GLSLComputeShader m_raycast_volume_compute_aggr_shdr;
+    vislib::graphics::gl::GLSLShader m_render_to_framebuffer_shdr;
+    vislib::graphics::gl::GLSLShader m_render_to_framebuffer_aggr_shdr;
 
-            for (auto& pname_pvalue : layout.float_parameters)
-                glTexParameterf(GL_TEXTURE_2D, pname_pvalue.first, pname_pvalue.second);
+    std::unique_ptr<glowl::Texture2D> m_render_target;
+    std::unique_ptr<glowl::Texture2D> m_normal_target;
+    std::unique_ptr<glowl::Texture2D> m_depth_target;
 
-            GLsizei levels = 1;
-
-            if (generateMipmap) levels = 1 + floor(log2(std::max(m_width, m_height)));
-
-            glTexStorage2D(GL_TEXTURE_2D, levels, m_internal_format, m_width, m_height);
-
-            if (data != nullptr) glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, m_width, m_height, m_format, m_type, data);
-
-            if (generateMipmap) glGenerateMipmap(GL_TEXTURE_2D);
-
-            glBindTexture(GL_TEXTURE_2D, 0);
-
-            GLenum err = glGetError();
-            if (err != GL_NO_ERROR) {
-                // "Do something cop!"
-                // std::cerr << "GL error during  (id: " << m_id << ") reload: " << err << std::endl;
-            }
-        }
-
-        TextureLayout getTextureLayout() const {
-            return TextureLayout(m_internal_format, m_width, m_height, 1, m_format, m_type, m_levels);
-        }
-
-        unsigned int getWidth() const { return m_width; }
-
-        unsigned int getHeight() const { return m_height; }
-
-    private:
-        unsigned int m_width;
-        unsigned int m_height;
-    };
-
-    class Texture3D : public Texture {
-    public:
-        Texture3D(std::string id, TextureLayout const& layout, GLvoid* data)
-            : Texture(id, layout.internal_format, layout.format, layout.type, layout.levels)
-            , m_width(layout.width)
-            , m_height(layout.height)
-            , m_depth(layout.depth) {
-            glGenTextures(1, &m_name);
-
-            glBindTexture(GL_TEXTURE_3D, m_name);
-
-            for (auto& pname_pvalue : layout.int_parameters)
-                glTexParameteri(GL_TEXTURE_3D, pname_pvalue.first, pname_pvalue.second);
-
-            for (auto& pname_pvalue : layout.float_parameters)
-                glTexParameterf(GL_TEXTURE_3D, pname_pvalue.first, pname_pvalue.second);
-
-            glTexStorage3D(GL_TEXTURE_3D, 1, m_internal_format, m_width, m_height, m_depth);
-
-            if (data != nullptr)
-                glTexSubImage3D(GL_TEXTURE_3D, 0, 0, 0, 0, m_width, m_height, m_depth, m_format, m_type, data);
-
-            glBindTexture(GL_TEXTURE_3D, 0);
-
-            m_texture_handle = glGetTextureHandleARB(m_name);
-
-            GLenum err = glGetError();
-            if (err != GL_NO_ERROR) {
-                // "Do something cop!"
-                // std::cerr << "GL error during 3D texture (id:" << id << ") creation: " << err << std::endl;
-            }
-        }
-
-        Texture3D(const Texture3D&) = delete;
-        Texture3D(Texture3D&& other) = delete;
-        Texture3D& operator=(const Texture3D& rhs) = delete;
-        Texture3D& operator=(Texture3D&& rhs) = delete;
-
-        /**
-         * \brief Bind the texture.
-         */
-        void bindTexture() const { glBindTexture(GL_TEXTURE_3D, m_name); }
-
-        void updateMipmaps() {
-            glBindTexture(GL_TEXTURE_3D, m_name);
-            glGenerateMipmap(GL_TEXTURE_3D);
-            glBindTexture(GL_TEXTURE_3D, 0);
-        }
-
-        /**
-         * \brief Reload the texture.
-         * \param data Pointer to the new texture data.
-         */
-        void reload(TextureLayout const& layout, GLvoid const* data) {
-            m_width = layout.width;
-            m_height = layout.height;
-            m_depth = layout.depth;
-            m_internal_format = layout.internal_format;
-            m_format = layout.format;
-            m_type = layout.type;
-
-            glDeleteTextures(1, &m_name);
-
-            glGenTextures(1, &m_name);
-
-            glBindTexture(GL_TEXTURE_3D, m_name);
-
-            for (auto& pname_pvalue : layout.int_parameters)
-                glTexParameteri(GL_TEXTURE_3D, pname_pvalue.first, pname_pvalue.second);
-
-            for (auto& pname_pvalue : layout.float_parameters)
-                glTexParameterf(GL_TEXTURE_3D, pname_pvalue.first, pname_pvalue.second);
-
-            glTexStorage3D(GL_TEXTURE_3D, 1, m_internal_format, m_width, m_height, m_depth);
-
-            if (data != nullptr)
-                glTexSubImage3D(GL_TEXTURE_3D, 0, 0, 0, 0, m_width, m_height, m_depth, m_format, m_type, data);
-
-            glBindTexture(GL_TEXTURE_3D, 0);
-
-            GLenum err = glGetError();
-            if (err != GL_NO_ERROR) {
-                // "Do something cop!"
-                // std::cerr << "GL error during texture reloading: " << err << std::endl;
-            }
-        }
-
-        TextureLayout getTextureLayout() const {
-            return TextureLayout(m_internal_format, m_width, m_height, m_depth, m_format, m_type, m_levels);
-        }
-
-        unsigned int getWidth() { return m_width; }
-        unsigned int getHeight() { return m_height; }
-        unsigned int getDepth() { return m_depth; }
-
-    private:
-        unsigned int m_width;
-        unsigned int m_height;
-        unsigned int m_depth;
-    };
-
-    std::unique_ptr<vislib::graphics::gl::GLSLComputeShader> m_raycast_volume_compute_shdr;
-    std::unique_ptr<vislib::graphics::gl::GLSLShader> m_render_to_framebuffer_shdr;
-
-    std::unique_ptr<Texture2D> m_render_target;
-
-    std::unique_ptr<Texture3D> m_volume_texture;
-
-    std::unique_ptr<Texture2D> m_transfer_function;
+    std::unique_ptr<glowl::Texture3D> m_volume_texture;
 
     GLuint tf_texture;
 
@@ -454,13 +124,37 @@ private:
     float m_volume_extents[3];
     float m_volume_resolution[3];
 
+    /** Parameters for changing the behavior */
+    core::param::ParamSlot m_mode;
+
+    core::param::ParamSlot m_ray_step_ratio_param;
+    core::param::ParamSlot m_opacity_threshold;
+    core::param::ParamSlot m_iso_value;
+    core::param::ParamSlot m_opacity;
+
+    core::param::ParamSlot m_use_lighting_slot;
+    core::param::ParamSlot m_ka_slot;
+    core::param::ParamSlot m_kd_slot;
+    core::param::ParamSlot m_ks_slot;
+    core::param::ParamSlot m_shininess_slot;
+    core::param::ParamSlot m_ambient_color;
+    core::param::ParamSlot m_specular_color;
+    core::param::ParamSlot m_light_color;
+    core::param::ParamSlot m_material_color;
+
+    core::param::ParamSlot paramOverride;
+    core::param::ParamSlot paramMinOverride;
+    core::param::ParamSlot paramMaxOverride;
+
     /** caller slot */
+    megamol::core::CallerSlot m_renderer_callerSlot;
     megamol::core::CallerSlot m_volumetricData_callerSlot;
     megamol::core::CallerSlot m_transferFunction_callerSlot;
 
-    core::param::ParamSlot m_ray_step_ratio_param;
-
     std::array<float, 2> valRange;
+
+    /** FBO for chaining renderers */
+    vislib::graphics::gl::FramebufferObject fbo;
 };
 
 } // namespace volume
diff --git a/plugins/mmstd_volume/src/mmstd_volume.cpp b/plugins/mmstd_volume/src/mmstd_volume.cpp
index 6258579ab..57016396a 100644
--- a/plugins/mmstd_volume/src/mmstd_volume.cpp
+++ b/plugins/mmstd_volume/src/mmstd_volume.cpp
@@ -16,6 +16,7 @@
 #include "DirectVolumeRenderer.h"
 #include "BuckyBall.h"
 #include "GridBalls.h"
+#include "DifferenceVolume.h"
 #include "DirPartVolume.h"
 #include "VolumeCache.h"
 #include "RenderVolumeSlice.h"
@@ -64,7 +65,7 @@ MMSTD_VOLUME_API const void * mmplgCoreCompatibilityValue(void) {
  * mmplgModuleCount
  */
 MMSTD_VOLUME_API int mmplgModuleCount(void) {
-    return 10;
+    return 11;
 }
 
 
@@ -82,7 +83,8 @@ MMSTD_VOLUME_API void* mmplgModuleDescription(int idx) {
     case 6: return new megamol::core::factories::ModuleAutoDescription<megamol::stdplugin::volume::RenderVolumeSlice>();
 	case 7: return new megamol::core::factories::ModuleAutoDescription<megamol::stdplugin::volume::VolumetricDataSource>();
 	case 8: return new megamol::core::factories::ModuleAutoDescription<megamol::stdplugin::volume::RaycastVolumeRenderer>();
-	case 9: return new megamol::core::factories::ModuleAutoDescription<megamol::stdplugin::volume::DatRawWriter>();
+    case 9: return new megamol::core::factories::ModuleAutoDescription<megamol::stdplugin::volume::DatRawWriter>();
+    case 10: return new megamol::core::factories::ModuleAutoDescription<megamol::stdplugin::volume::DifferenceVolume>();
     }
     return NULL;
 }
diff --git a/plugins/pbs/src/HeadnodeServer.cpp b/plugins/pbs/src/HeadnodeServer.cpp
index 422bdd3c0..6cc9b7701 100644
--- a/plugins/pbs/src/HeadnodeServer.cpp
+++ b/plugins/pbs/src/HeadnodeServer.cpp
@@ -15,6 +15,7 @@
 #include "mmcore/view/AbstractView.h"
 #include "mmcore/view/CallRenderView.h"
 #include "vislib/RawStorageSerialiser.h"
+#include "mmcore/view/AbstractRenderingView.h"
 
 
 megamol::pbs::HeadnodeServer::HeadnodeServer()
@@ -107,9 +108,11 @@ void megamol::pbs::HeadnodeServer::ParamUpdated(core::param::ParamSlot& slot) {
 bool megamol::pbs::HeadnodeServer::get_cam_upd(std::vector<char>& msg) {
 
     AbstractNamedObject::const_ptr_type avp;
+    std::vector<char> const null_buf(MessageHeaderSize, 0);
     const core::view::AbstractView* av = nullptr;
     core::Call* call = nullptr;
     unsigned int csn = 0;
+    bool gotUpdate = false;
 
     av = nullptr;
     call = this->view_slot_.CallAs<core::Call>();
@@ -119,24 +122,59 @@ bool megamol::pbs::HeadnodeServer::get_cam_upd(std::vector<char>& msg) {
     }
     if (av == nullptr) return false;
 
-    csn = av->GetCameraSyncNumber();
-    if ((csn != syncnumber)) {
-        syncnumber = csn;
-        vislib::RawStorage mem;
-        vislib::RawStorageSerialiser serialiser(&mem);
-        av->SerialiseCamera(serialiser);
-
-        msg.resize(MessageHeaderSize + mem.GetSize());
-        msg[0] = static_cast<char>(MessageType::CAM_UPD_MSG);
-        auto size = mem.GetSize();
-        std::copy(reinterpret_cast<char*>(&size), reinterpret_cast<char*>(&size) + MessageSizeSize,
-            msg.begin() + MessageTypeSize);
-        std::copy(mem.AsAt<char>(0), mem.AsAt<char>(0) + mem.GetSize(), msg.begin() + MessageHeaderSize);
-
-        return true;
-    }
+ 
+    const auto fun = [this, &gotUpdate, &msg](Module* mod) {
+        const auto arv = dynamic_cast<core::view::AbstractRenderingView*>(mod);
+        if (!gotUpdate && arv != nullptr) {
+            const auto csn = arv->GetCameraSyncNumber();
+            if (this->syncnumbers.find(arv->FullName().PeekBuffer()) == this->syncnumbers.end() ||
+                csn != this->syncnumbers[arv->FullName().PeekBuffer()]) {
+
+                vislib::RawStorage mem(100);
+                vislib::RawStorageSerialiser serialiser(&mem);
+
+                arv->SerialiseCamera(serialiser);
+
+                const uint32_t viewlen = arv->FullName().Length() + 1;
+                msg.resize(MessageHeaderSize + mem.GetSize() + sizeof(uint32_t) + viewlen);
+                msg[0] = static_cast<char>(MessageType::CAM_UPD_MSG);
+                char* lenpos = msg.data() + 1 + MessageSizeSize;
+                *reinterpret_cast<uint32_t*>(lenpos) = viewlen;
+                char* namepos = lenpos + sizeof(uint32_t);
+                memcpy(namepos, arv->FullName().PeekBuffer(), viewlen);
+                auto size = mem.GetSize() + viewlen + sizeof(uint32_t);
+                std::copy(reinterpret_cast<char*>(&size), reinterpret_cast<char*>(&size) + MessageSizeSize,
+                    msg.begin() + MessageTypeSize);
+                std::copy(mem.AsAt<char>(0), mem.AsAt<char>(0) + mem.GetSize(),
+                    msg.begin() + MessageHeaderSize + sizeof(uint32_t) + viewlen);
+
+                gotUpdate = true;
+
+                this->syncnumbers[arv->FullName().PeekBuffer()] = csn;
+            }
+        }
+    };
+
+    this->GetCoreInstance()->EnumModulesNoLock(av->FullName().PeekBuffer(), fun);
+
+    //csn = av->GetCameraSyncNumber();
+    //if ((csn != syncnumber)) {
+    //    syncnumber = csn;
+    //    vislib::RawStorage mem;
+    //    vislib::RawStorageSerialiser serialiser(&mem);
+    //    av->SerialiseCamera(serialiser);
 
-    return false;
+    //    msg.resize(MessageHeaderSize + mem.GetSize());
+    //    msg[0] = static_cast<char>(MessageType::CAM_UPD_MSG);
+    //    auto size = mem.GetSize();
+    //    std::copy(reinterpret_cast<char*>(&size), reinterpret_cast<char*>(&size) + MessageSizeSize,
+    //        msg.begin() + MessageTypeSize);
+    //    std::copy(mem.AsAt<char>(0), mem.AsAt<char>(0) + mem.GetSize(), msg.begin() + MessageHeaderSize);
+
+    //    return true;
+    //}
+
+    return gotUpdate;
 }
 
 
@@ -179,20 +217,20 @@ void megamol::pbs::HeadnodeServer::do_communication() {
 
     // retrieve modulgraph
     if (this->deploy_project_slot_.Param<core::param::BoolParam>()->Value()) {
-    if (this->GetCoreInstance()->IsLuaProject()) {
-        auto const lua = std::string(this->GetCoreInstance()->GetMergedLuaProject());
-        std::vector<char> msg(MessageHeaderSize + lua.size());
-        msg[0] = MessageType::PRJ_FILE_MSG;
-        auto size = lua.size();
-        std::copy(reinterpret_cast<char*>(&size), reinterpret_cast<char*>(&size) + MessageSizeSize,
-            msg.begin() + MessageTypeSize);
-        std::copy(lua.begin(), lua.end(), msg.begin() + MessageHeaderSize);
-        {
-            std::lock_guard<std::mutex> lock(send_buffer_guard_);
-            send_buffer_.insert(send_buffer_.end(), msg.begin(), msg.end());
+        if (this->GetCoreInstance()->IsLuaProject()) {
+            auto const lua = std::string(this->GetCoreInstance()->GetMergedLuaProject());
+            std::vector<char> msg(MessageHeaderSize + lua.size());
+            msg[0] = MessageType::PRJ_FILE_MSG;
+            auto size = lua.size();
+            std::copy(reinterpret_cast<char*>(&size), reinterpret_cast<char*>(&size) + MessageSizeSize,
+                msg.begin() + MessageTypeSize);
+            std::copy(lua.begin(), lua.end(), msg.begin() + MessageHeaderSize);
+            {
+                std::lock_guard<std::mutex> lock(send_buffer_guard_);
+                send_buffer_.insert(send_buffer_.end(), msg.begin(), msg.end());
+            }
         }
     }
-    }
     try {
         while (run_threads_) {
             // Wait for message
@@ -215,7 +253,7 @@ void megamol::pbs::HeadnodeServer::do_communication() {
                 }
 
                 if (!send_buffer_.empty()) {
-		    // vislib::sys::Log::DefaultLog.WriteInfo("HeadnodeServer: Sending parameter update.\n");
+                    // vislib::sys::Log::DefaultLog.WriteInfo("HeadnodeServer: Sending parameter update.\n");
                     comm_fabric_.Send(send_buffer_, send_type::SEND);
                     send_buffer_.clear();
                     buffer_has_changed_.store(false);
diff --git a/plugins/pbs/src/HeadnodeServer.h b/plugins/pbs/src/HeadnodeServer.h
index 2a01e3668..b230cee66 100644
--- a/plugins/pbs/src/HeadnodeServer.h
+++ b/plugins/pbs/src/HeadnodeServer.h
@@ -12,6 +12,7 @@
 
 #include "DistributedProto.h"
 #include "FBOCommFabric.h"
+#include <map>
 
 namespace megamol {
 namespace pbs {
@@ -108,7 +109,8 @@ private:
 
     std::vector<char> send_buffer_;
 
-    unsigned int syncnumber = -1;
+    // unsigned int syncnumber = -1;
+    std::map<std::string, unsigned int> syncnumbers;
 
     std::thread comm_thread_;
 
diff --git a/plugins/pbs/src/RendernodeView.cpp b/plugins/pbs/src/RendernodeView.cpp
index 9d8114881..2d76bd6d8 100644
--- a/plugins/pbs/src/RendernodeView.cpp
+++ b/plugins/pbs/src/RendernodeView.cpp
@@ -14,6 +14,7 @@
 #include "vislib/RawStorageSerialiser.h"
 #include "vislib/sys/Log.h"
 #include "vislib/sys/SystemInformation.h"
+#include "mmcore/view/AbstractRenderingView.h"
 
 //#define RV_DEBUG_OUTPUT = 1
 
@@ -104,12 +105,23 @@ bool megamol::pbs::RendernodeView::process_msgs(Message_t const& msgs) {
                 msg.resize(size);
                 std::copy(ibegin + MessageHeaderSize, ibegin + MessageHeaderSize + size, msg.begin());
             }
-            vislib::RawStorageSerialiser ser(reinterpret_cast<unsigned char*>(msg.data()), msg.size());
-            auto view = this->getConnectedView();
-            if (view != nullptr) {
-                view->DeserialiseCamera(ser);
-            } else {
-                vislib::sys::Log::DefaultLog.WriteError("RendernodeView: Cannot update camera. No view connected.");
+            uint32_t namelen = *reinterpret_cast<uint32_t*>(msg.data());
+            std::string viewname(msg.data() + sizeof(uint32_t));
+
+            vislib::RawStorageSerialiser ser(reinterpret_cast<unsigned char*>(msg.data() + sizeof(uint32_t) + namelen), msg.size() - namelen - sizeof(uint32_t));
+            //vislib::sys::Log::DefaultLog.WriteInfo("got info about view %s (len: %u), ser mem len = %u",
+            //    viewname.c_str(), namelen, ser.Storage()->GetSize());
+
+            bool foundview = false;
+            const auto fun = [&ser, &foundview](core::view::AbstractRenderingView* mod) {
+                mod->DeserialiseCamera(ser);
+                foundview = true;
+            };
+
+            this->GetCoreInstance()->FindModuleNoLock<core::view::AbstractRenderingView>(viewname, fun);
+           
+            if (!foundview) {
+                vislib::sys::Log::DefaultLog.WriteError("RendernodeView: Cannot update camera. Cannot find view %s.", viewname.c_str());
             }
         } break;
         case MessageType::HEAD_DISC_MSG:
diff --git a/plugins/template/include/MegaMolPlugin/MegaMolPlugin.h b/plugins/template/include/MegaMolPlugin/MegaMolPlugin.h
index 803021e51..ecdab4dae 100644
--- a/plugins/template/include/MegaMolPlugin/MegaMolPlugin.h
+++ b/plugins/template/include/MegaMolPlugin/MegaMolPlugin.h
@@ -1,6 +1,6 @@
 /*
  * MegaMolPlugin.h
- * Copyright (C) 2009-2015 by MegaMol Team
+ * Copyright (C) 2009-2019 by MegaMol Team
  * Alle Rechte vorbehalten.
  */
 #ifndef MEGAMOLPLUGIN_H_INCLUDED
@@ -34,7 +34,7 @@ extern "C" {
 #endif
 
 /**
- * Returns the version of the MegaMol plugin api used by this plugin.
+ * Returns the version of the MegaMol plugin api used by this plugin.
  *
  * @return 200 -- (ver.: 2.00)
  */
diff --git a/plugins/template/instawiz.ps1 b/plugins/template/instawiz.ps1
index 2003cb04f..7e5c99a5f 100644
--- a/plugins/template/instawiz.ps1
+++ b/plugins/template/instawiz.ps1
@@ -1,6 +1,6 @@
 #
 # MegaMol Plugin Instantiation Wizard
-# Copyright 2018 by MegaMol Team
+# Copyright 2018-2019 by MegaMol Team
 # Alle Rechte vorbehalten.
 #
 
@@ -55,24 +55,25 @@ if (-not [string]::IsNullOrEmpty($accept)) {
 
 # perform instantiation
 Move-Item -Path ".\include\MegaMolPlugin\" -Destination ".\include\$pluginname\"
+$uppername = $pluginname.ToUpper()
 
 $fn = ".\include\$pluginname\$pluginname.h"
 Move-Item -Path ".\include\$pluginname\MegaMolPlugin.h" -Destination $fn
 $temp = [IO.File]::ReadAllText($fn)
-$temp = $temp -replace "MegaMolPlugin", "$pluginname"
-$temp = $temp -replace "MEGAMOLPLUGIN", "${$pluginname.ToUpper()}"
+$temp = $temp -creplace "MegaMolPlugin", "$pluginname"
+$temp = $temp -creplace "MEGAMOLPLUGIN", "$uppername"
 [IO.File]::WriteAllText($fn, $temp)
 
 $fn = ".\src\$pluginname.cpp"
 Move-Item -Path ".\src\MegaMolPlugin.cpp" -Destination $fn
 $temp = [IO.File]::ReadAllText($fn)
-$temp = $temp -replace "MegaMolPlugin", "$pluginname"
-$temp = $temp -replace "MEGAMOLPLUGIN", "${$pluginname.ToUpper()}"
+$temp = $temp -creplace "MegaMolPlugin", "$pluginname"
+$temp = $temp -creplace "MEGAMOLPLUGIN", "$uppername"
 [IO.File]::WriteAllText($fn, $temp)
 
 $fn = ".\src\stdafx.h";
 $temp = [IO.File]::ReadAllText($fn)
-$temp = $temp -replace "MEGAMOLPLUGIN", "${$pluginname.ToUpper()}"
+$temp = $temp -creplace "MEGAMOLPLUGIN", "$uppername"
 [IO.File]::WriteAllText($fn, $temp)
 
 
@@ -80,7 +81,7 @@ $temp = $temp -replace "MEGAMOLPLUGIN", "${$pluginname.ToUpper()}"
 
 $fn = ".\CMakeLists.txt";
 $temp = [IO.File]::ReadAllText($fn)
-$temp = $temp -replace "MegaMolPlugin", "$pluginname"
+$temp = $temp -creplace "MegaMolPlugin", "$pluginname"
 [IO.File]::WriteAllText($fn, $temp)
 
 # Completed
