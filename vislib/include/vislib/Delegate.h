/*
 * Delegate.h
 *
 * Copyright (C) 2006 - 2011 by Visualisierungsinstitut Universitaet Stuttgart.
 * Alle Rechte vorbehalten.
 */

#ifndef VISLIB_DELEGATE_H_INCLUDED
#define VISLIB_DELEGATE_H_INCLUDED
#if (defined(_MSC_VER) && (_MSC_VER > 1000))
#pragma once
#endif /* (defined(_MSC_VER) && (_MSC_VER > 1000)) */
#if defined(_WIN32) && defined(_MANAGED)
#pragma managed(push, off)
#endif /* defined(_WIN32) && defined(_MANAGED) */

#include "vislib/IllegalStateException.h"
#include "vislib/assert.h"
#include "vislib/memutils.h"


/*
 * This file is generated by 'implementDelegate.pl'
 */


namespace vislib {


/**
 * Class representing a single callback target, which can either be a
 * function (c or static member) or a member-object pair, both with an
 * optional context object (usually a pointer).
 *
 * The first template parameter specifies the return value.
 * The other template parameters define the parameter list of the
 * callback, while void is used to (implicitly) terminate the list.
 * The parameter list may only have a maximum of 10 elements.
 */
template<class Rv = void, class P1 = void, class P2 = void, class P3 = void, class P4 = void, class P5 = void,
    class P6 = void, class P7 = void, class P8 = void, class P9 = void, class P10 = void>
class Delegate {
public:
    /**
     * Ctor
     */
    Delegate(void) : callee(NULL) {
        // intentionally empty
    }

    /**
     * Copy ctor
     *
     * @param src The object to clone from
     */
    Delegate(const Delegate& src) : callee(NULL) {
        (*this) = src;
    }

    /**
     * Ctor
     *
     * @param funcPtr Function pointer to be set
     */
    Delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10))
            : callee((funcPtr == NULL) ? NULL : new FunctionCallee(funcPtr)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param funcPtr Function pointer to be set
     * @param ctxt The user data context used when calling the function
     */
    template<class CT1, class CT2>
    Delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, CT1), CT2 ctxt)
            : callee((funcPtr == NULL) ? NULL : new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     */
    template<class C>
    Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10))
            : callee(new MethodCallee<C>(obj, methPtr)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     * @param ctxt The user data context used when calling the method
     */
    template<class C, class CT1, class CT2>
    Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, CT1), CT2 ctxt)
            : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
        // intentionally empty
    }

    /**
     * Dtor
     *
     * Note that no memory will be freed (user data context, etc.)
     */
    ~Delegate(void) {
        SAFE_DELETE(this->callee);
    }

    /**
     * Answer whether the target for this delegate is set
     *
     * @return True if the target for this delegate is set
     */
    inline bool IsTargetSet(void) const {
        return this->callee != NULL;
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     */
    void Set(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10)) {
        SAFE_DELETE(this->callee);
        if (funcPtr != NULL) {
            this->callee = new FunctionCallee(funcPtr);
        }
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     * @param ctxt The user data context used when calling the function
     */
    template<class CT1, class CT2>
    void Set(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, CT1), CT2 ctxt) {
        SAFE_DELETE(this->callee);
        if (funcPtr != NULL) {
            this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
        }
    }

    /**
     * Sets the target for this delegate
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     */
    template<class C>
    void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10)) {
        SAFE_DELETE(this->callee);
        this->callee = new MethodCallee<C>(obj, methPtr);
    }

    /**
     * Sets the target for this delegate
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     * @param ctxt The user data context used when calling the method
     */
    template<class C, class CT1, class CT2>
    void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, CT1), CT2 ctxt) {
        SAFE_DELETE(this->callee);
        this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
    }

    /**
     * Unsets the target for this delegate
     *
     * Note that no memory will be freed (user data context, etc.)
     */
    void Unset(void) {
        SAFE_DELETE(this->callee);
    }

    /**
     * Calls the delegate's target
     *
     * Parameter and return value depend on the template arguments of the delegate
     */
    Rv operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10) {
        if (this->callee == NULL) {
            throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
        }
        return this->callee->Call(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);
    }

    /**
     * Test for equality
     *
     * @param rhs The right hand side operand
     *
     * @return True if this and rhs are equal
     */
    bool operator==(const Delegate& rhs) const {
        if (this->callee == NULL) {
            return (rhs.callee == NULL);
        }
        return this->callee->Equals(*rhs.callee);
    }

    /**
     * Assignment operator
     *
     * @param rhs The right hand side operand
     *
     * @return A reference to this object
     */
    Delegate& operator=(const Delegate& rhs) {
        SAFE_DELETE(this->callee);
        if (rhs.callee != NULL) {
            this->callee = rhs.callee->Clone();
        }
        return *this;
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     *
     * @return A reference to this object
     */
    Delegate& operator=(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10)) {
        this->Set(funcPtr);
        return *this;
    }

private:
    /**
     * abstract base class for callee implementations
     */
    class AbstractCallee {
    public:
        /** Ctor */
        AbstractCallee(void) {
            // intentionally empty
        }

        /** Dtor */
        virtual ~AbstractCallee(void) {
            // intentionally empty
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10) = 0;

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) = 0;

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) = 0;
    };

    /**
     * Callee implementation for functions
     */
    class FunctionCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The function pointer (must not be NULL)
         */
        FunctionCallee(Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10)) : AbstractCallee(), func(func) {
            ASSERT(this->func != NULL);
        }

        /** Dtor */
        virtual ~FunctionCallee(void) {
            this->func = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10) {
            return this->func(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new FunctionCallee(this->func);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const FunctionCallee* r = dynamic_cast<const FunctionCallee*>(&rhs);
            return (r != NULL) && (r->func == this->func);
        }

    private:
        /** The function pointer */
        Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10);
    };

    /**
     * Callee implementation for functions with user data context
     */
    template<class CT1>
    class FunctionContextCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The function pointer (must not be NULL)
         * @param ctxt The user data context
         */
        FunctionContextCallee(Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, CT1), CT1 ctxt)
                : AbstractCallee()
                , func(func)
                , ctxt(ctxt) {
            ASSERT(this->func != NULL);
        }

        /** Dtor */
        virtual ~FunctionContextCallee(void) {
            this->func = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10) {
            return this->func(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, this->ctxt);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new FunctionContextCallee<CT1>(this->func, this->ctxt);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const FunctionContextCallee* r = dynamic_cast<const FunctionContextCallee*>(&rhs);
            return (r != NULL) && (r->func == this->func) && (r->ctxt == this->ctxt);
        }

    private:
        /** The function pointer */
        Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, CT1);

        /** The user data context */
        CT1 ctxt;
    };

    /**
     * Callee implementation for methods
     */
    template<class C>
    class MethodCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The method pointer (must not be NULL)
         * @param ctxt The user data context
         */
        MethodCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10))
                : AbstractCallee()
                , obj(obj)
                , meth(meth) {
            ASSERT(this->meth != NULL);
        }

        /** Dtor */
        virtual ~MethodCallee(void) {
            this->meth = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10) {
            return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new MethodCallee<C>(this->obj, this->meth);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const MethodCallee* r = dynamic_cast<const MethodCallee*>(&rhs);
            return (r != NULL) && (&r->obj == &this->obj) && (r->meth == this->meth);
        }

    private:
        /** The object */
        C& obj;

        /** The method pointer */
        Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10);
    };

    /**
     * Callee implementation for methods with user data context
     */
    template<class C, class CT1>
    class MethodContextCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param obj The object
         * @param func The method pointer (must not be NULL)
         * @param ctxt The user data context
         */
        MethodContextCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, CT1), CT1 ctxt)
                : AbstractCallee()
                , obj(obj)
                , meth(meth)
                , ctxt(ctxt) {
            ASSERT(this->meth != NULL);
        }

        /** Dtor */
        virtual ~MethodContextCallee(void) {
            this->meth = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10) {
            return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, this->ctxt);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new MethodContextCallee<C, CT1>(this->obj, this->meth, this->ctxt);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const MethodContextCallee* r = dynamic_cast<const MethodContextCallee*>(&rhs);
            return (r != NULL) && (&r->obj == &this->obj) && (r->meth == this->meth) && (r->ctxt == this->ctxt);
        }

    private:
        /** The object */
        C& obj;

        /** The method pointer */
        Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, CT1);

        /** The user data context */
        CT1 ctxt;
    };

    /** The callee target */
    AbstractCallee* callee;
};


/**
 * Template specialication for delegate functions with 9 parameters
 */
template<class Rv, class P1, class P2, class P3, class P4, class P5, class P6, class P7, class P8, class P9>
class Delegate<Rv, P1, P2, P3, P4, P5, P6, P7, P8, P9, void> {
public:
    /**
     * Ctor
     */
    Delegate(void) : callee(NULL) {
        // intentionally empty
    }

    /**
     * Copy ctor
     *
     * @param src The object to clone from
     */
    Delegate(const Delegate& src) : callee(NULL) {
        (*this) = src;
    }

    /**
     * Ctor
     *
     * @param funcPtr Function pointer to be set
     */
    Delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9))
            : callee((funcPtr == NULL) ? NULL : new FunctionCallee(funcPtr)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param funcPtr Function pointer to be set
     * @param ctxt The user data context used when calling the function
     */
    template<class CT1, class CT2>
    Delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, CT1), CT2 ctxt)
            : callee((funcPtr == NULL) ? NULL : new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     */
    template<class C>
    Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9)) : callee(new MethodCallee<C>(obj, methPtr)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     * @param ctxt The user data context used when calling the method
     */
    template<class C, class CT1, class CT2>
    Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, CT1), CT2 ctxt)
            : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
        // intentionally empty
    }

    /**
     * Dtor
     *
     * Note that no memory will be freed (user data context, etc.)
     */
    ~Delegate(void) {
        SAFE_DELETE(this->callee);
    }

    /**
     * Answer whether the target for this delegate is set
     *
     * @return True if the target for this delegate is set
     */
    inline bool IsTargetSet(void) const {
        return this->callee != NULL;
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     */
    void Set(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9)) {
        SAFE_DELETE(this->callee);
        if (funcPtr != NULL) {
            this->callee = new FunctionCallee(funcPtr);
        }
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     * @param ctxt The user data context used when calling the function
     */
    template<class CT1, class CT2>
    void Set(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, CT1), CT2 ctxt) {
        SAFE_DELETE(this->callee);
        if (funcPtr != NULL) {
            this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
        }
    }

    /**
     * Sets the target for this delegate
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     */
    template<class C>
    void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9)) {
        SAFE_DELETE(this->callee);
        this->callee = new MethodCallee<C>(obj, methPtr);
    }

    /**
     * Sets the target for this delegate
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     * @param ctxt The user data context used when calling the method
     */
    template<class C, class CT1, class CT2>
    void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, CT1), CT2 ctxt) {
        SAFE_DELETE(this->callee);
        this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
    }

    /**
     * Unsets the target for this delegate
     *
     * Note that no memory will be freed (user data context, etc.)
     */
    void Unset(void) {
        SAFE_DELETE(this->callee);
    }

    /**
     * Calls the delegate's target
     *
     * Parameter and return value depend on the template arguments of the delegate
     */
    Rv operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
        if (this->callee == NULL) {
            throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
        }
        return this->callee->Call(p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    /**
     * Test for equality
     *
     * @param rhs The right hand side operand
     *
     * @return True if this and rhs are equal
     */
    bool operator==(const Delegate& rhs) const {
        if (this->callee == NULL) {
            return (rhs.callee == NULL);
        }
        return this->callee->Equals(*rhs.callee);
    }

    /**
     * Assignment operator
     *
     * @param rhs The right hand side operand
     *
     * @return A reference to this object
     */
    Delegate& operator=(const Delegate& rhs) {
        SAFE_DELETE(this->callee);
        if (rhs.callee != NULL) {
            this->callee = rhs.callee->Clone();
        }
        return *this;
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     *
     * @return A reference to this object
     */
    Delegate& operator=(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9)) {
        this->Set(funcPtr);
        return *this;
    }

private:
    /**
     * abstract base class for callee implementations
     */
    class AbstractCallee {
    public:
        /** Ctor */
        AbstractCallee(void) {
            // intentionally empty
        }

        /** Dtor */
        virtual ~AbstractCallee(void) {
            // intentionally empty
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) = 0;

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) = 0;

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) = 0;
    };

    /**
     * Callee implementation for functions
     */
    class FunctionCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The function pointer (must not be NULL)
         */
        FunctionCallee(Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, P9)) : AbstractCallee(), func(func) {
            ASSERT(this->func != NULL);
        }

        /** Dtor */
        virtual ~FunctionCallee(void) {
            this->func = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
            return this->func(p1, p2, p3, p4, p5, p6, p7, p8, p9);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new FunctionCallee(this->func);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const FunctionCallee* r = dynamic_cast<const FunctionCallee*>(&rhs);
            return (r != NULL) && (r->func == this->func);
        }

    private:
        /** The function pointer */
        Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, P9);
    };

    /**
     * Callee implementation for functions with user data context
     */
    template<class CT1>
    class FunctionContextCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The function pointer (must not be NULL)
         * @param ctxt The user data context
         */
        FunctionContextCallee(Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, P9, CT1), CT1 ctxt)
                : AbstractCallee()
                , func(func)
                , ctxt(ctxt) {
            ASSERT(this->func != NULL);
        }

        /** Dtor */
        virtual ~FunctionContextCallee(void) {
            this->func = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
            return this->func(p1, p2, p3, p4, p5, p6, p7, p8, p9, this->ctxt);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new FunctionContextCallee<CT1>(this->func, this->ctxt);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const FunctionContextCallee* r = dynamic_cast<const FunctionContextCallee*>(&rhs);
            return (r != NULL) && (r->func == this->func) && (r->ctxt == this->ctxt);
        }

    private:
        /** The function pointer */
        Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, P9, CT1);

        /** The user data context */
        CT1 ctxt;
    };

    /**
     * Callee implementation for methods
     */
    template<class C>
    class MethodCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The method pointer (must not be NULL)
         * @param ctxt The user data context
         */
        MethodCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, P9))
                : AbstractCallee()
                , obj(obj)
                , meth(meth) {
            ASSERT(this->meth != NULL);
        }

        /** Dtor */
        virtual ~MethodCallee(void) {
            this->meth = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
            return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, p7, p8, p9);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new MethodCallee<C>(this->obj, this->meth);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const MethodCallee* r = dynamic_cast<const MethodCallee*>(&rhs);
            return (r != NULL) && (&r->obj == &this->obj) && (r->meth == this->meth);
        }

    private:
        /** The object */
        C& obj;

        /** The method pointer */
        Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, P9);
    };

    /**
     * Callee implementation for methods with user data context
     */
    template<class C, class CT1>
    class MethodContextCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param obj The object
         * @param func The method pointer (must not be NULL)
         * @param ctxt The user data context
         */
        MethodContextCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, P9, CT1), CT1 ctxt)
                : AbstractCallee()
                , obj(obj)
                , meth(meth)
                , ctxt(ctxt) {
            ASSERT(this->meth != NULL);
        }

        /** Dtor */
        virtual ~MethodContextCallee(void) {
            this->meth = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
            return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, p7, p8, p9, this->ctxt);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new MethodContextCallee<C, CT1>(this->obj, this->meth, this->ctxt);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const MethodContextCallee* r = dynamic_cast<const MethodContextCallee*>(&rhs);
            return (r != NULL) && (&r->obj == &this->obj) && (r->meth == this->meth) && (r->ctxt == this->ctxt);
        }

    private:
        /** The object */
        C& obj;

        /** The method pointer */
        Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, P9, CT1);

        /** The user data context */
        CT1 ctxt;
    };

    /** The callee target */
    AbstractCallee* callee;
};


/**
 * Template specialication for delegate functions with 8 parameters
 */
template<class Rv, class P1, class P2, class P3, class P4, class P5, class P6, class P7, class P8>
class Delegate<Rv, P1, P2, P3, P4, P5, P6, P7, P8, void, void> {
public:
    /**
     * Ctor
     */
    Delegate(void) : callee(NULL) {
        // intentionally empty
    }

    /**
     * Copy ctor
     *
     * @param src The object to clone from
     */
    Delegate(const Delegate& src) : callee(NULL) {
        (*this) = src;
    }

    /**
     * Ctor
     *
     * @param funcPtr Function pointer to be set
     */
    Delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8))
            : callee((funcPtr == NULL) ? NULL : new FunctionCallee(funcPtr)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param funcPtr Function pointer to be set
     * @param ctxt The user data context used when calling the function
     */
    template<class CT1, class CT2>
    Delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, CT1), CT2 ctxt)
            : callee((funcPtr == NULL) ? NULL : new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     */
    template<class C>
    Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8)) : callee(new MethodCallee<C>(obj, methPtr)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     * @param ctxt The user data context used when calling the method
     */
    template<class C, class CT1, class CT2>
    Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8, CT1), CT2 ctxt)
            : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
        // intentionally empty
    }

    /**
     * Dtor
     *
     * Note that no memory will be freed (user data context, etc.)
     */
    ~Delegate(void) {
        SAFE_DELETE(this->callee);
    }

    /**
     * Answer whether the target for this delegate is set
     *
     * @return True if the target for this delegate is set
     */
    inline bool IsTargetSet(void) const {
        return this->callee != NULL;
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     */
    void Set(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8)) {
        SAFE_DELETE(this->callee);
        if (funcPtr != NULL) {
            this->callee = new FunctionCallee(funcPtr);
        }
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     * @param ctxt The user data context used when calling the function
     */
    template<class CT1, class CT2>
    void Set(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, CT1), CT2 ctxt) {
        SAFE_DELETE(this->callee);
        if (funcPtr != NULL) {
            this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
        }
    }

    /**
     * Sets the target for this delegate
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     */
    template<class C>
    void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8)) {
        SAFE_DELETE(this->callee);
        this->callee = new MethodCallee<C>(obj, methPtr);
    }

    /**
     * Sets the target for this delegate
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     * @param ctxt The user data context used when calling the method
     */
    template<class C, class CT1, class CT2>
    void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8, CT1), CT2 ctxt) {
        SAFE_DELETE(this->callee);
        this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
    }

    /**
     * Unsets the target for this delegate
     *
     * Note that no memory will be freed (user data context, etc.)
     */
    void Unset(void) {
        SAFE_DELETE(this->callee);
    }

    /**
     * Calls the delegate's target
     *
     * Parameter and return value depend on the template arguments of the delegate
     */
    Rv operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
        if (this->callee == NULL) {
            throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
        }
        return this->callee->Call(p1, p2, p3, p4, p5, p6, p7, p8);
    }

    /**
     * Test for equality
     *
     * @param rhs The right hand side operand
     *
     * @return True if this and rhs are equal
     */
    bool operator==(const Delegate& rhs) const {
        if (this->callee == NULL) {
            return (rhs.callee == NULL);
        }
        return this->callee->Equals(*rhs.callee);
    }

    /**
     * Assignment operator
     *
     * @param rhs The right hand side operand
     *
     * @return A reference to this object
     */
    Delegate& operator=(const Delegate& rhs) {
        SAFE_DELETE(this->callee);
        if (rhs.callee != NULL) {
            this->callee = rhs.callee->Clone();
        }
        return *this;
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     *
     * @return A reference to this object
     */
    Delegate& operator=(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8)) {
        this->Set(funcPtr);
        return *this;
    }

private:
    /**
     * abstract base class for callee implementations
     */
    class AbstractCallee {
    public:
        /** Ctor */
        AbstractCallee(void) {
            // intentionally empty
        }

        /** Dtor */
        virtual ~AbstractCallee(void) {
            // intentionally empty
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) = 0;

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) = 0;

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) = 0;
    };

    /**
     * Callee implementation for functions
     */
    class FunctionCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The function pointer (must not be NULL)
         */
        FunctionCallee(Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8)) : AbstractCallee(), func(func) {
            ASSERT(this->func != NULL);
        }

        /** Dtor */
        virtual ~FunctionCallee(void) {
            this->func = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
            return this->func(p1, p2, p3, p4, p5, p6, p7, p8);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new FunctionCallee(this->func);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const FunctionCallee* r = dynamic_cast<const FunctionCallee*>(&rhs);
            return (r != NULL) && (r->func == this->func);
        }

    private:
        /** The function pointer */
        Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8);
    };

    /**
     * Callee implementation for functions with user data context
     */
    template<class CT1>
    class FunctionContextCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The function pointer (must not be NULL)
         * @param ctxt The user data context
         */
        FunctionContextCallee(Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, CT1), CT1 ctxt)
                : AbstractCallee()
                , func(func)
                , ctxt(ctxt) {
            ASSERT(this->func != NULL);
        }

        /** Dtor */
        virtual ~FunctionContextCallee(void) {
            this->func = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
            return this->func(p1, p2, p3, p4, p5, p6, p7, p8, this->ctxt);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new FunctionContextCallee<CT1>(this->func, this->ctxt);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const FunctionContextCallee* r = dynamic_cast<const FunctionContextCallee*>(&rhs);
            return (r != NULL) && (r->func == this->func) && (r->ctxt == this->ctxt);
        }

    private:
        /** The function pointer */
        Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, CT1);

        /** The user data context */
        CT1 ctxt;
    };

    /**
     * Callee implementation for methods
     */
    template<class C>
    class MethodCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The method pointer (must not be NULL)
         * @param ctxt The user data context
         */
        MethodCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8)) : AbstractCallee(), obj(obj), meth(meth) {
            ASSERT(this->meth != NULL);
        }

        /** Dtor */
        virtual ~MethodCallee(void) {
            this->meth = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
            return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, p7, p8);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new MethodCallee<C>(this->obj, this->meth);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const MethodCallee* r = dynamic_cast<const MethodCallee*>(&rhs);
            return (r != NULL) && (&r->obj == &this->obj) && (r->meth == this->meth);
        }

    private:
        /** The object */
        C& obj;

        /** The method pointer */
        Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8);
    };

    /**
     * Callee implementation for methods with user data context
     */
    template<class C, class CT1>
    class MethodContextCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param obj The object
         * @param func The method pointer (must not be NULL)
         * @param ctxt The user data context
         */
        MethodContextCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, CT1), CT1 ctxt)
                : AbstractCallee()
                , obj(obj)
                , meth(meth)
                , ctxt(ctxt) {
            ASSERT(this->meth != NULL);
        }

        /** Dtor */
        virtual ~MethodContextCallee(void) {
            this->meth = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
            return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, p7, p8, this->ctxt);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new MethodContextCallee<C, CT1>(this->obj, this->meth, this->ctxt);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const MethodContextCallee* r = dynamic_cast<const MethodContextCallee*>(&rhs);
            return (r != NULL) && (&r->obj == &this->obj) && (r->meth == this->meth) && (r->ctxt == this->ctxt);
        }

    private:
        /** The object */
        C& obj;

        /** The method pointer */
        Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, CT1);

        /** The user data context */
        CT1 ctxt;
    };

    /** The callee target */
    AbstractCallee* callee;
};


/**
 * Template specialication for delegate functions with 7 parameters
 */
template<class Rv, class P1, class P2, class P3, class P4, class P5, class P6, class P7>
class Delegate<Rv, P1, P2, P3, P4, P5, P6, P7, void, void, void> {
public:
    /**
     * Ctor
     */
    Delegate(void) : callee(NULL) {
        // intentionally empty
    }

    /**
     * Copy ctor
     *
     * @param src The object to clone from
     */
    Delegate(const Delegate& src) : callee(NULL) {
        (*this) = src;
    }

    /**
     * Ctor
     *
     * @param funcPtr Function pointer to be set
     */
    Delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7))
            : callee((funcPtr == NULL) ? NULL : new FunctionCallee(funcPtr)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param funcPtr Function pointer to be set
     * @param ctxt The user data context used when calling the function
     */
    template<class CT1, class CT2>
    Delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, CT1), CT2 ctxt)
            : callee((funcPtr == NULL) ? NULL : new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     */
    template<class C>
    Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7)) : callee(new MethodCallee<C>(obj, methPtr)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     * @param ctxt The user data context used when calling the method
     */
    template<class C, class CT1, class CT2>
    Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, CT1), CT2 ctxt)
            : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
        // intentionally empty
    }

    /**
     * Dtor
     *
     * Note that no memory will be freed (user data context, etc.)
     */
    ~Delegate(void) {
        SAFE_DELETE(this->callee);
    }

    /**
     * Answer whether the target for this delegate is set
     *
     * @return True if the target for this delegate is set
     */
    inline bool IsTargetSet(void) const {
        return this->callee != NULL;
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     */
    void Set(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7)) {
        SAFE_DELETE(this->callee);
        if (funcPtr != NULL) {
            this->callee = new FunctionCallee(funcPtr);
        }
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     * @param ctxt The user data context used when calling the function
     */
    template<class CT1, class CT2>
    void Set(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, CT1), CT2 ctxt) {
        SAFE_DELETE(this->callee);
        if (funcPtr != NULL) {
            this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
        }
    }

    /**
     * Sets the target for this delegate
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     */
    template<class C>
    void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7)) {
        SAFE_DELETE(this->callee);
        this->callee = new MethodCallee<C>(obj, methPtr);
    }

    /**
     * Sets the target for this delegate
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     * @param ctxt The user data context used when calling the method
     */
    template<class C, class CT1, class CT2>
    void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, CT1), CT2 ctxt) {
        SAFE_DELETE(this->callee);
        this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
    }

    /**
     * Unsets the target for this delegate
     *
     * Note that no memory will be freed (user data context, etc.)
     */
    void Unset(void) {
        SAFE_DELETE(this->callee);
    }

    /**
     * Calls the delegate's target
     *
     * Parameter and return value depend on the template arguments of the delegate
     */
    Rv operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
        if (this->callee == NULL) {
            throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
        }
        return this->callee->Call(p1, p2, p3, p4, p5, p6, p7);
    }

    /**
     * Test for equality
     *
     * @param rhs The right hand side operand
     *
     * @return True if this and rhs are equal
     */
    bool operator==(const Delegate& rhs) const {
        if (this->callee == NULL) {
            return (rhs.callee == NULL);
        }
        return this->callee->Equals(*rhs.callee);
    }

    /**
     * Assignment operator
     *
     * @param rhs The right hand side operand
     *
     * @return A reference to this object
     */
    Delegate& operator=(const Delegate& rhs) {
        SAFE_DELETE(this->callee);
        if (rhs.callee != NULL) {
            this->callee = rhs.callee->Clone();
        }
        return *this;
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     *
     * @return A reference to this object
     */
    Delegate& operator=(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7)) {
        this->Set(funcPtr);
        return *this;
    }

private:
    /**
     * abstract base class for callee implementations
     */
    class AbstractCallee {
    public:
        /** Ctor */
        AbstractCallee(void) {
            // intentionally empty
        }

        /** Dtor */
        virtual ~AbstractCallee(void) {
            // intentionally empty
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) = 0;

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) = 0;

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) = 0;
    };

    /**
     * Callee implementation for functions
     */
    class FunctionCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The function pointer (must not be NULL)
         */
        FunctionCallee(Rv (*func)(P1, P2, P3, P4, P5, P6, P7)) : AbstractCallee(), func(func) {
            ASSERT(this->func != NULL);
        }

        /** Dtor */
        virtual ~FunctionCallee(void) {
            this->func = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
            return this->func(p1, p2, p3, p4, p5, p6, p7);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new FunctionCallee(this->func);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const FunctionCallee* r = dynamic_cast<const FunctionCallee*>(&rhs);
            return (r != NULL) && (r->func == this->func);
        }

    private:
        /** The function pointer */
        Rv (*func)(P1, P2, P3, P4, P5, P6, P7);
    };

    /**
     * Callee implementation for functions with user data context
     */
    template<class CT1>
    class FunctionContextCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The function pointer (must not be NULL)
         * @param ctxt The user data context
         */
        FunctionContextCallee(Rv (*func)(P1, P2, P3, P4, P5, P6, P7, CT1), CT1 ctxt)
                : AbstractCallee()
                , func(func)
                , ctxt(ctxt) {
            ASSERT(this->func != NULL);
        }

        /** Dtor */
        virtual ~FunctionContextCallee(void) {
            this->func = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
            return this->func(p1, p2, p3, p4, p5, p6, p7, this->ctxt);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new FunctionContextCallee<CT1>(this->func, this->ctxt);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const FunctionContextCallee* r = dynamic_cast<const FunctionContextCallee*>(&rhs);
            return (r != NULL) && (r->func == this->func) && (r->ctxt == this->ctxt);
        }

    private:
        /** The function pointer */
        Rv (*func)(P1, P2, P3, P4, P5, P6, P7, CT1);

        /** The user data context */
        CT1 ctxt;
    };

    /**
     * Callee implementation for methods
     */
    template<class C>
    class MethodCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The method pointer (must not be NULL)
         * @param ctxt The user data context
         */
        MethodCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7)) : AbstractCallee(), obj(obj), meth(meth) {
            ASSERT(this->meth != NULL);
        }

        /** Dtor */
        virtual ~MethodCallee(void) {
            this->meth = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
            return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, p7);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new MethodCallee<C>(this->obj, this->meth);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const MethodCallee* r = dynamic_cast<const MethodCallee*>(&rhs);
            return (r != NULL) && (&r->obj == &this->obj) && (r->meth == this->meth);
        }

    private:
        /** The object */
        C& obj;

        /** The method pointer */
        Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7);
    };

    /**
     * Callee implementation for methods with user data context
     */
    template<class C, class CT1>
    class MethodContextCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param obj The object
         * @param func The method pointer (must not be NULL)
         * @param ctxt The user data context
         */
        MethodContextCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, CT1), CT1 ctxt)
                : AbstractCallee()
                , obj(obj)
                , meth(meth)
                , ctxt(ctxt) {
            ASSERT(this->meth != NULL);
        }

        /** Dtor */
        virtual ~MethodContextCallee(void) {
            this->meth = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
            return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, p7, this->ctxt);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new MethodContextCallee<C, CT1>(this->obj, this->meth, this->ctxt);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const MethodContextCallee* r = dynamic_cast<const MethodContextCallee*>(&rhs);
            return (r != NULL) && (&r->obj == &this->obj) && (r->meth == this->meth) && (r->ctxt == this->ctxt);
        }

    private:
        /** The object */
        C& obj;

        /** The method pointer */
        Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, CT1);

        /** The user data context */
        CT1 ctxt;
    };

    /** The callee target */
    AbstractCallee* callee;
};


/**
 * Template specialication for delegate functions with 6 parameters
 */
template<class Rv, class P1, class P2, class P3, class P4, class P5, class P6>
class Delegate<Rv, P1, P2, P3, P4, P5, P6, void, void, void, void> {
public:
    /**
     * Ctor
     */
    Delegate(void) : callee(NULL) {
        // intentionally empty
    }

    /**
     * Copy ctor
     *
     * @param src The object to clone from
     */
    Delegate(const Delegate& src) : callee(NULL) {
        (*this) = src;
    }

    /**
     * Ctor
     *
     * @param funcPtr Function pointer to be set
     */
    Delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6)) : callee((funcPtr == NULL) ? NULL : new FunctionCallee(funcPtr)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param funcPtr Function pointer to be set
     * @param ctxt The user data context used when calling the function
     */
    template<class CT1, class CT2>
    Delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, CT1), CT2 ctxt)
            : callee((funcPtr == NULL) ? NULL : new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     */
    template<class C>
    Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6)) : callee(new MethodCallee<C>(obj, methPtr)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     * @param ctxt The user data context used when calling the method
     */
    template<class C, class CT1, class CT2>
    Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, CT1), CT2 ctxt)
            : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
        // intentionally empty
    }

    /**
     * Dtor
     *
     * Note that no memory will be freed (user data context, etc.)
     */
    ~Delegate(void) {
        SAFE_DELETE(this->callee);
    }

    /**
     * Answer whether the target for this delegate is set
     *
     * @return True if the target for this delegate is set
     */
    inline bool IsTargetSet(void) const {
        return this->callee != NULL;
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     */
    void Set(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6)) {
        SAFE_DELETE(this->callee);
        if (funcPtr != NULL) {
            this->callee = new FunctionCallee(funcPtr);
        }
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     * @param ctxt The user data context used when calling the function
     */
    template<class CT1, class CT2>
    void Set(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, CT1), CT2 ctxt) {
        SAFE_DELETE(this->callee);
        if (funcPtr != NULL) {
            this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
        }
    }

    /**
     * Sets the target for this delegate
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     */
    template<class C>
    void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6)) {
        SAFE_DELETE(this->callee);
        this->callee = new MethodCallee<C>(obj, methPtr);
    }

    /**
     * Sets the target for this delegate
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     * @param ctxt The user data context used when calling the method
     */
    template<class C, class CT1, class CT2>
    void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, CT1), CT2 ctxt) {
        SAFE_DELETE(this->callee);
        this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
    }

    /**
     * Unsets the target for this delegate
     *
     * Note that no memory will be freed (user data context, etc.)
     */
    void Unset(void) {
        SAFE_DELETE(this->callee);
    }

    /**
     * Calls the delegate's target
     *
     * Parameter and return value depend on the template arguments of the delegate
     */
    Rv operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
        if (this->callee == NULL) {
            throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
        }
        return this->callee->Call(p1, p2, p3, p4, p5, p6);
    }

    /**
     * Test for equality
     *
     * @param rhs The right hand side operand
     *
     * @return True if this and rhs are equal
     */
    bool operator==(const Delegate& rhs) const {
        if (this->callee == NULL) {
            return (rhs.callee == NULL);
        }
        return this->callee->Equals(*rhs.callee);
    }

    /**
     * Assignment operator
     *
     * @param rhs The right hand side operand
     *
     * @return A reference to this object
     */
    Delegate& operator=(const Delegate& rhs) {
        SAFE_DELETE(this->callee);
        if (rhs.callee != NULL) {
            this->callee = rhs.callee->Clone();
        }
        return *this;
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     *
     * @return A reference to this object
     */
    Delegate& operator=(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6)) {
        this->Set(funcPtr);
        return *this;
    }

private:
    /**
     * abstract base class for callee implementations
     */
    class AbstractCallee {
    public:
        /** Ctor */
        AbstractCallee(void) {
            // intentionally empty
        }

        /** Dtor */
        virtual ~AbstractCallee(void) {
            // intentionally empty
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) = 0;

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) = 0;

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) = 0;
    };

    /**
     * Callee implementation for functions
     */
    class FunctionCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The function pointer (must not be NULL)
         */
        FunctionCallee(Rv (*func)(P1, P2, P3, P4, P5, P6)) : AbstractCallee(), func(func) {
            ASSERT(this->func != NULL);
        }

        /** Dtor */
        virtual ~FunctionCallee(void) {
            this->func = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
            return this->func(p1, p2, p3, p4, p5, p6);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new FunctionCallee(this->func);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const FunctionCallee* r = dynamic_cast<const FunctionCallee*>(&rhs);
            return (r != NULL) && (r->func == this->func);
        }

    private:
        /** The function pointer */
        Rv (*func)(P1, P2, P3, P4, P5, P6);
    };

    /**
     * Callee implementation for functions with user data context
     */
    template<class CT1>
    class FunctionContextCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The function pointer (must not be NULL)
         * @param ctxt The user data context
         */
        FunctionContextCallee(Rv (*func)(P1, P2, P3, P4, P5, P6, CT1), CT1 ctxt)
                : AbstractCallee()
                , func(func)
                , ctxt(ctxt) {
            ASSERT(this->func != NULL);
        }

        /** Dtor */
        virtual ~FunctionContextCallee(void) {
            this->func = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
            return this->func(p1, p2, p3, p4, p5, p6, this->ctxt);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new FunctionContextCallee<CT1>(this->func, this->ctxt);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const FunctionContextCallee* r = dynamic_cast<const FunctionContextCallee*>(&rhs);
            return (r != NULL) && (r->func == this->func) && (r->ctxt == this->ctxt);
        }

    private:
        /** The function pointer */
        Rv (*func)(P1, P2, P3, P4, P5, P6, CT1);

        /** The user data context */
        CT1 ctxt;
    };

    /**
     * Callee implementation for methods
     */
    template<class C>
    class MethodCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The method pointer (must not be NULL)
         * @param ctxt The user data context
         */
        MethodCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6)) : AbstractCallee(), obj(obj), meth(meth) {
            ASSERT(this->meth != NULL);
        }

        /** Dtor */
        virtual ~MethodCallee(void) {
            this->meth = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
            return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new MethodCallee<C>(this->obj, this->meth);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const MethodCallee* r = dynamic_cast<const MethodCallee*>(&rhs);
            return (r != NULL) && (&r->obj == &this->obj) && (r->meth == this->meth);
        }

    private:
        /** The object */
        C& obj;

        /** The method pointer */
        Rv (C::*meth)(P1, P2, P3, P4, P5, P6);
    };

    /**
     * Callee implementation for methods with user data context
     */
    template<class C, class CT1>
    class MethodContextCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param obj The object
         * @param func The method pointer (must not be NULL)
         * @param ctxt The user data context
         */
        MethodContextCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, CT1), CT1 ctxt)
                : AbstractCallee()
                , obj(obj)
                , meth(meth)
                , ctxt(ctxt) {
            ASSERT(this->meth != NULL);
        }

        /** Dtor */
        virtual ~MethodContextCallee(void) {
            this->meth = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
            return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, this->ctxt);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new MethodContextCallee<C, CT1>(this->obj, this->meth, this->ctxt);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const MethodContextCallee* r = dynamic_cast<const MethodContextCallee*>(&rhs);
            return (r != NULL) && (&r->obj == &this->obj) && (r->meth == this->meth) && (r->ctxt == this->ctxt);
        }

    private:
        /** The object */
        C& obj;

        /** The method pointer */
        Rv (C::*meth)(P1, P2, P3, P4, P5, P6, CT1);

        /** The user data context */
        CT1 ctxt;
    };

    /** The callee target */
    AbstractCallee* callee;
};


/**
 * Template specialication for delegate functions with 5 parameters
 */
template<class Rv, class P1, class P2, class P3, class P4, class P5>
class Delegate<Rv, P1, P2, P3, P4, P5, void, void, void, void, void> {
public:
    /**
     * Ctor
     */
    Delegate(void) : callee(NULL) {
        // intentionally empty
    }

    /**
     * Copy ctor
     *
     * @param src The object to clone from
     */
    Delegate(const Delegate& src) : callee(NULL) {
        (*this) = src;
    }

    /**
     * Ctor
     *
     * @param funcPtr Function pointer to be set
     */
    Delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5)) : callee((funcPtr == NULL) ? NULL : new FunctionCallee(funcPtr)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param funcPtr Function pointer to be set
     * @param ctxt The user data context used when calling the function
     */
    template<class CT1, class CT2>
    Delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, CT1), CT2 ctxt)
            : callee((funcPtr == NULL) ? NULL : new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     */
    template<class C>
    Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5)) : callee(new MethodCallee<C>(obj, methPtr)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     * @param ctxt The user data context used when calling the method
     */
    template<class C, class CT1, class CT2>
    Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, CT1), CT2 ctxt)
            : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
        // intentionally empty
    }

    /**
     * Dtor
     *
     * Note that no memory will be freed (user data context, etc.)
     */
    ~Delegate(void) {
        SAFE_DELETE(this->callee);
    }

    /**
     * Answer whether the target for this delegate is set
     *
     * @return True if the target for this delegate is set
     */
    inline bool IsTargetSet(void) const {
        return this->callee != NULL;
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     */
    void Set(Rv (*funcPtr)(P1, P2, P3, P4, P5)) {
        SAFE_DELETE(this->callee);
        if (funcPtr != NULL) {
            this->callee = new FunctionCallee(funcPtr);
        }
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     * @param ctxt The user data context used when calling the function
     */
    template<class CT1, class CT2>
    void Set(Rv (*funcPtr)(P1, P2, P3, P4, P5, CT1), CT2 ctxt) {
        SAFE_DELETE(this->callee);
        if (funcPtr != NULL) {
            this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
        }
    }

    /**
     * Sets the target for this delegate
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     */
    template<class C>
    void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5)) {
        SAFE_DELETE(this->callee);
        this->callee = new MethodCallee<C>(obj, methPtr);
    }

    /**
     * Sets the target for this delegate
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     * @param ctxt The user data context used when calling the method
     */
    template<class C, class CT1, class CT2>
    void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, CT1), CT2 ctxt) {
        SAFE_DELETE(this->callee);
        this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
    }

    /**
     * Unsets the target for this delegate
     *
     * Note that no memory will be freed (user data context, etc.)
     */
    void Unset(void) {
        SAFE_DELETE(this->callee);
    }

    /**
     * Calls the delegate's target
     *
     * Parameter and return value depend on the template arguments of the delegate
     */
    Rv operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
        if (this->callee == NULL) {
            throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
        }
        return this->callee->Call(p1, p2, p3, p4, p5);
    }

    /**
     * Test for equality
     *
     * @param rhs The right hand side operand
     *
     * @return True if this and rhs are equal
     */
    bool operator==(const Delegate& rhs) const {
        if (this->callee == NULL) {
            return (rhs.callee == NULL);
        }
        return this->callee->Equals(*rhs.callee);
    }

    /**
     * Assignment operator
     *
     * @param rhs The right hand side operand
     *
     * @return A reference to this object
     */
    Delegate& operator=(const Delegate& rhs) {
        SAFE_DELETE(this->callee);
        if (rhs.callee != NULL) {
            this->callee = rhs.callee->Clone();
        }
        return *this;
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     *
     * @return A reference to this object
     */
    Delegate& operator=(Rv (*funcPtr)(P1, P2, P3, P4, P5)) {
        this->Set(funcPtr);
        return *this;
    }

private:
    /**
     * abstract base class for callee implementations
     */
    class AbstractCallee {
    public:
        /** Ctor */
        AbstractCallee(void) {
            // intentionally empty
        }

        /** Dtor */
        virtual ~AbstractCallee(void) {
            // intentionally empty
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) = 0;

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) = 0;

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) = 0;
    };

    /**
     * Callee implementation for functions
     */
    class FunctionCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The function pointer (must not be NULL)
         */
        FunctionCallee(Rv (*func)(P1, P2, P3, P4, P5)) : AbstractCallee(), func(func) {
            ASSERT(this->func != NULL);
        }

        /** Dtor */
        virtual ~FunctionCallee(void) {
            this->func = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
            return this->func(p1, p2, p3, p4, p5);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new FunctionCallee(this->func);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const FunctionCallee* r = dynamic_cast<const FunctionCallee*>(&rhs);
            return (r != NULL) && (r->func == this->func);
        }

    private:
        /** The function pointer */
        Rv (*func)(P1, P2, P3, P4, P5);
    };

    /**
     * Callee implementation for functions with user data context
     */
    template<class CT1>
    class FunctionContextCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The function pointer (must not be NULL)
         * @param ctxt The user data context
         */
        FunctionContextCallee(Rv (*func)(P1, P2, P3, P4, P5, CT1), CT1 ctxt)
                : AbstractCallee()
                , func(func)
                , ctxt(ctxt) {
            ASSERT(this->func != NULL);
        }

        /** Dtor */
        virtual ~FunctionContextCallee(void) {
            this->func = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
            return this->func(p1, p2, p3, p4, p5, this->ctxt);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new FunctionContextCallee<CT1>(this->func, this->ctxt);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const FunctionContextCallee* r = dynamic_cast<const FunctionContextCallee*>(&rhs);
            return (r != NULL) && (r->func == this->func) && (r->ctxt == this->ctxt);
        }

    private:
        /** The function pointer */
        Rv (*func)(P1, P2, P3, P4, P5, CT1);

        /** The user data context */
        CT1 ctxt;
    };

    /**
     * Callee implementation for methods
     */
    template<class C>
    class MethodCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The method pointer (must not be NULL)
         * @param ctxt The user data context
         */
        MethodCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5)) : AbstractCallee(), obj(obj), meth(meth) {
            ASSERT(this->meth != NULL);
        }

        /** Dtor */
        virtual ~MethodCallee(void) {
            this->meth = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
            return (this->obj.*this->meth)(p1, p2, p3, p4, p5);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new MethodCallee<C>(this->obj, this->meth);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const MethodCallee* r = dynamic_cast<const MethodCallee*>(&rhs);
            return (r != NULL) && (&r->obj == &this->obj) && (r->meth == this->meth);
        }

    private:
        /** The object */
        C& obj;

        /** The method pointer */
        Rv (C::*meth)(P1, P2, P3, P4, P5);
    };

    /**
     * Callee implementation for methods with user data context
     */
    template<class C, class CT1>
    class MethodContextCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param obj The object
         * @param func The method pointer (must not be NULL)
         * @param ctxt The user data context
         */
        MethodContextCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, CT1), CT1 ctxt)
                : AbstractCallee()
                , obj(obj)
                , meth(meth)
                , ctxt(ctxt) {
            ASSERT(this->meth != NULL);
        }

        /** Dtor */
        virtual ~MethodContextCallee(void) {
            this->meth = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
            return (this->obj.*this->meth)(p1, p2, p3, p4, p5, this->ctxt);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new MethodContextCallee<C, CT1>(this->obj, this->meth, this->ctxt);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const MethodContextCallee* r = dynamic_cast<const MethodContextCallee*>(&rhs);
            return (r != NULL) && (&r->obj == &this->obj) && (r->meth == this->meth) && (r->ctxt == this->ctxt);
        }

    private:
        /** The object */
        C& obj;

        /** The method pointer */
        Rv (C::*meth)(P1, P2, P3, P4, P5, CT1);

        /** The user data context */
        CT1 ctxt;
    };

    /** The callee target */
    AbstractCallee* callee;
};


/**
 * Template specialication for delegate functions with 4 parameters
 */
template<class Rv, class P1, class P2, class P3, class P4>
class Delegate<Rv, P1, P2, P3, P4, void, void, void, void, void, void> {
public:
    /**
     * Ctor
     */
    Delegate(void) : callee(NULL) {
        // intentionally empty
    }

    /**
     * Copy ctor
     *
     * @param src The object to clone from
     */
    Delegate(const Delegate& src) : callee(NULL) {
        (*this) = src;
    }

    /**
     * Ctor
     *
     * @param funcPtr Function pointer to be set
     */
    Delegate(Rv (*funcPtr)(P1, P2, P3, P4)) : callee((funcPtr == NULL) ? NULL : new FunctionCallee(funcPtr)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param funcPtr Function pointer to be set
     * @param ctxt The user data context used when calling the function
     */
    template<class CT1, class CT2>
    Delegate(Rv (*funcPtr)(P1, P2, P3, P4, CT1), CT2 ctxt)
            : callee((funcPtr == NULL) ? NULL : new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     */
    template<class C>
    Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4)) : callee(new MethodCallee<C>(obj, methPtr)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     * @param ctxt The user data context used when calling the method
     */
    template<class C, class CT1, class CT2>
    Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, CT1), CT2 ctxt)
            : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
        // intentionally empty
    }

    /**
     * Dtor
     *
     * Note that no memory will be freed (user data context, etc.)
     */
    ~Delegate(void) {
        SAFE_DELETE(this->callee);
    }

    /**
     * Answer whether the target for this delegate is set
     *
     * @return True if the target for this delegate is set
     */
    inline bool IsTargetSet(void) const {
        return this->callee != NULL;
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     */
    void Set(Rv (*funcPtr)(P1, P2, P3, P4)) {
        SAFE_DELETE(this->callee);
        if (funcPtr != NULL) {
            this->callee = new FunctionCallee(funcPtr);
        }
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     * @param ctxt The user data context used when calling the function
     */
    template<class CT1, class CT2>
    void Set(Rv (*funcPtr)(P1, P2, P3, P4, CT1), CT2 ctxt) {
        SAFE_DELETE(this->callee);
        if (funcPtr != NULL) {
            this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
        }
    }

    /**
     * Sets the target for this delegate
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     */
    template<class C>
    void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4)) {
        SAFE_DELETE(this->callee);
        this->callee = new MethodCallee<C>(obj, methPtr);
    }

    /**
     * Sets the target for this delegate
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     * @param ctxt The user data context used when calling the method
     */
    template<class C, class CT1, class CT2>
    void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, CT1), CT2 ctxt) {
        SAFE_DELETE(this->callee);
        this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
    }

    /**
     * Unsets the target for this delegate
     *
     * Note that no memory will be freed (user data context, etc.)
     */
    void Unset(void) {
        SAFE_DELETE(this->callee);
    }

    /**
     * Calls the delegate's target
     *
     * Parameter and return value depend on the template arguments of the delegate
     */
    Rv operator()(P1 p1, P2 p2, P3 p3, P4 p4) {
        if (this->callee == NULL) {
            throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
        }
        return this->callee->Call(p1, p2, p3, p4);
    }

    /**
     * Test for equality
     *
     * @param rhs The right hand side operand
     *
     * @return True if this and rhs are equal
     */
    bool operator==(const Delegate& rhs) const {
        if (this->callee == NULL) {
            return (rhs.callee == NULL);
        }
        return this->callee->Equals(*rhs.callee);
    }

    /**
     * Assignment operator
     *
     * @param rhs The right hand side operand
     *
     * @return A reference to this object
     */
    Delegate& operator=(const Delegate& rhs) {
        SAFE_DELETE(this->callee);
        if (rhs.callee != NULL) {
            this->callee = rhs.callee->Clone();
        }
        return *this;
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     *
     * @return A reference to this object
     */
    Delegate& operator=(Rv (*funcPtr)(P1, P2, P3, P4)) {
        this->Set(funcPtr);
        return *this;
    }

private:
    /**
     * abstract base class for callee implementations
     */
    class AbstractCallee {
    public:
        /** Ctor */
        AbstractCallee(void) {
            // intentionally empty
        }

        /** Dtor */
        virtual ~AbstractCallee(void) {
            // intentionally empty
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4) = 0;

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) = 0;

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) = 0;
    };

    /**
     * Callee implementation for functions
     */
    class FunctionCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The function pointer (must not be NULL)
         */
        FunctionCallee(Rv (*func)(P1, P2, P3, P4)) : AbstractCallee(), func(func) {
            ASSERT(this->func != NULL);
        }

        /** Dtor */
        virtual ~FunctionCallee(void) {
            this->func = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4) {
            return this->func(p1, p2, p3, p4);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new FunctionCallee(this->func);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const FunctionCallee* r = dynamic_cast<const FunctionCallee*>(&rhs);
            return (r != NULL) && (r->func == this->func);
        }

    private:
        /** The function pointer */
        Rv (*func)(P1, P2, P3, P4);
    };

    /**
     * Callee implementation for functions with user data context
     */
    template<class CT1>
    class FunctionContextCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The function pointer (must not be NULL)
         * @param ctxt The user data context
         */
        FunctionContextCallee(Rv (*func)(P1, P2, P3, P4, CT1), CT1 ctxt) : AbstractCallee(), func(func), ctxt(ctxt) {
            ASSERT(this->func != NULL);
        }

        /** Dtor */
        virtual ~FunctionContextCallee(void) {
            this->func = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4) {
            return this->func(p1, p2, p3, p4, this->ctxt);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new FunctionContextCallee<CT1>(this->func, this->ctxt);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const FunctionContextCallee* r = dynamic_cast<const FunctionContextCallee*>(&rhs);
            return (r != NULL) && (r->func == this->func) && (r->ctxt == this->ctxt);
        }

    private:
        /** The function pointer */
        Rv (*func)(P1, P2, P3, P4, CT1);

        /** The user data context */
        CT1 ctxt;
    };

    /**
     * Callee implementation for methods
     */
    template<class C>
    class MethodCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The method pointer (must not be NULL)
         * @param ctxt The user data context
         */
        MethodCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4)) : AbstractCallee(), obj(obj), meth(meth) {
            ASSERT(this->meth != NULL);
        }

        /** Dtor */
        virtual ~MethodCallee(void) {
            this->meth = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4) {
            return (this->obj.*this->meth)(p1, p2, p3, p4);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new MethodCallee<C>(this->obj, this->meth);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const MethodCallee* r = dynamic_cast<const MethodCallee*>(&rhs);
            return (r != NULL) && (&r->obj == &this->obj) && (r->meth == this->meth);
        }

    private:
        /** The object */
        C& obj;

        /** The method pointer */
        Rv (C::*meth)(P1, P2, P3, P4);
    };

    /**
     * Callee implementation for methods with user data context
     */
    template<class C, class CT1>
    class MethodContextCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param obj The object
         * @param func The method pointer (must not be NULL)
         * @param ctxt The user data context
         */
        MethodContextCallee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, CT1), CT1 ctxt)
                : AbstractCallee()
                , obj(obj)
                , meth(meth)
                , ctxt(ctxt) {
            ASSERT(this->meth != NULL);
        }

        /** Dtor */
        virtual ~MethodContextCallee(void) {
            this->meth = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3, P4 p4) {
            return (this->obj.*this->meth)(p1, p2, p3, p4, this->ctxt);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new MethodContextCallee<C, CT1>(this->obj, this->meth, this->ctxt);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const MethodContextCallee* r = dynamic_cast<const MethodContextCallee*>(&rhs);
            return (r != NULL) && (&r->obj == &this->obj) && (r->meth == this->meth) && (r->ctxt == this->ctxt);
        }

    private:
        /** The object */
        C& obj;

        /** The method pointer */
        Rv (C::*meth)(P1, P2, P3, P4, CT1);

        /** The user data context */
        CT1 ctxt;
    };

    /** The callee target */
    AbstractCallee* callee;
};


/**
 * Template specialication for delegate functions with 3 parameters
 */
template<class Rv, class P1, class P2, class P3>
class Delegate<Rv, P1, P2, P3, void, void, void, void, void, void, void> {
public:
    /**
     * Ctor
     */
    Delegate(void) : callee(NULL) {
        // intentionally empty
    }

    /**
     * Copy ctor
     *
     * @param src The object to clone from
     */
    Delegate(const Delegate& src) : callee(NULL) {
        (*this) = src;
    }

    /**
     * Ctor
     *
     * @param funcPtr Function pointer to be set
     */
    Delegate(Rv (*funcPtr)(P1, P2, P3)) : callee((funcPtr == NULL) ? NULL : new FunctionCallee(funcPtr)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param funcPtr Function pointer to be set
     * @param ctxt The user data context used when calling the function
     */
    template<class CT1, class CT2>
    Delegate(Rv (*funcPtr)(P1, P2, P3, CT1), CT2 ctxt)
            : callee((funcPtr == NULL) ? NULL : new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     */
    template<class C>
    Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3)) : callee(new MethodCallee<C>(obj, methPtr)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     * @param ctxt The user data context used when calling the method
     */
    template<class C, class CT1, class CT2>
    Delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, CT1), CT2 ctxt)
            : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
        // intentionally empty
    }

    /**
     * Dtor
     *
     * Note that no memory will be freed (user data context, etc.)
     */
    ~Delegate(void) {
        SAFE_DELETE(this->callee);
    }

    /**
     * Answer whether the target for this delegate is set
     *
     * @return True if the target for this delegate is set
     */
    inline bool IsTargetSet(void) const {
        return this->callee != NULL;
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     */
    void Set(Rv (*funcPtr)(P1, P2, P3)) {
        SAFE_DELETE(this->callee);
        if (funcPtr != NULL) {
            this->callee = new FunctionCallee(funcPtr);
        }
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     * @param ctxt The user data context used when calling the function
     */
    template<class CT1, class CT2>
    void Set(Rv (*funcPtr)(P1, P2, P3, CT1), CT2 ctxt) {
        SAFE_DELETE(this->callee);
        if (funcPtr != NULL) {
            this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
        }
    }

    /**
     * Sets the target for this delegate
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     */
    template<class C>
    void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3)) {
        SAFE_DELETE(this->callee);
        this->callee = new MethodCallee<C>(obj, methPtr);
    }

    /**
     * Sets the target for this delegate
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     * @param ctxt The user data context used when calling the method
     */
    template<class C, class CT1, class CT2>
    void Set(C& obj, Rv (C::*methPtr)(P1, P2, P3, CT1), CT2 ctxt) {
        SAFE_DELETE(this->callee);
        this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
    }

    /**
     * Unsets the target for this delegate
     *
     * Note that no memory will be freed (user data context, etc.)
     */
    void Unset(void) {
        SAFE_DELETE(this->callee);
    }

    /**
     * Calls the delegate's target
     *
     * Parameter and return value depend on the template arguments of the delegate
     */
    Rv operator()(P1 p1, P2 p2, P3 p3) {
        if (this->callee == NULL) {
            throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
        }
        return this->callee->Call(p1, p2, p3);
    }

    /**
     * Test for equality
     *
     * @param rhs The right hand side operand
     *
     * @return True if this and rhs are equal
     */
    bool operator==(const Delegate& rhs) const {
        if (this->callee == NULL) {
            return (rhs.callee == NULL);
        }
        return this->callee->Equals(*rhs.callee);
    }

    /**
     * Assignment operator
     *
     * @param rhs The right hand side operand
     *
     * @return A reference to this object
     */
    Delegate& operator=(const Delegate& rhs) {
        SAFE_DELETE(this->callee);
        if (rhs.callee != NULL) {
            this->callee = rhs.callee->Clone();
        }
        return *this;
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     *
     * @return A reference to this object
     */
    Delegate& operator=(Rv (*funcPtr)(P1, P2, P3)) {
        this->Set(funcPtr);
        return *this;
    }

private:
    /**
     * abstract base class for callee implementations
     */
    class AbstractCallee {
    public:
        /** Ctor */
        AbstractCallee(void) {
            // intentionally empty
        }

        /** Dtor */
        virtual ~AbstractCallee(void) {
            // intentionally empty
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3) = 0;

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) = 0;

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) = 0;
    };

    /**
     * Callee implementation for functions
     */
    class FunctionCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The function pointer (must not be NULL)
         */
        FunctionCallee(Rv (*func)(P1, P2, P3)) : AbstractCallee(), func(func) {
            ASSERT(this->func != NULL);
        }

        /** Dtor */
        virtual ~FunctionCallee(void) {
            this->func = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3) {
            return this->func(p1, p2, p3);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new FunctionCallee(this->func);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const FunctionCallee* r = dynamic_cast<const FunctionCallee*>(&rhs);
            return (r != NULL) && (r->func == this->func);
        }

    private:
        /** The function pointer */
        Rv (*func)(P1, P2, P3);
    };

    /**
     * Callee implementation for functions with user data context
     */
    template<class CT1>
    class FunctionContextCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The function pointer (must not be NULL)
         * @param ctxt The user data context
         */
        FunctionContextCallee(Rv (*func)(P1, P2, P3, CT1), CT1 ctxt) : AbstractCallee(), func(func), ctxt(ctxt) {
            ASSERT(this->func != NULL);
        }

        /** Dtor */
        virtual ~FunctionContextCallee(void) {
            this->func = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3) {
            return this->func(p1, p2, p3, this->ctxt);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new FunctionContextCallee<CT1>(this->func, this->ctxt);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const FunctionContextCallee* r = dynamic_cast<const FunctionContextCallee*>(&rhs);
            return (r != NULL) && (r->func == this->func) && (r->ctxt == this->ctxt);
        }

    private:
        /** The function pointer */
        Rv (*func)(P1, P2, P3, CT1);

        /** The user data context */
        CT1 ctxt;
    };

    /**
     * Callee implementation for methods
     */
    template<class C>
    class MethodCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The method pointer (must not be NULL)
         * @param ctxt The user data context
         */
        MethodCallee(C& obj, Rv (C::*meth)(P1, P2, P3)) : AbstractCallee(), obj(obj), meth(meth) {
            ASSERT(this->meth != NULL);
        }

        /** Dtor */
        virtual ~MethodCallee(void) {
            this->meth = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3) {
            return (this->obj.*this->meth)(p1, p2, p3);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new MethodCallee<C>(this->obj, this->meth);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const MethodCallee* r = dynamic_cast<const MethodCallee*>(&rhs);
            return (r != NULL) && (&r->obj == &this->obj) && (r->meth == this->meth);
        }

    private:
        /** The object */
        C& obj;

        /** The method pointer */
        Rv (C::*meth)(P1, P2, P3);
    };

    /**
     * Callee implementation for methods with user data context
     */
    template<class C, class CT1>
    class MethodContextCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param obj The object
         * @param func The method pointer (must not be NULL)
         * @param ctxt The user data context
         */
        MethodContextCallee(C& obj, Rv (C::*meth)(P1, P2, P3, CT1), CT1 ctxt)
                : AbstractCallee()
                , obj(obj)
                , meth(meth)
                , ctxt(ctxt) {
            ASSERT(this->meth != NULL);
        }

        /** Dtor */
        virtual ~MethodContextCallee(void) {
            this->meth = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2, P3 p3) {
            return (this->obj.*this->meth)(p1, p2, p3, this->ctxt);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new MethodContextCallee<C, CT1>(this->obj, this->meth, this->ctxt);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const MethodContextCallee* r = dynamic_cast<const MethodContextCallee*>(&rhs);
            return (r != NULL) && (&r->obj == &this->obj) && (r->meth == this->meth) && (r->ctxt == this->ctxt);
        }

    private:
        /** The object */
        C& obj;

        /** The method pointer */
        Rv (C::*meth)(P1, P2, P3, CT1);

        /** The user data context */
        CT1 ctxt;
    };

    /** The callee target */
    AbstractCallee* callee;
};


/**
 * Template specialication for delegate functions with 2 parameters
 */
template<class Rv, class P1, class P2>
class Delegate<Rv, P1, P2, void, void, void, void, void, void, void, void> {
public:
    /**
     * Ctor
     */
    Delegate(void) : callee(NULL) {
        // intentionally empty
    }

    /**
     * Copy ctor
     *
     * @param src The object to clone from
     */
    Delegate(const Delegate& src) : callee(NULL) {
        (*this) = src;
    }

    /**
     * Ctor
     *
     * @param funcPtr Function pointer to be set
     */
    Delegate(Rv (*funcPtr)(P1, P2)) : callee((funcPtr == NULL) ? NULL : new FunctionCallee(funcPtr)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param funcPtr Function pointer to be set
     * @param ctxt The user data context used when calling the function
     */
    template<class CT1, class CT2>
    Delegate(Rv (*funcPtr)(P1, P2, CT1), CT2 ctxt)
            : callee((funcPtr == NULL) ? NULL : new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     */
    template<class C>
    Delegate(C& obj, Rv (C::*methPtr)(P1, P2)) : callee(new MethodCallee<C>(obj, methPtr)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     * @param ctxt The user data context used when calling the method
     */
    template<class C, class CT1, class CT2>
    Delegate(C& obj, Rv (C::*methPtr)(P1, P2, CT1), CT2 ctxt)
            : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
        // intentionally empty
    }

    /**
     * Dtor
     *
     * Note that no memory will be freed (user data context, etc.)
     */
    ~Delegate(void) {
        SAFE_DELETE(this->callee);
    }

    /**
     * Answer whether the target for this delegate is set
     *
     * @return True if the target for this delegate is set
     */
    inline bool IsTargetSet(void) const {
        return this->callee != NULL;
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     */
    void Set(Rv (*funcPtr)(P1, P2)) {
        SAFE_DELETE(this->callee);
        if (funcPtr != NULL) {
            this->callee = new FunctionCallee(funcPtr);
        }
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     * @param ctxt The user data context used when calling the function
     */
    template<class CT1, class CT2>
    void Set(Rv (*funcPtr)(P1, P2, CT1), CT2 ctxt) {
        SAFE_DELETE(this->callee);
        if (funcPtr != NULL) {
            this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
        }
    }

    /**
     * Sets the target for this delegate
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     */
    template<class C>
    void Set(C& obj, Rv (C::*methPtr)(P1, P2)) {
        SAFE_DELETE(this->callee);
        this->callee = new MethodCallee<C>(obj, methPtr);
    }

    /**
     * Sets the target for this delegate
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     * @param ctxt The user data context used when calling the method
     */
    template<class C, class CT1, class CT2>
    void Set(C& obj, Rv (C::*methPtr)(P1, P2, CT1), CT2 ctxt) {
        SAFE_DELETE(this->callee);
        this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
    }

    /**
     * Unsets the target for this delegate
     *
     * Note that no memory will be freed (user data context, etc.)
     */
    void Unset(void) {
        SAFE_DELETE(this->callee);
    }

    /**
     * Calls the delegate's target
     *
     * Parameter and return value depend on the template arguments of the delegate
     */
    Rv operator()(P1 p1, P2 p2) {
        if (this->callee == NULL) {
            throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
        }
        return this->callee->Call(p1, p2);
    }

    /**
     * Test for equality
     *
     * @param rhs The right hand side operand
     *
     * @return True if this and rhs are equal
     */
    bool operator==(const Delegate& rhs) const {
        if (this->callee == NULL) {
            return (rhs.callee == NULL);
        }
        return this->callee->Equals(*rhs.callee);
    }

    /**
     * Assignment operator
     *
     * @param rhs The right hand side operand
     *
     * @return A reference to this object
     */
    Delegate& operator=(const Delegate& rhs) {
        SAFE_DELETE(this->callee);
        if (rhs.callee != NULL) {
            this->callee = rhs.callee->Clone();
        }
        return *this;
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     *
     * @return A reference to this object
     */
    Delegate& operator=(Rv (*funcPtr)(P1, P2)) {
        this->Set(funcPtr);
        return *this;
    }

private:
    /**
     * abstract base class for callee implementations
     */
    class AbstractCallee {
    public:
        /** Ctor */
        AbstractCallee(void) {
            // intentionally empty
        }

        /** Dtor */
        virtual ~AbstractCallee(void) {
            // intentionally empty
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2) = 0;

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) = 0;

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) = 0;
    };

    /**
     * Callee implementation for functions
     */
    class FunctionCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The function pointer (must not be NULL)
         */
        FunctionCallee(Rv (*func)(P1, P2)) : AbstractCallee(), func(func) {
            ASSERT(this->func != NULL);
        }

        /** Dtor */
        virtual ~FunctionCallee(void) {
            this->func = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2) {
            return this->func(p1, p2);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new FunctionCallee(this->func);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const FunctionCallee* r = dynamic_cast<const FunctionCallee*>(&rhs);
            return (r != NULL) && (r->func == this->func);
        }

    private:
        /** The function pointer */
        Rv (*func)(P1, P2);
    };

    /**
     * Callee implementation for functions with user data context
     */
    template<class CT1>
    class FunctionContextCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The function pointer (must not be NULL)
         * @param ctxt The user data context
         */
        FunctionContextCallee(Rv (*func)(P1, P2, CT1), CT1 ctxt) : AbstractCallee(), func(func), ctxt(ctxt) {
            ASSERT(this->func != NULL);
        }

        /** Dtor */
        virtual ~FunctionContextCallee(void) {
            this->func = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2) {
            return this->func(p1, p2, this->ctxt);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new FunctionContextCallee<CT1>(this->func, this->ctxt);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const FunctionContextCallee* r = dynamic_cast<const FunctionContextCallee*>(&rhs);
            return (r != NULL) && (r->func == this->func) && (r->ctxt == this->ctxt);
        }

    private:
        /** The function pointer */
        Rv (*func)(P1, P2, CT1);

        /** The user data context */
        CT1 ctxt;
    };

    /**
     * Callee implementation for methods
     */
    template<class C>
    class MethodCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The method pointer (must not be NULL)
         * @param ctxt The user data context
         */
        MethodCallee(C& obj, Rv (C::*meth)(P1, P2)) : AbstractCallee(), obj(obj), meth(meth) {
            ASSERT(this->meth != NULL);
        }

        /** Dtor */
        virtual ~MethodCallee(void) {
            this->meth = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2) {
            return (this->obj.*this->meth)(p1, p2);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new MethodCallee<C>(this->obj, this->meth);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const MethodCallee* r = dynamic_cast<const MethodCallee*>(&rhs);
            return (r != NULL) && (&r->obj == &this->obj) && (r->meth == this->meth);
        }

    private:
        /** The object */
        C& obj;

        /** The method pointer */
        Rv (C::*meth)(P1, P2);
    };

    /**
     * Callee implementation for methods with user data context
     */
    template<class C, class CT1>
    class MethodContextCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param obj The object
         * @param func The method pointer (must not be NULL)
         * @param ctxt The user data context
         */
        MethodContextCallee(C& obj, Rv (C::*meth)(P1, P2, CT1), CT1 ctxt)
                : AbstractCallee()
                , obj(obj)
                , meth(meth)
                , ctxt(ctxt) {
            ASSERT(this->meth != NULL);
        }

        /** Dtor */
        virtual ~MethodContextCallee(void) {
            this->meth = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1, P2 p2) {
            return (this->obj.*this->meth)(p1, p2, this->ctxt);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new MethodContextCallee<C, CT1>(this->obj, this->meth, this->ctxt);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const MethodContextCallee* r = dynamic_cast<const MethodContextCallee*>(&rhs);
            return (r != NULL) && (&r->obj == &this->obj) && (r->meth == this->meth) && (r->ctxt == this->ctxt);
        }

    private:
        /** The object */
        C& obj;

        /** The method pointer */
        Rv (C::*meth)(P1, P2, CT1);

        /** The user data context */
        CT1 ctxt;
    };

    /** The callee target */
    AbstractCallee* callee;
};


/**
 * Template specialication for delegate functions with 1 parameters
 */
template<class Rv, class P1>
class Delegate<Rv, P1, void, void, void, void, void, void, void, void, void> {
public:
    /**
     * Ctor
     */
    Delegate(void) : callee(NULL) {
        // intentionally empty
    }

    /**
     * Copy ctor
     *
     * @param src The object to clone from
     */
    Delegate(const Delegate& src) : callee(NULL) {
        (*this) = src;
    }

    /**
     * Ctor
     *
     * @param funcPtr Function pointer to be set
     */
    Delegate(Rv (*funcPtr)(P1)) : callee((funcPtr == NULL) ? NULL : new FunctionCallee(funcPtr)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param funcPtr Function pointer to be set
     * @param ctxt The user data context used when calling the function
     */
    template<class CT1, class CT2>
    Delegate(Rv (*funcPtr)(P1, CT1), CT2 ctxt)
            : callee((funcPtr == NULL) ? NULL : new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     */
    template<class C>
    Delegate(C& obj, Rv (C::*methPtr)(P1)) : callee(new MethodCallee<C>(obj, methPtr)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     * @param ctxt The user data context used when calling the method
     */
    template<class C, class CT1, class CT2>
    Delegate(C& obj, Rv (C::*methPtr)(P1, CT1), CT2 ctxt)
            : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
        // intentionally empty
    }

    /**
     * Dtor
     *
     * Note that no memory will be freed (user data context, etc.)
     */
    ~Delegate(void) {
        SAFE_DELETE(this->callee);
    }

    /**
     * Answer whether the target for this delegate is set
     *
     * @return True if the target for this delegate is set
     */
    inline bool IsTargetSet(void) const {
        return this->callee != NULL;
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     */
    void Set(Rv (*funcPtr)(P1)) {
        SAFE_DELETE(this->callee);
        if (funcPtr != NULL) {
            this->callee = new FunctionCallee(funcPtr);
        }
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     * @param ctxt The user data context used when calling the function
     */
    template<class CT1, class CT2>
    void Set(Rv (*funcPtr)(P1, CT1), CT2 ctxt) {
        SAFE_DELETE(this->callee);
        if (funcPtr != NULL) {
            this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
        }
    }

    /**
     * Sets the target for this delegate
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     */
    template<class C>
    void Set(C& obj, Rv (C::*methPtr)(P1)) {
        SAFE_DELETE(this->callee);
        this->callee = new MethodCallee<C>(obj, methPtr);
    }

    /**
     * Sets the target for this delegate
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     * @param ctxt The user data context used when calling the method
     */
    template<class C, class CT1, class CT2>
    void Set(C& obj, Rv (C::*methPtr)(P1, CT1), CT2 ctxt) {
        SAFE_DELETE(this->callee);
        this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
    }

    /**
     * Unsets the target for this delegate
     *
     * Note that no memory will be freed (user data context, etc.)
     */
    void Unset(void) {
        SAFE_DELETE(this->callee);
    }

    /**
     * Calls the delegate's target
     *
     * Parameter and return value depend on the template arguments of the delegate
     */
    Rv operator()(P1 p1) {
        if (this->callee == NULL) {
            throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
        }
        return this->callee->Call(p1);
    }

    /**
     * Test for equality
     *
     * @param rhs The right hand side operand
     *
     * @return True if this and rhs are equal
     */
    bool operator==(const Delegate& rhs) const {
        if (this->callee == NULL) {
            return (rhs.callee == NULL);
        }
        return this->callee->Equals(*rhs.callee);
    }

    /**
     * Assignment operator
     *
     * @param rhs The right hand side operand
     *
     * @return A reference to this object
     */
    Delegate& operator=(const Delegate& rhs) {
        SAFE_DELETE(this->callee);
        if (rhs.callee != NULL) {
            this->callee = rhs.callee->Clone();
        }
        return *this;
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     *
     * @return A reference to this object
     */
    Delegate& operator=(Rv (*funcPtr)(P1)) {
        this->Set(funcPtr);
        return *this;
    }

private:
    /**
     * abstract base class for callee implementations
     */
    class AbstractCallee {
    public:
        /** Ctor */
        AbstractCallee(void) {
            // intentionally empty
        }

        /** Dtor */
        virtual ~AbstractCallee(void) {
            // intentionally empty
        }

        /** Call */
        virtual Rv Call(P1 p1) = 0;

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) = 0;

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) = 0;
    };

    /**
     * Callee implementation for functions
     */
    class FunctionCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The function pointer (must not be NULL)
         */
        FunctionCallee(Rv (*func)(P1)) : AbstractCallee(), func(func) {
            ASSERT(this->func != NULL);
        }

        /** Dtor */
        virtual ~FunctionCallee(void) {
            this->func = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1) {
            return this->func(p1);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new FunctionCallee(this->func);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const FunctionCallee* r = dynamic_cast<const FunctionCallee*>(&rhs);
            return (r != NULL) && (r->func == this->func);
        }

    private:
        /** The function pointer */
        Rv (*func)(P1);
    };

    /**
     * Callee implementation for functions with user data context
     */
    template<class CT1>
    class FunctionContextCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The function pointer (must not be NULL)
         * @param ctxt The user data context
         */
        FunctionContextCallee(Rv (*func)(P1, CT1), CT1 ctxt) : AbstractCallee(), func(func), ctxt(ctxt) {
            ASSERT(this->func != NULL);
        }

        /** Dtor */
        virtual ~FunctionContextCallee(void) {
            this->func = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1) {
            return this->func(p1, this->ctxt);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new FunctionContextCallee<CT1>(this->func, this->ctxt);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const FunctionContextCallee* r = dynamic_cast<const FunctionContextCallee*>(&rhs);
            return (r != NULL) && (r->func == this->func) && (r->ctxt == this->ctxt);
        }

    private:
        /** The function pointer */
        Rv (*func)(P1, CT1);

        /** The user data context */
        CT1 ctxt;
    };

    /**
     * Callee implementation for methods
     */
    template<class C>
    class MethodCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The method pointer (must not be NULL)
         * @param ctxt The user data context
         */
        MethodCallee(C& obj, Rv (C::*meth)(P1)) : AbstractCallee(), obj(obj), meth(meth) {
            ASSERT(this->meth != NULL);
        }

        /** Dtor */
        virtual ~MethodCallee(void) {
            this->meth = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1) {
            return (this->obj.*this->meth)(p1);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new MethodCallee<C>(this->obj, this->meth);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const MethodCallee* r = dynamic_cast<const MethodCallee*>(&rhs);
            return (r != NULL) && (&r->obj == &this->obj) && (r->meth == this->meth);
        }

    private:
        /** The object */
        C& obj;

        /** The method pointer */
        Rv (C::*meth)(P1);
    };

    /**
     * Callee implementation for methods with user data context
     */
    template<class C, class CT1>
    class MethodContextCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param obj The object
         * @param func The method pointer (must not be NULL)
         * @param ctxt The user data context
         */
        MethodContextCallee(C& obj, Rv (C::*meth)(P1, CT1), CT1 ctxt)
                : AbstractCallee()
                , obj(obj)
                , meth(meth)
                , ctxt(ctxt) {
            ASSERT(this->meth != NULL);
        }

        /** Dtor */
        virtual ~MethodContextCallee(void) {
            this->meth = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(P1 p1) {
            return (this->obj.*this->meth)(p1, this->ctxt);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new MethodContextCallee<C, CT1>(this->obj, this->meth, this->ctxt);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const MethodContextCallee* r = dynamic_cast<const MethodContextCallee*>(&rhs);
            return (r != NULL) && (&r->obj == &this->obj) && (r->meth == this->meth) && (r->ctxt == this->ctxt);
        }

    private:
        /** The object */
        C& obj;

        /** The method pointer */
        Rv (C::*meth)(P1, CT1);

        /** The user data context */
        CT1 ctxt;
    };

    /** The callee target */
    AbstractCallee* callee;
};


/**
 * Template specialication for delegate functions with 0 parameters
 */
template<class Rv>
class Delegate<Rv, void, void, void, void, void, void, void, void, void, void> {
public:
    /**
     * Ctor
     */
    Delegate(void) : callee(NULL) {
        // intentionally empty
    }

    /**
     * Copy ctor
     *
     * @param src The object to clone from
     */
    Delegate(const Delegate& src) : callee(NULL) {
        (*this) = src;
    }

    /**
     * Ctor
     *
     * @param funcPtr Function pointer to be set
     */
    Delegate(Rv (*funcPtr)(void)) : callee((funcPtr == NULL) ? NULL : new FunctionCallee(funcPtr)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param funcPtr Function pointer to be set
     * @param ctxt The user data context used when calling the function
     */
    template<class CT1, class CT2>
    Delegate(Rv (*funcPtr)(CT1), CT2 ctxt)
            : callee((funcPtr == NULL) ? NULL : new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     */
    template<class C>
    Delegate(C& obj, Rv (C::*methPtr)(void)) : callee(new MethodCallee<C>(obj, methPtr)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     * @param ctxt The user data context used when calling the method
     */
    template<class C, class CT1, class CT2>
    Delegate(C& obj, Rv (C::*methPtr)(CT1), CT2 ctxt) : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
        // intentionally empty
    }

    /**
     * Dtor
     *
     * Note that no memory will be freed (user data context, etc.)
     */
    ~Delegate(void) {
        SAFE_DELETE(this->callee);
    }

    /**
     * Answer whether the target for this delegate is set
     *
     * @return True if the target for this delegate is set
     */
    inline bool IsTargetSet(void) const {
        return this->callee != NULL;
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     */
    void Set(Rv (*funcPtr)(void)) {
        SAFE_DELETE(this->callee);
        if (funcPtr != NULL) {
            this->callee = new FunctionCallee(funcPtr);
        }
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     * @param ctxt The user data context used when calling the function
     */
    template<class CT1, class CT2>
    void Set(Rv (*funcPtr)(CT1), CT2 ctxt) {
        SAFE_DELETE(this->callee);
        if (funcPtr != NULL) {
            this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
        }
    }

    /**
     * Sets the target for this delegate
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     */
    template<class C>
    void Set(C& obj, Rv (C::*methPtr)(void)) {
        SAFE_DELETE(this->callee);
        this->callee = new MethodCallee<C>(obj, methPtr);
    }

    /**
     * Sets the target for this delegate
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     * @param ctxt The user data context used when calling the method
     */
    template<class C, class CT1, class CT2>
    void Set(C& obj, Rv (C::*methPtr)(CT1), CT2 ctxt) {
        SAFE_DELETE(this->callee);
        this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
    }

    /**
     * Unsets the target for this delegate
     *
     * Note that no memory will be freed (user data context, etc.)
     */
    void Unset(void) {
        SAFE_DELETE(this->callee);
    }

    /**
     * Calls the delegate's target
     *
     * Parameter and return value depend on the template arguments of the delegate
     */
    Rv operator()(void) {
        if (this->callee == NULL) {
            throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
        }
        return this->callee->Call();
    }

    /**
     * Test for equality
     *
     * @param rhs The right hand side operand
     *
     * @return True if this and rhs are equal
     */
    bool operator==(const Delegate& rhs) const {
        if (this->callee == NULL) {
            return (rhs.callee == NULL);
        }
        return this->callee->Equals(*rhs.callee);
    }

    /**
     * Assignment operator
     *
     * @param rhs The right hand side operand
     *
     * @return A reference to this object
     */
    Delegate& operator=(const Delegate& rhs) {
        SAFE_DELETE(this->callee);
        if (rhs.callee != NULL) {
            this->callee = rhs.callee->Clone();
        }
        return *this;
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     *
     * @return A reference to this object
     */
    Delegate& operator=(Rv (*funcPtr)(void)) {
        this->Set(funcPtr);
        return *this;
    }

private:
    /**
     * abstract base class for callee implementations
     */
    class AbstractCallee {
    public:
        /** Ctor */
        AbstractCallee(void) {
            // intentionally empty
        }

        /** Dtor */
        virtual ~AbstractCallee(void) {
            // intentionally empty
        }

        /** Call */
        virtual Rv Call(void) = 0;

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) = 0;

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) = 0;
    };

    /**
     * Callee implementation for functions
     */
    class FunctionCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The function pointer (must not be NULL)
         */
        FunctionCallee(Rv (*func)(void)) : AbstractCallee(), func(func) {
            ASSERT(this->func != NULL);
        }

        /** Dtor */
        virtual ~FunctionCallee(void) {
            this->func = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(void) {
            return this->func();
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new FunctionCallee(this->func);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const FunctionCallee* r = dynamic_cast<const FunctionCallee*>(&rhs);
            return (r != NULL) && (r->func == this->func);
        }

    private:
        /** The function pointer */
        Rv (*func)(void);
    };

    /**
     * Callee implementation for functions with user data context
     */
    template<class CT1>
    class FunctionContextCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The function pointer (must not be NULL)
         * @param ctxt The user data context
         */
        FunctionContextCallee(Rv (*func)(CT1), CT1 ctxt) : AbstractCallee(), func(func), ctxt(ctxt) {
            ASSERT(this->func != NULL);
        }

        /** Dtor */
        virtual ~FunctionContextCallee(void) {
            this->func = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(void) {
            return this->func(this->ctxt);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new FunctionContextCallee<CT1>(this->func, this->ctxt);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const FunctionContextCallee* r = dynamic_cast<const FunctionContextCallee*>(&rhs);
            return (r != NULL) && (r->func == this->func) && (r->ctxt == this->ctxt);
        }

    private:
        /** The function pointer */
        Rv (*func)(CT1);

        /** The user data context */
        CT1 ctxt;
    };

    /**
     * Callee implementation for methods
     */
    template<class C>
    class MethodCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The method pointer (must not be NULL)
         * @param ctxt The user data context
         */
        MethodCallee(C& obj, Rv (C::*meth)(void)) : AbstractCallee(), obj(obj), meth(meth) {
            ASSERT(this->meth != NULL);
        }

        /** Dtor */
        virtual ~MethodCallee(void) {
            this->meth = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(void) {
            return (this->obj.*this->meth)();
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new MethodCallee<C>(this->obj, this->meth);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const MethodCallee* r = dynamic_cast<const MethodCallee*>(&rhs);
            return (r != NULL) && (&r->obj == &this->obj) && (r->meth == this->meth);
        }

    private:
        /** The object */
        C& obj;

        /** The method pointer */
        Rv (C::*meth)(void);
    };

    /**
     * Callee implementation for methods with user data context
     */
    template<class C, class CT1>
    class MethodContextCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param obj The object
         * @param func The method pointer (must not be NULL)
         * @param ctxt The user data context
         */
        MethodContextCallee(C& obj, Rv (C::*meth)(CT1), CT1 ctxt) : AbstractCallee(), obj(obj), meth(meth), ctxt(ctxt) {
            ASSERT(this->meth != NULL);
        }

        /** Dtor */
        virtual ~MethodContextCallee(void) {
            this->meth = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual Rv Call(void) {
            return (this->obj.*this->meth)(this->ctxt);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new MethodContextCallee<C, CT1>(this->obj, this->meth, this->ctxt);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const MethodContextCallee* r = dynamic_cast<const MethodContextCallee*>(&rhs);
            return (r != NULL) && (&r->obj == &this->obj) && (r->meth == this->meth) && (r->ctxt == this->ctxt);
        }

    private:
        /** The object */
        C& obj;

        /** The method pointer */
        Rv (C::*meth)(CT1);

        /** The user data context */
        CT1 ctxt;
    };

    /** The callee target */
    AbstractCallee* callee;
};


/**
 * Template specialication for delegate functions without parameters and
 * without return value.
 */
template<>
class Delegate<void, void, void, void, void, void, void, void, void, void, void> {
public:
    /**
     * Ctor
     */
    Delegate(void) : callee(NULL) {
        // intentionally empty
    }

    /**
     * Copy ctor
     *
     * @param src The object to clone from
     */
    Delegate(const Delegate& src) : callee(NULL) {
        (*this) = src;
    }

    /**
     * Ctor
     *
     * @param funcPtr Function pointer to be set
     */
    Delegate(void (*funcPtr)(void)) : callee((funcPtr == NULL) ? NULL : new FunctionCallee(funcPtr)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param funcPtr Function pointer to be set
     * @param ctxt The user data context used when calling the function
     */
    template<class CT1, class CT2>
    Delegate(void (*funcPtr)(CT1), CT2 ctxt)
            : callee((funcPtr == NULL) ? NULL : new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     */
    template<class C>
    Delegate(C& obj, void (C::*methPtr)(void)) : callee(new MethodCallee<C>(obj, methPtr)) {
        // intentionally empty
    }

    /**
     * Ctor
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     * @param ctxt The user data context used when calling the method
     */
    template<class C, class CT1, class CT2>
    Delegate(C& obj, void (C::*methPtr)(CT1), CT2 ctxt) : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
        // intentionally empty
    }

    /**
     * Dtor
     *
     * Note that no memory will be freed (user data context, etc.)
     */
    ~Delegate(void) {
        SAFE_DELETE(this->callee);
    }

    /**
     * Answer whether the target for this delegate is set
     *
     * @return True if the target for this delegate is set
     */
    inline bool IsTargetSet(void) const {
        return this->callee != NULL;
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     */
    void Set(void (*funcPtr)(void)) {
        SAFE_DELETE(this->callee);
        if (funcPtr != NULL) {
            this->callee = new FunctionCallee(funcPtr);
        }
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     * @param ctxt The user data context used when calling the function
     */
    template<class CT1, class CT2>
    void Set(void (*funcPtr)(CT1), CT2 ctxt) {
        SAFE_DELETE(this->callee);
        if (funcPtr != NULL) {
            this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
        }
    }

    /**
     * Sets the target for this delegate
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     */
    template<class C>
    void Set(C& obj, void (C::*methPtr)(void)) {
        SAFE_DELETE(this->callee);
        this->callee = new MethodCallee<C>(obj, methPtr);
    }

    /**
     * Sets the target for this delegate
     *
     * @param obj The object to call the member of
     * @param methPtr The method class pointer to be set (must not be NULL)
     * @param ctxt The user data context used when calling the method
     */
    template<class C, class CT1, class CT2>
    void Set(C& obj, void (C::*methPtr)(CT1), CT2 ctxt) {
        SAFE_DELETE(this->callee);
        this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
    }

    /**
     * Unsets the target for this delegate
     *
     * Note that no memory will be freed (user data context, etc.)
     */
    void Unset(void) {
        SAFE_DELETE(this->callee);
    }

    /**
     * Calls the delegate's target
     *
     * Parameter and return value depend on the template arguments of the delegate
     */
    void operator()(void) {
        if (this->callee == NULL) {
            throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
        }
        this->callee->Call();
    }

    /**
     * Test for equality
     *
     * @param rhs The right hand side operand
     *
     * @return True if this and rhs are equal
     */
    bool operator==(const Delegate& rhs) const {
        if (this->callee == NULL) {
            return (rhs.callee == NULL);
        }
        return this->callee->Equals(*rhs.callee);
    }

    /**
     * Assignment operator
     *
     * @param rhs The right hand side operand
     *
     * @return A reference to this object
     */
    Delegate& operator=(const Delegate& rhs) {
        SAFE_DELETE(this->callee);
        if (rhs.callee != NULL) {
            this->callee = rhs.callee->Clone();
        }
        return *this;
    }

    /**
     * Sets the target for this delegate
     *
     * @param funcPtr Function pointer to be set
     *
     * @return A reference to this object
     */
    Delegate& operator=(void (*funcPtr)(void)) {
        this->Set(funcPtr);
        return *this;
    }

private:
    /**
     * abstract base class for callee implementations
     */
    class AbstractCallee {
    public:
        /** Ctor */
        AbstractCallee(void) {
            // intentionally empty
        }

        /** Dtor */
        virtual ~AbstractCallee(void) {
            // intentionally empty
        }

        /** Call */
        virtual void Call(void) = 0;

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) = 0;

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) = 0;
    };

    /**
     * Callee implementation for functions
     */
    class FunctionCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The function pointer (must not be NULL)
         */
        FunctionCallee(void (*func)(void)) : AbstractCallee(), func(func) {
            ASSERT(this->func != NULL);
        }

        /** Dtor */
        virtual ~FunctionCallee(void) {
            this->func = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual void Call(void) {
            this->func();
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new FunctionCallee(this->func);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const FunctionCallee* r = dynamic_cast<const FunctionCallee*>(&rhs);
            return (r != NULL) && (r->func == this->func);
        }

    private:
        /** The function pointer */
        void (*func)(void);
    };

    /**
     * Callee implementation for functions with user data context
     */
    template<class CT1>
    class FunctionContextCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The function pointer (must not be NULL)
         * @param ctxt The user data context
         */
        FunctionContextCallee(void (*func)(CT1), CT1 ctxt) : AbstractCallee(), func(func), ctxt(ctxt) {
            ASSERT(this->func != NULL);
        }

        /** Dtor */
        virtual ~FunctionContextCallee(void) {
            this->func = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual void Call(void) {
            this->func(this->ctxt);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new FunctionContextCallee<CT1>(this->func, this->ctxt);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const FunctionContextCallee* r = dynamic_cast<const FunctionContextCallee*>(&rhs);
            return (r != NULL) && (r->func == this->func) && (r->ctxt == this->ctxt);
        }

    private:
        /** The function pointer */
        void (*func)(CT1);

        /** The user data context */
        CT1 ctxt;
    };

    /**
     * Callee implementation for methods
     */
    template<class C>
    class MethodCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param func The method pointer (must not be NULL)
         * @param ctxt The user data context
         */
        MethodCallee(C& obj, void (C::*meth)(void)) : AbstractCallee(), obj(obj), meth(meth) {
            ASSERT(this->meth != NULL);
        }

        /** Dtor */
        virtual ~MethodCallee(void) {
            this->meth = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual void Call(void) {
            (this->obj.*this->meth)();
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new MethodCallee<C>(this->obj, this->meth);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const MethodCallee* r = dynamic_cast<const MethodCallee*>(&rhs);
            return (r != NULL) && (&r->obj == &this->obj) && (r->meth == this->meth);
        }

    private:
        /** The object */
        C& obj;

        /** The method pointer */
        void (C::*meth)(void);
    };

    /**
     * Callee implementation for methods with user data context
     */
    template<class C, class CT1>
    class MethodContextCallee : public AbstractCallee {
    public:
        /**
         * Ctor
         *
         * @param obj The object
         * @param func The method pointer (must not be NULL)
         * @param ctxt The user data context
         */
        MethodContextCallee(C& obj, void (C::*meth)(CT1), CT1 ctxt)
                : AbstractCallee()
                , obj(obj)
                , meth(meth)
                , ctxt(ctxt) {
            ASSERT(this->meth != NULL);
        }

        /** Dtor */
        virtual ~MethodContextCallee(void) {
            this->meth = NULL; // DO NOT DELETE
        }

        /** Call */
        virtual void Call(void) {
            (this->obj.*this->meth)(this->ctxt);
        }

        /**
         * Clones this object
         *
         * @return A clone
         */
        virtual AbstractCallee* Clone(void) {
            return new MethodContextCallee<C, CT1>(this->obj, this->meth, this->ctxt);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        virtual bool Equals(const AbstractCallee& rhs) {
            const MethodContextCallee* r = dynamic_cast<const MethodContextCallee*>(&rhs);
            return (r != NULL) && (&r->obj == &this->obj) && (r->meth == this->meth) && (r->ctxt == this->ctxt);
        }

    private:
        /** The object */
        C& obj;

        /** The method pointer */
        void (C::*meth)(CT1);

        /** The user data context */
        CT1 ctxt;
    };

    /** The callee target */
    AbstractCallee* callee;
};

} /* end namespace vislib */

#if defined(_WIN32) && defined(_MANAGED)
#pragma managed(pop)
#endif /* defined(_WIN32) && defined(_MANAGED) */
#endif /* VISLIB_DELEGATE_H_INCLUDED */
