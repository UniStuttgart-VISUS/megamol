<?xml version="1.0" encoding="utf-8"?>
<btf type="MegaMolGLSLShader" version="1.0" namespace="NGsplat">
    <include file="common"/>

    <shader name="vertex">
        <snippet type="version">140</snippet>
        <snippet name="common::defines"/>
        <snippet name="attributes" type="string">
            <![CDATA[
#extension GL_ARB_shader_storage_buffer_object : require
#extension GL_EXT_gpu_shader4 : require
uniform vec4 viewAttr;

uniform float scaling;
uniform float alphaScaling;
uniform float zNear;

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
uniform mat4 modelViewProjection;
uniform mat4 modelViewInverse;
#endif // CALC_CAM_SYS

// clipping plane attributes
uniform vec4 clipDat;
uniform vec4 clipCol;
uniform int instanceOffset;
uniform int attenuateSubpixel;

uniform vec4 inConsts1;
attribute float colIdx;
uniform sampler1D colTab;

varying vec4 objPos;
varying vec4 camPos;
//varying vec4 lightPos;
varying float squarRad;
varying float rad;
varying float effectiveDiameter;

#ifdef DEFERRED_SHADING
varying float pointSize;
#endif

#ifdef RETICLE
varying vec2 centerFragment;
#endif // RETICLE

#define CONSTRAD inConsts1.x
#define MIN_COLV inConsts1.y
#define MAX_COLV inConsts1.z
#define COLTAB_SIZE inConsts1.w
]]>
        </snippet>
        <snippet name="MainParams" type="string">
        <![CDATA[
void main(void) {
    float theColIdx;
    vec4 theColor;
    vec4 inPos;
]]>
        </snippet>
        <snippet name="MainRest" type="string">
        <![CDATA[
    // remove the sphere radius from the w coordinates to the rad varyings
    //vec4 inPos = gl_Vertex;
    //rad = (CONSTRAD < -0.5) ? inPos.w : CONSTRAD;
    //inPos.w = 1.0;
    //inPos = vec4(0.0, 0.0, 0.0, 1.0);
    //rad = 1.0;
    float cid = MAX_COLV - MIN_COLV;
    if (cid < 0.000001) {
        gl_FrontColor = theColor;
    } else {
        cid = (theColIdx - MIN_COLV) / cid;
        cid = clamp(cid, 0.0, 1.0);
        
        cid *= (1.0 - 1.0 / COLTAB_SIZE);
        cid += 0.5 / COLTAB_SIZE;
        
        gl_FrontColor = texture(colTab, cid);
    }

    rad *= scaling;

    squarRad = rad * rad;
]]>
        
        </snippet>
        <snippet name="posTrans" type="string">
            <![CDATA[

    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)

    // calculate cam position
    camPos = modelViewInverse[3]; // (C) by Christoph
    camPos.xyz -= objPos.xyz; // cam pos to glyph space

    // calculate light position in glyph space
    //lightPos = modelViewInverse * gl_LightSource[0].position;
]]></snippet>
        <snippet name="clippingPlane" type="string">
        <![CDATA[

    // clipping
    float od = clipDat.w - 1.0;
    if (any(notEqual(clipDat.xyz, vec3(0, 0, 0)))) {
        od = dot(objPos.xyz, clipDat.xyz) - rad;
    }

]]></snippet>
        <snippet name="MainLast" type="string">
            <![CDATA[

    // Sphere-Touch-Plane-Approachâ„¢
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    vec2 d, p, q, h, dd;

    // get camera orthonormal coordinate system
    vec4 tmp;

#ifdef CALC_CAM_SYS
    // camera coordinate system in object space
    tmp = modelViewInverse[3] + modelViewInverse[2];
    vec3 camIn = normalize(tmp.xyz);
    tmp = modelViewInverse[3] + modelViewInverse[1];
    vec3 camUp = tmp.xyz;
    vec3 camRight = normalize(cross(camIn, camUp));
    camUp = cross(camIn, camRight);
#endif // CALC_CAM_SYS

    vec2 mins, maxs;
    vec3 testPos;
    vec4 projPos;

    // projected camera vector
    vec3 c2 = vec3(dot(camPos.xyz, camRight), dot(camPos.xyz, camUp), dot(camPos.xyz, camIn));

    vec3 cpj1 = camIn * c2.z + camRight * c2.x;
    vec3 cpm1 = camIn * c2.x - camRight * c2.z;

    vec3 cpj2 = camIn * c2.z + camUp * c2.y;
    vec3 cpm2 = camIn * c2.y - camUp * c2.z;
    
    d.x = length(cpj1);
    d.y = length(cpj2);

    dd = vec2(1.0) / d;

    p = squarRad * dd;
    q = d - p;
    h = sqrt(p * q);
    //h = vec2(0.0);
    
    p *= dd;
    h *= dd;

    cpj1 *= p.x;
    cpm1 *= h.x;
    cpj2 *= p.y;
    cpm2 *= h.y;

    // TODO: rewrite only using four projections, additions in homogenous coordinates and delayed perspective divisions.
    testPos = objPos.xyz + cpj1 + cpm1;
    projPos = modelViewProjection * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = projPos.xy;
    maxs = projPos.xy;

    testPos -= 2.0 * cpm1;
    projPos = modelViewProjection * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos = objPos.xyz + cpj2 + cpm2;
    projPos = modelViewProjection * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos -= 2.0 * cpm2;
    projPos = modelViewProjection * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);
    gl_Position = vec4((mins + maxs) * 0.5, 0.0, (od > clipDat.w) ? 0.0 : 1.0);
    maxs = (maxs - mins) * 0.5 * winHalf;
    gl_PointSize = max(maxs.x, maxs.y) + 0.5;

    if (attenuateSubpixel == 1) {
        effectiveDiameter = gl_PointSize;
    } else {
        effectiveDiameter = 1.0;
    }

    //vec4 projPos = gl_ModelViewProjectionMatrix * vec4(objPos.xyz, 1.0);
    //projPos /= projPos.w;
    //gl_Position = projPos;
    //float camDist = sqrt(dot(camPos.xyz, camPos.xyz));
    //gl_PointSize = max((rad / camDist) * zNear, 1.0);

}
]]></snippet>
    </shader>

    <shader name="fragment">
        <snippet type="version">120</snippet>
        <snippet name="common::defines"/>
        <snippet name="common::lighting::simple"/>
        <snippet name="body1" type="string">
            <![CDATA[
#ifdef BACKSIDE_ENABLED
uniform float hitsideFlag;
#endif // BACKSIDE_ENABLED
//#define DISCARD_COLOR_MARKER

// clipping plane attributes
uniform vec4 clipDat;
uniform vec4 clipCol;
uniform float alphaScaling;

uniform vec4 viewAttr;

FLACH varying vec4 objPos;
FLACH varying vec4 camPos;
//FLACH varying vec4 lightPos;
FLACH varying float squarRad;
FLACH varying float rad;
FLACH varying float effectiveDiameter;

#ifdef RETICLE
FLACH varying vec2 centerFragment;
#endif // RETICLE

void main(void) {

    //gl_FragColor = vec4((gl_PointCoord.xy - vec2(0.5)) * vec2(2.0), 0.0, 1.0);
    //gl_FragColor = vec4(gl_PointCoord.xy, 0.5, 1.0);
    //gl_FragColor = gl_Color;
    vec2 dist = gl_PointCoord.xy - vec2(0.5);
    float d = sqrt(dot(dist, dist));
    float alpha = 0.5-d;
    alpha *= effectiveDiameter * effectiveDiameter;
    alpha *= alphaScaling;
    gl_FragColor = vec4(gl_Color.rgb, alpha);
    //gl_FragColor = vec4(gl_Color.rgb, 1.0);
}
]]>
        </snippet>
    </shader>

</btf>