<?xml version="1.0" encoding="utf-8"?>
<btf type="MegaMolGLSLShader" version="1.0" namespace="uncertaintycartoontessellation">
    <include file="common"/>

    <shader name="vertex">
        <snippet type="version">130</snippet>
        <snippet name="common::defines"/>
        <snippet name="attributes" type="string">
<!--
/////////////////////////////
// VERTEX - common defines //
/////////////////////////////

    /////////////
    // DEFINES //
    /////////////
    #define CONSTRAD    inConsts1.x
    #define MIN_COLV    inConsts1.y
    #define MAX_COLV    inConsts1.z
    #define COLTAB_SIZE inConsts1.w
    
    ////////////////
    // EXTENSIONS //
    ////////////////    
    #extension GL_ARB_shader_storage_buffer_object : require
    #extension GL_EXT_gpu_shader4                  : require
    
    /////////
    // OUT //
    /////////
    out vec4  objPos;
    out vec4  camPos;
    out vec4  lightPos;
    out float squarRad;                                                 // radius squared
    out float rad;                                                      // radius
    out vec4  vertColor;
    
    /////////////////////
    // INPUT variables //
    /////////////////////   
    uniform vec4      viewAttr;                             

    uniform float     scaling;                                          // UNUSED - only used by slpine shader    
    
    uniform vec3      camIn;
    uniform vec3      camUp;
    uniform vec3      camRight;

    // clipping plane attributes
    uniform vec4      clipDat;
    uniform vec4      clipCol;

    uniform mat4      MVinv;
    uniform mat4      MVinvtrans;
    uniform mat4      MVP;
    uniform mat4      MVPinv;
    uniform mat4      MVPtransp;

    uniform vec4      inConsts1;
    
    uniform int       instanceOffset;                                   // UNUSED - for what ? - always 0 assigned
    // uniform sampler1D colTab;                                        // UNUSED - 1D texture

-->
        </snippet>
        <snippet name="MainParams" type="string">
<!--

////////////////////////////
// VERTEX - main - params //
////////////////////////////

    //////////
    // MAIN //
    //////////
    void main(void) {
    
        float theColIdx;                                                // UNUSED - NOT initialised ? (= ... ?)
        vec4  theColor;                                                 // UNUSED - NOT initialised ? (= gl_Color)
        vec4  inPos;                                                    // UNUSED - NOT initialised ? (= gl_Position)
-->
        </snippet>
        <!-- here comes the injected snippet -->
        <snippet name="MainRest" type="string">
<!--

//////////////////////////
// VERTEX - main - rest //
//////////////////////////

    vertColor = theColor;
        
    rad      *= scaling;
    squarRad  = rad * rad;
-->        
        </snippet>
        <snippet name="posTrans" type="string">
<!--

//////////////////////////////////////////
// VERTEX - main - position translation //
//////////////////////////////////////////

    // object pivot point in object space    
    objPos       = inPos;                                               // no w-div needed, because w is 1.0 (Because I know)

    // calculate cam position
    camPos       = MVinv[3];                                            // (C) by Christoph
    camPos.xyz  -= objPos.xyz;                                          // cam pos to glyph space

    // calculate light position in glyph space
    lightPos     = MVinv * gl_LightSource[0].position;
    
    gl_Position  = objPos;
    gl_PointSize = 2.0;
}
-->
        </snippet>
    </shader>


    <shader name="tesscontrol">
      <snippet type="version">400</snippet>
      <snippet type="string">
        <!--
        
///////////////////////////
// TESSELATION - control //
///////////////////////////

    /////////////
    // DEFINES //
    /////////////
    #define STRUCT_COUNT 9                                              // must be equal to 'UncertaintyDataCall::secStructure::NOE'
    
    ////////////////
    // EXTENSIONS //
    ////////////////  
    #extension GL_ARB_shader_storage_buffer_object : require
    #extension GL_EXT_gpu_shader4                  : require

    ////////////
    // LAYOUT //
    ////////////  
    layout(vertices = 4) out;

    ////////
    // IN //
    ////////
    in vec4 camPos[];
    
    /////////
    // OUT //
    /////////    
    out int id[];

    ///////////////
    // variables //
    ///////////////
    uniform int uOuter0 = 16;
    uniform int uOuter1 = 16;

    // uniform int minInner = 6;                                        // UNUSED - just as INFO
    // uniform int maxInner = 30;                                       // UNUSED - just as INFO - why 30?
    // uniform int minOuter = 6;                                        // UNUSED - just as INFO
    // uniform int maxOuter = 30;                                       // UNUSED - just as INFO - why 30?
    uniform int instanceOffset = 0;                                     // UNUSED ?
    
    uniform int tessLevel;


    struct CAlpha
    {
        vec4  pos;
        vec3  dir;
        int   colIdx;        
        vec4  col;
	    float diff;
		int   flag; 
		float unc[STRUCT_COUNT];
	    int   sortedStruct[STRUCT_COUNT];
    };

    layout(std430, binding = 2) buffer shader_data {
        CAlpha atoms[];
    };

    //////////
    // MAIN //
    //////////
    void main() {
        
        int atomPos  = gl_PrimitiveID + (gl_InvocationID % 2);          // 4 invocations because of "layout(vertices = 4) out".
                                                                        // output vertices with index 0 and 2 belong to atomPos with inv%2=0 and 
                                                                        // vertices with index 1 and 3 belong to atomPos with inv%2=1 (???)
        gl_out[gl_InvocationID].gl_Position = atoms[atomPos].pos; 
        id[gl_InvocationID]                 = atomPos;
    
        vec4 cp = camPos[0];                                            // UNUSED ? 
    
        if(gl_InvocationID == 0)
        {
            int tessOuter0 = tessLevel; // uOuter0
            int tessOuter1 = tessLevel; // uOuter1
            
            gl_TessLevelOuter[0] = float(tessOuter0);
            gl_TessLevelOuter[1] = float(tessOuter1);
            gl_TessLevelOuter[2] = float(tessOuter0);
            gl_TessLevelOuter[3] = float(tessOuter1);
        
            gl_TessLevelInner[0] = float(tessOuter0);
            gl_TessLevelInner[1] = float(tessOuter1);
        }
    }
-->
      </snippet>
    </shader>

    <shader name="tesseval">
      <snippet type="version">430</snippet>
      <snippet type="string">
        <!--
        
//////////////////////////////
// TESSELATION - evaluation //
//////////////////////////////
                      
    /////////////
    // DEFINES //
    /////////////
    #define M_PI          3.1415926535897932384626433832795

    // should be equal to 'UncertaintyDataCall::secStructure':
    #define H_ALPHA_HELIX 0   
    #define G_310_HELIX   1
    #define I_PI_HELIX    2
    #define E_EXT_STRAND  3
    #define T_H_TURN      4
    #define B_BRIDGE      5
    #define S_BEND        6
    #define C_COIL        7
    #define NOTDEFINED    8
    #define STRUCT_COUNT  9                                   
    
    // should be equal to 'UncertaintyCartoonRenderer::coloringModes':    
	#define COLOR_MODE_STRUCT        0
    #define COLOR_MODE_UNCERTAIN     1
	#define COLOR_MODE_CHAIN         2
	#define COLOR_MODE_AMINOACID     3
    #define COLOR_MODE_RESIDUE_DEBUG 4
            
    // should be equal to 'UncertaintyCartoonRenderer::uncVisModeualisations':   
    #define UNC_VIS_NONE   0
	#define UNC_VIS_SIN_U  1
	#define UNC_VIS_SIN_V  2    
	#define UNC_VIS_SIN_UV 3
    
    ////////////////
    // EXTENSIONS //
    ////////////////  
    #extension GL_ARB_shader_storage_buffer_object : require
    #extension GL_EXT_gpu_shader4                  : require
        
    ////////////
    // LAYOUT //
    ////////////          
    layout(quads, equal_spacing, ccw) in;
    //layout(isolines, equal_spacing) in;

    ////////
    // IN //
    ////////   
    in int   id[];
    
    /////////
    // OUT //
    /////////        
    out vec4 color;
    out vec3 n;
    
    out vec2 dith;                                                      // DITHERING - pass start and end value for dithering threshold to fragment shader

    ///////////////
    // variables //
    ///////////////    
    uniform float minDistance = 1.0;                                    // UNUSED ?
    uniform float maxDistance = 1.0;                                    // UNUSED ?
    
    uniform int                 ditherCount       = 0;                  // DITHERING - current dithering pass - in range [1,number of sec truct types - 1], dithering is disabled for 0
    uniform bool                interpolateColors = false;
    uniform bool                onlyTubes         = false;  
    uniform float               pipeWidth         = 1.0;
    uniform int                 colorMode         = 0;
    uniform int                 uncVisMode        = 0;
    uniform vec4[STRUCT_COUNT]  structColRGB;                           // the RGB colors for the strucutre types (order as in 'UncertaintyDataCall::secStructure')
    uniform vec4                uncDistor;                              // uncertainty distortion parameters: (0) amplification for sin>0, 
                                                                        //                                    (1) repeat of sin(2*PI), 
                                                                        //                                    (2) uncertainty overall (true if value = 0.0),
                                                                        //                                    (3) UNUSED
    struct CAlpha                                       
    {
        vec4  pos;
        vec3  dir;
        int   colIdx;                                                   // UNUSED - don't delete ! ... otherwise shader has 'strange' behaviour - WHY?
        vec4  col;
	    float diff;
		int   flag;                                        
		float unc[STRUCT_COUNT];
	    int   sortedStruct[STRUCT_COUNT];
    };

    layout(std430, binding = 2) buffer shader_data {
        CAlpha atoms[];
    };

    const float arrowLUT[10] =                                          // LUT = look-up-table
    {
        5.0, 5.0, 5.0, 8.0, 7.0, 6.0, 4.5, 3.0, 2.0, 1.0
    };

    //////////
    // MAIN //
    //////////
    void main() {
    
        // start(max) and end(min) values for dithering threshold
        dith = vec2(1.0, 0.0);
        int structIndex = 0;
        
        // for dithering passes: calculate start and end value for dithering threshold
        if (ditherCount > 0) { 
            CAlpha alpha = atoms[id[1]];  
            structIndex = ditherCount-1;
            dith = vec2(1.0, 0.0);
             
            // accumulate all uncertainties up to current structure type (sum uncertainty from minimum to current)
            for (int i = 0; i < structIndex; i++) {
                dith[0] -= alpha.unc[alpha.sortedStruct[i]];
            }
            dith[1] = dith[0] - alpha.unc[alpha.sortedStruct[structIndex]];
            
            // default assignment 
            gl_Position = vec4(0.0);
            n           = vec3(0.0);
            color       = vec4(0.0);
        }
        else {
            // pass current uncertainty to fragment shader (as flag for choosing right phong material)
            dith[1] = 1.0 - atoms[id[1]].unc[atoms[id[1]].sortedStruct[0]];
        }
        
        
        if ((dith[0] - dith[1]) > 0.00001) { // threshold for uncertainty values ? ...
                      
            CAlpha alph0 = atoms[id[0] - 1];                            // (id[0] - 1) doesn't exist for first vertex call ?
            CAlpha alph1 = atoms[id[0]];
            CAlpha alph2 = atoms[id[1]];
            CAlpha alph3 = atoms[id[1] + 1];
        
            vec4 p0 = alph0.pos;
            vec4 p1 = alph1.pos;
            vec4 p2 = alph2.pos;
            vec4 p3 = alph3.pos;
       
            float u = gl_TessCoord.x;
            float v = gl_TessCoord.y;
        
            // Cubic B-Spline
            u += 3;
            float q = ( u - 1.0) / 3.0;
            vec4 d10 = p0 * ( 1.0 - q) + p1 * q;
            float q1 = ( u - 2.0) / 3.0;
            vec4 d11 =  p1 * ( 1.0 - q1) + p2 * q1;
            float q2 = ( u - 3.0) / 3.0; 
            vec4 d12 =  p2 * ( 1.0 - q2) + p3 * q2;
        
            float q3 = ( u - 2.0) / 2.0; 
            vec4 d20 = d10 * ( 1.0 - q3) + d11 * q3;
            float q4 = ( u - 3.0) / 2.0; 
            vec4 d21 = d11 * ( 1.0 - q4) + d12 * q4;
        
            float q5 = ( u - 3.0); 
            vec4 mypos = d20 * (1.0 - q5) + d21 * q5;
            vec4 savepos = mypos;
            gl_Position =  d20 * ( 1.0 - q5) + d21 * q5;
        
            // interpolate directions
            vec3 dir10 = mix(alph0.dir, alph1.dir, q);
            vec3 dir11 = mix(alph1.dir, alph2.dir, q1);
            vec3 dir12 = mix(alph2.dir, alph3.dir, q2);
        
            vec3 dir20 = mix(dir10, dir11, q3);
            vec3 dir21 = mix(dir11, dir12, q4);
        
            vec3 dir = normalize(mix(dir20, dir21, q5));
        
            vec3 tangent = normalize(d21.xyz - d20.xyz);
                // vec3 normal = normalize(cross(tangent, dir)); - UNUSED
        
            // compute corrected direction that is truly orthogonal to the tangent vector
            vec3 nDir    = dir;
            nDir         = dir -  dot(dir, tangent) * tangent;
            nDir         = -normalize(nDir);
                                   
            // assign current structure type
            int mytype   = alph2.sortedStruct[structIndex];
                    
            // assign colors
            if(interpolateColors) // interpolate colors
            {      
                vec4 colors[4];
                
                for(int i = 0; i < 4; i++)
                {        
                    if (colorMode == COLOR_MODE_STRUCT) {
                        colors[i] = structColRGB[atoms[id[0] + i - 1].sortedStruct[structIndex]];
                    }     
                    else if (colorMode == COLOR_MODE_UNCERTAIN) {
                        colors[i] = structColRGB[atoms[id[0] + i - 1].sortedStruct[structIndex]];
                    }                    
                    else if ((colorMode == COLOR_MODE_CHAIN) || (colorMode == COLOR_MODE_AMINOACID)) {
                        colors[i] = atoms[id[0] + i - 1].col; 
                    }
                    else { // if (colorMode == COLOR_MODE_RESIDUE_DEBUG) {
                        int colorIndex = id[0] + i - 1;
                        colors[i] = vec4(1.0 - float(colorIndex % 5) / 4.0, float(colorIndex % 3) / 2.0, float(colorIndex % 5) / 4.0, 1.0);
                    }
                }     
                                     
                vec4 c10 = colors[0] * (1.0 - q) + colors[1] * q;
                vec4 c11 = colors[1] * (1.0 - q1) + colors[2] * q1;
                vec4 c12 = colors[2] * (1.0 - q2) + colors[3] * q2;
            
                vec4 c20 = c10 * (1.0 - q3) + c11 * q3;
                vec4 c21 = c11 * (1.0 - q4) + c12 * q4;
            
                color = c20 * (1.0 - q5) + c21 * q5;
            }
            else // current C-alpha is alph2
            {
                if (colorMode == COLOR_MODE_STRUCT) {
                    color = structColRGB[mytype];
                }     
                else if (colorMode == COLOR_MODE_UNCERTAIN) {
                    color= structColRGB[mytype];
                }                    
                else if ((colorMode == COLOR_MODE_CHAIN) || (colorMode == COLOR_MODE_AMINOACID)) {
                    color = alph2.col; 
                }
                else { // if (colorMode == COLOR_MODE_RESIDUE_DEBUG) {
                    int colorIndex = id[1];
                    color = vec4(1.0 - float(colorIndex % 5) / 4.0, float(colorIndex % 3) / 2.0, float(colorIndex % 5) / 4.0, 1.0);
                }
            }
            
            // check if geometry type changes at the beginning from tube to helix or strand
            bool changeStart = false;   
            int edgeType     = alph1.sortedStruct[0];
            if (((edgeType == C_COIL) || (edgeType == S_BEND) || (edgeType == T_H_TURN) || (edgeType == NOTDEFINED)) && 
                ((mytype != C_COIL) && (mytype != S_BEND) && (mytype != T_H_TURN) && (mytype != NOTDEFINED))) {
                changeStart = true;
            }
            // check if geometry type changes at the end      
            bool changeEnd = false;
            edgeType       = alph3.sortedStruct[0];        
            if (((edgeType == C_COIL) || (edgeType == S_BEND) || (edgeType == T_H_TURN) || (edgeType == NOTDEFINED)) && 
                ((mytype != C_COIL) && (mytype != S_BEND) && (mytype != T_H_TURN) && (mytype != NOTDEFINED))) {
                changeEnd = true;
            }
            
            // DEBUG - mark the position of the arrow heads white
            /*if((mytype == E_EXT_STRAND) || (mytype == B_BRIDGE))
            {
                if(changeEnd) 
                    color = vec4(1.0, 1.0, 1.0, 1.0);
            }*/
            
            // calculate geometry and normal
            if ((onlyTubes) || ((mytype == C_COIL) || (mytype == S_BEND) || (mytype == T_H_TURN) || (mytype == NOTDEFINED)))  // backbone
            {
                // rotate negative dir vector around tangent vector
                float a = 2.0 * M_PI - v * 2.0 * M_PI;            // has to be this angle because of backface culling
                vec3 vrot = nDir * cos(a) + cross(tangent, nDir) * sin(a) + tangent * dot(tangent, nDir) * (1.0 - cos(a)); 
                vrot = normalize(vrot);
            
                mypos.xyz += pipeWidth * vrot;
                n = vrot;
            } 
            else  // alpha helix and beta sheets             
            {
                vec3 curPos = mypos.xyz + nDir * pipeWidth;             // point <width> under the backbone
                vec3 normalDown = nDir;
                vec3 normalLeft = normalize(cross(tangent, -nDir));

                u = gl_TessCoord.x;
                v = gl_TessCoord.y;
                float factor = 0.01;
                float thresh = 0.01;
            
                float val = 1.0 / float(gl_TessLevelOuter[1]);

                float lutVal = 5.0f;
                if(changeEnd) 
                {
                    if((mytype == E_EXT_STRAND) || (mytype == B_BRIDGE))  // arrow heads
                    {
                        lutVal = u * 9.0f;                              // the size of the LUT is hardcoded to be 10
                        float mymin = arrowLUT[int(floor(lutVal))];
                        float mymax = arrowLUT[int(ceil(lutVal))];
                        float theU  = (lutVal - floor(lutVal)) / (ceil(lutVal) - floor(lutVal));

                        if(ceil(lutVal) - floor(lutVal) < 0.5) 
                        {
                            theU = 0.0f;

                            if(ceil(lutVal) > 8.9f)
                                theU = 1.0f;
                        }

                        lutVal = mix(mymin, mymax, theU);
                    }
                }
            
                if(v < val)
                {
                    mypos.xyz += nDir * pipeWidth * lutVal + normalLeft * mix(0, pipeWidth, v / val);
                    n = normalDown; // down (part 1)
                }
                else if( v >= val && v < 0.5 - val)
                {
                    mypos.xyz += nDir * pipeWidth * lutVal + normalLeft * pipeWidth - nDir * mix(0, pipeWidth * lutVal * 2.0, (v - val)/(0.5 - 2 * val) );
                    n = normalLeft; // left
                }
                else if(v >= 0.5 - val && v < 0.5 + val)
                {
                    mypos.xyz += -nDir * pipeWidth * lutVal + pipeWidth * normalLeft - normalLeft * mix(0, 2 * pipeWidth, (v - (0.5 - val))/(2 * val));
                    n = -normalDown; // up
                }
                else if(v >= 0.5 + val && v < 1.0 - val)
                {
                    mypos.xyz += -nDir * pipeWidth * lutVal - pipeWidth * normalLeft + nDir * mix(0, pipeWidth * lutVal * 2.0, (v- (0.5 + val))/(0.5 - 2 * val));
                    n = -normalLeft; // right
                }
                else 
                {
                    mypos.xyz += nDir * pipeWidth * lutVal - normalLeft * mix(pipeWidth, 0, ((v - (1.0 - val))/ val));
                    n = normalDown; // down (part 2)
                }
            

                // if change in secondary structure is at the beginning: make transition from spline to tube surface
                if(changeStart)
                {
                    vec3 surfdir = mypos.xyz - savepos.xyz;             // direction from spline to tube surface.
                    vec3 newpos = savepos.xyz + normalize(surfdir) * pipeWidth;
                
                    if(u < factor)
                    {
                        mypos.xyz = mix(newpos, mypos.xyz, u / factor);
                        mypos.xyz += thresh * (-tangent);
                        n = -tangent;
                    }
                }
                
                // if change in secondary structure is at the end: make transition from spline to tube surface
                if(changeEnd)
                {
                    vec3 surfdir = mypos.xyz - savepos.xyz;             // direction from spline to tube surface.
                    vec3 newpos = savepos.xyz + normalize(surfdir) * pipeWidth;
                
                    if(u > (1.0 - factor))
                    {
                        mypos.xyz = mix(mypos.xyz, newpos, (u - (1.0 - factor))/ factor);
                        mypos.xyz += thresh * tangent;
                        n = tangent;
                    }
                }
                
            }
            
            
            // uncertainty visualisation
            
            // apply surface displacement parameter
            float uncFac = 0.0;
            float distorLev = uncDistor[1];  
            float ampLevel  = uncDistor[0];            
            if (uncDistor[2] > 0.0) {
                // if dithering is enabled use structure uncertainty else use uncertainty difference
                if (ditherCount > 0)  {
                    uncFac = 0.0;
                    if (alph2.unc[alph2.sortedStruct[0]] < 1.0) {
                        uncFac  = alph2.unc[alph2.sortedStruct[structIndex]]; // in range [0,1]
                    }
                }
                else {
                    uncFac  = alph2.diff;                               // in range [0,1]
                }
            }    
            
            // displacement of geometry and adjustment of normal vector
            float uNdisp = 0.0;
            float vNdisp = 0.0;
            float disp   = 0.0;
            
            if (uncVisMode == UNC_VIS_SIN_U) { // U
                float uDisp = distorLev * 2.0 * M_PI * gl_TessCoord.x; 
                float fac   = (pipeWidth/2.0) * uncFac;                
                disp = sin(uDisp);
                if(disp > 0.0) {
                    fac *= ampLevel;
                }
                disp *= fac;                
                
                float uM      = fac * cos(uDisp);                       // derivation = gradient of fac*sin(uDisp)
                vec2  uNormal = normalize(vec2(0.0, 1.0));              // normal in UV-space
                vec2  uGrad   = normalize(vec2(1.0, uM));               // tangent of fac*sin(uDisp) in UV-space
                vec2  uOffset = (-dot(uGrad, uNormal))*uGrad;           // offset vector for normal in UV-space
                uNdisp        = dot(vec2(1.0, 0.0), uOffset);           // offset projected on tangent = x-axis in U direction
                vNdisp        = 0.0;
            }
            else if (uncVisMode == UNC_VIS_SIN_V) { // V    
                float vDisp   = distorLev * 2.0 * M_PI * gl_TessCoord.y;
                float fac     = (pipeWidth/2.0) * uncFac;         
                disp = sin(vDisp);
                if(disp > 0.0) {
                    fac *= ampLevel;
                }
                disp *= fac; 
                
                float vM      = fac * cos(vDisp);                       // derivation = gradient of fac*sin(vDisp)
                vec2  vNormal = normalize(vec2(0.0, 1.0));              // normal in UV-space
                vec2  vGrad   = normalize(vec2(1.0, vM));               // tangent of fac*sin(vDisp) in UV-space
                vec2  vOffset = (-dot(vGrad, vNormal))*vGrad;           // offset vector for normal in UV-space
                vNdisp        = dot(vec2(1.0, 0.0), vOffset);           // offset projected on cross(n,tangent) = x-axis in V direction
                uNdisp        = 0.0;            
            }    
            else if (uncVisMode == UNC_VIS_SIN_UV) {  // U,V
                float uDisp = distorLev * 2.0 * M_PI * gl_TessCoord.x; 
                float vDisp = distorLev * 2.0 * M_PI * gl_TessCoord.y;
                float fac   = (pipeWidth/2.0) * uncFac;     
                float dispU = sin(uDisp);
                float dispV = sin(vDisp);
                disp = (dispU + dispV);
                if ((dispU > 0.0) && (dispV > 0.0)) {
                    fac *= ampLevel;
                }
                disp *= fac; 

                float uM      = fac * cos(uDisp);                       // derivation = gradient of fac*sin(uDisp)
                vec2  uNormal = normalize(vec2(0.0, 1.0));              // normal in UV-space
                vec2  uGrad   = normalize(vec2(1.0, uM));               // tangent of fac*sin(uDisp) in UV-space
                vec2  uOffset = (-dot(uGrad, uNormal))*uGrad;           // offset vector for normal in UV-space
                uNdisp        = dot(vec2(1.0, 0.0), uOffset);           // offset projected on tangent = x-axis in U direction
                
                float vM      = fac * cos(vDisp);                       // derivation = gradient of fac*sin(vDisp)
                vec2  vNormal = normalize(vec2(0.0, 1.0));              // normal in UV-space
                vec2  vGrad   = normalize(vec2(1.0, vM));               // tangent of fac*sin(vDisp) in UV-space
                vec2  vOffset = (-dot(vGrad, vNormal))*vGrad;           // offset vector for normal in UV-space
                vNdisp        = dot(vec2(1.0, 0.0), vOffset);           // offset projected on cross(n,tangent) = x-axis in V direction             
            }
            
            mypos.xyz  += (disp + pipeWidth) * n;            
            n           = normalize(n + uNdisp * tangent + vNdisp * normalize(cross(n, tangent)));
          
            gl_Position = mypos;
        }
    }
-->
      </snippet>
    </shader>

    <shader name="geometry">
      <snippet type="version">400</snippet>
      <snippet type="string">
        <!--
        
///////////////
// GEOMETRY //
//////////////

    ////////////
    // LAYOUT //
    ////////////
    layout(triangles) in;
    layout(triangle_strip, max_vertices = 4) out;

    /////////
    // IN //
    //////// 
    in vec4 color[];
    in vec3 n[];

    in vec2 dith[];                                                     // DITHERING - dithering threshold from tesselation eval 
    
    //////////
    // OUT //
    /////////  
    out vec4 mycol;
    out vec3 normal;
    
    out vec2 dithThresh;                                                // DITHERING - pass dithering threshold to frag shader
    
    /////////////////////
    // INPUT variables //
    /////////////////////
    uniform mat4 MVP;  
    uniform mat4 MVinvtrans;
    
    //////////
    // MAIN //
    //////////
    void main() {
        
        for(int i = 0; i < gl_in.length(); i++) {                       // length = ?

            gl_Position  = MVP * gl_in[i].gl_Position;
            mycol        = color[i];
            vec4 normal4 = MVinvtrans * vec4(n[i], 0);
            normal       = normalize(normal4.xyz);

            dithThresh = dith[i];
            
            EmitVertex();
        }

        EndPrimitive();
      
    }
-->
      </snippet>
    </shader>

    <shader name="fragment">
        <snippet type="version">140</snippet>
        <snippet name="common::defines"/>
        <snippet name="common::lighting::simple"/>
        <snippet name="body1" type="string">
<!--

//////////////
// FRAGMENT //
//////////////

    ////////////////
    // EXTENSIONS //
    ////////////////  
    #extension GL_ARB_conservative_depth       : require
    #extension GL_ARB_explicit_attrib_location : enable

    ////////////
    // LAYOUT //
    ////////////  
    layout (depth_greater) out float gl_FragDepth; // we think this is right
    // this should be wrong //layout (depth_less) out float gl_FragDepth;

    /////////
    // IN //
    //////// 
    in vec4 mycol;
    in vec3 normal;
    
    in vec2 dithThresh;                                                 // DITHERING - the threshold for dithering
                          
    //////////
    // OUT //
    /////////
    out layout(location = 0) vec4 outCol;
    
    /////////////////////
    // INPUT variables //
    /////////////////////
    uniform vec4 viewAttr;
    
    uniform mat4 MVP;
    uniform mat4 MV;
    uniform mat4 MVPinv;
    uniform mat4 MVPtransp;
    
    uniform mat4 ProjInv;
    uniform vec4 lightPos;
    uniform vec4 diffuseColor   = vec4(1.0);
    uniform vec4 ambientColor   = vec4(1.0); 
    uniform vec4 specularColor  = vec4(1.0);    
    uniform vec4 phong          = vec4(0.6, 0.6, 0.8, 10.0);
    uniform vec4 phongUncertain = vec4(0.6, 0.6, 0.8, 10.0);    
  
    uniform int ditherCount    = 0;                                     // DITHERING - current dithering pass - in range [0,number of sec truct types - 1]
                    
    const float dithMat[64] =   { 0, 32,  8, 40,  2, 34, 10, 42,        // DITHERING - dither matrix bayer 8x8
                                 48, 16, 56, 24, 50, 18, 58, 26,
                                 12, 44,  4, 36, 14, 46,  6, 38, 
                                 60, 28, 52, 20, 62, 30, 54, 22,
                                  3, 35, 11, 43,  1, 33,  9, 41,
                                 51, 19, 59, 27, 49, 17, 57, 25,
                                 15, 47,  7, 39, 13, 45,  5, 37,
                                 63, 31, 55, 23, 61, 29, 53, 21};                
    //////////
    // MAIN //
    //////////
    void main(void) {
    
        outCol        = mycol;
        vec4 material = phong;
    
        // dithering - check if fragment is discarded
        if (ditherCount > 0) {
            if ((dithThresh[0] - dithThresh[1])  < 0.00001) {
                discard;  
            }
            else {
                int index = (int(gl_FragCoord.y)%8 * 8 + int(gl_FragCoord.x)%8);
                float t   = dithMat[index] / 64.0;
                // draw fragment only if (dithThresht[0] = start = max) >= t >=  (dithThresht[1] = end = min)
                if ((t > dithThresh[0]) || (dithThresh[1] > t)) { 
                    discard;
                }   
            }
        }
        
        // assign uncertain material properties if difference of max-min < 1.0
        if ((dithThresh[0] - dithThresh[1]) < (1.0 - 0.00001)) {
            material = phongUncertain;
        }
                
        vec4 pos      = ProjInv * gl_FragCoord.xyzw;
        vec4 light    = MV * lightPos;
        
        vec3 lightDir = normalize(lightPos.xyz);
            //vec3 lightDir = normalize(light.xyz - pos.xyz);
            
        vec3 n  = normal;
        vec3 e  = pos.xyz;
        vec3 h  = normalize(lightDir + e);
        float d = dot(n, lightDir);
        vec3 r  = normalize(2.0 * d * n - lightDir);
        vec3 c  = material.x * mycol.xyz + material.y * mycol.xyz * max(d, 0.0);
        
        vec4 eyenew = vec4(0.0, 0.0, 0.0, 1.0);
    
        if(dot(lightDir, n) < 0.0) {
            c += vec3(0.0);
        }
        else {
            c += material.z * vec3(pow(max(dot(r, lightDir), 0.0), material.w));
        }
        
        outCol = vec4(c, 1.0);
    
    }
-->
        </snippet>
    </shader>

</btf>
