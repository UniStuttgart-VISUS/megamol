<?xml version="1.0" encoding="utf-8"?>
<btf type="MegaMolGLSLShader" version="1.0" namespace="protein_cuda">
  <include file="common"/>
  <include file="colormaps"/>
  <include file="electrostatics"/>

  <snippet name="commondefines" type="string">
    <!-- 
//#define FOGGING_SES
//#define FLATSHADE_SES
#define OGL_DEPTH_SES
//#define SFB_DEMO

#define CLIP
#define DEPTH
#define SMALL_SPRITE_LIGHTING
//#define CALC_CAM_SYS

#ifdef DEBUG
#undef CLIP
#define RETICLE
#define AXISHINTS
#endif // DEBUG

//#define BULLSHIT

#ifndef FLACH
#define FLACH
#endif

//#define SET_COLOR
//#define COLOR1 vec3( 249.0/255.0, 187.0/255.0, 103.0/255.0)
#define COLOR1 vec3( 183.0/255.0, 204.0/255.0, 220.0/255.0)

//#define COLOR_SES
#define COLOR_BLUE vec3( 145.0/255.0, 191.0/255.0, 219.0/255.0)
#define COLOR_GREEN vec3( 161.0/255.0, 215.0/255.0, 106.0/255.0)
#define COLOR_YELLOW vec3( 255.0/255.0, 255.0/255.0, 191.0/255.0)
#define COLOR_RED vec3( 228.0/255.0, 37.0/255.0, 34.0/255.0)

-->
  </snippet>

  <namespace name="std">
    <shader name="sphereVertex">
      <snippet type="version">110</snippet>
      <snippet name="commondefines"/>
      <snippet type="string">
        <!--

#undef HALO
//#define HALO
#undef HALO_RAD
#define HALO_RAD  0.1

uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying float squarRad;
varying float rad;

#ifdef RETICLE
varying vec2 centerFragment;
#endif // RETICLE

void main(void) {

    // remove the sphere radius from the w coordinates to the rad varyings
    vec4 inPos = gl_Vertex;
    rad = inPos.w;
    squarRad = rad * rad;
    inPos.w = 1.0;

    
    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)


    // calculate cam position
    camPos = gl_ModelViewMatrixInverse[3]; // (C) by Christoph
    camPos.xyz -= objPos.xyz; // cam pos to glyph space
    

    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = gl_ModelViewMatrixInverse * gl_LightSource[0].position - objPos;
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    lightPos = gl_ModelViewMatrixInverse * normalize( gl_LightSource[0].position);
    
    

    // send color to fragment shader
    gl_FrontColor = gl_Color;


    // Sphere-Touch-Plane-Approach
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    vec2 d, p, q, h, dd;

    // get camera orthonormal coordinate system
    vec4 tmp;

#ifdef CALC_CAM_SYS
    // camera coordinate system in object space
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[2];
    vec3 camIn = normalize(tmp.xyz);
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[1];
    vec3 camUp = tmp.xyz;
    vec3 camRight = normalize(cross(camIn, camUp));
    camUp = cross(camIn, camRight);
#endif // CALC_CAM_SYS

    vec2 mins, maxs;
    vec3 testPos;
    vec4 projPos;

    
#ifdef HALO
    squarRad = (rad + HALO_RAD) * (rad + HALO_RAD);
#endif // HALO
    
    // projected camera vector
    vec3 c2 = vec3(dot(camPos.xyz, camRight), dot(camPos.xyz, camUp), dot(camPos.xyz, camIn));

    vec3 cpj1 = camIn * c2.z + camRight * c2.x;
    vec3 cpm1 = camIn * c2.x - camRight * c2.z;

    vec3 cpj2 = camIn * c2.z + camUp * c2.y;
    vec3 cpm2 = camIn * c2.y - camUp * c2.z;
    
    d.x = length(cpj1);
    d.y = length(cpj2);

    dd = vec2(1.0) / d;

    p = squarRad * dd;
    q = d - p;
    h = sqrt(p * q);
    //h = vec2(0.0);
    
    p *= dd;
    h *= dd;

    cpj1 *= p.x;
    cpm1 *= h.x;
    cpj2 *= p.y;
    cpm2 *= h.y;

    // TODO: rewrite only using four projections, additions in homogenous coordinates and delayed perspective divisions.
    testPos = objPos.xyz + cpj1 + cpm1;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = projPos.xy;
    maxs = projPos.xy;

    testPos -= 2.0 * cpm1;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos = objPos.xyz + cpj2 + cpm2;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos -= 2.0 * cpm2;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    gl_PointSize = max((maxs.x - mins.x) * winHalf.x, (maxs.y - mins.y) * winHalf.y) * 0.5;

#ifdef SMALL_SPRITE_LIGHTING
    // for normal crowbaring on very small sprites
    lightPos.w = (clamp(gl_PointSize, 1.0, 5.0) - 1.0) / 4.0;
#endif // SMALL_SPRITE_LIGHTING
    
#ifdef RETICLE
    centerFragment = gl_Position.xy / gl_Position.w;
#endif // RETICLE

    // gl_PointSize = 32.0;
    
#ifdef HALO
    squarRad = rad * rad;
#endif // HALO
}
-->
      </snippet>
    </shader>

    <shader name="sphereSolventVertex">
      <snippet type="version">110</snippet>
      <snippet name="commondefines"/>
      <snippet type="string">
        <!--

#undef HALO
//#define HALO
#undef HALO_RAD
#define HALO_RAD  0.1

uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

// density volume lookup for a simple neighbour test ...
uniform sampler3D volumeSampler;
uniform vec3 minBBox;
uniform vec3 invBBoxExtend;
uniform float solventMolThreshold;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying float squarRad;
varying float rad;

#ifdef RETICLE
varying vec2 centerFragment;
#endif // RETICLE

void main(void) {

    // remove the sphere radius from the w coordinates to the rad varyings
    vec4 inPos = gl_Vertex;
    rad = inPos.w;
    squarRad = rad * rad;

    // translate position to 3d-texture coordinates: (p-min) / ||max-min||
    vec3 volPos = (inPos.xyz - minBBox) * invBBoxExtend;
    inPos.w = texture3D(volumeSampler, volPos).w < solventMolThreshold ? 0.0 : 1.0; 
/*  if (texture3D(volumeSampler, volPos).w < solventMolThreshold)
        inPos.w = 0.0;  // return; ?
    else
        inPos.w = 1.0;*/
    // tut sowas?
//  float test = texture3D(volumeSampler, inPos.xyz).w < solventMolThreshold;
//  inPos.w = 1.0 - test;

    
    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)


    // calculate cam position
    camPos = gl_ModelViewMatrixInverse[3]; // (C) by Christoph
    camPos.xyz -= objPos.xyz; // cam pos to glyph space
    

    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = gl_ModelViewMatrixInverse * gl_LightSource[0].position - objPos;
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    lightPos = gl_ModelViewMatrixInverse * normalize( gl_LightSource[0].position);
    
    

    // send color to fragment shader
    gl_FrontColor = gl_Color;


    // Sphere-Touch-Plane-Approach
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    vec2 d, p, q, h, dd;

    // get camera orthonormal coordinate system
    vec4 tmp;

#ifdef CALC_CAM_SYS
    // camera coordinate system in object space
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[2];
    vec3 camIn = normalize(tmp.xyz);
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[1];
    vec3 camUp = tmp.xyz;
    vec3 camRight = normalize(cross(camIn, camUp));
    camUp = cross(camIn, camRight);
#endif // CALC_CAM_SYS

    vec2 mins, maxs;
    vec3 testPos;
    vec4 projPos;

    
#ifdef HALO
    squarRad = (rad + HALO_RAD) * (rad + HALO_RAD);
#endif // HALO
    
    // projected camera vector
    vec3 c2 = vec3(dot(camPos.xyz, camRight), dot(camPos.xyz, camUp), dot(camPos.xyz, camIn));

    vec3 cpj1 = camIn * c2.z + camRight * c2.x;
    vec3 cpm1 = camIn * c2.x - camRight * c2.z;

    vec3 cpj2 = camIn * c2.z + camUp * c2.y;
    vec3 cpm2 = camIn * c2.y - camUp * c2.z;
    
    d.x = length(cpj1);
    d.y = length(cpj2);

    dd = vec2(1.0) / d;

    p = squarRad * dd;
    q = d - p;
    h = sqrt(p * q);
    //h = vec2(0.0);
    
    p *= dd;
    h *= dd;

    cpj1 *= p.x;
    cpm1 *= h.x;
    cpj2 *= p.y;
    cpm2 *= h.y;

    // TODO: rewrite only using four projections, additions in homogenous coordinates and delayed perspective divisions.
    testPos = objPos.xyz + cpj1 + cpm1;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = projPos.xy;
    maxs = projPos.xy;

    testPos -= 2.0 * cpm1;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos = objPos.xyz + cpj2 + cpm2;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos -= 2.0 * cpm2;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    gl_Position = vec4((mins + maxs) * 0.5, 0.0, /*1.0*/inPos.w);
    gl_PointSize = max((maxs.x - mins.x) * winHalf.x, (maxs.y - mins.y) * winHalf.y) * 0.5;

#ifdef SMALL_SPRITE_LIGHTING
    // for normal crowbaring on very small sprites
    lightPos.w = (clamp(gl_PointSize, 1.0, 5.0) - 1.0) / 4.0;
#endif // SMALL_SPRITE_LIGHTING
    
#ifdef RETICLE
    centerFragment = gl_Position.xy / gl_Position.w;
#endif // RETICLE

    // gl_PointSize = 32.0;
    
#ifdef HALO
    squarRad = rad * rad;
#endif // HALO
}
-->
      </snippet>
    </shader>

    <shader name="visibleSolventMoleculeVertex">
      <snippet type="version">110</snippet>
      <snippet type="string">
        <!--
// density volume lookup for a simple neighbour test ...
uniform sampler3D volumeSampler;
uniform vec3 minBBox;
uniform vec3 invBBoxExtend;
uniform float solventMolThreshold;

attribute vec2 inParams;

void main(void) {
    // translate position to 3d-texture coordinates: ( pos - min) / ||max-min||
    vec3 volPos = ( gl_Vertex.xyz - minBBox) * invBBoxExtend;
    float visible = texture3D( volumeSampler, volPos).w < solventMolThreshold ? 0.0 : 1.0;  
    
    // send color to fragment shader
    //gl_FrontColor = vec4( 1.0, inParams.x, inParams.y, 1.0);
    gl_FrontColor = vec4( visible, inParams.x, inParams.y, 1.0);
    
    
    gl_Position = gl_ModelViewProjectionMatrix * vec4( float( int( inParams.y + 0.5) / 8192), 
        float( mod( floor( inParams.y + 0.5), 8192.0)), 
        0.0, visible);
    
    //gl_Position = gl_ModelViewProjectionMatrix * vec4( inParams.x, 0.0, 0.0, visible);
}
-->
      </snippet>
    </shader>

    <shader name="solventTypeCountVertex">
      <snippet type="version">110</snippet>
      <snippet type="string">
        <!--
void main(void) {
    // send color to fragment shader
    if( gl_Vertex.x > 0.0 )
        gl_FrontColor = vec4( 1.0, 1.0, 1.0, 1.0);
    else
        gl_FrontColor = vec4( 0.0, 0.0, 0.0, 0.0);
    
    gl_Position = gl_ModelViewProjectionMatrix * vec4( gl_Vertex.y, 0.0, 0.0, 1.0);
}
-->
      </snippet>
    </shader>

    <shader name="visibleSolventMoleculeFragment">
      <snippet type="version">110</snippet>
      <snippet type="string">
        <!--
                
void main(void) {
    gl_FragColor = gl_Color;
}
-->
      </snippet>
    </shader>

    <shader name="sphereVertexGeom">
      <snippet type="version">140</snippet>
      <snippet type="string">
        <!--
uniform mat4 modelview;
uniform mat4 proj;

in vec4 vertex;
in vec4 color;

out vec4 inColor;

void main(void) {
    gl_Position = vertex;
    inColor = color;
}
-->
      </snippet>
    </shader>

    <shader name="sphereGeom">
      <snippet type="version">140</snippet>
      <snippet type="string">
        <!--
#extension GL_ARB_gpu_shader5 : enable
#extension GL_EXT_geometry_shader4 : enable

//layout (points) in;
//layout (triangle_strip, max_vertices = 4) out;

uniform mat4 modelview;
uniform mat4 proj;
uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)
uniform vec4 lightPos;

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

in vec4 inColor[1];

out vec4 color;
out vec4 objPos;
out vec4 camPos;
out vec4 light;
out float rad;
out float squareRad;

mat4 modelviewproj = proj*modelview; // TODO Move this to the CPU?
mat4 modelviewInv = inverse(modelview);

void main(void) {
    
    // remove the sphere radius from the w coordinates to the rad varyings
    //vec4 inPos = gl_in[0].gl_Position;
    vec4 inPos = gl_PositionIn[0];
    rad = inPos.w;
    squareRad = rad*rad;
    inPos.w = 1.0;

    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)

    // calculate cam position
    camPos = modelviewInv[3]; // (C) by Christoph
    camPos.xyz -= objPos.xyz; // cam pos to glyph space
    
    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = modelviewInv * gl_LightSource[0].position - objPos;
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    light = modelviewInv*normalize(lightPos);
    
    color = inColor[0];    
    
       // Sphere-Touch-Plane-Approach
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    vec2 d, p, q, h, dd;

    // get camera orthonormal coordinate system
    vec4 tmp;

/*#ifdef CALC_CAM_SYS
    // camera coordinate system in object space
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[2];
    vec3 camIn = normalize(tmp.xyz);
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[1];
    vec3 camUp = tmp.xyz;
    vec3 camRight = normalize(cross(camIn, camUp));
    camUp = cross(camIn, camRight);
#endif // CALC_CAM_SYS*/

    vec2 mins, maxs;
    vec3 testPos;
    vec4 projPos;

    
#ifdef HALO
    squarRad = (rad + HALO_RAD) * (rad + HALO_RAD);
#endif // HALO
    
    // projected camera vector
    vec3 c2 = vec3(dot(camPos.xyz, camRight), dot(camPos.xyz, camUp), dot(camPos.xyz, camIn));

    vec3 cpj1 = camIn * c2.z + camRight * c2.x;
    vec3 cpm1 = camIn * c2.x - camRight * c2.z;

    vec3 cpj2 = camIn * c2.z + camUp * c2.y;
    vec3 cpm2 = camIn * c2.y - camUp * c2.z;
    
    d.x = length(cpj1);
    d.y = length(cpj2);

    dd = vec2(1.0) / d;

    p = squareRad * dd;
    q = d - p;
    h = sqrt(p * q);
    //h = vec2(0.0);
    
    p *= dd;
    h *= dd;

    cpj1 *= p.x;
    cpm1 *= h.x;
    cpj2 *= p.y;
    cpm2 *= h.y;

    testPos = objPos.xyz + cpj1 + cpm1;
    projPos = modelviewproj * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = projPos.xy;
    maxs = projPos.xy;

    testPos -= 2.0 * cpm1;
    projPos = modelviewproj * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos = objPos.xyz + cpj2 + cpm2;
    projPos = modelviewproj * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos -= 2.0 * cpm2;
    projPos = modelviewproj * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    //gl_Position = vec4((mins + maxs) * 0.5, 0.0, /*1.0*/inPos.w);
    //gl_PointSize = max((maxs.x - mins.x) * winHalf.x, (maxs.y - mins.y) * winHalf.y) * 0.5;
    
    // Cube vertices
    /*vec4 posA =  modelviewproj * vec4(objPos.xyz + (camRight + camUp + camIn)*rad, 1.0);
    vec4 posB =  modelviewproj * vec4(objPos.xyz + (camRight - camUp + camIn)*rad, 1.0);
    vec4 posC =  modelviewproj * vec4(objPos.xyz + (-camRight + camUp + camIn)*rad, 1.0);
    vec4 posD =  modelviewproj * vec4(objPos.xyz + (-camRight - camUp + camIn)*rad, 1.0);
    vec4 posE =  modelviewproj * vec4(objPos.xyz + (-camRight - camUp - camIn)*rad, 1.0);
    vec4 posF =  modelviewproj * vec4(objPos.xyz + (camRight - camUp - camIn)*rad, 1.0);
    vec4 posG =  modelviewproj * vec4(objPos.xyz + (camRight + camUp - camIn)*rad, 1.0);
    vec4 posH =  modelviewproj * vec4(objPos.xyz + (-camRight + camUp - camIn)*rad, 1.0);*/
    
    // Triangle strip
    /*gl_Position = posA; EmitVertex();
    gl_Position = posB; EmitVertex();
    gl_Position = posC; EmitVertex();
    gl_Position = posD; EmitVertex();
    gl_Position = posE; EmitVertex();
    gl_Position = posB; EmitVertex();
    gl_Position = posF; EmitVertex();
    gl_Position = posG; EmitVertex();
    gl_Position = posE; EmitVertex();
    gl_Position = posH; EmitVertex();
    gl_Position = posC; EmitVertex();
    gl_Position = posG; EmitVertex();
    gl_Position = posA; EmitVertex();
    gl_Position = posB; EmitVertex();
    gl_Position = posC; EmitVertex();
    gl_Position = posD; EmitVertex();
    gl_Position = posA; EmitVertex();
    gl_Position = posB; EmitVertex();*/
    gl_Position = vec4(mins.x, maxs.y, 0.0, inPos.w); EmitVertex();
    gl_Position = vec4(mins.x, mins.y, 0.0, inPos.w); EmitVertex();
    gl_Position = vec4(maxs.x, maxs.y, 0.0, inPos.w); EmitVertex();
    gl_Position = vec4(maxs.x, mins.y, 0.0, inPos.w); EmitVertex();
    EndPrimitive();
}
-->
      </snippet>
    </shader>
    
    
        <shader name="sphereFragmentCB">
      <snippet type="version">110</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet type="string">
        <!--

#undef HALO
//#define HALO
#undef HALO_RAD
#define HALO_RAD  0.1

uniform vec4 viewAttr;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying float squarRad;
varying float rad;

#ifdef RETICLE
varying vec2 centerFragment;
#endif // RETICLE

void main(void) {
    vec4 coord;
    vec3 ray;
    float lambda;
    vec3 color;
    vec3 sphereintersection = vec3( 0.0);
    vec3 normal;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    

    // transform fragment coordinates from view coordinates to object coordinates.
    coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;
    coord -= objPos; // ... and to glyph space
    

    // calc the viewing ray
    ray = normalize(coord.xyz - camPos.xyz);


    // calculate the geometry-ray-intersection
    float d1 = -dot(camPos.xyz, ray);                       // projected length of the cam-sphere-vector onto the ray
    float d2s = dot(camPos.xyz, camPos.xyz) - d1 * d1;      // off axis of cam-sphere-vector and ray
    float radicand = squarRad - d2s;                        // square of difference of projected length and lambda
#ifdef CLIP
    lambda = d1 - sqrt(radicand);                           // lambda

    float radicand2 = 0.0;
#ifdef HALO
    radicand2 = (rad+HALO_RAD)*(rad+HALO_RAD) - d2s;
    if( radicand2 < 0.0 ) {
        discard;
    }
    else if( radicand < 0.0 ) {
        // idea for halo from Tarini et al. (tvcg 2006)
        color = vec3(0.1);
        normal = vec3(0.0, 1.0, 0.0);
    }
#else
    if( radicand < 0.0 ) {
        discard;
    }
#endif // HALO
    else {
        // chose color for lighting
        //color = gl_Color.rgb;
        color = vec3(0.70, 0.8, 0.4);
        sphereintersection = lambda * ray + camPos.xyz;    // intersection point
        // "calc" normal at intersection point
        normal = sphereintersection / rad;
    }
    
#endif // CLIP

#ifdef SMALL_SPRITE_LIGHTING
    normal = mix(-ray, normal, lightPos.w);
#endif // SMALL_SPRITE_LIGHTING

#ifdef AXISHINTS
    // debug-axis-hints
    float mc = min(abs(normal.x), min(abs(normal.y), abs(normal.z)));
    if (mc < 0.05)            { color = vec3(0.5); }
    if (abs(normal.x) > 0.98) { color = vec3(1.0, 0.0, 0.0); }
    if (abs(normal.y) > 0.98) { color = vec3(0.0, 1.0, 0.0); }
    if (abs(normal.z) > 0.98) { color = vec3(0.0, 0.0, 1.0); }
    if (normal.x < -0.99)     { color = vec3(0.5); }
    if (normal.y < -0.99)     { color = vec3(0.5); }
    if (normal.z < -0.99)     { color = vec3(0.5); }
#endif // AXISHINTS

    // phong lighting with directional light
    //gl_FragColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color), 1.0);
    gl_FragColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color), gl_Color.w);
    gl_FragDepth = gl_FragCoord.z;

    // calculate depth
#ifdef DEPTH
    vec4 Ding = vec4( sphereintersection + objPos.xyz, 1.0);
    float depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
    float depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
    gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
    
#ifndef CLIP
    gl_FragDepth = (radicand < 0.0) ? 1.0 : ((depth / depthW) + 1.0) * 0.5;
    gl_FragColor.rgb = (radicand < 0.0) ? gl_Color.rgb : gl_FragColor.rgb;
#endif // CLIP

#endif // DEPTH

    
#ifdef RETICLE
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    if (min(abs(coord.x - centerFragment.x), abs(coord.y - centerFragment.y)) < 0.002) {
        //gl_FragColor.rgb = vec3(1.0, 1.0, 0.5);
        gl_FragColor.rgb += vec3(0.3, 0.3, 0.5);
    }
#endif // RETICLE

#ifdef PUXELS
if(puxels_use != 0)
    puxels_store(makePuxel(packUnorm4x8(gl_FragColor), normal, gl_FragDepth));
#endif

    //gl_FragColor.rgb = normal;
    //gl_FragColor.rgb = lightPos.xyz;
}
-->
      </snippet>
    </shader>

    <shader name="sphereFragment">
      <snippet type="version">110</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet type="string">
        <!--

#undef HALO
//#define HALO
#undef HALO_RAD
#define HALO_RAD  0.1

uniform vec4 viewAttr;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying float squarRad;
varying float rad;

#ifdef RETICLE
varying vec2 centerFragment;
#endif // RETICLE

void main(void) {
    vec4 coord;
    vec3 ray;
    float lambda;
    vec3 color;
    vec3 sphereintersection = vec3( 0.0);
    vec3 normal;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    

    // transform fragment coordinates from view coordinates to object coordinates.
    coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;
    coord -= objPos; // ... and to glyph space
    

    // calc the viewing ray
    ray = normalize(coord.xyz - camPos.xyz);


    // calculate the geometry-ray-intersection
    float d1 = -dot(camPos.xyz, ray);                       // projected length of the cam-sphere-vector onto the ray
    float d2s = dot(camPos.xyz, camPos.xyz) - d1 * d1;      // off axis of cam-sphere-vector and ray
    float radicand = squarRad - d2s;                        // square of difference of projected length and lambda
#ifdef CLIP
    lambda = d1 - sqrt(radicand);                           // lambda

    float radicand2 = 0.0;
#ifdef HALO
    radicand2 = (rad+HALO_RAD)*(rad+HALO_RAD) - d2s;
    if( radicand2 < 0.0 ) {
        discard;
    }
    else if( radicand < 0.0 ) {
        // idea for halo from Tarini et al. (tvcg 2006)
        color = vec3(0.1);
        normal = vec3(0.0, 1.0, 0.0);
    }
#else
    if( radicand < 0.0 ) {
        discard;
    }
#endif // HALO
    else {
        // chose color for lighting
        color = gl_Color.rgb;
        sphereintersection = lambda * ray + camPos.xyz;    // intersection point
        // "calc" normal at intersection point
        normal = sphereintersection / rad;
    }
    
#endif // CLIP

#ifdef SMALL_SPRITE_LIGHTING
    normal = mix(-ray, normal, lightPos.w);
#endif // SMALL_SPRITE_LIGHTING

#ifdef AXISHINTS
    // debug-axis-hints
    float mc = min(abs(normal.x), min(abs(normal.y), abs(normal.z)));
    if (mc < 0.05)            { color = vec3(0.5); }
    if (abs(normal.x) > 0.98) { color = vec3(1.0, 0.0, 0.0); }
    if (abs(normal.y) > 0.98) { color = vec3(0.0, 1.0, 0.0); }
    if (abs(normal.z) > 0.98) { color = vec3(0.0, 0.0, 1.0); }
    if (normal.x < -0.99)     { color = vec3(0.5); }
    if (normal.y < -0.99)     { color = vec3(0.5); }
    if (normal.z < -0.99)     { color = vec3(0.5); }
#endif // AXISHINTS

    // phong lighting with directional light
    //gl_FragColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color), 1.0);
    gl_FragColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color), gl_Color.w);
    gl_FragDepth = gl_FragCoord.z;

    // calculate depth
#ifdef DEPTH
    vec4 Ding = vec4( sphereintersection + objPos.xyz, 1.0);
    float depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
    float depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
    gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
    
#ifndef CLIP
    gl_FragDepth = (radicand < 0.0) ? 1.0 : ((depth / depthW) + 1.0) * 0.5;
    gl_FragColor.rgb = (radicand < 0.0) ? gl_Color.rgb : gl_FragColor.rgb;
#endif // CLIP

#endif // DEPTH

    
#ifdef RETICLE
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    if (min(abs(coord.x - centerFragment.x), abs(coord.y - centerFragment.y)) < 0.002) {
        //gl_FragColor.rgb = vec3(1.0, 1.0, 0.5);
        gl_FragColor.rgb += vec3(0.3, 0.3, 0.5);
    }
#endif // RETICLE

#ifdef PUXELS
if(puxels_use != 0)
    puxels_store(makePuxel(packUnorm4x8(gl_FragColor), normal, gl_FragDepth));
#endif

    //gl_FragColor.rgb = normal;
    //gl_FragColor.rgb = lightPos.xyz;
}
-->
      </snippet>
    </shader>

    <!-- offscreen rendering -->
    <shader name="sphereFragmentOR">
      <snippet type="version">110</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet type="string">
        <!--

#undef HALO
//#define HALO
#undef HALO_RAD
#define HALO_RAD  0.1

uniform vec4 viewAttr;
uniform vec2 zValues;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying float squarRad;
varying float rad;

#ifdef RETICLE
varying vec2 centerFragment;
#endif // RETICLE

void main(void) {
    vec4 coord;
    vec3 ray;
    float lambda;
    vec3 color;
    vec3 sphereintersection = vec3( 0.0);
    vec3 normal;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    

    // transform fragment coordinates from view coordinates to object coordinates.
    coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;
    coord -= objPos; // ... and to glyph space
    

    // calc the viewing ray
    ray = normalize(coord.xyz - camPos.xyz);


    // calculate the geometry-ray-intersection
    float d1 = -dot(camPos.xyz, ray);                       // projected length of the cam-sphere-vector onto the ray
    float d2s = dot(camPos.xyz, camPos.xyz) - d1 * d1;      // off axis of cam-sphere-vector and ray
    float radicand = squarRad - d2s;                        // square of difference of projected length and lambda
#ifdef CLIP
    lambda = d1 - sqrt(radicand);                           // lambda

    float radicand2 = 0.0;
#ifdef HALO
    radicand2 = (rad+HALO_RAD)*(rad+HALO_RAD) - d2s;
    if( radicand2 < 0.0 ) {
        discard;
    }
    else if( radicand < 0.0 ) {
        // idea for halo from Tarini et al. (tvcg 2006)
        color = vec3(0.1);
        normal = vec3(0.0, 1.0, 0.0);
    }
#else
    if( radicand < 0.0 ) {
        discard;
    }
#endif // HALO
    else {
        // chose color for lighting
        color = gl_Color.rgb;
        sphereintersection = lambda * ray + camPos.xyz;    // intersection point
        // "calc" normal at intersection point
        normal = sphereintersection / rad;
    }
    
#endif // CLIP

#ifdef SMALL_SPRITE_LIGHTING
    normal = mix(-ray, normal, lightPos.w);
#endif // SMALL_SPRITE_LIGHTING

#ifdef AXISHINTS
    // debug-axis-hints
    float mc = min(abs(normal.x), min(abs(normal.y), abs(normal.z)));
    if (mc < 0.05)            { color = vec3(0.5); }
    if (abs(normal.x) > 0.98) { color = vec3(1.0, 0.0, 0.0); }
    if (abs(normal.y) > 0.98) { color = vec3(0.0, 1.0, 0.0); }
    if (abs(normal.z) > 0.98) { color = vec3(0.0, 0.0, 1.0); }
    if (normal.x < -0.99)     { color = vec3(0.5); }
    if (normal.y < -0.99)     { color = vec3(0.5); }
    if (normal.z < -0.99)     { color = vec3(0.5); }
#endif // AXISHINTS

    // phong lighting with directional light
    //gl_FragColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color), 1.0);
    //gl_FragColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color), gl_Color.w);
    gl_FragData[0] = vec4(color, 1.0);
    
    // calculate depth
#ifdef DEPTH
    
    /*vec4 Ding = vec4(sphereintersection + objPos.xyz, 1.0);
    float depth = -dot(gl_ModelViewMatrixTranspose[2], Ding);
    //float depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding); 
    // Map near ... far to 0 ... 1
    gl_FragDepth = (depth - zValues.x) / (zValues.y - zValues.x);*/
    
    vec4 Ding = vec4(sphereintersection + objPos.xyz, 1.0);
    float depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
    float depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
    float d = ((depth / depthW) + 1.0) * 0.5;
    
    float n = zValues.x;
    float f = zValues.y;
    float depthES;

    // Unproject depth and switch sign -> positive eye space depth
    depthES = 2.0*n*f/(f+n-d*(f-n));
    // Map near ... far to 0 ... 1
    depthES = (depthES - n)/(f-n);
    
    gl_FragDepth = depthES;
    
#ifndef CLIP
    gl_FragDepth = (radicand < 0.0) ? 1.0 : (depth - zValues.y) / (zValues.z - zValues.y);
    gl_FragData[0].rgb = (radicand < 0.0) ? gl_Color.rgb : gl_FragData[0].rgb;
#endif // CLIP

#endif // DEPTH

    
#ifdef RETICLE
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    if (min(abs(coord.x - centerFragment.x), abs(coord.y - centerFragment.y)) < 0.002) {
        //gl_FragColor.rgb = vec3(1.0, 1.0, 0.5);
        gl_FragData[0].rgb += vec3(0.3, 0.3, 0.5);
    }
#endif // RETICLE

//    gl_FragColor.rgb = normal;
    //gl_FragData[1] = vec4(normalize(gl_NormalMatrix*normal), 1.0); // get eye space normal
    gl_FragData[1] = vec4(normalize(gl_NormalMatrix*normal), 1.0); // get eye space normal
}
-->
      </snippet>
    </shader>

    <shader name="sphereFragmentGeom">
      <snippet type="version">140</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet type="string">
        <!--
#extension GL_ARB_gpu_shader5 : enable
#extension GL_EXT_geometry_shader4 : enable

uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)
uniform mat4 modelview;
uniform mat4 proj;

in vec4 color;
in vec4 objPos;
in vec4 camPos;
in vec4 light;
in float rad;
in float squareRad;

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

mat4 modelviewproj = proj*modelview; // TODO Move this to the CPU?
mat4 modelviewprojInv = inverse(modelviewproj);
mat4 modelviewprojTrans = transpose(modelviewproj);

void main(void) {
    vec4 coord;
    vec3 ray;
    float lambda;
    vec3 colOut;
    vec3 sphereintersection = vec3( 0.0);
    vec3 normal;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    
    // transform fragment coordinates from view coordinates to object coordinates.
    coord = modelviewprojInv * coord;
    coord /= coord.w;
    coord -= objPos; // ... and to glyph space
    
    // calc the viewing ray
    ray = normalize(coord.xyz - camPos.xyz);

    // calculate the geometry-ray-intersection
    float d1 = -dot(camPos.xyz, ray);                       // projected length of the cam-sphere-vector onto the ray
    float d2s = dot(camPos.xyz, camPos.xyz) - d1 * d1;      // off axis of cam-sphere-vector and ray
    float radicand = squareRad - d2s;                        // square of difference of projected length and lambda
#ifdef CLIP
    lambda = d1 - sqrt(radicand);                           // lambda

    float radicand2 = 0.0;
    if( radicand < 0.0 ) {
        discard;
    }
    else {
        // chose color for lighting
        colOut = color.rgb;
        sphereintersection = lambda * ray + camPos.xyz;    // intersection point
        // "calc" normal at intersection point
        normal = sphereintersection / rad;
    }
    
#endif // CLIP

    // phong lighting with directional light
    //gl_FragColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color), 1.0);
    gl_FragColor = vec4(LocalLighting(ray, normal, light.xyz, colOut), color.w);
    
    // calculate depth
#ifdef DEPTH
    vec4 Ding = vec4(sphereintersection + objPos.xyz, 1.0);
    float depth = dot(modelviewprojTrans[2], Ding);
    float depthW = dot(modelviewprojTrans[3], Ding);
    gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
    
#ifndef CLIP
    gl_FragDepth = (radicand < 0.0) ? 1.0 : ((depth / depthW) + 1.0) * 0.5;
    gl_FragColor.rgb = (radicand < 0.0) ? color.rgb : gl_FragColor.rgb;
#endif // CLIP

#endif // DEPTH

    
#ifdef RETICLE
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    if (min(abs(coord.x - centerFragment.x), abs(coord.y - centerFragment.y)) < 0.002) {
        //gl_FragColor.rgb = vec3(1.0, 1.0, 0.5);
        gl_FragColor.rgb += vec3(0.3, 0.3, 0.5);
    }
#endif // RETICLE

//gl_FragColor.rgb = normal; // DEBUG
//gl_FragColor = color; // DEBUG
}
-->
      </snippet>
    </shader>

    <shader name="sphereClipPlaneVertex">
      <snippet type="version">110</snippet>
      <snippet name="commondefines"/>
      <snippet type="string">
        <!--
uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying float squarRad;
varying float rad;

#ifdef RETICLE
varying vec2 centerFragment;
#endif // RETICLE

void main(void) {

    // remove the sphere radius from the w coordinates to the rad varyings
    vec4 inPos = gl_Vertex;
    rad = inPos.w;
    squarRad = rad * rad;
    inPos.w = 1.0;

    
    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)


    // calculate cam position
    camPos = gl_ModelViewMatrixInverse[3]; // (C) by Christoph
    camPos.xyz -= objPos.xyz; // cam pos to glyph space
    

    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = gl_ModelViewMatrixInverse * gl_LightSource[0].position - objPos; // note: w is bullshit now!
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    lightPos = gl_ModelViewMatrixInverse * normalize( gl_LightSource[0].position);
    

    // send color to fragment shader
    gl_FrontColor = gl_Color;


    // Sphere-Touch-Plane-Approach
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    vec2 d, p, q, h, dd;

    // get camera orthonormal coordinate system
    vec4 tmp;

#ifdef CALC_CAM_SYS
    // camera coordinate system in object space
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[2];
    vec3 camIn = normalize(tmp.xyz);
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[1];
    vec3 camUp = tmp.xyz;
    vec3 camRight = normalize(cross(camIn, camUp));
    camUp = cross(camIn, camRight);
#endif // CALC_CAM_SYS

    vec2 mins, maxs;
    vec3 testPos;
    vec4 projPos;

    // projected camera vector
    vec3 c2 = vec3(dot(camPos.xyz, camRight), dot(camPos.xyz, camUp), dot(camPos.xyz, camIn));

    vec3 cpj1 = camIn * c2.z + camRight * c2.x;
    vec3 cpm1 = camIn * c2.x - camRight * c2.z;

    vec3 cpj2 = camIn * c2.z + camUp * c2.y;
    vec3 cpm2 = camIn * c2.y - camUp * c2.z;
    
    d.x = length(cpj1);
    d.y = length(cpj2);

    dd = vec2(1.0) / d;

    p = squarRad * dd;
    q = d - p;
    h = sqrt(p * q);
    //h = vec2(0.0);
    
    p *= dd;
    h *= dd;

    cpj1 *= p.x;
    cpm1 *= h.x;
    cpj2 *= p.y;
    cpm2 *= h.y;

    // TODO: rewrite only using four projections, additions in homogenous coordinates and delayed perspective divisions.
    testPos = objPos.xyz + cpj1 + cpm1;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = projPos.xy;
    maxs = projPos.xy;

    testPos -= 2.0 * cpm1;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos = objPos.xyz + cpj2 + cpm2;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos -= 2.0 * cpm2;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    gl_PointSize = max((maxs.x - mins.x) * winHalf.x, (maxs.y - mins.y) * winHalf.y) * 0.5;

#ifdef SMALL_SPRITE_LIGHTING
    // for normal crowbaring on very small sprites
    lightPos.w = (clamp(gl_PointSize, 1.0, 5.0) - 1.0) / 4.0;
#endif // SMALL_SPRITE_LIGHTING
    
#ifdef RETICLE
    centerFragment = gl_Position.xy / gl_Position.w;
#endif // RETICLE

    // gl_PointSize = 32.0;
}
-->
      </snippet>
    </shader>

    <shader name="sphereClipPlaneFragment">
      <snippet type="version">110</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet type="string">
        <!--
uniform vec4 viewAttr;

uniform vec3 clipPlaneDir;
uniform vec3 clipPlaneBase;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying float squarRad;
varying float rad;

#ifdef RETICLE
varying vec2 centerFragment;
#endif // RETICLE

void main(void) {
    vec4 coord;
    vec3 ray;
    float lambda;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    
    // transform fragment coordinates from view coordinates to object coordinates.
    coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;
    coord -= objPos; // ... and to glyph space

    // calc the viewing ray
    ray = normalize(coord.xyz - camPos.xyz);

    // calculate the geometry-ray-intersection
    float d1 = -dot(camPos.xyz, ray);                       // projected length of the cam-sphere-vector onto the ray
    float d2s = dot(camPos.xyz, camPos.xyz) - d1 * d1;      // off axis of cam-sphere-vector and ray
    float radicand = squarRad - d2s;                        // square of difference of projected length and lambda
#ifdef CLIP
    if (radicand < 0.0) { discard; }
#endif // CLIP
    lambda = d1 - sqrt(radicand);                           // lambda
    vec3 sphereintersection = lambda * ray + camPos.xyz;    // intersection point

    // "calc" normal at intersection point
    vec3 normal = sphereintersection / rad;
#ifdef SMALL_SPRITE_LIGHTING
    normal = mix(-ray, normal, lightPos.w);
#endif // SMALL_SPRITE_LIGHTING

    // chose color for lighting
    vec3 color = gl_Color.rgb;
  
    // cut with clipping plane
    vec3 planeNormal = normalize( clipPlaneDir);
    float d = -dot( planeNormal, clipPlaneBase - objPos.xyz);
    float dist1 = dot( sphereintersection, planeNormal) + d;
  float dist2 = d;
  float t = -( dot( planeNormal, camPos.xyz) + d ) / dot( planeNormal, ray);
  vec3 planeintersect = camPos.xyz + t * ray;
    if( dist1 > 0.0 )
  {
    if( dist2 < rad )
    {
      if( length( planeintersect) < rad )
      {
        sphereintersection = planeintersect;
        normal = planeNormal;
        color *= 0.6;
      }
      else
      {
        discard;
      }
    }
    else
    {
      discard;
    }
  }
  
#ifdef AXISHINTS
    // debug-axis-hints
    float mc = min(abs(normal.x), min(abs(normal.y), abs(normal.z)));
    if (mc < 0.05)            { color = vec3(0.5); }
    if (abs(normal.x) > 0.98) { color = vec3(1.0, 0.0, 0.0); }
    if (abs(normal.y) > 0.98) { color = vec3(0.0, 1.0, 0.0); }
    if (abs(normal.z) > 0.98) { color = vec3(0.0, 0.0, 1.0); }
    if (normal.x < -0.99)     { color = vec3(0.5); }
    if (normal.y < -0.99)     { color = vec3(0.5); }
    if (normal.z < -0.99)     { color = vec3(0.5); }
#endif // AXISHINTS

    // phong lighting with directional light
    gl_FragColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color), 1.0);
    
    // calculate depth
#ifdef DEPTH
    vec4 Ding = vec4(sphereintersection + objPos.xyz, 1.0);
    float depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
    float depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
    gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
#ifndef CLIP
    gl_FragDepth = (radicand < 0.0) ? 1.0 : ((depth / depthW) + 1.0) * 0.5;
    gl_FragColor.rgb = (radicand < 0.0) ? gl_Color.rgb : gl_FragColor.rgb;
#endif // CLIP
#endif // DEPTH

#ifdef RETICLE
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    if (min(abs(coord.x - centerFragment.x), abs(coord.y - centerFragment.y)) < 0.002) {
        //gl_FragColor.rgb = vec3(1.0, 1.0, 0.5);
        gl_FragColor.rgb += vec3(0.3, 0.3, 0.5);
    }
#endif // RETICLE

//    gl_FragColor.rgb = normal;
}
-->
      </snippet>
    </shader>

    <shader name="cylinderVertex">
      <snippet type="version">110</snippet>
      <snippet name="commondefines"/>
      <snippet type="string">
        <!--

uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

#ifdef DEBUG
uniform vec2 circleAttr;
#endif // DEBUG

//
attribute vec2 inParams;
attribute vec4 quatC; // conjugate quaternion
//

// colors of cylinder
attribute vec3 color1;
attribute vec3 color2;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying vec3 radz;

varying vec3 rotMatT0;
varying vec3 rotMatT1; // rotation matrix from the quaternion
varying vec3 rotMatT2;

#ifdef RETICLE
varying vec2 centerFragment;
#endif // RETICLE

void main(void) {
    const vec4 quatConst = vec4(1.0, -1.0, 0.5, 0.0);
    vec4 tmp, tmp1;

    // remove the sphere radius from the w coordinates to the rad varyings
    vec4 inPos = gl_Vertex;

    radz.x = inParams.x;
    radz.y = radz.x * radz.x;
    radz.z = inParams.y * 0.5;

    inPos.w = 1.0;

    
    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)


    // orientation quaternion to inverse rotation matrix conversion
    // Begin: Holy code!
    tmp = quatC.xzyw * quatC.yxzw;                        // tmp <- (xy, xz, yz, ww)
    tmp1 = quatC * quatC.w;                                // tmp1 <- (xw, yw, zw, %)
    tmp1.w = -quatConst.z;                                // tmp1 <- (xw, yw, zw, -0.5)

    rotMatT0.xyz = tmp1.wzy * quatConst.xxy + tmp.wxy;    // matrix0 <- (ww-0.5, xy+zw, xz-yw, %)
    rotMatT0.x = quatC.x * quatC.x + rotMatT0.x;        // matrix0 <- (ww+x*x-0.5, xy+zw, xz-yw, %)
    rotMatT0 = rotMatT0 + rotMatT0;                     // matrix0 <- (2(ww+x*x)-1, 2(xy+zw), 2(xz-yw), %)

    rotMatT1.xyz = tmp1.zwx * quatConst.yxx + tmp.xwz;     // matrix1 <- (xy-zw, ww-0.5, yz+xw, %)
    rotMatT1.y = quatC.y * quatC.y + rotMatT1.y;         // matrix1 <- (xy-zw, ww+y*y-0.5, yz+xw, %)
    rotMatT1 = rotMatT1 + rotMatT1;                     // matrix1 <- (2(xy-zw), 2(ww+y*y)-1, 2(yz+xw), %)

    rotMatT2.xyz = tmp1.yxw * quatConst.xyx + tmp.yzw;     // matrix2 <- (xz+yw, yz-xw, ww-0.5, %)
    rotMatT2.z = quatC.z * quatC.z + rotMatT2.z;         // matrix2 <- (xz+yw, yz-xw, ww+zz-0.5, %)
    rotMatT2 = rotMatT2 + rotMatT2;                     // matrix2 <- (2(xz+yw), 2(yz-xw), 2(ww+zz)-1, %)    
    // End: Holy code!


    // calculate cam position
    tmp = gl_ModelViewMatrixInverse[3]; // (C) by Christoph
    tmp.xyz -= objPos.xyz; // cam move
    camPos.xyz = rotMatT0 * tmp.x + rotMatT1 * tmp.y + rotMatT2 * tmp.z;
    

    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = gl_ModelViewMatrixInverse * gl_LightSource[0].position - objPos; // note: w is bullshit now!
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    lightPos = gl_ModelViewMatrixInverse * normalize( gl_LightSource[0].position);
    lightPos.xyz = rotMatT0 * lightPos.x + rotMatT1 * lightPos.y + rotMatT2 * lightPos.z;
    

    // send color to fragment shader
    gl_FrontColor = gl_Color;

    // calculate point sprite
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    // lumberjack approach
    vec4 pos, projPos;
    vec4 pX, pY, pZ, pOP;
    vec2 mins, maxs, pp;

#define CYL_HALF_LEN radz.z
#define CYL_RAD radz.x

    projPos.w = 0.0;

    //pos = vec4(0.0, 0.0, 0.0, 1.0);
    //projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    //projPos.y = dot(rotMatT1.xyz, pos.xyz);
    //projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos; // + projPos; // move
    pos.w = 1.0; // now we're in object space
    pOP = gl_ModelViewProjectionMatrix * pos;

    pos = vec4(1.0, 0.0, 0.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = gl_ModelViewProjectionMatrix * pos;
    pX = (projPos - pOP) * CYL_HALF_LEN;

    pos = vec4(0.0, 1.0, 0.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = gl_ModelViewProjectionMatrix * pos;
    pY = (projPos - pOP) * CYL_RAD;

    pos = vec4(0.0, 0.0, 1.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = gl_ModelViewProjectionMatrix * pos;
    pZ = (projPos - pOP) * CYL_RAD;

    // 8 corners of doom
    pos = pOP + pX;
    projPos = pos + pY + pZ;
    mins = maxs = projPos.xy / projPos.w;

    projPos = pos - pY + pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos + pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);


    pos = pOP - pX;
    projPos = pos + pY + pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY + pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos + pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);


    gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    maxs = (maxs - mins) * 0.5 * winHalf;
    gl_PointSize = max(maxs.x, maxs.y);


//    // oabb-approach
//    // calculate pOP, pX, pY, and pZ as above
//
//    pos = pOP + pX * circleAttr.x;
//    gl_Position = vec4(pos.xyz / pos.w, 1.0);
//
//    float l = camPos.y * camPos.y + camPos.z * camPos.z;
//    if (l < radz.y) { // radius-square
//        // camera is inside the cylinder
//        //  so choose nearest cap and we are done
//        gl_FrontSecondaryColor = vec4(0.5, 0.0, 0.0, 1.0);
//
//        // calculate 4 points of doom
//        pos = pOP + pX * sign(camPos.x);
//
//        projPos = pos + pY + pZ;
//        mins = maxs = projPos.xy / projPos.w;
//
//        projPos = pos - pY + pZ;
//        pp = projPos.xy / projPos.w;
//        mins = min(mins, pp);
//        maxs = max(maxs, pp);
//
//        projPos = pos + pY - pZ;
//        pp = projPos.xy / projPos.w;
//        mins = min(mins, pp);
//        maxs = max(maxs, pp);
//
//        projPos = pos - pY - pZ;
//        pp = projPos.xy / projPos.w;
//        mins = min(mins, pp);
//        maxs = max(maxs, pp);
//
//        gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
//        maxs = (maxs - mins) * 0.5 * winHalf;
//        gl_PointSize = max(maxs.x, maxs.y);
//
//    } else {
//        // camera is outside the cylinder
//        //  so find touching planes
//        gl_FrontSecondaryColor = vec4(0.0, 0.5, 0.0, 1.0);
//
//        vec2 j = vec2(camPos.y, camPos.z);
//        float d = length(j);
//        j /= d;
//        vec2 m = vec2(j.y, -j.x);
//        float p = radz.y / d;
//        float q = d - p;
//        float h = sqrt(p * q);
//
//        vec2 i = j * p + m * h * circleAttr.x;
//
//        i /= radz.x;
//
////        pos = pOP + pX * circleAttr.x + pY * n.y + pZ * n.z;
////        pos = pOP + pX + pY * circleAttr.y + pZ * circleAttr.x;
//
//        float minCylX = -CYL_HALF_LEN + (((radz.x - p * sign(-CYL_HALF_LEN - camPos.x)) * (-CYL_HALF_LEN - camPos.x)) / (-d * sign(-CYL_HALF_LEN - camPos.x) + radz.x)); // tut net so ganz
//        float maxCylX =  CYL_HALF_LEN + (((radz.x + p * sign(CYL_HALF_LEN - camPos.x)) * (CYL_HALF_LEN - camPos.x)) / (d * sign(CYL_HALF_LEN - camPos.x) + radz.x)); // tut, keine Ahnung warum
//
//
//        float fX = mix(minCylX, maxCylX, (circleAttr.y + 1.0) * 0.5);
//
//        pX /= CYL_HALF_LEN;
//
//        pos = pOP + pX * fX + pY * i.x + pZ * i.y;
//      
//        gl_Position = vec4(pos.xyz / pos.w, 1.0);
//
//    }


#ifdef RETICLE
    centerFragment = gl_Position.xy / gl_Position.w;
#endif // RETICLE
    
    // set colors
    gl_FrontColor.r = color1.r;
    gl_FrontColor.g = color1.g;
    gl_FrontColor.b = color1.b;

    gl_FrontSecondaryColor.r = color2.r;
    gl_FrontSecondaryColor.g = color2.g;
    gl_FrontSecondaryColor.b = color2.b;
    
}
-->
      </snippet>
    </shader>

    <shader name="cylinderSolventVertex">
      <snippet type="version">110</snippet>
      <snippet name="commondefines"/>
      <snippet type="string">
        <!--

uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

#ifdef DEBUG
uniform vec2 circleAttr;
#endif // DEBUG

//
attribute vec2 inParams;
attribute vec4 quatC; // conjugate quaternion
//

// colors of cylinder
attribute vec3 color1;
attribute vec3 color2;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying vec3 radz;

varying vec3 rotMatT0;
varying vec3 rotMatT1; // rotation matrix from the quaternion
varying vec3 rotMatT2;

#ifdef RETICLE
varying vec2 centerFragment;
#endif // RETICLE

// density volume lookup for a simple neighbour test ...
uniform sampler3D volumeSampler;
uniform vec3 minBBox;
uniform vec3 invBBoxExtend;
uniform float solventMolThreshold;

void main(void) {
    const vec4 quatConst = vec4(1.0, -1.0, 0.5, 0.0);
    vec4 tmp, tmp1;

    // remove the sphere radius from the w coordinates to the rad varyings
    vec4 inPos = gl_Vertex;

    radz.x = inParams.x;
    radz.y = radz.x * radz.x;
    radz.z = inParams.y * 0.5;

    vec3 volPos = (inPos.xyz - minBBox) * invBBoxExtend;
    inPos.w = texture3D(volumeSampler, volPos).w < solventMolThreshold ? 0.0 : 1.0; 
/*  if (texture3D(volumeSampler, volPos).w < solventMolThreshold)
        inPos.w = 0.0;  // return; ?
    else
        inPos.w = 1.0;*/
    // tut sowas?
//  float test = texture3D(volumeSampler, inPos.xyz).w < solventMolThreshold;
//  inPos.w = 1.0 - test;

    
    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)


    // orientation quaternion to inverse rotation matrix conversion
    // Begin: Holy code!
    tmp = quatC.xzyw * quatC.yxzw;                        // tmp <- (xy, xz, yz, ww)
    tmp1 = quatC * quatC.w;                                // tmp1 <- (xw, yw, zw, %)
    tmp1.w = -quatConst.z;                                // tmp1 <- (xw, yw, zw, -0.5)

    rotMatT0.xyz = tmp1.wzy * quatConst.xxy + tmp.wxy;    // matrix0 <- (ww-0.5, xy+zw, xz-yw, %)
    rotMatT0.x = quatC.x * quatC.x + rotMatT0.x;        // matrix0 <- (ww+x*x-0.5, xy+zw, xz-yw, %)
    rotMatT0 = rotMatT0 + rotMatT0;                     // matrix0 <- (2(ww+x*x)-1, 2(xy+zw), 2(xz-yw), %)

    rotMatT1.xyz = tmp1.zwx * quatConst.yxx + tmp.xwz;     // matrix1 <- (xy-zw, ww-0.5, yz+xw, %)
    rotMatT1.y = quatC.y * quatC.y + rotMatT1.y;         // matrix1 <- (xy-zw, ww+y*y-0.5, yz+xw, %)
    rotMatT1 = rotMatT1 + rotMatT1;                     // matrix1 <- (2(xy-zw), 2(ww+y*y)-1, 2(yz+xw), %)

    rotMatT2.xyz = tmp1.yxw * quatConst.xyx + tmp.yzw;     // matrix2 <- (xz+yw, yz-xw, ww-0.5, %)
    rotMatT2.z = quatC.z * quatC.z + rotMatT2.z;         // matrix2 <- (xz+yw, yz-xw, ww+zz-0.5, %)
    rotMatT2 = rotMatT2 + rotMatT2;                     // matrix2 <- (2(xz+yw), 2(yz-xw), 2(ww+zz)-1, %)    
    // End: Holy code!


    // calculate cam position
    tmp = gl_ModelViewMatrixInverse[3]; // (C) by Christoph
    tmp.xyz -= objPos.xyz; // cam move
    camPos.xyz = rotMatT0 * tmp.x + rotMatT1 * tmp.y + rotMatT2 * tmp.z;
    

    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = gl_ModelViewMatrixInverse * gl_LightSource[0].position - objPos; // note: w is bullshit now!
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    lightPos = gl_ModelViewMatrixInverse * normalize( gl_LightSource[0].position);
    lightPos.xyz = rotMatT0 * lightPos.x + rotMatT1 * lightPos.y + rotMatT2 * lightPos.z;
    

    // send color to fragment shader
    gl_FrontColor = gl_Color;

    // calculate point sprite
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    // lumberjack approach
    vec4 pos, projPos;
    vec4 pX, pY, pZ, pOP;
    vec2 mins, maxs, pp;

#define CYL_HALF_LEN radz.z
#define CYL_RAD radz.x

    projPos.w = 0.0;

    //pos = vec4(0.0, 0.0, 0.0, 1.0);
    //projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    //projPos.y = dot(rotMatT1.xyz, pos.xyz);
    //projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos; // + projPos; // move
    pos.w = 1.0; // now we're in object space
    pOP = gl_ModelViewProjectionMatrix * pos;

    pos = vec4(1.0, 0.0, 0.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = gl_ModelViewProjectionMatrix * pos;
    pX = (projPos - pOP) * CYL_HALF_LEN;

    pos = vec4(0.0, 1.0, 0.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = gl_ModelViewProjectionMatrix * pos;
    pY = (projPos - pOP) * CYL_RAD;

    pos = vec4(0.0, 0.0, 1.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = gl_ModelViewProjectionMatrix * pos;
    pZ = (projPos - pOP) * CYL_RAD;

    // 8 corners of doom
    pos = pOP + pX;
    projPos = pos + pY + pZ;
    mins = maxs = projPos.xy / projPos.w;

    projPos = pos - pY + pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos + pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);


    pos = pOP - pX;
    projPos = pos + pY + pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY + pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos + pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);


    gl_Position = vec4((mins + maxs) * 0.5, 0.0, inPos.w);
    maxs = (maxs - mins) * 0.5 * winHalf;
    gl_PointSize = max(maxs.x, maxs.y);


//    // oabb-approach
//    // calculate pOP, pX, pY, and pZ as above
//
//    pos = pOP + pX * circleAttr.x;
//    gl_Position = vec4(pos.xyz / pos.w, inPos.w);
//
//    float l = camPos.y * camPos.y + camPos.z * camPos.z;
//    if (l < radz.y) { // radius-square
//        // camera is inside the cylinder
//        //  so choose nearest cap and we are done
//        gl_FrontSecondaryColor = vec4(0.5, 0.0, 0.0, 1.0);
//
//        // calculate 4 points of doom
//        pos = pOP + pX * sign(camPos.x);
//
//        projPos = pos + pY + pZ;
//        mins = maxs = projPos.xy / projPos.w;
//
//        projPos = pos - pY + pZ;
//        pp = projPos.xy / projPos.w;
//        mins = min(mins, pp);
//        maxs = max(maxs, pp);
//
//        projPos = pos + pY - pZ;
//        pp = projPos.xy / projPos.w;
//        mins = min(mins, pp);
//        maxs = max(maxs, pp);
//
//        projPos = pos - pY - pZ;
//        pp = projPos.xy / projPos.w;
//        mins = min(mins, pp);
//        maxs = max(maxs, pp);
//
//        gl_Position = vec4((mins + maxs) * 0.5, 0.0, inPos.w);
//        maxs = (maxs - mins) * 0.5 * winHalf;
//        gl_PointSize = max(maxs.x, maxs.y);
//
//    } else {
//        // camera is outside the cylinder
//        //  so find touching planes
//        gl_FrontSecondaryColor = vec4(0.0, 0.5, 0.0, 1.0);
//
//        vec2 j = vec2(camPos.y, camPos.z);
//        float d = length(j);
//        j /= d;
//        vec2 m = vec2(j.y, -j.x);
//        float p = radz.y / d;
//        float q = d - p;
//        float h = sqrt(p * q);
//
//        vec2 i = j * p + m * h * circleAttr.x;
//
//        i /= radz.x;
//
////        pos = pOP + pX * circleAttr.x + pY * n.y + pZ * n.z;
////        pos = pOP + pX + pY * circleAttr.y + pZ * circleAttr.x;
//
//        float minCylX = -CYL_HALF_LEN + (((radz.x - p * sign(-CYL_HALF_LEN - camPos.x)) * (-CYL_HALF_LEN - camPos.x)) / (-d * sign(-CYL_HALF_LEN - camPos.x) + radz.x)); // tut net so ganz
//        float maxCylX =  CYL_HALF_LEN + (((radz.x + p * sign(CYL_HALF_LEN - camPos.x)) * (CYL_HALF_LEN - camPos.x)) / (d * sign(CYL_HALF_LEN - camPos.x) + radz.x)); // tut, keine Ahnung warum
//
//
//        float fX = mix(minCylX, maxCylX, (circleAttr.y + 1.0) * 0.5);
//
//        pX /= CYL_HALF_LEN;
//
//        pos = pOP + pX * fX + pY * i.x + pZ * i.y;
//      
//        gl_Position = vec4(pos.xyz / pos.w, inPos.w);
//
//    }


#ifdef RETICLE
    centerFragment = gl_Position.xy / gl_Position.w;
#endif // RETICLE
    
    // set colors
    gl_FrontColor.r = color1.r;
    gl_FrontColor.g = color1.g;
    gl_FrontColor.b = color1.b;

    gl_FrontSecondaryColor.r = color2.r;
    gl_FrontSecondaryColor.g = color2.g;
    gl_FrontSecondaryColor.b = color2.b;
    
}
-->
      </snippet>
    </shader>

    <shader name="cylinderVertexGeom">
      <snippet type="version">140</snippet>
      <snippet type="string">
        <!--
in vec4 vertex;
in vec2 params;
in vec4 quatC; // conjugate quaternion
in vec3 color1;
in vec3 color2;

out vec2 inParams;
out vec4 inQuatC; 
out vec3 inColor1;
out vec3 inColor2;

void main(void) {
    gl_Position = vertex;
    inParams = params;
    inQuatC = quatC;
    inColor1 = color1;
    inColor2 = color2;
}
-->
      </snippet>
    </shader>

    <shader name="cylinderGeom">
      <snippet type="version">140</snippet>
      <snippet type="string">
        <!--
#extension GL_ARB_gpu_shader5 : enable
#extension GL_EXT_geometry_shader4 : enable

//layout (points) in;
//layout (triangle_strip, max_vertices = 4) out;

uniform mat4 modelview;
uniform mat4 proj;
uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)
uniform vec4 lightPos;

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

in vec2 inParams[1];
in vec4 inQuatC[1]; 
in vec3 inColor1[1];
in vec3 inColor2[1];

out vec4 objPos;
out vec4 camPos;
out vec4 light;
out vec3 radz;
out vec3 rotMatT0;
out vec3 rotMatT1; // rotation matrix from the quaternion
out vec3 rotMatT2;
out vec3 colOut1;
out vec3 colOut2;

mat4 modelviewproj = proj*modelview; // TODO Move this to the CPU?
mat4 modelviewInv = inverse(modelview);

void main(void) {
    const vec4 quatConst = vec4(1.0, -1.0, 0.5, 0.0);
    vec4 tmp, tmp1;

    // remove the sphere radius from the w coordinates to the rad varyings
    vec4 inPos = gl_PositionIn[0];

    radz.x = inParams[0].x;
    radz.y = radz.x*radz.x;
    radz.z = inParams[0].y * 0.5;

    inPos.w = 1.0;

    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)


    // orientation quaternion to inverse rotation matrix conversion
    // Begin: Holy code!
    tmp = inQuatC[0].xzyw * inQuatC[0].yxzw;                  // tmp <- (xy, xz, yz, ww)
    tmp1 = inQuatC[0] * inQuatC[0].w;                         // tmp1 <- (xw, yw, zw, %)
    tmp1.w = -quatConst.z;                                    // tmp1 <- (xw, yw, zw, -0.5)

    rotMatT0.xyz = tmp1.wzy * quatConst.xxy + tmp.wxy;        // matrix0 <- (ww-0.5, xy+zw, xz-yw, %)
    rotMatT0.x = inQuatC[0].x * inQuatC[0].x + rotMatT0.x;    // matrix0 <- (ww+x*x-0.5, xy+zw, xz-yw, %)
    rotMatT0 = rotMatT0 + rotMatT0;                           // matrix0 <- (2(ww+x*x)-1, 2(xy+zw), 2(xz-yw), %)

    rotMatT1.xyz = tmp1.zwx * quatConst.yxx + tmp.xwz;        // matrix1 <- (xy-zw, ww-0.5, yz+xw, %)
    rotMatT1.y = inQuatC[0].y * inQuatC[0].y + rotMatT1.y;    // matrix1 <- (xy-zw, ww+y*y-0.5, yz+xw, %)
    rotMatT1 = rotMatT1 + rotMatT1;                           // matrix1 <- (2(xy-zw), 2(ww+y*y)-1, 2(yz+xw), %)

    rotMatT2.xyz = tmp1.yxw * quatConst.xyx + tmp.yzw;        // matrix2 <- (xz+yw, yz-xw, ww-0.5, %)
    rotMatT2.z = inQuatC[0].z * inQuatC[0].z + rotMatT2.z;    // matrix2 <- (xz+yw, yz-xw, ww+zz-0.5, %)
    rotMatT2 = rotMatT2 + rotMatT2;                           // matrix2 <- (2(xz+yw), 2(yz-xw), 2(ww+zz)-1, %)    
    // End: Holy code!


    // calculate cam position
    tmp = modelviewInv[3]; // (C) by Christoph
    tmp.xyz -= objPos.xyz; // cam move
    camPos.xyz = rotMatT0 * tmp.x + rotMatT1 * tmp.y + rotMatT2 * tmp.z;
    

    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = gl_ModelViewMatrixInverse * gl_LightSource[0].position - objPos; // note: w is bullshit now!
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    light = modelviewInv * normalize(lightPos);
    light.xyz = rotMatT0 * light.x + rotMatT1 * light.y + rotMatT2 * light.z;
    

    // send color to fragment shader 
    colOut1 = inColor1[0];
    colOut2 = inColor2[0];

    // calculate point sprite
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    // lumberjack approach
    vec4 pos, projPos;
    vec4 pX, pY, pZ, pOP;
    vec2 mins, maxs, pp;

#define CYL_HALF_LEN radz.z
#define CYL_RAD radz.x

    projPos.w = 0.0;

    //pos = vec4(0.0, 0.0, 0.0, 1.0);
    //projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    //projPos.y = dot(rotMatT1.xyz, pos.xyz);
    //projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos; // + projPos; // move
    pos.w = 1.0; // now we're in object space
    pOP = modelviewproj * pos;

    pos = vec4(1.0, 0.0, 0.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = modelviewproj * pos;
    pX = (projPos - pOP) * CYL_HALF_LEN;

    pos = vec4(0.0, 1.0, 0.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = modelviewproj * pos;
    pY = (projPos - pOP) * CYL_RAD;

    pos = vec4(0.0, 0.0, 1.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = modelviewproj * pos;
    pZ = (projPos - pOP) * CYL_RAD;

    // 8 corners of doom
    pos = pOP + pX;
    projPos = pos + pY + pZ;
    mins = maxs = projPos.xy / projPos.w;
//    mins = maxs = projPos.xy;

    projPos = pos - pY + pZ;
    pp = projPos.xy / projPos.w;
    //pp = projPos.xy;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos + pY - pZ;
    pp = projPos.xy / projPos.w;
    //pp = projPos.xy;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY - pZ;
    pp = projPos.xy / projPos.w;
    //pp = projPos.xy;
    mins = min(mins, pp);
    maxs = max(maxs, pp);


    pos = pOP - pX;
    projPos = pos + pY + pZ;
    pp = projPos.xy / projPos.w;
    //pp = projPos.xy;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY + pZ;
    pp = projPos.xy / projPos.w;
    //pp = projPos.xy;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos + pY - pZ;
    pp = projPos.xy / projPos.w;
    //pp = projPos.xy;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY - pZ;
    pp = projPos.xy / projPos.w;
    //pp = projPos.xy;
    mins = min(mins, pp);
    maxs = max(maxs, pp);


    vec4 center = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    //maxs = (maxs - mins) * 0.5 * winHalf;
    float point_size_cs = max((maxs*projPos.w - mins*projPos.w).x, (maxs*projPos.w - mins*projPos.w).y);
    //maxs = vec2(max(maxs.x, maxs.y), max(maxs.x, maxs.y));
    //mins = vec2(min(mins.x, mins.y), min(mins.x, mins.y));
    
    //colOut1 = vec3(1.0, 0.0, 0.0);
    gl_Position = vec4(mins.x, maxs.y, 0.0, 1.0); EmitVertex();
//    vec4 posTest = pOP - pX + pY + pZ; 
//    posTest.xyz /= posTest.w;
//    gl_Position = vec4(posTest.xyz, 1.0); EmitVertex();
//    gl_Position = modelviewproj*vec4(objPos.xyz-camRight*0.7+camUp*0.7, 1.0); EmitVertex();
    //colOut1 = vec3(0.0, 1.0, 0.0);
    gl_Position = vec4(mins.x, mins.y, 0.0, 1.0); EmitVertex();
//    posTest = pOP - pX - pY + pZ; 
//    posTest.xyz /= posTest.w;
//    gl_Position = vec4(posTest.xyz, 1.0); EmitVertex();
//    gl_Position = modelviewproj*vec4(objPos.xyz-camRight*0.7-camUp*0.7, 1.0); EmitVertex();
    //colOut1 = vec3(0.0, 0.0, 1.0);
    gl_Position = vec4(maxs.x, maxs.y, 0.0, 1.0); EmitVertex();
//    posTest = pOP + pX + pY + pZ; 
//    posTest.xyz /= posTest.w;
//    gl_Position = vec4(posTest.xyz, 1.0); EmitVertex();
//    gl_Position = modelviewproj*vec4(objPos.xyz+camRight*0.7+camUp*0.7, 1.0); EmitVertex();
    //colOut1 = vec3(1.0, 1.0, 1.0);
    gl_Position = vec4(maxs.x, mins.y, 0.0, 1.0); EmitVertex();
//    posTest = pOP + pX - pY + pZ; 
//    posTest.xyz /= posTest.w;
//    gl_Position = vec4(posTest.xyz, 1.0); EmitVertex();
//    gl_Position = modelviewproj*vec4(objPos.xyz+camRight*0.7-camUp*0.7, 1.0); EmitVertex();
    
    EndPrimitive();    
}
-->
      </snippet>
    </shader>

    <shader name="cylinderFragment">
      <snippet type="version">110</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet type="string">
        <!--

//#undef CLIP

// #define RENDER_CAPS

uniform vec4 viewAttr;

FLACH varying vec4 objPos;
FLACH varying vec4 camPos;
FLACH varying vec4 lightPos;
FLACH varying vec3 radz;

FLACH varying vec3 rotMatT0;
FLACH varying vec3 rotMatT1; // rotation matrix from the quaternion
FLACH varying vec3 rotMatT2;

#ifdef RETICLE
FLACH varying vec2 centerFragment;
#endif // RETICLE

void main(void) {
    vec4 coord;
    vec3 ray, tmp;
    const float maxLambda = 50000.0;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    

    // transform fragment coordinates from view coordinates to object coordinates.
    coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;
    coord -= objPos; // ... and move


    // calc the viewing ray
    ray = rotMatT0 * coord.x + rotMatT1 * coord.y + rotMatT2 * coord.z;
    ray = normalize(ray - camPos.xyz);


    // calculate the geometry-ray-intersection

    // cylinder parameters
#define CYL_RAD radz.x
#define CYL_RAD_SQ radz.y
#define CYL_HALF_LEN radz.z

    float rDc = dot(ray.yz, camPos.yz);
    float rDr = dot(ray.yz, ray.yz);

    float radicand = (rDc * rDc) - (rDr * (dot(camPos.yz, camPos.yz) - CYL_RAD_SQ));

#ifdef CLIP
    if (radicand < 0.0) { discard; }
#endif // CLIP

   float radix = sqrt(radicand);
    vec2 lambdas = vec2((-rDc - radix) / rDr, (-rDc + radix) / rDr);

    // calculations for cylinder caps
    vec3 cylPt1 = camPos.xyz + ray * lambdas.x;
    vec3 cylPt2 = camPos.xyz + ray * lambdas.y;

#ifdef RENDER_CAPS
    bool cylPt1Right = (cylPt1.x > 0.0);
#endif // RENDER_CAPS
    bool cylPt1Valid = (cylPt1.x <= CYL_HALF_LEN) && (cylPt1.x >= -CYL_HALF_LEN); // trim cylinder
#ifdef RENDER_CAPS
    bool cylPt2Valid = cylPt1Right ? (cylPt2.x <= CYL_HALF_LEN) : (cylPt2.x >= -CYL_HALF_LEN);
#else
    bool cylPt2Valid = (cylPt2.x <= CYL_HALF_LEN) && (cylPt2.x >= -CYL_HALF_LEN);
#endif // RENDER_CAPS

#ifdef RENDER_CAPS
    lambdas.x = cylPt1Valid ? lambdas.x : (((cylPt1Right ? CYL_HALF_LEN : -CYL_HALF_LEN) - camPos.x) / ray.x);
    lambdas.x = (cylPt1Valid || cylPt2Valid) ? lambdas.x : maxLambda;

#ifdef CLIP
    if (lambdas.x >= maxLambda) { discard; }
#else // CLIP
    if (lambdas.x >= maxLambda) { radicand = -1.0; }
#endif // CLIP

#else // RENDER_CAPS
    lambdas.x = (cylPt1Valid) ? lambdas.x : lambdas.y;    

#ifdef CLIP
    if ((!cylPt1Valid && !cylPt2Valid)) { discard; }
#else // CLIP
    if ((!cylPt1Valid && !cylPt2Valid)) { radicand = -1.0; }
#endif // CLIP
#endif // RENDER_CAPS

    vec3 intersection = camPos.xyz + ray * lambdas.x;
#ifdef RENDER_CAPS
    vec3 normal = (cylPt1Valid ? vec3(0.0, normalize(intersection.yz)) : (cylPt1Right ? vec3(1.0, 0.0, 0.0) : vec3(-1.0, 0.0, 0.0)));
#else // RENDER_CAPS
    vec3 normal = vec3(0.0, normalize(intersection.yz));
#endif // RENDER_CAPS


    // chose color for lighting
    vec3 color = gl_Color.rgb;

    // set fragment color (kroneml)
    if( cylPt1.x > 0.0 )
    {
        color = gl_SecondaryColor.rgb;
    }
    else
    {
        color = gl_Color.rgb;
    }

    // phong lighting with directional light
    gl_FragColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color), 1.0);


    // calculate depth
#ifdef DEPTH
    tmp = intersection;
    intersection.x = dot(rotMatT0, tmp.xyz);
    intersection.y = dot(rotMatT1, tmp.xyz);
    intersection.z = dot(rotMatT2, tmp.xyz);

    intersection += objPos.xyz;

    vec4 Ding = vec4(intersection, 1.0);
    float depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
    float depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
#ifndef CLIP
    if (radicand < 0.0) { 
        gl_FragColor = gl_SecondaryColor;
        depth = 1.0;
        depthW = 1.0;
    }
#endif // CLIP
    gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
#endif // DEPTH

#ifdef RETICLE
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    if (min(abs(coord.x - centerFragment.x), abs(coord.y - centerFragment.y)) < 0.002) {
        gl_FragColor.rgb += vec3(0.3, 0.3, 0.5);
    }
#endif // RETICLE
//    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
//    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
}
-->
      </snippet>
    </shader>

    <shader name="cylinderFragmentGeom">
      <snippet type="version">140</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet type="string">
        <!--
#extension GL_ARB_gpu_shader5 : enable
#extension GL_EXT_geometry_shader4 : enable

//#undef CLIP

uniform mat4 modelview;
uniform mat4 proj;
uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)
//uniform vec4 lightPos;

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

in vec4 objPos;
in vec4 camPos;
in vec4 light;
in vec3 radz;
in vec3 rotMatT0;
in vec3 rotMatT1; // rotation matrix from the quaternion
in vec3 rotMatT2;
in vec3 colOut1;
in vec3 colOut2;

mat4 modelviewproj = proj*modelview; // TODO Move this to the CPU?
mat4 modelviewprojInv = inverse(modelviewproj);
mat4 modelviewprojTrans = transpose(modelviewproj);

void main(void) {
    vec4 coord;
    vec3 ray, tmp;
    const float maxLambda = 50000.0;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    

    // transform fragment coordinates from view coordinates to object coordinates.
    coord = modelviewprojInv * coord;
    coord /= coord.w;
    coord -= objPos; // ... and move


    // calc the viewing ray
    ray = rotMatT0 * coord.x + rotMatT1 * coord.y + rotMatT2 * coord.z;
    ray = normalize(ray - camPos.xyz);

    // calculate the geometry-ray-intersection

    // cylinder parameters
#define CYL_RAD radz.x
#define CYL_RAD_SQ radz.y
#define CYL_HALF_LEN radz.z

    float rDc = dot(ray.yz, camPos.yz);
    float rDr = dot(ray.yz, ray.yz);

    float radicand = (rDc * rDc) - (rDr * (dot(camPos.yz, camPos.yz) - CYL_RAD_SQ));

#ifdef CLIP
    if (radicand < 0.0) { discard; }
#endif // CLIP

    float radix = sqrt(radicand);
    vec2 lambdas = vec2((-rDc - radix) / rDr, (-rDc + radix) / rDr);

    // calculations for cylinder caps
    vec3 cylPt1 = camPos.xyz + ray * lambdas.x;
    vec3 cylPt2 = camPos.xyz + ray * lambdas.y;


#ifdef RENDER_CAPS
    bool cylPt1Right = (cylPt1.x > 0.0);
#endif // RENDER_CAPS
    bool cylPt1Valid = (cylPt1.x <= CYL_HALF_LEN) && (cylPt1.x >= -CYL_HALF_LEN); // trim cylinder
#ifdef RENDER_CAPS
    bool cylPt2Valid = cylPt1Right ? (cylPt2.x <= CYL_HALF_LEN) : (cylPt2.x >= -CYL_HALF_LEN);
#else
    bool cylPt2Valid = (cylPt2.x <= CYL_HALF_LEN) && (cylPt2.x >= -CYL_HALF_LEN);
#endif // RENDER_CAPS

#ifdef RENDER_CAPS
    lambdas.x = cylPt1Valid ? lambdas.x : (((cylPt1Right ? CYL_HALF_LEN : -CYL_HALF_LEN) - camPos.x) / ray.x);
    lambdas.x = (cylPt1Valid || cylPt2Valid) ? lambdas.x : maxLambda;

#ifdef CLIP
#else // CLIP
    if (lambdas.x >= maxLambda) { radicand = -1.0; }
#endif // CLIP

#else // RENDER_CAPS
    lambdas.x = (cylPt1Valid) ? lambdas.x : lambdas.y;    

#ifdef CLIP
    if ((!cylPt1Valid && !cylPt2Valid)) { discard; }
#else // CLIP
    if ((!cylPt1Valid && !cylPt2Valid)) { radicand = -1.0; }
#endif // CLIP
#endif // RENDER_CAPS

    vec3 intersection = camPos.xyz + ray * lambdas.x;
#ifdef RENDER_CAPS
    vec3 normal = (cylPt1Valid ? vec3(0.0, normalize(intersection.yz)) : (cylPt1Right ? vec3(1.0, 0.0, 0.0) : vec3(-1.0, 0.0, 0.0)));
#else // RENDER_CAPS
    vec3 normal = vec3(0.0, normalize(intersection.yz));
#endif // RENDER_CAPS


    // chose color for lighting
    vec3 color;
    // set fragment color (kroneml)
    if( cylPt1.x > 0.0 )
    {
        color = colOut2;
    }
    else
    {
        color = colOut1;
    }

    // phong lighting with directional light
    gl_FragColor = vec4(LocalLighting(ray, normal, light.xyz, color), 1.0);


    // calculate depth
#ifdef DEPTH
    tmp = intersection;
    intersection.x = dot(rotMatT0, tmp.xyz);
    intersection.y = dot(rotMatT1, tmp.xyz);
    intersection.z = dot(rotMatT2, tmp.xyz);

    intersection += objPos.xyz;

    vec4 Ding = vec4(intersection, 1.0);
    float depth = dot(modelviewprojTrans[2], Ding);
    float depthW = dot(modelviewprojTrans[3], Ding);
#ifndef CLIP
    if (radicand < 0.0) { 
        gl_FragColor = vec4(colOut2, 1.0);
//        gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);
        depth = 1.0;
        depthW = 1.0;
    }
#endif // CLIP
    gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
#endif // DEPTH

#ifdef RETICLE
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    if (min(abs(coord.x - centerFragment.x), abs(coord.y - centerFragment.y)) < 0.002) {
        gl_FragColor.rgb += vec3(0.3, 0.3, 0.5);
    }
#endif // RETICLE
    //gl_FragColor = vec4(colOut1, 1.0);
}
-->
      </snippet>
    </shader>

    <!-- offscreen rendering -->
    <shader name="cylinderFragmentOR">
      <!--<snippet type="version">130</snippet>-->
      <snippet type="string">
        <!--
        #version 120
        -->
      </snippet>
      <snippet name="commondefines"/>
      <snippet type="string">
        <!--
#extension GL_ARB_gpu_shader5 : enable

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS               

//#undef CLIP

// #define RENDER_CAPS

uniform vec4 viewAttr;
uniform vec2 zValues;

FLACH varying vec4 objPos;
FLACH varying vec4 camPos;
FLACH varying vec4 lightPos;
FLACH varying vec3 radz;

FLACH varying vec3 rotMatT0;
FLACH varying vec3 rotMatT1; // rotation matrix from the quaternion
FLACH varying vec3 rotMatT2;

#ifdef RETICLE
FLACH varying vec2 centerFragment;
#endif // RETICLE

void main(void) {
    vec4 coord;
    vec3 ray, tmp;
    const float maxLambda = 50000.0;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    

    // transform fragment coordinates from view coordinates to object coordinates.
    coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;
    coord -= objPos; // ... and move


    // calc the viewing ray
    ray = rotMatT0 * coord.x + rotMatT1 * coord.y + rotMatT2 * coord.z;
    ray = normalize(ray - camPos.xyz);


    // calculate the geometry-ray-intersection

    // cylinder parameters
#define CYL_RAD radz.x
#define CYL_RAD_SQ radz.y
#define CYL_HALF_LEN radz.z

    float rDc = dot(ray.yz, camPos.yz);
    float rDr = dot(ray.yz, ray.yz);

    float radicand = (rDc * rDc) - (rDr * (dot(camPos.yz, camPos.yz) - CYL_RAD_SQ));

#ifdef CLIP
    if (radicand < 0.0) { discard; }
#endif // CLIP

    float radix = sqrt(radicand);
    vec2 lambdas = vec2((-rDc - radix) / rDr, (-rDc + radix) / rDr);

    // calculations for cylinder caps
    vec3 cylPt1 = camPos.xyz + ray * lambdas.x;
    vec3 cylPt2 = camPos.xyz + ray * lambdas.y;

#ifdef RENDER_CAPS
    bool cylPt1Right = (cylPt1.x > 0.0);
#endif // RENDER_CAPS
    bool cylPt1Valid = (cylPt1.x <= CYL_HALF_LEN) && (cylPt1.x >= -CYL_HALF_LEN); // trim cylinder
#ifdef RENDER_CAPS
    bool cylPt2Valid = cylPt1Right ? (cylPt2.x <= CYL_HALF_LEN) : (cylPt2.x >= -CYL_HALF_LEN);
#else
    bool cylPt2Valid = (cylPt2.x <= CYL_HALF_LEN) && (cylPt2.x >= -CYL_HALF_LEN);
#endif // RENDER_CAPS

#ifdef RENDER_CAPS
    lambdas.x = cylPt1Valid ? lambdas.x : (((cylPt1Right ? CYL_HALF_LEN : -CYL_HALF_LEN) - camPos.x) / ray.x);
    lambdas.x = (cylPt1Valid || cylPt2Valid) ? lambdas.x : maxLambda;

#ifdef CLIP
    if (lambdas.x >= maxLambda) { discard; }
#else // CLIP
    if (lambdas.x >= maxLambda) { radicand = -1.0; }
#endif // CLIP

#else // RENDER_CAPS
    lambdas.x = (cylPt1Valid) ? lambdas.x : lambdas.y;    

#ifdef CLIP
    if ((!cylPt1Valid && !cylPt2Valid)) { discard; }
#else // CLIP
    if ((!cylPt1Valid && !cylPt2Valid)) { radicand = -1.0; }
#endif // CLIP
#endif // RENDER_CAPS

    vec3 intersection = camPos.xyz + ray * lambdas.x;
#ifdef RENDER_CAPS
    vec3 normal = (cylPt1Valid ? vec3(0.0, normalize(intersection.yz)) : (cylPt1Right ? vec3(1.0, 0.0, 0.0) : vec3(-1.0, 0.0, 0.0)));
#else // RENDER_CAPS
    vec3 normal = vec3(0.0, normalize(intersection.yz));
#endif // RENDER_CAPS


    // chose color for lighting
    vec3 color = gl_Color.rgb;

    // set fragment color (kroneml)
    if( cylPt1.x > 0.0 )
    {
        color = gl_SecondaryColor.rgb;
    }
    else
    {
        color = gl_Color.rgb;
    }

    // phong lighting with directional light
    //gl_FragColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color), 1.0);
    gl_FragData[0] = vec4(color, 1.0);

    // calculate depth
#ifdef DEPTH
    tmp = intersection;
    intersection.x = dot(rotMatT0, tmp.xyz);
    intersection.y = dot(rotMatT1, tmp.xyz);
    intersection.z = dot(rotMatT2, tmp.xyz);

    intersection += objPos.xyz;

    /*vec4 Ding = vec4(intersection, 1.0);
    float depth = -dot(gl_ModelViewMatrixTranspose[2], Ding);
    gl_FragDepth = (depth - zValues.x) / (zValues.y - zValues.x);*/
    
    vec4 Ding = vec4(intersection, 1.0);
    float depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
    float depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
    float d = ((depth / depthW) + 1.0) * 0.5;
    
    float n = zValues.x;
    float f = zValues.y;
    float depthES;

    // Unproject depth and switch sign -> positive eye space depth
    depthES = 2.0*n*f/(f+n-d*(f-n));
    // Map near ... far to 0 ... 1
    depthES = (depthES - n)/(f-n);
    
    gl_FragDepth = depthES;
  
#ifndef CLIP
    if (radicand < 0.0) { 
        gl_FragData[0] = gl_SecondaryColor;
        depth = 1.0;
        //depthW = 1.0;
    }
#endif // CLIP
    //gl_FragDepth = (depth - zValues.x) / (zValues.y - zValues.x);;
    gl_FragDepth = depthES;
#endif // DEPTH

#ifdef RETICLE
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    if (min(abs(coord.x - centerFragment.x), abs(coord.y - centerFragment.y)) < 0.002) {
        gl_FragData[0].rgb += vec3(0.3, 0.3, 0.5);
    }
#endif // RETICLE

    // Rotate normal
    mat3 rotMat= mat3(rotMatT0, rotMatT1, rotMatT2);
    vec3 normalWS = inverse(rotMat)*normal;
    gl_FragData[1] = vec4(normalize(gl_NormalMatrix*normalWS), 1.0); // get eye space normal
}
-->
      </snippet>
    </shader>
    
    
<shader name="cylinderClipPlaneFragment">
      <snippet type="version">110</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet type="string">
        <!--

//#undef CLIP

// #define RENDER_CAPS

uniform vec3 clipPlaneDir;
uniform vec3 clipPlaneBase;

uniform vec4 viewAttr;

FLACH varying vec4 objPos;
FLACH varying vec4 camPos;
FLACH varying vec4 lightPos;
FLACH varying vec3 radz;

FLACH varying vec3 rotMatT0;
FLACH varying vec3 rotMatT1; // rotation matrix from the quaternion
FLACH varying vec3 rotMatT2;

#ifdef RETICLE
FLACH varying vec2 centerFragment;
#endif // RETICLE

void main(void) {
    vec4 coord;
    vec3 ray, tmp;
    const float maxLambda = 50000.0;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    

    // transform fragment coordinates from view coordinates to object coordinates.
    coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;
    coord -= objPos; // ... and move


    // calc the viewing ray
    ray = rotMatT0 * coord.x + rotMatT1 * coord.y + rotMatT2 * coord.z;
    ray = normalize(ray - camPos.xyz);


    // calculate the geometry-ray-intersection

    // cylinder parameters
#define CYL_RAD radz.x
#define CYL_RAD_SQ radz.y
#define CYL_HALF_LEN radz.z

    float rDc = dot(ray.yz, camPos.yz);
    float rDr = dot(ray.yz, ray.yz);

    float radicand = (rDc * rDc) - (rDr * (dot(camPos.yz, camPos.yz) - CYL_RAD_SQ));

#ifdef CLIP
    if (radicand < 0.0) { discard; }
#endif // CLIP

   float radix = sqrt(radicand);
    vec2 lambdas = vec2((-rDc - radix) / rDr, (-rDc + radix) / rDr);

    // calculations for cylinder caps
    vec3 cylPt1 = camPos.xyz + ray * lambdas.x;
    vec3 cylPt2 = camPos.xyz + ray * lambdas.y;

#ifdef RENDER_CAPS
    bool cylPt1Right = (cylPt1.x > 0.0);
#endif // RENDER_CAPS
    bool cylPt1Valid = (cylPt1.x <= CYL_HALF_LEN) && (cylPt1.x >= -CYL_HALF_LEN); // trim cylinder
#ifdef RENDER_CAPS
    bool cylPt2Valid = cylPt1Right ? (cylPt2.x <= CYL_HALF_LEN) : (cylPt2.x >= -CYL_HALF_LEN);
#else
    bool cylPt2Valid = (cylPt2.x <= CYL_HALF_LEN) && (cylPt2.x >= -CYL_HALF_LEN);
#endif // RENDER_CAPS

#ifdef RENDER_CAPS
    lambdas.x = cylPt1Valid ? lambdas.x : (((cylPt1Right ? CYL_HALF_LEN : -CYL_HALF_LEN) - camPos.x) / ray.x);
    lambdas.x = (cylPt1Valid || cylPt2Valid) ? lambdas.x : maxLambda;

#ifdef CLIP
    if (lambdas.x >= maxLambda) { discard; }
#else // CLIP
    if (lambdas.x >= maxLambda) { radicand = -1.0; }
#endif // CLIP

#else // RENDER_CAPS
    lambdas.x = (cylPt1Valid) ? lambdas.x : lambdas.y;    

#ifdef CLIP
    if ((!cylPt1Valid && !cylPt2Valid)) { discard; }
#else // CLIP
    if ((!cylPt1Valid && !cylPt2Valid)) { radicand = -1.0; }
#endif // CLIP
#endif // RENDER_CAPS

    vec3 intersection = camPos.xyz + ray * lambdas.x;
#ifdef RENDER_CAPS
    vec3 normal = (cylPt1Valid ? vec3(0.0, normalize(intersection.yz)) : (cylPt1Right ? vec3(1.0, 0.0, 0.0) : vec3(-1.0, 0.0, 0.0)));
#else // RENDER_CAPS
    vec3 normal = vec3(0.0, normalize(intersection.yz));
#endif // RENDER_CAPS


    // chose color for lighting
    vec3 color = gl_Color.rgb;

    // set fragment color (kroneml)
    if( cylPt1.x > 0.0 )
    {
        color = gl_SecondaryColor.rgb;
    }
    else
    {
        color = gl_Color.rgb;
    }
    
    // cut with clipping plane
    vec3 planeNormal = normalize( clipPlaneDir);
    // Compute distance of the object from the plane
    float d = -dot( planeNormal, clipPlaneBase - objPos.xyz);
    if (d > 0.0) discard;
   /* float dist1 = dot( intersection, planeNormal) + d;
  float dist2 = d;
  float t = -( dot( planeNormal, camPos.xyz) + d ) / dot( planeNormal, ray);
  vec3 planeintersect = camPos.xyz + t * ray;
    if( dist1 > 0.0 )
  {
    if( dist2 < rad )
    {
      if( length( planeintersect) < rad )
      {
        intersection = planeintersect;
        normal = planeNormal;
        color = vec3( 1.0, 0.7, 0.0);
      }
      else
      {
        discard;
      }
    }
    else
    {
      discard;
    }
  }*/

    // phong lighting with directional light
    gl_FragColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color), 1.0);


    // calculate depth
#ifdef DEPTH
    tmp = intersection;
    intersection.x = dot(rotMatT0, tmp.xyz);
    intersection.y = dot(rotMatT1, tmp.xyz);
    intersection.z = dot(rotMatT2, tmp.xyz);

    intersection += objPos.xyz;

    vec4 Ding = vec4(intersection, 1.0);
    float depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
    float depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
#ifndef CLIP
    if (radicand < 0.0) { 
        gl_FragColor = gl_SecondaryColor;
        depth = 1.0;
        depthW = 1.0;
    }
#endif // CLIP
    gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
#endif // DEPTH

#ifdef RETICLE
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    if (min(abs(coord.x - centerFragment.x), abs(coord.y - centerFragment.y)) < 0.002) {
        gl_FragColor.rgb += vec3(0.3, 0.3, 0.5);
    }
#endif // RETICLE
//    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
//    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
}
-->
      </snippet>
    </shader>

    <shader name="hbondLineSolventVertex">
      <snippet type="version">110</snippet>
      <snippet name="commondefines"/>
      <snippet type="string">
        <!--
// density volume lookup for a simple neighbour test ...
uniform sampler3D volumeSampler;
uniform vec3 minBBox;
uniform vec3 invBBoxExtend;
uniform float solventMolThreshold;

void main(void) {

    // remove the sphere radius from the w coordinates to the rad varyings

    vec4 inPos = gl_Vertex;

    // translate position to 3d-texture coordinates: (p-min) / ||max-min||
    vec3 volPos = (inPos.xyz - minBBox) * invBBoxExtend;
    inPos.w = texture3D(volumeSampler, volPos).w < solventMolThreshold ? 0.0 : 1.0; 
/*  if (texture3D(volumeSampler, volPos).w < solventMolThreshold)
        inPos.w = 0.0;  // return; ?
    else
        inPos.w = 1.0;*/
    // tut sowas?
//  float test = texture3D(volumeSampler, inPos.xyz).w < solventMolThreshold;
//  inPos.w = 1.0 - test;

    // send color to fragment shader
    gl_FrontColor = gl_Color;

#if 0
    gl_Position = ftransform();
    gl_Position.w = inPos.w;
#else
    gl_Position = gl_ModelViewProjectionMatrix * inPos;
#endif
}
-->
      </snippet>
    </shader>

    <shader name="hbondLineSolventFragment">
      <snippet type="version">110</snippet>
      <!--snippet name="commondefines"/-->
      <!--snippet name="::common::lighting::simple"/-->
      <snippet type="string">
        <!--
//uniform vec4 ...
//varying vec4 ...

void main(void) {
    gl_FragColor = gl_Color;
}
-->
      </snippet>
    </shader>

    <shader name="perpixellightVertex">
      <snippet type="version">120</snippet>
      <snippet type="string">
        <!--
varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;
varying vec4 col;

void main()
{    
    // transformation of the normal into eye space
    normal = normalize(gl_NormalMatrix * gl_Normal);
    
    // normalize the direction of the light
    lightDir = normalize(vec3(gl_LightSource[0].position));

    // normalize the halfVector to pass it to the fragment shader
    halfVector = normalize(gl_LightSource[0].halfVector.xyz);
                
    // compute the diffuse, ambient and globalAmbient terms
    /*
    diffuse = gl_FrontMaterial.diffuse * gl_LightSource[0].diffuse;
    ambient = gl_FrontMaterial.ambient * gl_LightSource[0].ambient;
    ambient += gl_LightModel.ambient * gl_FrontMaterial.ambient;
    */
    diffuse = gl_Color * gl_LightSource[0].diffuse;
    ambient = gl_Color * gl_LightSource[0].ambient;
    ambient += gl_LightModel.ambient * gl_Color;

    gl_Position = ftransform();
    gl_FrontColor = gl_Color;
    gl_BackColor = gl_Color;
}
-->
      </snippet>
    </shader>

    <shader name="perpixellightFragment">
      <snippet type="version">120</snippet>
      <snippet type="string">
        <!--
uniform int twoSidedLight = 0;

varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;


void main() {
	float tsl = clamp(float(twoSidedLight), 0.0, 1.0);
    vec3 n,halfV;
    float NdotL,NdotHV;
    
    // store the ambient term
    vec4 color = ambient;
    
    // store the normalized interpolated normal
    n = normalize(normal);

    // compute the dot product between normal and lightDir
    NdotL = dot(n,lightDir);
    if (NdotL > 0.0) {
		// front side
        color += diffuse * NdotL;
        halfV = normalize(halfVector);
        NdotHV = max(dot(n,halfV),4.88e-04);
        color += gl_FrontMaterial.specular * gl_LightSource[0].specular * pow(NdotHV, gl_FrontMaterial.shininess);
    } else {
		// back side
        color += diffuse * (-NdotL) * tsl;
        //halfV = normalize(halfVector);
        //NdotHV = max(dot(-n,halfV),4.88e-04);
        //color += gl_FrontMaterial.specular * gl_LightSource[0].specular * pow(NdotHV, gl_FrontMaterial.shininess) * tsl;
	}

    gl_FragColor = color;
}
-->
      </snippet>
    </shader>

    <shader name="perpixellightFragmentOR">
      <snippet type="version">120</snippet>
      <snippet type="string">
        <!--
uniform int twoSidedLight = 0;

varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;
varying vec4 col;



void main() {
	float tsl = clamp(float(twoSidedLight), 0.0, 1.0);
    vec3 n,halfV;
    float NdotL,NdotHV;
    

    // store the ambient term
    vec4 color = ambient;
    
    // store the normalized interpolated normal
    n = normalize(normal);


    // compute the dot product between normal and lightDir
    NdotL = dot(n,lightDir);
    if (NdotL > 0.0) {
		// front side
        color += diffuse * NdotL;
        halfV = normalize(halfVector);

        NdotHV = max(dot(n,halfV),4.88e-04);
        color += gl_FrontMaterial.specular * gl_LightSource[0].specular * pow(NdotHV, gl_FrontMaterial.shininess);
    } else {
		// back side
        color += diffuse * (-NdotL) * tsl;

        //halfV = normalize(halfVector);
        //NdotHV = max(dot(-n,halfV),4.88e-04);
        //color += gl_FrontMaterial.specular * gl_LightSource[0].specular * pow(NdotHV, gl_FrontMaterial.shininess) * tsl;
	}


    //gl_FragColor = color;

    gl_FragData[0] = gl_Color;    
    gl_FragData[1] = vec4(n, 1.0); // get eye space normal
}
-->
      </snippet>
    </shader>

    <shader name="hfilterVertex">
      <snippet type="version">120</snippet>
      <snippet type="string">
        <!--
uniform float sigma = 2.0;

varying vec2 texCoord;
varying float sigmaSqx2;
varying float sigmaxSqrt2PI;

void main()
{
    gl_Position.xy = gl_Vertex.xy * 2.0 - 1.0;
    gl_Position.zw = vec2( -1.0, 1.0);

    texCoord = gl_Vertex.xy;
    //precompute factors used every iteration
    sigmaSqx2 = sigma * sigma * 2.0;
    sigmaxSqrt2PI = 2.50662827 * sigma;    // = sqrt( 2.0 * 3.1415926) * sigma;
}
-->
      </snippet>
    </shader>

    <shader name="hfilterFragment">
      <snippet type="version">120</snippet>
      <snippet type="string">
        <!--
#extension GL_ARB_draw_buffers : require
#extension GL_EXT_gpu_shader4 : require

uniform sampler2D tex;
uniform float sigma = 2.0;
//direction to perfom the gaussian
vec2 direction = vec2( 1.0, 0.0);

varying vec2 texCoord;
varying float sigmaSqx2;
varying float sigmaxSqrt2PI;

void main()
{
    vec2 size = vec2( textureSize2D( tex, 0));
    vec2 offset = 1.0 / size; 

    //compute the radius across the kernel
    int radius = int( floor( 3.0*sigma) - 1.0);

    vec4 accum = vec4( 0.0);

    // separable Gaussian
    for( int ii = -radius; ii <= radius; ii++ )
    {
        float r = float(ii);
        float factor = pow( 2.71828, -(r*r) / sigmaSqx2 ) / sigmaxSqrt2PI;
        accum.xyz += factor * texture2D( tex, texCoord + r * direction * offset).xyz;
    }
    // preserve the original depth value in w
    accum.w = texture2D( tex, texCoord).x;
    
    gl_FragColor = accum;
}
-->
      </snippet>
    </shader>

    <shader name="vfilterVertex">
      <snippet type="version">120</snippet>
      <snippet type="string">
        <!--
uniform float sigma = 2.0;
uniform float lambda = 10.0;

varying vec2 texCoord;
varying float sigmaSqx2;
varying float sigmaxSqrt2PI;

void main()
{
    gl_Position.xy = gl_Vertex.xy * 2.0 - 1.0;
    gl_Position.zw = vec2( -1.0, 1.0);

    texCoord = gl_Vertex.xy;
    //precompute factors used every iteration
    sigmaSqx2 = sigma * sigma * 2.0;
    sigmaxSqrt2PI = 2.50662827 * sigma;    // = sqrt( 2.0 * 3.1415926) * sigma;
}
-->
      </snippet>
    </shader>

    <shader name="vfilterFragment">
      <snippet type="version">120</snippet>
      <snippet type="string">
        <!--
#extension GL_ARB_draw_buffers : require
#extension GL_EXT_gpu_shader4 : require

uniform sampler2D tex;
uniform sampler2D colorTex;

uniform float sigma;
uniform float lambda;

//direction to perfom the gaussian
vec2 direction = vec2( 0.0, 1.0);

varying vec2 texCoord;
varying float sigmaSqx2;
varying float sigmaxSqrt2PI;

void main()
{
    vec2 size = vec2( textureSize2D( tex, 0));
    vec2 offset = 1.0 / size; 

    //compute the radius across the kernel
    int radius = int( floor( 3.0*sigma) - 1.0);

    vec4 accum = vec4( 0.0);

    // separable Gaussian
    for( int ii = -radius; ii <= radius; ii++ )
    {
        float r = float(ii);
        float factor = pow( 2.71828, -(r*r) / sigmaSqx2 ) / sigmaxSqrt2PI;
        accum.xyz += factor * texture2D( tex, texCoord + r * direction * offset).xyz;
    }
    // preserve the original depth value in w
    accum.w = texture2D( tex, texCoord).w;
    
    if( accum.w < 1.0 )
        gl_FragColor = texture2D( colorTex, texCoord) + min( vec4( accum.x) - vec4( accum.w), 0.0)*lambda;
    else
        gl_FragColor = texture2D( colorTex, texCoord);
    //gl_FragColor = texture2D( colorTex, texCoord) + min( vec4( accum.x) - vec4( accum.w), 0.05)*lambda;
}
-->
      </snippet>
    </shader>

    <shader name="silhouetteVertex">
      <snippet type="version">120</snippet>
      <snippet type="string">
        <!--
uniform float difference = 0.1;

varying vec2 texCoord;

void main()
{
    gl_Position.xy = gl_Vertex.xy * 2.0 - 1.0;
    gl_Position.zw = vec2( -1.0, 1.0);
    gl_FrontColor = gl_Color;

    texCoord = gl_Vertex.xy;
}
-->
      </snippet>
    </shader>

    <shader name="silhouetteFragment">
      <snippet type="version">120</snippet>
      <snippet type="string">
        <!--
#extension GL_EXT_gpu_shader4 : require

uniform sampler2D tex;
uniform sampler2D colorTex;

uniform float difference = 0.1;

varying vec2 texCoord;

void main()
{
    vec2 size = vec2( textureSize2D( tex, 0));
    vec2 offset = 1.0 / size; 

    if( abs( texture2D( tex, texCoord).x - texture2D( tex, texCoord + vec2( 1.0, 0.0) * offset).x ) > difference ||
            abs( texture2D( tex, texCoord).x - texture2D( tex, texCoord - vec2( 1.0, 0.0) * offset).x ) > difference ||
            abs( texture2D( tex, texCoord).x - texture2D( tex, texCoord + vec2( 0.0, 1.0) * offset).x ) > difference ||
            abs( texture2D( tex, texCoord).x - texture2D( tex, texCoord - vec2( 0.0, 1.0) * offset).x ) > difference ||
            ( texture2D( tex, texCoord).x < 0.99 && texture2D( tex, texCoord + vec2( 1.0, 0.0) * offset).x > 0.99 ) ||
            ( texture2D( tex, texCoord).x < 0.99 && texture2D( tex, texCoord - vec2( 1.0, 0.0) * offset).x > 0.99 ) ||
            ( texture2D( tex, texCoord).x < 0.99 && texture2D( tex, texCoord + vec2( 0.0, 1.0) * offset).x > 0.99 ) ||
            ( texture2D( tex, texCoord).x < 0.99 && texture2D( tex, texCoord - vec2( 0.0, 1.0) * offset).x > 0.99 ) )
    {
        gl_FragColor = gl_Color;
    }
    else
    {
        gl_FragColor = texture2D( colorTex, texCoord);
    }
}
-->
      </snippet>
    </shader>

    <shader name="writeIdVertex">
      <snippet type="version">120</snippet>
      <snippet type="string">
        <!--
  attribute float inId;
  varying float id;
  
  void main(void)
  {
    id = inId;
    gl_Position = ftransform();
    gl_FrontColor = gl_Color;
    gl_BackColor = gl_Color;
  }
-->
      </snippet>
    </shader>

    <shader name="writeIdFragment">
      <snippet type="version">120</snippet>
      <snippet type="string">
        <!--
  varying float id;
  
  void main(void)
  {
    gl_FragColor.r = id;
    gl_FragColor.gb = vec2( 0.0);
    //gl_FragColor.gb = gl_FragCoord.xy;
    gl_FragColor.a = 1.0;
  }
-->
      </snippet>
    </shader>

    <shader name="storeIdVertex">
      <snippet type="version">120</snippet>
      <snippet type="string">
        <!--
  void main(void)
  {
    gl_Position = gl_Vertex;
  }
-->
      </snippet>
    </shader>

    <shader name="storeIdFragment">
      <snippet type="version">120</snippet>
      <snippet name="commondefines"/>
      <snippet type="string">
        <!--
  void main(void)
  {
    gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0);
  }
-->
      </snippet>
    </shader>

    <shader name="arrowVertex">
      <snippet type="version">120</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet type="string">
        <!--
uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

#ifdef DEBUG
uniform vec2 circleAttr;
#endif // DEBUG

uniform float radScale;

//
//attribute vec2 inParams;
//attribute vec4 quatC; // conjugate quaternion
//

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying vec4 radz; /* (cyl-Rad, tip-Rad, overall-Len, tip-Len) */

varying vec3 rotMatT0;
varying vec3 rotMatT1; // rotation matrix from the quaternion
varying vec3 rotMatT2;

#ifdef RETICLE
varying vec2 centerFragment;
#endif // RETICLE

void main(void) {
    //const vec4 quatConst = vec4(1.0, -1.0, 0.5, 0.0);
    vec4 tmp, tmp1;

    //vec4 vertex2 = gl_MultiTexCoord0;

    //vec4 quatC = vec4(0.0, 0.0, 0.0, 1.0);
    vec2 inParams = vec2(gl_Vertex.w, length(gl_Vertex.xyz - gl_MultiTexCoord0.xyz));

    //vec3 xAxis = gl_Vertex.xyz - gl_MultiTexCoord0.xyz;
    vec3 xAxis = gl_MultiTexCoord0.xyz - gl_Vertex.xyz;
    xAxis /= inParams.y;

    vec4 inPos = gl_Vertex;

    radz.x = inParams.x * radScale;
    radz.y = radz.x * 1.5;
    radz.z = inParams.y;
//    radz.w = min(gl_MultiTexCoord0.w, radz.z);
    radz.w = radz.z * 0.4;

    inPos.w = 1.0;
    
    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)


    // orientation matrix based on direction vector
    vec3 tmpy = (xAxis.x == 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0);
    vec3 tmpz = normalize(cross(tmpy, xAxis));
    tmpy = normalize(cross(xAxis, tmpz));

    rotMatT0 = vec3(xAxis.x, tmpy.x, tmpz.x);
    rotMatT1 = vec3(xAxis.y, tmpy.y, tmpz.y);
    rotMatT2 = vec3(xAxis.z, tmpy.z, tmpz.z);

    //rotMatT0 = xAxis;
    //rotMatT0 = normalize(rotMatT0);
    //rotMatT1 = ((rotMatT0.x > 0.9) || (rotMatT0.x < -0.9)) ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0); // normal on tmp
    //rotMatT1 = cross(rotMatT1, rotMatT0);
    //rotMatT1 = normalize(rotMatT1);    
    //rotMatT2 = cross(rotMatT0, rotMatT1);


    //rotMatT0 = xAxis;
    //rotMatT1 = (xAxis.x == 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0);
    //rotMatT2 = normalize(cross(rotMatT0, rotMatT1));
    //rotMatT1 = normalize(cross(rotMatT0, rotMatT2));


    // calculate cam position
    tmp = gl_ModelViewMatrixInverse[3]; // (C) by Christoph
    tmp.xyz -= objPos.xyz; // cam move
    camPos.xyz = rotMatT0 * tmp.x + rotMatT1 * tmp.y + rotMatT2 * tmp.z;
    

    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = gl_ModelViewMatrixInverse * gl_LightSource[0].position - objPos; // note: w is bullshit now!
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    lightPos = gl_ModelViewMatrixInverse * normalize( gl_LightSource[0].position);
    lightPos.xyz = rotMatT0 * lightPos.x + rotMatT1 * lightPos.y + rotMatT2 * lightPos.z;
    

    // send color to fragment shader
    gl_FrontColor = gl_Color;
/*
    float sc = 1.0 - inParams.x;
    sc *= sc;
    gl_FrontColor = vec4(0.0, 1.0 - sc, sc, 1.0);
*/

    // calculate point sprite
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    // lumberjack approach
    vec4 pos, projPos;
    vec4 pX, pY, pZ, pOP;
    vec2 mins, maxs, pp;

#define CYL_LEN radz.z
#define CYL_RAD radz.y

    projPos.w = 0.0;

    //pos = vec4(0.0, 0.0, 0.0, 1.0);
    //projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    //projPos.y = dot(rotMatT1.xyz, pos.xyz);
    //projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos; // + projPos; // move
    pos.w = 1.0; // now we're in object space
    pOP = gl_ModelViewProjectionMatrix * pos;

    pos = vec4(1.0, 0.0, 0.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = gl_ModelViewProjectionMatrix * pos;
    pX = (projPos - pOP) * CYL_LEN;

    pos = vec4(0.0, 1.0, 0.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = gl_ModelViewProjectionMatrix * pos;
    pY = (projPos - pOP) * CYL_RAD;

    pos = vec4(0.0, 0.0, 1.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = gl_ModelViewProjectionMatrix * pos;
    pZ = (projPos - pOP) * CYL_RAD;

    // 8 corners of doom
    pos = pOP + pX;
    projPos = pos + pY + pZ;
    mins = maxs = projPos.xy / projPos.w;

    projPos = pos - pY + pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos + pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    pos = pOP;
    projPos = pos + pY + pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY + pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos + pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);


    gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    maxs = (maxs - mins) * 0.5 * winHalf;
    gl_PointSize = max(maxs.x, maxs.y);

#ifdef RETICLE
    centerFragment = gl_Position.xy / gl_Position.w;
#endif // RETICLE
}
-->
      </snippet>
    </shader>

    <shader name="arrowVertexGeom">
      <snippet type="version">140</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet type="string">
        <!--
uniform mat4 modelview;
uniform mat4 proj;

in vec4 pos0;
in vec4 pos1;
in vec4 color;

out vec4 inPos0;
out vec4 inPos1;
out vec4 inColor;

void main(void) {
    inPos0 = pos0;
    inPos1 = pos1;
    inColor = color;
}
-->
      </snippet>
    </shader>

    <shader name="arrowFragment">
      <snippet type="version">120</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet type="string">
        <!--
// #undef CLIP

#define RENDER_CAPS

uniform vec4 viewAttr;

FLACH varying vec4 objPos;
FLACH varying vec4 camPos;
FLACH varying vec4 lightPos;
FLACH varying vec4 radz;

#ifdef RETICLE
FLACH varying vec2 centerFragment;
#endif // RETICLE

FLACH varying vec3 rotMatT0;
FLACH varying vec3 rotMatT1; // rotation matrix from the quaternion
FLACH varying vec3 rotMatT2;

void main(void) {
    vec4 coord;
    vec3 ray, tmp;
    const float maxLambda = 50000.0;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    

    // transform fragment coordinates from view coordinates to object coordinates.
    coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;
    coord -= objPos; // ... and move


    // calc the viewing ray
    ray = rotMatT0 * coord.x + rotMatT1 * coord.y + rotMatT2 * coord.z;
    ray = normalize(ray - camPos.xyz);


    // calculate the geometry-ray-intersection

    // cylinder parameters
#define CYL_RAD radz.x
#define CYL_RAD_SQ radz.x * radz.x
#define CYL_LEN radz.z
#define TIP_RAD radz.y
#define TIP_LEN radz.w

    // super unoptimized cone code

    float coneF = TIP_RAD / TIP_LEN;
    coneF *= coneF;
    float coneA = coneF * ray.x * ray.x - ray.y * ray.y - ray.z * ray.z;
    float coneB = 2.0 * (coneF * ray.x * camPos.x - ray.y * camPos.y - ray.z * camPos.z);
    float coneC = coneF * camPos.x * camPos.x - camPos.y * camPos.y - camPos.z * camPos.z;

    float rDc = dot(ray.yz, camPos.yz);
    float rDr = dot(ray.yz, ray.yz);

    vec2 radicand = vec2(
        (rDc * rDc) - (rDr * (dot(camPos.yz, camPos.yz) - CYL_RAD_SQ)),
        coneB * coneB - 4.0 * coneA * coneC);
    vec2 divisor = vec2(rDr, 2.0 * coneA);
    vec2 radix = sqrt(radicand);
    vec2 minusB = vec2(-rDc, -coneB);

    vec4 lambda = vec4(
        (minusB.x - radix.x) / divisor.x,
        (minusB.y + radix.y) / divisor.y,
        (minusB.x + radix.x) / divisor.x,
        (minusB.y - radix.y) / divisor.y);

    bvec4 invalid = bvec4(
        (divisor.x == 0.0) || (radicand.x < 0.0),
        (divisor.y == 0.0) || (radicand.y < 0.0),
        (divisor.x == 0.0) || (radicand.x < 0.0),
        (divisor.y == 0.0) || (radicand.y < 0.0));

    vec4 ix = camPos.xxxx + ray.xxxx * lambda;


    invalid.x = invalid.x || (ix.x < TIP_LEN) || (ix.x > CYL_LEN);
    invalid.y = invalid.y || (ix.y < 0.0) || (ix.y > TIP_LEN);
    invalid.z = invalid.z || !(((ix.z > TIP_LEN) || (ix.x > CYL_LEN)) && (ix.z < CYL_LEN));
    invalid.w = invalid.w || !((ix.w > 0.0) && (ix.w < TIP_LEN));

    if (invalid.x && invalid.y && invalid.z && invalid.w) {
#ifdef CLIP
        discard;
#endif // CLIP
    }

    vec3 intersection, color;
    vec3 normal = vec3(1.0, 0.0, 0.0);
    color = gl_Color.rgb;

    if (!invalid.y) {
        invalid.xzw = bvec3(true, true, true);
        intersection = camPos.xyz + ray * lambda.y;
        normal = normalize(vec3(-TIP_RAD / TIP_LEN, normalize(intersection.yz)));
//        color = vec3(1.0, 0.0, 0.0);
    }
    if (!invalid.x) {
        invalid.zw = bvec2(true, true);
        intersection = camPos.xyz + ray * lambda.x;
        normal = vec3(0.0, normalize(intersection.yz));
    }
    if (!invalid.z) {
        invalid.w = true;
        lambda.z = (CYL_LEN - camPos.x) / ray.x;
        intersection = camPos.xyz + ray * lambda.z;
    }
    if (!invalid.w) {
        lambda.w = (TIP_LEN - camPos.x) / ray.x;
        intersection = camPos.xyz + ray * lambda.w;
    }

    //color.r = 1.0 - intersection.x / CYL_LEN;
    //color.g = 0.0; // intersection.x / CYL_LEN;
    //color.b = intersection.x / CYL_LEN;

    // phong lighting with directional light
    gl_FragColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color), 1.0);
//    gl_FragColor = vec4(color, 1.0);
//    gl_FragColor = vec4(color, 1.0);
    gl_FragColor.rgb = 0.75 * gl_FragColor.rgb + 0.25 * color;


    // calculate depth
#ifdef DEPTH
    tmp = intersection;
    intersection.x = dot(rotMatT0, tmp.xyz);
    intersection.y = dot(rotMatT1, tmp.xyz);
    intersection.z = dot(rotMatT2, tmp.xyz);

    intersection += objPos.xyz;

    vec4 Ding = vec4(intersection, 1.0);
    float depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
    float depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
#ifndef CLIP
    if (invalid.x && invalid.y && invalid.z && invalid.w) { 
        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
        gl_FragDepth = 0.99999;
    } else {
#endif // CLIP
    gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
#ifndef CLIP
    }
#endif // CLIP

#endif // DEPTH

#ifdef RETICLE
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    if (min(abs(coord.x - centerFragment.x), abs(coord.y - centerFragment.y)) < 0.002) {
        gl_FragColor.rgb += vec3(0.3, 0.3, 0.5);
    }
#endif // RETICLE


}
-->
      </snippet>
    </shader>
    
    <shader name="arrowGeom">
      <snippet type="version">140</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet type="string">
        <!--
#extension GL_ARB_gpu_shader5 : enable
#extension GL_EXT_geometry_shader4 : enable

layout (points) in;
layout (triangle_strip, max_vertices = 4) out;

uniform mat4 modelview;
uniform mat4 proj;
uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)
uniform vec4 lightPos;

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

#ifdef DEBUG
uniform vec2 circleAttr;
#endif // DEBUG

uniform float radScale;

in vec4 inPos0[1];
in vec4 inPos1[1];
in vec4 inColor[1];

out vec4 objPos;
out vec4 camPos;
out vec4 light;
out vec4 radz; /* (cyl-Rad, tip-Rad, overall-Len, tip-Len) */
out vec3 rotMatT0;
out vec3 rotMatT1; // rotation matrix from the quaternion
out vec3 rotMatT2;
out vec4 colOut;

#ifdef RETICLE
out vec2 centerFragment;
#endif // RETICLE

mat4 modelviewproj = proj*modelview; // TODO Move this to the CPU?
mat4 modelviewInv = inverse(modelview);

void main(void) {
    //const vec4 quatConst = vec4(1.0, -1.0, 0.5, 0.0);
    vec4 tmp, tmp1;

    //vec4 vertex2 = gl_MultiTexCoord0;

    //vec4 quatC = vec4(0.0, 0.0, 0.0, 1.0);
    vec2 inParams = vec2(inPos0[0].w, length(inPos0[0].xyz - inPos1[0].xyz));

    //vec3 xAxis = gl_Vertex.xyz - gl_MultiTexCoord0.xyz;
    vec3 xAxis = inPos1[0].xyz - inPos0[0].xyz;
    xAxis /= inParams.y;

    // remove the sphere radius from the w coordinates to the rad varyings
    vec4 inPos = inPos0[0];

    radz.x = inParams.x * radScale;
    radz.y = radz.x * 1.5;
    radz.z = inParams.y;
//    radz.w = min(gl_MultiTexCoord0.w, radz.z);
    radz.w = radz.z * 0.4;

    inPos.w = 1.0;
    
    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)


    // orientation matrix based on direction vector
    vec3 tmpy = (xAxis.x == 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0);
    vec3 tmpz = normalize(cross(tmpy, xAxis));
    tmpy = normalize(cross(xAxis, tmpz));

    rotMatT0 = vec3(xAxis.x, tmpy.x, tmpz.x);
    rotMatT1 = vec3(xAxis.y, tmpy.y, tmpz.y);
    rotMatT2 = vec3(xAxis.z, tmpy.z, tmpz.z);

    //rotMatT0 = xAxis;
    //rotMatT0 = normalize(rotMatT0);
    //rotMatT1 = ((rotMatT0.x > 0.9) || (rotMatT0.x < -0.9)) ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0); // normal on tmp
    //rotMatT1 = cross(rotMatT1, rotMatT0);
    //rotMatT1 = normalize(rotMatT1);    
    //rotMatT2 = cross(rotMatT0, rotMatT1);


    //rotMatT0 = xAxis;
    //rotMatT1 = (xAxis.x == 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0);
    //rotMatT2 = normalize(cross(rotMatT0, rotMatT1));
    //rotMatT1 = normalize(cross(rotMatT0, rotMatT2));


    // calculate cam position
    tmp = modelviewInv[3]; // (C) by Christoph
    tmp.xyz -= objPos.xyz; // cam move
    camPos.xyz = rotMatT0 * tmp.x + rotMatT1 * tmp.y + rotMatT2 * tmp.z;
    

    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = gl_ModelViewMatrixInverse * gl_LightSource[0].position - objPos; // note: w is bullshit now!
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    light = modelviewInv * normalize(lightPos);
    light.xyz = rotMatT0 * light.x + rotMatT1 * light.y + rotMatT2 * light.z;
    

    // send color to fragment shader
    colOut = inColor[0];
/*
    float sc = 1.0 - inParams.x;
    sc *= sc;
    gl_FrontColor = vec4(0.0, 1.0 - sc, sc, 1.0);
*/

    // calculate point sprite
    //vec2 winHalf = 2.0 / viewAttr.zw; // window size

    // lumberjack approach
    vec4 pos, projPos;
    vec4 pX, pY, pZ, pOP;
    vec2 mins, maxs, pp;

#define CYL_LEN radz.z
#define CYL_RAD radz.y

    projPos.w = 0.0;

    //pos = vec4(0.0, 0.0, 0.0, 1.0);
    //projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    //projPos.y = dot(rotMatT1.xyz, pos.xyz);
    //projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos; // + projPos; // move
    pos.w = 1.0; // now we're in object space
    pOP = modelviewproj * pos;

    pos = vec4(1.0, 0.0, 0.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = modelviewproj * pos;
    pX = (projPos - pOP) * CYL_LEN;

    pos = vec4(0.0, 1.0, 0.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = modelviewproj * pos;
    pY = (projPos - pOP) * CYL_RAD;

    pos = vec4(0.0, 0.0, 1.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = modelviewproj * pos;
    pZ = (projPos - pOP) * CYL_RAD;

    // 8 corners of doom
    pos = pOP + pX;
    projPos = pos + pY + pZ;
    mins = maxs = projPos.xy / projPos.w;

    projPos = pos - pY + pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos + pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    pos = pOP;
    projPos = pos + pY + pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY + pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos + pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

/*    gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    maxs = (maxs - mins) * 0.5 * winHalf;
    gl_PointSize = max(maxs.x, maxs.y);

#ifdef RETICLE
    centerFragment = gl_Position.xy / gl_Position.w;
#endif // RETICLE*/

    gl_Position = vec4(mins.x, maxs.y, 0.0, inPos.w); EmitVertex();
    gl_Position = vec4(mins.x, mins.y, 0.0, inPos.w); EmitVertex();
    gl_Position = vec4(maxs.x, maxs.y, 0.0, inPos.w); EmitVertex();
    gl_Position = vec4(maxs.x, mins.y, 0.0, inPos.w); EmitVertex();
    EndPrimitive();
}
-->
      </snippet>
    </shader>

    <shader name="arrowFragmentGeom">
      <snippet type="version">140</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet type="string">
        <!--
// #undef CLIP
#extension GL_ARB_gpu_shader5 : enable
#extension GL_EXT_geometry_shader4 : enable

#define RENDER_CAPS

uniform vec4 viewAttr;
uniform mat4 modelview;
uniform mat4 proj;

in vec4 objPos;
in vec4 camPos;
in vec4 light;
in vec4 radz; /* (cyl-Rad, tip-Rad, overall-Len, tip-Len) */
in vec3 rotMatT0;
in vec3 rotMatT1; // rotation matrix from the quaternion
in vec3 rotMatT2;
in vec4 colOut;

#ifdef RETICLE
in vec2 centerFragment;
#endif // RETICLE

mat4 modelviewproj = proj*modelview; // TODO Move this to the CPU?
mat4 modelviewProjInv = inverse(modelviewproj);
mat4 modelviewProjTrans = transpose(modelviewproj);

void main(void) {
    vec4 coord;
    vec3 ray, tmp;
    const float maxLambda = 50000.0;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);

    // transform fragment coordinates from view coordinates to object coordinates.
    coord = modelviewProjInv * coord;
    coord /= coord.w;
    coord -= objPos; // ... and move


    // calc the viewing ray
    ray = rotMatT0 * coord.x + rotMatT1 * coord.y + rotMatT2 * coord.z;
    ray = normalize(ray - camPos.xyz);


    // calculate the geometry-ray-intersection

    // cylinder parameters
#define CYL_RAD radz.x
#define CYL_RAD_SQ radz.x * radz.x
#define CYL_LEN radz.z
#define TIP_RAD radz.y
#define TIP_LEN radz.w

    // super unoptimized cone code

    float coneF = TIP_RAD / TIP_LEN;
    coneF *= coneF;
    float coneA = coneF * ray.x * ray.x - ray.y * ray.y - ray.z * ray.z;
    float coneB = 2.0 * (coneF * ray.x * camPos.x - ray.y * camPos.y - ray.z * camPos.z);
    float coneC = coneF * camPos.x * camPos.x - camPos.y * camPos.y - camPos.z * camPos.z;

    float rDc = dot(ray.yz, camPos.yz);
    float rDr = dot(ray.yz, ray.yz);

    vec2 radicand = vec2(
        (rDc * rDc) - (rDr * (dot(camPos.yz, camPos.yz) - CYL_RAD_SQ)),
        coneB * coneB - 4.0 * coneA * coneC);
    vec2 divisor = vec2(rDr, 2.0 * coneA);
    vec2 radix = sqrt(radicand);
    vec2 minusB = vec2(-rDc, -coneB);

    vec4 lambda = vec4(
        (minusB.x - radix.x) / divisor.x,
        (minusB.y + radix.y) / divisor.y,
        (minusB.x + radix.x) / divisor.x,
        (minusB.y - radix.y) / divisor.y);

    bvec4 invalid = bvec4(
        (divisor.x == 0.0) || (radicand.x < 0.0),
        (divisor.y == 0.0) || (radicand.y < 0.0),
        (divisor.x == 0.0) || (radicand.x < 0.0),
        (divisor.y == 0.0) || (radicand.y < 0.0));

    vec4 ix = camPos.xxxx + ray.xxxx * lambda;


    invalid.x = invalid.x || (ix.x < TIP_LEN) || (ix.x > CYL_LEN);
    invalid.y = invalid.y || (ix.y < 0.0) || (ix.y > TIP_LEN);
    invalid.z = invalid.z || !(((ix.z > TIP_LEN) || (ix.x > CYL_LEN)) && (ix.z < CYL_LEN));
    invalid.w = invalid.w || !((ix.w > 0.0) && (ix.w < TIP_LEN));

    if (invalid.x && invalid.y && invalid.z && invalid.w) {
#ifdef CLIP
        discard;
#endif // CLIP
    }

    vec3 intersection, color;
    vec3 normal = vec3(1.0, 0.0, 0.0);
    color = colOut.rgb;

    if (!invalid.y) {
        invalid.xzw = bvec3(true, true, true);
        intersection = camPos.xyz + ray * lambda.y;
        normal = normalize(vec3(-TIP_RAD / TIP_LEN, normalize(intersection.yz)));
//        color = vec3(1.0, 0.0, 0.0);
    }
    if (!invalid.x) {
        invalid.zw = bvec2(true, true);
        intersection = camPos.xyz + ray * lambda.x;
        normal = vec3(0.0, normalize(intersection.yz));
    }
    if (!invalid.z) {
        invalid.w = true;
        lambda.z = (CYL_LEN - camPos.x) / ray.x;
        intersection = camPos.xyz + ray * lambda.z;
    }
    if (!invalid.w) {
        lambda.w = (TIP_LEN - camPos.x) / ray.x;
        intersection = camPos.xyz + ray * lambda.w;
    }

    //color.r = 1.0 - intersection.x / CYL_LEN;
    //color.g = 0.0; // intersection.x / CYL_LEN;
    //color.b = intersection.x / CYL_LEN;

    // phong lighting with directional light
    gl_FragColor = vec4(LocalLighting(ray, normal, light.xyz, color), 1.0);
/*    vec4 lightparams = vec4(0.2, 0.8, 0.4, 10.0);
#define LIGHT_AMBIENT lightparams.x
#define LIGHT_DIFFUSE lightparams.y
#define LIGHT_SPECULAR lightparams.z
#define LIGHT_EXPONENT lightparams.w
    gl_FragColor = vec4(LIGHT_AMBIENT*color, 1.0);*/
    gl_FragColor.rgb = 0.75 * gl_FragColor.rgb + 0.25 * color;


    // calculate depth
#ifdef DEPTH
    tmp = intersection;
    intersection.x = dot(rotMatT0, tmp.xyz);
    intersection.y = dot(rotMatT1, tmp.xyz);
    intersection.z = dot(rotMatT2, tmp.xyz);

    intersection += objPos.xyz;

    vec4 Ding = vec4(intersection, 1.0);
    float depth = dot(modelviewProjTrans[2], Ding);
    float depthW = dot(modelviewProjTrans[3], Ding);
#ifndef CLIP
    if (invalid.x && invalid.y && invalid.z && invalid.w) { 
        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
        gl_FragDepth = 0.99999;
    } else {
#endif // CLIP
    gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
#ifndef CLIP
    }
#endif // CLIP

//    gl_FragColor.rgb *= ;

#endif // DEPTH

#ifdef RETICLE
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    if (min(abs(coord.x - centerFragment.x), abs(coord.y - centerFragment.y)) < 0.002) {
        gl_FragColor.rgb += vec3(0.3, 0.3, 0.5);
    }
#endif // RETICLE*/
}
-->
      </snippet>
    </shader>

    <shader name="filterSphereVertex">
      <snippet type="version">110</snippet>
      <snippet name="commondefines"/>
      <snippet type="string">
        <!--

#undef HALO
//#define HALO
#undef HALO_RAD
#define HALO_RAD  0.1

uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)

attribute float filter;

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying float squarRad;
varying float rad;

#ifdef RETICLE
varying vec2 centerFragment;
#endif // RETICLE

void main(void) {


    // remove the sphere radius from the w coordinates to the rad varyings
    vec4 inPos = gl_Vertex;
    rad = inPos.w;
    squarRad = rad * rad;
    inPos.w = 1.0;

    
    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)


    // calculate cam position
    camPos = gl_ModelViewMatrixInverse[3]; // (C) by Christoph
    camPos.xyz -= objPos.xyz; // cam pos to glyph space
    

    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = gl_ModelViewMatrixInverse * gl_LightSource[0].position - objPos;
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    lightPos = gl_ModelViewMatrixInverse * normalize( gl_LightSource[0].position);
    
    

    // send color to fragment shader
    gl_FrontColor = gl_Color; 

    // Sphere-Touch-Plane-Approach
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    vec2 d, p, q, h, dd;

    // get camera orthonormal coordinate system
    vec4 tmp;

#ifdef CALC_CAM_SYS
    // camera coordinate system in object space
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[2];
    vec3 camIn = normalize(tmp.xyz);
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[1];
    vec3 camUp = tmp.xyz;
    vec3 camRight = normalize(cross(camIn, camUp));
    camUp = cross(camIn, camRight);
#endif // CALC_CAM_SYS

    vec2 mins, maxs;
    vec3 testPos;
    vec4 projPos;

    
#ifdef HALO
    squarRad = (rad + HALO_RAD) * (rad + HALO_RAD);
#endif // HALO
    
    // projected camera vector
    vec3 c2 = vec3(dot(camPos.xyz, camRight), dot(camPos.xyz, camUp), dot(camPos.xyz, camIn));

    vec3 cpj1 = camIn * c2.z + camRight * c2.x;
    vec3 cpm1 = camIn * c2.x - camRight * c2.z;

    vec3 cpj2 = camIn * c2.z + camUp * c2.y;
    vec3 cpm2 = camIn * c2.y - camUp * c2.z;
    
    d.x = length(cpj1);
    d.y = length(cpj2);

    dd = vec2(1.0) / d;

    p = squarRad * dd;
    q = d - p;
    h = sqrt(p * q);
    //h = vec2(0.0);
    
    p *= dd;
    h *= dd;

    cpj1 *= p.x;
    cpm1 *= h.x;
    cpj2 *= p.y;
    cpm2 *= h.y;

    // TODO: rewrite only using four projections, additions in homogenous coordinates and delayed perspective divisions.
    testPos = objPos.xyz + cpj1 + cpm1;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = projPos.xy;
    maxs = projPos.xy;

    testPos -= 2.0 * cpm1;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos = objPos.xyz + cpj2 + cpm2;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos -= 2.0 * cpm2;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    gl_PointSize = max((maxs.x - mins.x) * winHalf.x, (maxs.y - mins.y) * winHalf.y) * 0.5;

#ifdef SMALL_SPRITE_LIGHTING
    // for normal crowbaring on very small sprites
    lightPos.w = (clamp(gl_PointSize, 1.0, 5.0) - 1.0) / 4.0;
#endif // SMALL_SPRITE_LIGHTING
    
#ifdef RETICLE
    centerFragment = gl_Position.xy / gl_Position.w;
#endif // RETICLE

    // gl_PointSize = 32.0;
    
#ifdef HALO
    squarRad = rad * rad;
#endif // HALO

    // Apply filter if necessary
    if(filter == 0.0) {
        gl_PointSize = 0.0;
    }
}
-->
      </snippet>
    </shader>

    <shader name="filterCylinderVertex">
      <snippet type="version">110</snippet>
      <snippet name="commondefines"/>
      <snippet type="string">
        <!--

uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

#ifdef DEBUG
uniform vec2 circleAttr;
#endif // DEBUG

//
attribute vec2 inParams;
attribute vec4 quatC; // conjugate quaternion
//

// colors of cylinder
attribute vec3 color1;
attribute vec3 color2;

attribute float filter;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying vec3 radz;

varying vec3 rotMatT0;
varying vec3 rotMatT1; // rotation matrix from the quaternion
varying vec3 rotMatT2;

#ifdef RETICLE
varying vec2 centerFragment;
#endif // RETICLE

void main(void) {
    const vec4 quatConst = vec4(1.0, -1.0, 0.5, 0.0);
    vec4 tmp, tmp1;

    // remove the sphere radius from the w coordinates to the rad varyings
    vec4 inPos = gl_Vertex;

    radz.x = inParams.x;
    radz.y = radz.x * radz.x;
    radz.z = inParams.y * 0.5;

    inPos.w = 1.0;

    
    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)


    // orientation quaternion to inverse rotation matrix conversion
    // Begin: Holy code!
    tmp = quatC.xzyw * quatC.yxzw;                        // tmp <- (xy, xz, yz, ww)
    tmp1 = quatC * quatC.w;                                // tmp1 <- (xw, yw, zw, %)
    tmp1.w = -quatConst.z;                                // tmp1 <- (xw, yw, zw, -0.5)

    rotMatT0.xyz = tmp1.wzy * quatConst.xxy + tmp.wxy;    // matrix0 <- (ww-0.5, xy+zw, xz-yw, %)
    rotMatT0.x = quatC.x * quatC.x + rotMatT0.x;        // matrix0 <- (ww+x*x-0.5, xy+zw, xz-yw, %)
    rotMatT0 = rotMatT0 + rotMatT0;                     // matrix0 <- (2(ww+x*x)-1, 2(xy+zw), 2(xz-yw), %)

    rotMatT1.xyz = tmp1.zwx * quatConst.yxx + tmp.xwz;     // matrix1 <- (xy-zw, ww-0.5, yz+xw, %)
    rotMatT1.y = quatC.y * quatC.y + rotMatT1.y;         // matrix1 <- (xy-zw, ww+y*y-0.5, yz+xw, %)
    rotMatT1 = rotMatT1 + rotMatT1;                     // matrix1 <- (2(xy-zw), 2(ww+y*y)-1, 2(yz+xw), %)

    rotMatT2.xyz = tmp1.yxw * quatConst.xyx + tmp.yzw;     // matrix2 <- (xz+yw, yz-xw, ww-0.5, %)
    rotMatT2.z = quatC.z * quatC.z + rotMatT2.z;         // matrix2 <- (xz+yw, yz-xw, ww+zz-0.5, %)
    rotMatT2 = rotMatT2 + rotMatT2;                     // matrix2 <- (2(xz+yw), 2(yz-xw), 2(ww+zz)-1, %)    
    // End: Holy code!


    // calculate cam position
    tmp = gl_ModelViewMatrixInverse[3]; // (C) by Christoph
    tmp.xyz -= objPos.xyz; // cam move
    camPos.xyz = rotMatT0 * tmp.x + rotMatT1 * tmp.y + rotMatT2 * tmp.z;
    

    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = gl_ModelViewMatrixInverse * gl_LightSource[0].position - objPos; // note: w is bullshit now!
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    lightPos = gl_ModelViewMatrixInverse * normalize( gl_LightSource[0].position);
    lightPos.xyz = rotMatT0 * lightPos.x + rotMatT1 * lightPos.y + rotMatT2 * lightPos.z;
    

    // send color to fragment shader
    gl_FrontColor = gl_Color;

    // calculate point sprite
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    // lumberjack approach
    vec4 pos, projPos;
    vec4 pX, pY, pZ, pOP;
    vec2 mins, maxs, pp;

#define CYL_HALF_LEN radz.z
#define CYL_RAD radz.x

    projPos.w = 0.0;

    //pos = vec4(0.0, 0.0, 0.0, 1.0);
    //projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    //projPos.y = dot(rotMatT1.xyz, pos.xyz);
    //projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos; // + projPos; // move
    pos.w = 1.0; // now we're in object space
    pOP = gl_ModelViewProjectionMatrix * pos;

    pos = vec4(1.0, 0.0, 0.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = gl_ModelViewProjectionMatrix * pos;
    pX = (projPos - pOP) * CYL_HALF_LEN;

    pos = vec4(0.0, 1.0, 0.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = gl_ModelViewProjectionMatrix * pos;
    pY = (projPos - pOP) * CYL_RAD;

    pos = vec4(0.0, 0.0, 1.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = gl_ModelViewProjectionMatrix * pos;
    pZ = (projPos - pOP) * CYL_RAD;

    // 8 corners of doom
    pos = pOP + pX;
    projPos = pos + pY + pZ;
    mins = maxs = projPos.xy / projPos.w;

    projPos = pos - pY + pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos + pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);


    pos = pOP - pX;
    projPos = pos + pY + pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY + pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos + pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);


    gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    maxs = (maxs - mins) * 0.5 * winHalf;
    gl_PointSize = max(maxs.x, maxs.y);


//    // oabb-approach
//    // calculate pOP, pX, pY, and pZ as above
//
//    pos = pOP + pX * circleAttr.x;
//    gl_Position = vec4(pos.xyz / pos.w, 1.0);
//
//    float l = camPos.y * camPos.y + camPos.z * camPos.z;
//    if (l < radz.y) { // radius-square
//        // camera is inside the cylinder
//        //  so choose nearest cap and we are done
//        gl_FrontSecondaryColor = vec4(0.5, 0.0, 0.0, 1.0);
//
//        // calculate 4 points of doom
//        pos = pOP + pX * sign(camPos.x);
//
//        projPos = pos + pY + pZ;
//        mins = maxs = projPos.xy / projPos.w;
//
//        projPos = pos - pY + pZ;
//        pp = projPos.xy / projPos.w;
//        mins = min(mins, pp);
//        maxs = max(maxs, pp);
//
//        projPos = pos + pY - pZ;
//        pp = projPos.xy / projPos.w;
//        mins = min(mins, pp);
//        maxs = max(maxs, pp);
//
//        projPos = pos - pY - pZ;
//        pp = projPos.xy / projPos.w;
//        mins = min(mins, pp);
//        maxs = max(maxs, pp);
//
//        gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
//        maxs = (maxs - mins) * 0.5 * winHalf;
//        gl_PointSize = max(maxs.x, maxs.y);
//
//    } else {
//        // camera is outside the cylinder
//        //  so find touching planes
//        gl_FrontSecondaryColor = vec4(0.0, 0.5, 0.0, 1.0);
//
//        vec2 j = vec2(camPos.y, camPos.z);
//        float d = length(j);
//        j /= d;
//        vec2 m = vec2(j.y, -j.x);
//        float p = radz.y / d;
//        float q = d - p;
//        float h = sqrt(p * q);
//
//        vec2 i = j * p + m * h * circleAttr.x;
//
//        i /= radz.x;
//
////        pos = pOP + pX * circleAttr.x + pY * n.y + pZ * n.z;
////        pos = pOP + pX + pY * circleAttr.y + pZ * circleAttr.x;
//
//        float minCylX = -CYL_HALF_LEN + (((radz.x - p * sign(-CYL_HALF_LEN - camPos.x)) * (-CYL_HALF_LEN - camPos.x)) / (-d * sign(-CYL_HALF_LEN - camPos.x) + radz.x)); // tut net so ganz
//        float maxCylX =  CYL_HALF_LEN + (((radz.x + p * sign(CYL_HALF_LEN - camPos.x)) * (CYL_HALF_LEN - camPos.x)) / (d * sign(CYL_HALF_LEN - camPos.x) + radz.x)); // tut, keine Ahnung warum
//
//
//        float fX = mix(minCylX, maxCylX, (circleAttr.y + 1.0) * 0.5);
//
//        pX /= CYL_HALF_LEN;
//
//        pos = pOP + pX * fX + pY * i.x + pZ * i.y;
//      
//        gl_Position = vec4(pos.xyz / pos.w, 1.0);
//
//    }


#ifdef RETICLE
    centerFragment = gl_Position.xy / gl_Position.w;
#endif // RETICLE
    
    // set colors
    gl_FrontColor.r = color1.r;
    gl_FrontColor.g = color1.g;
    gl_FrontColor.b = color1.b;

    gl_FrontSecondaryColor.r = color2.r;
    gl_FrontSecondaryColor.g = color2.g;
    gl_FrontSecondaryColor.b = color2.b;
    
    // Apply filter if necessary
    if( filter == 0.0) {
        gl_PointSize = 0.0;
    }

}
-->
      </snippet>
    </shader>

    <shader name="filterCylinderFragment">
      <snippet type="version">110</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet type="string">
        <!--

//#undef CLIP

// #define RENDER_CAPS

uniform vec4 viewAttr;

FLACH varying vec4 objPos;
FLACH varying vec4 camPos;
FLACH varying vec4 lightPos;
FLACH varying vec3 radz;

FLACH varying vec3 rotMatT0;
FLACH varying vec3 rotMatT1; // rotation matrix from the quaternion
FLACH varying vec3 rotMatT2;

#ifdef RETICLE
FLACH varying vec2 centerFragment;
#endif // RETICLE

void main(void) {
    vec4 coord;
    vec3 ray, tmp;
    const float maxLambda = 50000.0;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    

    // transform fragment coordinates from view coordinates to object coordinates.
    coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;
    coord -= objPos; // ... and move


    // calc the viewing ray
    ray = rotMatT0 * coord.x + rotMatT1 * coord.y + rotMatT2 * coord.z;
    ray = normalize(ray - camPos.xyz);


    // calculate the geometry-ray-intersection

    // cylinder parameters
#define CYL_RAD radz.x
#define CYL_RAD_SQ radz.y
#define CYL_HALF_LEN radz.z

    float rDc = dot(ray.yz, camPos.yz);
    float rDr = dot(ray.yz, ray.yz);

    float radicand = (rDc * rDc) - (rDr * (dot(camPos.yz, camPos.yz) - CYL_RAD_SQ));

#ifdef CLIP
    if (radicand < 0.0) { discard; }
#endif // CLIP

    float radix = sqrt(radicand);
    vec2 lambdas = vec2((-rDc - radix) / rDr, (-rDc + radix) / rDr);

    // calculations for cylinder caps
    vec3 cylPt1 = camPos.xyz + ray * lambdas.x;
    vec3 cylPt2 = camPos.xyz + ray * lambdas.y;

#ifdef RENDER_CAPS
    bool cylPt1Right = (cylPt1.x > 0.0);
#endif // RENDER_CAPS
    bool cylPt1Valid = (cylPt1.x <= CYL_HALF_LEN) && (cylPt1.x >= -CYL_HALF_LEN); // trim cylinder
#ifdef RENDER_CAPS
    bool cylPt2Valid = cylPt1Right ? (cylPt2.x <= CYL_HALF_LEN) : (cylPt2.x >= -CYL_HALF_LEN);
#else
    bool cylPt2Valid = (cylPt2.x <= CYL_HALF_LEN) && (cylPt2.x >= -CYL_HALF_LEN);
#endif // RENDER_CAPS

#ifdef RENDER_CAPS
    lambdas.x = cylPt1Valid ? lambdas.x : (((cylPt1Right ? CYL_HALF_LEN : -CYL_HALF_LEN) - camPos.x) / ray.x);
    lambdas.x = (cylPt1Valid || cylPt2Valid) ? lambdas.x : maxLambda;

#ifdef CLIP
    if (lambdas.x >= maxLambda) { discard; }
#else // CLIP
    if (lambdas.x >= maxLambda) { radicand = -1.0; }
#endif // CLIP

#else // RENDER_CAPS
    lambdas.x = (cylPt1Valid) ? lambdas.x : lambdas.y;    

#ifdef CLIP
    if ((!cylPt1Valid && !cylPt2Valid)) { discard; }
#else // CLIP
    if ((!cylPt1Valid && !cylPt2Valid)) { radicand = -1.0; }
#endif // CLIP
#endif // RENDER_CAPS

    vec3 intersection = camPos.xyz + ray * lambdas.x;
#ifdef RENDER_CAPS
    vec3 normal = (cylPt1Valid ? vec3(0.0, normalize(intersection.yz)) : (cylPt1Right ? vec3(1.0, 0.0, 0.0) : vec3(-1.0, 0.0, 0.0)));
#else // RENDER_CAPS
    vec3 normal = vec3(0.0, normalize(intersection.yz));
#endif // RENDER_CAPS


    // chose color for lighting
    vec3 color = gl_Color.rgb;

    // set fragment color (kroneml)
    if( cylPt1.x > 0.0 )
    {
        color = gl_SecondaryColor.rgb;
    }
    else
    {
        color = gl_Color.rgb;
    }

    // phong lighting with directional light
    gl_FragColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color), 1.0);


    // calculate depth
#ifdef DEPTH
    tmp = intersection;
    intersection.x = dot(rotMatT0, tmp.xyz);
    intersection.y = dot(rotMatT1, tmp.xyz);
    intersection.z = dot(rotMatT2, tmp.xyz);

    intersection += objPos.xyz;

    vec4 Ding = vec4(intersection, 1.0);
    float depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
    float depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
#ifndef CLIP
    if (radicand < 0.0) { 
        gl_FragColor = gl_SecondaryColor;
        depth = 1.0;
        depthW = 1.0;
    }
#endif // CLIP
    gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
#endif // DEPTH

#ifdef RETICLE
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    if (min(abs(coord.x - centerFragment.x), abs(coord.y - centerFragment.y)) < 0.002) {
        gl_FragColor.rgb += vec3(0.3, 0.3, 0.5);
    }
#endif // RETICLE
}
-->
      </snippet>
    </shader>

  </namespace>

  <!-- shaders for the cartoon protein renderer -->
  <namespace name="cartoon">
    <namespace name="cartoon">
      <shader name="vertex">
        <snippet type="string">
          <!--
/*
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120

varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;

void main(void)
{
    gl_FrontColor=gl_Color;
    gl_BackColor=gl_Color;
    
    // do not ftransform(), geometry shader needs the original vertices
    gl_Position= gl_Vertex;
}
-->
        </snippet>
      </shader>
      <shader name="geometry">
        <snippet type="string">
          <!--
/* Geometry Shader: Cartoon Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable

varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;


void lighting( vec3 norm)
{
    // transformation of the normal into eye space
    normal = normalize(gl_NormalMatrix * norm);
    // normalize the direction of the light
    lightDir = normalize(vec3(gl_LightSource[0].position));
    // normalize the halfVector to pass it to the fragment shader
    halfVector = normalize(gl_LightSource[0].halfVector.xyz);
    // compute the diffuse, ambient and globalAmbient terms
    diffuse = gl_FrontColor * gl_LightSource[0].diffuse;
    ambient = gl_FrontColor * gl_LightSource[0].ambient;
    ambient += gl_LightModel.ambient * gl_FrontColor;
}

void main(void)
{
    // get all vertex positions
    vec3 v0 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v1 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v2 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v3 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 v4 = vec3(gl_PositionIn[4].xyz) / gl_PositionIn[4].w;
    vec3 v5 = vec3(gl_PositionIn[5].xyz) / gl_PositionIn[5].w;
    // compute all needed directions
    vec3 dir20 = v2 - v0;
    vec3 dir12 = v1 - v2;
    vec3 dir32 = v3 - v2;
    vec3 dir43 = v4 - v3;
    vec3 dir53 = v5 - v3;
    
    // number of segments
    const int n = 6;
    // scale factor for the width of the tube
    float scale = gl_FrontColorIn[1].x;
    float stretch1 = gl_FrontColorIn[1].y;
    float stretch2 = gl_FrontColorIn[1].z;

    vec3 dir1 = normalize( cross( dir12, dir32));
    vec3 dir2 = normalize( cross( dir43, dir53));
    
    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    // coil/turn
    if( gl_FrontColorIn[2].x < 1.0 )
    {
        // angle for the rotation
        float alpha;
        // matrices for rotation
        mat3 e = mat3( 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
        mat3 m1 = mat3( 0.0,-ortho1.z, ortho1.y, ortho1.z, 0.0,-ortho1.x,-ortho1.y, ortho1.x, 0.0);
        mat3 m2 = mat3( 0.0,-ortho2.z, ortho2.y, ortho2.z, 0.0,-ortho2.x,-ortho2.y, ortho2.x, 0.0);
        mat3 m1quat = m1 * m1;
        mat3 m2quat = m2 * m2;
        
        vec3 res1;
        vec3 res2;
        
        dir1 = dir1 * scale;
        dir2 = dir2 * scale;
        
        for( int i = 0; i < n; i++ )
        {
            alpha = (360.0/float(n))*float(i);
            res1 = ( e + sin( radians( alpha)) * m1 + ( 1.0 - cos( radians( alpha))) * m1quat ) * dir1;
            res2 = ( e + sin( radians( alpha)) * m2 + ( 1.0 - cos( radians( alpha))) * m2quat ) * dir2;
            
            // copy color 
            gl_FrontColor = gl_FrontColorIn[0];
            // copy position 
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + res1).xyz, 1.0);
            // compute lighting
            lighting( normalize( res1));
            // done with the vertex 
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + res2).xyz, 1.0);
            lighting( normalize( res2));
            EmitVertex();
        }
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1).xyz, 1.0);
        lighting( normalize( dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2).xyz, 1.0);
        lighting( normalize( dir2));
        EmitVertex();
        
        EndPrimitive();
/*
        ////////////////
        // draw start //
        ////////////////
        for( int i = 0; i < n; i++ )
        {
            alpha = (360.0/float(n))*float(i);
            res1 = ( e + sin( radians( alpha)) * m2 + ( 1.0 - cos( radians( alpha))) * m2quat ) * dir2;
            alpha = (360.0/float(n))*float(i+1);
            res2 = ( e + sin( radians( alpha)) * m2 + ( 1.0 - cos( radians( alpha))) * m2quat ) * dir2;
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + res1).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + res2).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( v3, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            EndPrimitive();
        }
*/
/*
        //////////////
        // draw end //
        //////////////
        for( int i = 0; i < n; i++ )
        {
            alpha = (360.0/float(n))*float(i);
            res1 = ( e + sin( radians( alpha)) * m1 + ( 1.0 - cos( radians( alpha))) * m1quat ) * dir1;
            alpha = (360.0/float(n))*float(i+1);
            res2 = ( e + sin( radians( alpha)) * m1 + ( 1.0 - cos( radians( alpha))) * m1quat ) * dir1;
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + res1).xyz, 1.0);
            lighting( normalize(-dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + res2).xyz, 1.0);
            lighting( normalize(-dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( v2, 1.0);
            lighting( normalize(-dir20));
            EmitVertex();
            
            EndPrimitive();
        }
*/
    }
    // sheet ribbon
    else if( gl_FrontColorIn[2].x > 0.5 && gl_FrontColorIn[2].x < 1.5 )
    {
        dir1 = normalize( cross( dir1, ortho1))*stretch1;
        dir2 = normalize( cross( dir2, ortho2))*stretch2;
        vec3 norm1 = normalize( cross( dir1, ortho1));
        vec3 norm2 = normalize( cross( dir2, ortho2));
        
        /////////////////////
        // draw top ribbon //
        /////////////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
        lighting( normalize( norm1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
        lighting( normalize( norm1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
        lighting( normalize( norm2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
        lighting( normalize( norm2));
        EmitVertex();
        
        EndPrimitive();
        
        ////////////////////////
        // draw bottom ribbon //
        ////////////////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
        lighting( normalize(-norm1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
        lighting( normalize(-norm1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
        lighting( normalize(-norm2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
        lighting( normalize(-norm2));
        EmitVertex();
        
        EndPrimitive();
        
        /////////////////////
        // draw first side //
        /////////////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
        lighting( normalize( dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
        lighting( normalize( dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir2));
        EmitVertex();
        
        EndPrimitive();
        
        //////////////////////
        // draw second side //
        //////////////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
        lighting( normalize(-dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
        lighting( normalize(-dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
        lighting( normalize(-dir2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
        lighting( normalize(-dir2));
        EmitVertex();
        
        EndPrimitive();
        
        if( gl_FrontColorIn[2].y > 0.0 )
        {
            ////////////////
            // draw start //
            ////////////////
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            EndPrimitive();
        }
        
        if( gl_FrontColorIn[2].z > 0.0 )
        {
            //////////////
            // draw end //
            //////////////
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
            lighting( normalize(-dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
            lighting( normalize(-dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
            lighting( normalize(-dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
            lighting( normalize(-dir20));
            EmitVertex();
            
            EndPrimitive();
        }
    }
    // helix ribbon
    else if( gl_FrontColorIn[2].x > 1.5 && gl_FrontColorIn[2].x < 2.5 )
    {
        dir1 = normalize( cross( dir1, ortho1))*stretch1;
        dir2 = normalize( cross( dir2, ortho2))*stretch2;
        vec3 norm1 = normalize( cross( dir1, ortho1));
        vec3 norm2 = normalize( cross( dir2, ortho2));
        
        /////////////////////
        // draw top ribbon //
        /////////////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
        lighting( normalize(-dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
        lighting( normalize(-dir2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 + norm1*scale).xyz, 1.0);
        lighting( normalize( norm1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 + norm2*scale).xyz, 1.0);
        lighting( normalize( norm2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 + norm1*scale).xyz, 1.0);
        lighting( normalize( norm1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 + norm2*scale).xyz, 1.0);
        lighting( normalize( norm2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir2));
        EmitVertex();
        
        EndPrimitive();
        
        ////////////////////////
        // draw bottom ribbon //
        ////////////////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
        lighting( normalize(-dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
        lighting( normalize(-dir2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 - norm1*scale).xyz, 1.0);
        lighting( normalize(-norm1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 - norm2*scale).xyz, 1.0);
        lighting( normalize(-norm2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 - norm1*scale).xyz, 1.0);
        lighting( normalize(-norm1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 - norm2*scale).xyz, 1.0);
        lighting( normalize(-norm2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir2));
        EmitVertex();
        
        EndPrimitive();
        
        /////////////////////
        // draw first side //
        /////////////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir2));
        EmitVertex();
        
        EndPrimitive();
        
        //////////////////////
        // draw second side //
        //////////////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
        lighting( normalize(-dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
        lighting( normalize(-dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
        lighting( normalize(-dir2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
        lighting( normalize(-dir2));
        EmitVertex();
        
        EndPrimitive();
        
        if( gl_FrontColorIn[2].y > 0.0 )
        {
            ////////////////
            // draw start //
            ////////////////
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 + norm2*scale).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 + norm2*scale).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 - norm2*scale).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 - norm2*scale).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            EndPrimitive();
        }

        if( gl_FrontColorIn[2].z > 0.0 )
        {
            //////////////
            // draw end //
            //////////////
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 + norm1*scale).xyz, 1.0);
            lighting( normalize( -dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 + norm1*scale).xyz, 1.0);
            lighting( normalize( -dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
            lighting( normalize( -dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
            lighting( normalize( -dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
            lighting( normalize( -dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
            lighting( normalize( -dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 - norm1*scale).xyz, 1.0);
            lighting( normalize( -dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 - norm1*scale).xyz, 1.0);
            lighting( normalize( -dir20));
            EmitVertex();
            
            EndPrimitive();
        }
    }
}
-->
        </snippet>
      </shader>
      <shader name="fragment">
        <snippet type="string">
          <!--
/*
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120

varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;


void main(void)
{    
    //gl_FragColor = gl_Color;

    vec3 n,halfV;
    float NdotL,NdotHV;
    
    // store the ambient term
    vec4 color = ambient;
    
    // store the normalized interpolated normal
    n = normalize(normal);
    
    // compute the dot product between normal and ldir
    NdotL = max(dot(n,lightDir),0.0);
    if (NdotL > 0.0) {
        color += diffuse * NdotL;
        halfV = normalize(halfVector);
        NdotHV = max(dot(n,halfV),0.0);
        color += gl_FrontMaterial.specular * gl_LightSource[0].specular * 
                pow(NdotHV, gl_FrontMaterial.shininess);
    }

    gl_FragColor = color;
    
    /*
    vec3 fogCol = vec3( 1.0, 1.0, 1.0);
    const float LOG2 = 1.442695;
    float fogDensity = 0.35;
    float z = gl_FragCoord.z / gl_FragCoord.w;
    float fogFactor = exp2( - fogDensity * fogDensity * z * z * LOG2 );
    fogFactor = clamp(fogFactor, 0.0, 1.0);
    gl_FragColor.rgb = mix( fogCol, gl_FragColor.rgb, fogFactor );
    */
}
-->
        </snippet>
      </shader>
      <shader name="fragmentOR">
        <snippet type="string">
          <!--
/*
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120

uniform vec2 zValues;
uniform vec2 winSize;
varying vec4 diffuse;
varying vec3 normal;

void main(void)
{
    gl_FragData[0] =  vec4(diffuse.rgb, 1.0);
    // Normal is transformed to eye space in geometry shader
    gl_FragData[1].rgb = normalize(normal); 
    
    float n = zValues.x;
    float f = zValues.y;
    float depthES;
    
    // Unproject depth and switch sign -> positive eye space depth
    depthES = 2.0*n*f/(f+n-gl_FragCoord.z*(f-n));
    // Map near ... far to 0 ... 1
    depthES = (depthES - n)/(f-n);
    
    gl_FragDepth = depthES;
}
-->
        </snippet>
      </shader>
    </namespace>
    <shader name="tubeGeometry">
      <snippet type="string">
        <!-- 
/* Geometry Shader: Tube Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable

varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;


void lighting( vec3 norm)
{
    // transformation of the normal into eye space
    normal = normalize(gl_NormalMatrix * norm);
    // normalize the direction of the light
    lightDir = normalize(vec3(gl_LightSource[0].position));
    // normalize the halfVector to pass it to the fragment shader
    halfVector = normalize(gl_LightSource[0].halfVector.xyz);
    // compute the diffuse, ambient and globalAmbient terms
    diffuse = gl_FrontColor * gl_LightSource[0].diffuse;
    ambient = gl_FrontColor * gl_LightSource[0].ambient;
    ambient += gl_LightModel.ambient * gl_FrontColor;
}

void main(void)
{
    // get all vertex positions
    vec3 v0 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v1 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v2 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v3 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 v4 = vec3(gl_PositionIn[4].xyz) / gl_PositionIn[4].w;
    vec3 v5 = vec3(gl_PositionIn[5].xyz) / gl_PositionIn[5].w;
    // compute all needed directions
    vec3 dir20 = v2 - v0;
    vec3 dir12 = v1 - v2;
    vec3 dir32 = v3 - v2;
    vec3 dir43 = v4 - v3;
    vec3 dir53 = v5 - v3;
    
    // number of segments
    const int n = 12;
    // scale factor for the width of the tube
    float scale = gl_FrontColorIn[1].x;
    float stretch1 = gl_FrontColorIn[1].y;
    float stretch2 = gl_FrontColorIn[1].z;

    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));

    // angle for the rotation
    float alpha;
    // matrices for rotation
    mat3 e = mat3( 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
    mat3 m1 = mat3( 0.0,-ortho1.z, ortho1.y, ortho1.z, 0.0,-ortho1.x,-ortho1.y, ortho1.x, 0.0);
    mat3 m2 = mat3( 0.0,-ortho2.z, ortho2.y, ortho2.z, 0.0,-ortho2.x,-ortho2.y, ortho2.x, 0.0);
    mat3 m1quat = m1 * m1;
    mat3 m2quat = m2 * m2;
    
    vec3 res1;
    vec3 res2;
    
    dir1 = dir1 * scale;
    dir2 = dir2 * scale;
    
    for( int i = 0; i < n; i++ )
    {
        alpha = (360.0/float(n))*float(i);
        res1 = ( e + sin( radians( alpha)) * m1 + ( 1.0 - cos( radians( alpha))) * m1quat ) * dir1;
        res2 = ( e + sin( radians( alpha)) * m2 + ( 1.0 - cos( radians( alpha))) * m2quat ) * dir2;
        
        // copy color 
        gl_FrontColor = gl_FrontColorIn[0];
        // copy position 
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + res1).xyz, 1.0);
        // compute lighting
        lighting( normalize( res1));
        // done with the vertex 
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + res2).xyz, 1.0);
        lighting( normalize( res2));
        EmitVertex();
    }
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
}
-->
      </snippet>
    </shader>
    <shader name="arrowGeometry">
      <snippet type="string">
        <!--
/* Geometry Shader: Arrow Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable

varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;


void lighting( vec3 norm)
{
    // transformation of the normal into eye space
    normal = normalize(gl_NormalMatrix * norm);
    // normalize the direction of the light
    lightDir = normalize(vec3(gl_LightSource[0].position));
    // normalize the halfVector to pass it to the fragment shader
    halfVector = normalize(gl_LightSource[0].halfVector.xyz);
    // compute the diffuse, ambient and globalAmbient terms
    diffuse = gl_FrontColor * gl_LightSource[0].diffuse;
    ambient = gl_FrontColor * gl_LightSource[0].ambient;
    ambient += gl_LightModel.ambient * gl_FrontColor;
}

void main(void)
{
    // get all vertex positions
    vec3 v0 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v1 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v2 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v3 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 v4 = vec3(gl_PositionIn[4].xyz) / gl_PositionIn[4].w;
    vec3 v5 = vec3(gl_PositionIn[5].xyz) / gl_PositionIn[5].w;
    // compute all needed directions
    vec3 dir20 = v2 - v0;
    vec3 dir12 = v1 - v2;
    vec3 dir32 = v3 - v2;
    vec3 dir43 = v4 - v3;
    vec3 dir53 = v5 - v3;
    
    // scale factor for the width of the tube
    float scale = gl_FrontColorIn[1].x;
    float stretch1 = gl_FrontColorIn[1].y;
    float stretch2 = gl_FrontColorIn[1].z;

    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));

    dir1 = normalize( cross( dir1, ortho1))*stretch1;
    dir2 = normalize( cross( dir2, ortho2))*stretch2;
    
    vec3 norm1 = normalize( cross( dir1, ortho1));
    vec3 norm2 = normalize( cross( dir2, ortho2));
    
    /////////////////////
    // draw top ribbon //
    /////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
    lighting( normalize( norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
    lighting( normalize( norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
    lighting( normalize( norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
    lighting( normalize( norm2));
    EmitVertex();
    
    EndPrimitive();
    
    ////////////////////////
    // draw bottom ribbon //
    ////////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
    lighting( normalize(-norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
    lighting( normalize(-norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
    lighting( normalize(-norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
    lighting( normalize(-norm2));
    EmitVertex();
    
    EndPrimitive();
    
    /////////////////////
    // draw first side //
    /////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
    
    //////////////////////
    // draw second side //
    //////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    EndPrimitive();
    
    if( gl_FrontColorIn[2].y > 0.0 )
    {
        ////////////////
        // draw start //
        ////////////////
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        EndPrimitive();
    }
    
    if( gl_FrontColorIn[2].z > 0.0 )
    {
        //////////////
        // draw end //
        //////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
        lighting( normalize(-dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
        lighting( normalize(-dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
        lighting( normalize(-dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
        lighting( normalize(-dir20));
        EmitVertex();
        
        EndPrimitive();
    }

}
-->
      </snippet>
    </shader>
    <shader name="helixGeometry">
      <snippet type="string">
        <!--
/* Geometry Shader: Helix Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable

varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;


void lighting( vec3 norm)
{
    // transformation of the normal into eye space
    normal = normalize(gl_NormalMatrix * norm);
    // normalize the direction of the light
    lightDir = normalize(vec3(gl_LightSource[0].position));
    // normalize the halfVector to pass it to the fragment shader
    halfVector = normalize(gl_LightSource[0].halfVector.xyz);
    // compute the diffuse, ambient and globalAmbient terms
    diffuse = gl_FrontColor * gl_LightSource[0].diffuse;
    ambient = gl_FrontColor * gl_LightSource[0].ambient;
    ambient += gl_LightModel.ambient * gl_FrontColor;
}

void main(void)
{
    // get all vertex positions
    vec3 v0 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v1 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v2 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v3 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 v4 = vec3(gl_PositionIn[4].xyz) / gl_PositionIn[4].w;
    vec3 v5 = vec3(gl_PositionIn[5].xyz) / gl_PositionIn[5].w;
    // compute all needed directions
    vec3 dir20 = v2 - v0;
    vec3 dir12 = v1 - v2;
    vec3 dir32 = v3 - v2;
    vec3 dir43 = v4 - v3;
    vec3 dir53 = v5 - v3;
    
    // scale factor for the width of the tube
    float scale = gl_FrontColorIn[1].x;
    float stretch1 = gl_FrontColorIn[1].y;
    float stretch2 = gl_FrontColorIn[1].z;

    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));
    
    dir1 = normalize( cross( dir1, ortho1))*stretch1;
    dir2 = normalize( cross( dir2, ortho2))*stretch2;
    vec3 norm1 = normalize( cross( dir1, ortho1));
    vec3 norm2 = normalize( cross( dir2, ortho2));
    
    /////////////////////
    // draw top ribbon //
    /////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 + norm1*scale).xyz, 1.0);
    lighting( normalize( norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 + norm2*scale).xyz, 1.0);
    lighting( normalize( norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 + norm1*scale).xyz, 1.0);
    lighting( normalize( norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 + norm2*scale).xyz, 1.0);
    lighting( normalize( norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
    
    ////////////////////////
    // draw bottom ribbon //
    ////////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 - norm1*scale).xyz, 1.0);
    lighting( normalize(-norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 - norm2*scale).xyz, 1.0);
    lighting( normalize(-norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 - norm1*scale).xyz, 1.0);
    lighting( normalize(-norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 - norm2*scale).xyz, 1.0);
    lighting( normalize(-norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
    
    /////////////////////
    // draw first side //
    /////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
    
    //////////////////////
    // draw second side //
    //////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    EndPrimitive();
    
    if( gl_FrontColorIn[2].y > 0.0 )
    {
        ////////////////
        // draw start //
        ////////////////
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        EndPrimitive();
    }

    if( gl_FrontColorIn[2].z > 0.0 )
    {
        //////////////
        // draw end //
        //////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 + norm1*scale).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 + norm1*scale).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 - norm1*scale).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 - norm1*scale).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        EndPrimitive();
    }
}
-->
      </snippet>
    </shader>

    <namespace name="simple">
      <shader name="vertex">
        <snippet type="string">
          <!--
/*
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120


void main(void)
{
    gl_FrontColor=gl_Color;
    gl_BackColor=gl_Color;
    
    // do not ftransform(), geometry shader needs the original vertices
    gl_Position= gl_Vertex;
}
-->
        </snippet>
      </shader>
      <shader name="fragment">
        <snippet type="string">
          <!--
/*
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120


void main(void)
{    
    gl_FragColor = gl_Color;
}
-->
        </snippet>
      </shader>
      <shader name="tubeGeometry">
        <snippet type="string">
          <!--
/* Geometry Shader: Cartoon Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable


void lighting( vec3 norm)
{
    vec3 normal, lightDir;
    vec4 diffuse, ambient, globalAmbient;
    float NdotL;
    
    normal = normalize(gl_NormalMatrix * norm);
    lightDir = normalize(vec3(gl_LightSource[0].position));
    NdotL = max(dot(normal, lightDir), 0.0);
    diffuse = gl_FrontColor * gl_LightSource[0].diffuse;
    
    /* Compute the ambient and globalAmbient terms */
    ambient = gl_FrontColor * gl_LightSource[0].ambient;
    globalAmbient = gl_LightModel.ambient * gl_FrontColor;
    
    gl_FrontColor =  NdotL * diffuse + globalAmbient + ambient;
    gl_BackColor =  NdotL * diffuse + globalAmbient + ambient;
}

void main(void)
{
    // get all vertex positions
    vec3 v0 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v1 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v2 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v3 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 v4 = vec3(gl_PositionIn[4].xyz) / gl_PositionIn[4].w;
    vec3 v5 = vec3(gl_PositionIn[5].xyz) / gl_PositionIn[5].w;
    // compute all needed directions
    vec3 dir20 = v2 - v0;
    vec3 dir12 = v1 - v2;
    vec3 dir32 = v3 - v2;
    vec3 dir43 = v4 - v3;
    vec3 dir53 = v5 - v3;
    
    // number of segments
    const int n = 12;
    // scale factor for the width of the tube
    float scale = gl_FrontColorIn[1].x;
    float stretch1 = gl_FrontColorIn[1].y;
    float stretch2 = gl_FrontColorIn[1].z;

    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));
    
    // angle for the rotation
    float alpha;
    // matrices for rotation
    mat3 e = mat3( 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
    mat3 m1 = mat3( 0.0,-ortho1.z, ortho1.y, ortho1.z, 0.0,-ortho1.x,-ortho1.y, ortho1.x, 0.0);
    mat3 m2 = mat3( 0.0,-ortho2.z, ortho2.y, ortho2.z, 0.0,-ortho2.x,-ortho2.y, ortho2.x, 0.0);
    mat3 m1quat = m1 * m1;
    mat3 m2quat = m2 * m2;
    
    vec3 res1;
    vec3 res2;
    
    dir1 = dir1 * scale;
    dir2 = dir2 * scale;
    
    for( int i = 0; i < n; i++ )
    {
        alpha = (360.0/float(n))*float(i);
        res1 = ( e + sin( radians( alpha)) * m1 + ( 1.0 - cos( radians( alpha))) * m1quat ) * dir1;
        res2 = ( e + sin( radians( alpha)) * m2 + ( 1.0 - cos( radians( alpha))) * m2quat ) * dir2;
        
        // copy color 
        gl_FrontColor = gl_FrontColorIn[0];
        // copy position
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + res1).xyz, 1.0);
        // compute lighting
        lighting( normalize( res1));
        // done with the vertex 
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + res2).xyz, 1.0);
        lighting( normalize( res2));
        EmitVertex();
    }
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
}
-->
        </snippet>
      </shader>
      <shader name="arrowGeometry">
        <snippet type="string">
          <!--
/* Geometry Shader: Cartoon Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable


void lighting( vec3 norm)
{
    vec3 normal, lightDir;
    vec4 diffuse, ambient, globalAmbient;
    float NdotL;
    
    normal = normalize(gl_NormalMatrix * norm);
    lightDir = normalize(vec3(gl_LightSource[0].position));
    NdotL = max(dot(normal, lightDir), 0.0);
    diffuse = gl_FrontColor * gl_LightSource[0].diffuse;
    
    /* Compute the ambient and globalAmbient terms */
    ambient = gl_FrontColor * gl_LightSource[0].ambient;
    globalAmbient = gl_LightModel.ambient * gl_FrontColor;
    
    gl_FrontColor =  NdotL * diffuse + globalAmbient + ambient;
    gl_BackColor =  NdotL * diffuse + globalAmbient + ambient;
}

void main(void)
{
    // get all vertex positions
    vec3 v0 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v1 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v2 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v3 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 v4 = vec3(gl_PositionIn[4].xyz) / gl_PositionIn[4].w;
    vec3 v5 = vec3(gl_PositionIn[5].xyz) / gl_PositionIn[5].w;
    // compute all needed directions
    vec3 dir20 = v2 - v0;
    vec3 dir12 = v1 - v2;
    vec3 dir32 = v3 - v2;
    vec3 dir43 = v4 - v3;
    vec3 dir53 = v5 - v3;
    
    // scale factor for the width of the tube
    float scale = gl_FrontColorIn[1].x;
    float stretch1 = gl_FrontColorIn[1].y;
    float stretch2 = gl_FrontColorIn[1].z;

    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));

    dir1 = normalize( cross( dir1, ortho1))*stretch1;
    dir2 = normalize( cross( dir2, ortho2))*stretch2;
    vec3 norm1 = normalize( cross( dir1, ortho1));
    vec3 norm2 = normalize( cross( dir2, ortho2));
    
    /////////////////////
    // draw top ribbon //
    /////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
    lighting( normalize( norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
    lighting( normalize( norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
    lighting( normalize( norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
    lighting( normalize( norm2));
    EmitVertex();
    
    EndPrimitive();
    
    ////////////////////////
    // draw bottom ribbon //
    ////////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
    lighting( normalize(-norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
    lighting( normalize(-norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
    lighting( normalize(-norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
    lighting( normalize(-norm2));
    EmitVertex();
    
    EndPrimitive();
    
    /////////////////////
    // draw first side //
    /////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
    
    //////////////////////
    // draw second side //
    //////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    EndPrimitive();
    
    if( gl_FrontColorIn[2].y > 0.0 )
    {
        ////////////////
        // draw start //
        ////////////////
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        EndPrimitive();
    }
    
    if( gl_FrontColorIn[2].z > 0.0 )
    {
        //////////////
        // draw end //
        //////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
        lighting( normalize(-dir20));
        EmitVertex();
        
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
        lighting( normalize(-dir20));
        EmitVertex();
        
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
        lighting( normalize(-dir20));
        EmitVertex();
        
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
        lighting( normalize(-dir20));
        EmitVertex();
        
        EndPrimitive();
    }
}
-->
        </snippet>
      </shader>
      <shader name="helixGeometry">
        <snippet type="string">
          <!--
/* Geometry Shader: Cartoon Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable


void lighting( vec3 norm)
{
    vec3 normal, lightDir;
    vec4 diffuse, ambient, globalAmbient;
    float NdotL;
    
    normal = normalize(gl_NormalMatrix * norm);
    lightDir = normalize(vec3(gl_LightSource[0].position));
    NdotL = max(dot(normal, lightDir), 0.0);
    diffuse = gl_FrontColor * gl_LightSource[0].diffuse;
    
    /* Compute the ambient and globalAmbient terms */
    ambient = gl_FrontColor * gl_LightSource[0].ambient;
    globalAmbient = gl_LightModel.ambient * gl_FrontColor;
    
    gl_FrontColor =  NdotL * diffuse + globalAmbient + ambient;
    gl_BackColor =  NdotL * diffuse + globalAmbient + ambient;
}

void main(void)
{
    // get all vertex positions
    vec3 v0 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v1 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v2 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v3 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 v4 = vec3(gl_PositionIn[4].xyz) / gl_PositionIn[4].w;
    vec3 v5 = vec3(gl_PositionIn[5].xyz) / gl_PositionIn[5].w;
    // compute all needed directions
    vec3 dir20 = v2 - v0;
    vec3 dir12 = v1 - v2;
    vec3 dir32 = v3 - v2;
    vec3 dir43 = v4 - v3;
    vec3 dir53 = v5 - v3;
    
    // scale factor for the width of the tube
    float scale = gl_FrontColorIn[1].x;
    float stretch1 = gl_FrontColorIn[1].y;
    float stretch2 = gl_FrontColorIn[1].z;

    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));
    
    dir1 = normalize( cross( dir1, ortho1))*stretch1;
    dir2 = normalize( cross( dir2, ortho2))*stretch2;
    vec3 norm1 = normalize( cross( dir1, ortho1));
    vec3 norm2 = normalize( cross( dir2, ortho2));
        
    /////////////////////
    // draw top ribbon //
    /////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 + norm1*scale).xyz, 1.0);
    lighting( normalize( norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 + norm2*scale).xyz, 1.0);
    lighting( normalize( norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 + norm1*scale).xyz, 1.0);
    lighting( normalize( norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 + norm2*scale).xyz, 1.0);
    lighting( normalize( norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
    
    ////////////////////////
    // draw bottom ribbon //
    ////////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 - norm1*scale).xyz, 1.0);
    lighting( normalize(-norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 - norm2*scale).xyz, 1.0);
    lighting( normalize(-norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 - norm1*scale).xyz, 1.0);
    lighting( normalize(-norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 - norm2*scale).xyz, 1.0);
    lighting( normalize(-norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
    
    /////////////////////
    // draw first side //
    /////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
    
    //////////////////////
    // draw second side //
    //////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    EndPrimitive();
    
    if( gl_FrontColorIn[2].y > 0.0 )
    {
        ////////////////
        // draw start //
        ////////////////
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        EndPrimitive();
    }

    if( gl_FrontColorIn[2].z > 0.0 )
    {
        //////////////
        // draw end //
        //////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 + norm1*scale).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 + norm1*scale).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 - norm1*scale).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 - norm1*scale).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        EndPrimitive();
    }
}
-->
        </snippet>
      </shader>
    </namespace>

    <namespace name="spline">
      <shader name="vertex">
        <snippet type="string">
          <!--
/*
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120

void main(void)
{
    gl_FrontColor = gl_Color;
    gl_BackColor = gl_Color;
    gl_FrontSecondaryColor = gl_SecondaryColor;
    gl_BackSecondaryColor = gl_SecondaryColor;
    
    // do not ftransform(), geometry shader needs the original vertices
    gl_Position = gl_Vertex;
}
-->
        </snippet>
      </shader>
      <shader name="fragment">
        <snippet type="string">
          <!--
/*
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120

varying vec3 normal;
varying vec3 color;

void main(void) {
#if 0
    vec3 norm, lightDir;
    vec4 diffuse, ambient, globalAmbient;
    float NdotL;
    
    norm = normalize(gl_NormalMatrix * normal);
    lightDir = normalize(vec3(gl_LightSource[0].position));
    NdotL = max(dot(norm, lightDir), 0.0);
    diffuse = vec4( color, 1.0) * gl_LightSource[0].diffuse;
    
    /* Compute the ambient and globalAmbient terms */
    ambient = vec4( color, 1.0) * gl_LightSource[0].ambient;
    globalAmbient = gl_LightModel.ambient * vec4( color, 1.0);
    gl_FragColor = NdotL * diffuse + globalAmbient + ambient;
#else    
    // normalize the direction of the light
    vec3 lightDir = normalize(vec3(gl_LightSource[0].position));

    // normalize the halfVector to pass it to the fragment shader
    vec3 halfVector = normalize(gl_LightSource[0].halfVector.xyz);
    
    vec4 diffuse, ambient;
    // compute the diffuse, ambient and globalAmbient terms
    diffuse = vec4( color, 1.0) * gl_LightSource[0].diffuse;
    ambient = vec4( color, 1.0) * gl_LightSource[0].ambient;
    ambient += gl_LightModel.ambient * vec4( color, 1.0);
    
    vec3 n;
    float NdotL,NdotHV;
    
    // store the ambient term
    vec4 colorOut = ambient;
    
    // transformation of the normal into eye space
    n = normalize(gl_NormalMatrix * normal);

    // compute the dot product between normal and lightDir
    NdotL = dot(n,lightDir);
    if (NdotL > 0.0) {
		// front side
        colorOut += diffuse * NdotL;
        NdotHV = max(dot(n,halfVector),4.88e-04);
        colorOut += gl_FrontMaterial.specular * gl_LightSource[0].specular * pow(NdotHV, gl_FrontMaterial.shininess);
    }

    gl_FragColor = colorOut;
#endif
    //gl_FragColor = gl_Color;
}
-->
        </snippet>
      </shader>
      <shader name="tubeGeometry">
        <snippet type="string">
          <!--
/* Geometry Shader: Arrow Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable

varying out vec3 normal;
varying out vec3 color;

void compute( vec3 v2, vec3 v3, vec3 dir20, vec3 dir12, vec3 dir32, vec3 dir43, vec3 dir53, float scale, int n)
{
    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));

    // angle for the rotation
    float alpha;
    // matrices for rotation
    mat3 e = mat3( 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
    mat3 m1 = mat3( 0.0,-ortho1.z, ortho1.y, ortho1.z, 0.0,-ortho1.x,-ortho1.y, ortho1.x, 0.0);
    mat3 m2 = mat3( 0.0,-ortho2.z, ortho2.y, ortho2.z, 0.0,-ortho2.x,-ortho2.y, ortho2.x, 0.0);
    mat3 m1quat = m1 * m1;
    mat3 m2quat = m2 * m2;
    
    vec3 res1;
    vec3 res2;
    
    dir1 = dir1 * scale;
    dir2 = dir2 * scale;
    
    for( int i = 0; i < n; i++ )
    {
        alpha = (360.0/float(n))*float(i);
        res1 = ( e + sin( radians( alpha)) * m1 + ( 1.0 - cos( radians( alpha))) * m1quat ) * dir1;
        res2 = ( e + sin( radians( alpha)) * m2 + ( 1.0 - cos( radians( alpha))) * m2quat ) * dir2;
        
        // copy color 
        color = vec3( gl_FrontSecondaryColorIn[0]);
        // copy position 
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + res1).xyz, 1.0);
        // compute lighting
        normal = normalize( res1);
        // done with the vertex 
        EmitVertex();
        
        color = vec3( gl_FrontSecondaryColorIn[0]);
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + res2).xyz, 1.0);
        normal = normalize( res2);
        EmitVertex();
    }
    color = vec3( gl_FrontSecondaryColorIn[0]);
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1).xyz, 1.0);
    normal = normalize( dir1);
    EmitVertex();
    
    color = vec3( gl_FrontSecondaryColorIn[0]);
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2).xyz, 1.0);
    normal = normalize( dir2);
    EmitVertex();
    
    EndPrimitive();
}

void main(void)
{
    // number of segments for the tube
    int numSegTube = 6;
    // number of segments for each curve section
    const int numSeg = 6;
    const float N = float( numSeg);
    // dimension of 'results' and 'directions' MUST be numSeg+1 
    vec3 results[numSeg + 1];
    vec3 directions[numSeg + 1];
    // vertices and directions
    /*
    vec3 v0 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v1 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v2 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v3 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 v4 = vec3(gl_PositionIn[4].xyz) / gl_PositionIn[4].w;
    vec3 v5 = vec3(gl_PositionIn[5].xyz) / gl_PositionIn[5].w;
    vec3 n1 = vec3(gl_FrontColorIn[1].xyz) / gl_FrontColorIn[1].w;
    vec3 n2 = vec3(gl_FrontColorIn[2].xyz) / gl_FrontColorIn[2].w;
    vec3 n3 = vec3(gl_FrontColorIn[3].xyz) / gl_FrontColorIn[3].w;
    vec3 n4 = vec3(gl_FrontColorIn[4].xyz) / gl_FrontColorIn[4].w;
    */
    vec3 v1 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v2 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v3 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v4 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 n1 = vec3(gl_FrontColorIn[0].xyz) / gl_FrontColorIn[0].w;
    vec3 n2 = vec3(gl_FrontColorIn[1].xyz) / gl_FrontColorIn[1].w;
    vec3 n3 = vec3(gl_FrontColorIn[2].xyz) / gl_FrontColorIn[2].w;
    vec3 n4 = vec3(gl_FrontColorIn[3].xyz) / gl_FrontColorIn[3].w;
        
    // assign matrix S
  mat4 S;
    S[0] = vec4( 6.0/(N*N*N), 6.0/(N*N*N), 1.0/(N*N*N), 0.0 );
    S[1] = vec4(         0.0,   2.0/(N*N),   1.0/(N*N), 0.0 );
    S[2] = vec4(                 0.0,         0.0,       1.0/N, 0.0 );
    S[3] = vec4(                 0.0,         0.0,         0.0, 1.0 );
    // assign the basis matrix
  mat4 B;
    B[0] = vec4(-1.0/6.0, 3.0/6.0,-3.0/6.0, 1.0/6.0 );
    B[1] = vec4( 3.0/6.0,-6.0/6.0, 0.0/6.0, 4.0/6.0 );
    B[2] = vec4(-3.0/6.0, 3.0/6.0, 3.0/6.0, 1.0/6.0 );
    B[3] = vec4( 1.0/6.0, 0.0/6.0, 0.0/6.0, 0.0/6.0 );
    
    // assign the geometry matrix
    mat4 G;
    G[0] = vec4( v1.x, v2.x, v3.x, v4.x );
    G[1] = vec4( v1.y, v2.y, v3.y, v4.y );
    G[2] = vec4( v1.z, v2.z, v3.z, v4.z );
    G[3] = vec4( 1.0, 1.0, 1.0, 1.0 );
    // compute the matrix M
    mat4 M = S * ( B * G );
    // start computation of first spline segment 
    results[0] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    for( int k = 0; k < numSeg; k++ )
    {
        M[0].w = M[0].w + M[0].z;
        M[1].w = M[1].w + M[1].z;
        M[2].w = M[2].w + M[2].z;
        M[3].w = M[3].w + M[3].z;
        M[0].z = M[0].z + M[0].y;
        M[1].z = M[1].z + M[1].y;
        M[2].z = M[2].z + M[2].y;
        M[3].z = M[3].z + M[3].y;
        M[0].y = M[0].y + M[0].x;
        M[1].y = M[1].y + M[1].x;
        M[2].y = M[2].y + M[2].x;
        M[3].y = M[3].y + M[3].x;
        
        results[k+1] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    }
    
    G[0] = vec4( n1.x+v1.x, n2.x+v2.x, n3.x+v3.x, n4.x+v4.x );
    G[1] = vec4( n1.y+v1.y, n2.y+v2.y, n3.y+v3.y, n4.y+v4.y );
    G[2] = vec4( n1.z+v1.z, n2.z+v2.z, n3.z+v3.z, n4.z+v4.z );
    // compute the matrix M
    M = S * ( B * G );
    // start computation of second spline segments
    directions[0] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    for( int k = 0; k < numSeg; k++ )
    {
        M[0].w = M[0].w + M[0].z;
        M[1].w = M[1].w + M[1].z;
        M[2].w = M[2].w + M[2].z;
        M[3].w = M[3].w + M[3].z;
        M[0].z = M[0].z + M[0].y;
        M[1].z = M[1].z + M[1].y;
        M[2].z = M[2].z + M[2].y;
        M[3].z = M[3].z + M[3].y;
        M[0].y = M[0].y + M[0].x;
        M[1].y = M[1].y + M[1].x;
        M[2].y = M[2].y + M[2].x;
        M[3].y = M[3].y + M[3].x;
        directions[k+1] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    }
    
    // draw
    vec3 dir20;
    vec3 dir12;
    vec3 dir32;
    vec3 dir43;
    vec3 dir53;
    
    // compute all needed directions
    dir20 = v3 - v1;
    dir12 = directions[0] - results[0];
    dir32 = results[1] - results[0];
    dir43 = directions[1] - results[1];
    dir53 = results[2] - results[1];
    compute( results[0], results[1], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, numSegTube );
    
    for( int i = 0; i < numSeg-2; i++ )
    {
        // compute all needed directions
        dir20 = results[i+1] - results[i+0];
        dir12 = directions[i+1] - results[i+1];
        dir32 = results[i+2] - results[i+1];
        dir43 = directions[i+2] - results[i+2];
        dir53 = results[i+3] - results[i+2];
        compute( results[i+1], results[i+2], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, numSegTube );
    }
    
    // compute all needed directions
    dir20 = results[numSeg-1] - results[numSeg-2];
    dir12 = directions[numSeg-1] - results[numSeg-1];
    dir32 = results[numSeg] - results[numSeg-1];
    dir43 = directions[numSeg] - results[numSeg];
    dir53 = v4 - v2;
    compute( results[numSeg-1], results[numSeg], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, numSegTube );
}
-->
        </snippet>
      </shader>
      <shader name="arrowGeometry">
        <snippet type="string">
          <!--
/* Geometry Shader: Arrow Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable

varying out vec3 normal;
varying out vec3 color;

void compute( vec3 v2, vec3 v3, vec3 dir20, vec3 dir12, vec3 dir32, vec3 dir43, vec3 dir53, float scale, float stretch1, float stretch2)
{
    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));

    dir1 = normalize( cross( dir1, ortho1))*stretch1;
    dir2 = normalize( cross( dir2, ortho2))*stretch2;
    
    vec3 norm1 = normalize( cross( dir1, ortho1));
    vec3 norm2 = normalize( cross( dir2, ortho2));
    
    /////////////////////
    // draw top ribbon //
    /////////////////////
    color = vec3( gl_FrontSecondaryColorIn[0]);
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
    normal = norm1;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
    normal = norm2;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
    EmitVertex();
    
    EndPrimitive();
    
    ////////////////////////
    // draw bottom ribbon //
    ////////////////////////
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
    normal = -norm1;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
    normal = -norm2;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
    EmitVertex();
    
    EndPrimitive();
    
    /////////////////////
    // draw first side //
    /////////////////////
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
    normal = dir1;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
    normal = dir2;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
    EmitVertex();
    
    EndPrimitive();
    
    //////////////////////
    // draw second side //
    //////////////////////
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
    normal = -dir1;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
    normal = -dir2;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
    EmitVertex();
    
    EndPrimitive();
}

void main(void)
{
    // number of segments for each curve section
    const int numSeg = 6;
    const float N = float( numSeg);
    // dimension of 'results' and 'directions' MUST be numSeg+1 
    vec3 results[numSeg + 1];
    vec3 directions[numSeg + 1];
    // vertices and directions
    // vertices and directions
    vec3 v1 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v2 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v3 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v4 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 n1 = vec3(gl_FrontColorIn[0].xyz) / gl_FrontColorIn[0].w;
    vec3 n2 = vec3(gl_FrontColorIn[1].xyz) / gl_FrontColorIn[1].w;
    vec3 n3 = vec3(gl_FrontColorIn[2].xyz) / gl_FrontColorIn[2].w;
    vec3 n4 = vec3(gl_FrontColorIn[3].xyz) / gl_FrontColorIn[3].w;
        
    // assign matrix S
  mat4 S;
    S[0] = vec4( 6.0/(N*N*N), 6.0/(N*N*N), 1.0/(N*N*N), 0.0 );
    S[1] = vec4(         0.0,   2.0/(N*N),   1.0/(N*N), 0.0 );
    S[2] = vec4(                 0.0,         0.0,       1.0/N, 0.0 );
    S[3] = vec4(                 0.0,         0.0,         0.0, 1.0 );
    // assign the basis matrix
  mat4 B;
    B[0] = vec4(-1.0/6.0, 3.0/6.0,-3.0/6.0, 1.0/6.0 );
    B[1] = vec4( 3.0/6.0,-6.0/6.0, 0.0/6.0, 4.0/6.0 );
    B[2] = vec4(-3.0/6.0, 3.0/6.0, 3.0/6.0, 1.0/6.0 );
    B[3] = vec4( 1.0/6.0, 0.0/6.0, 0.0/6.0, 0.0/6.0 );
    
    // assign the geometry matrix
    mat4 G;
    G[0] = vec4( v1.x, v2.x, v3.x, v4.x );
    G[1] = vec4( v1.y, v2.y, v3.y, v4.y );
    G[2] = vec4( v1.z, v2.z, v3.z, v4.z );
    G[3] = vec4( 1.0, 1.0, 1.0, 1.0 );
    // compute the matrix M
    mat4 M = S * ( B * G );
    // start computation of first spline segment 
    results[0] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    for( int k = 0; k < numSeg; k++ )
    {
        M[0].w = M[0].w + M[0].z;
        M[1].w = M[1].w + M[1].z;
        M[2].w = M[2].w + M[2].z;
        M[3].w = M[3].w + M[3].z;
        M[0].z = M[0].z + M[0].y;
        M[1].z = M[1].z + M[1].y;
        M[2].z = M[2].z + M[2].y;
        M[3].z = M[3].z + M[3].y;
        M[0].y = M[0].y + M[0].x;
        M[1].y = M[1].y + M[1].x;
        M[2].y = M[2].y + M[2].x;
        M[3].y = M[3].y + M[3].x;
        
        results[k+1] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    }
    
    mat4 G1;
    G1[0] = vec4( n1.x+v1.x, n2.x+v2.x, n3.x+v3.x, n4.x+v4.x );
    G1[1] = vec4( n1.y+v1.y, n2.y+v2.y, n3.y+v3.y, n4.y+v4.y );
    G1[2] = vec4( n1.z+v1.z, n2.z+v2.z, n3.z+v3.z, n4.z+v4.z );
    G1[3] = vec4( 1.0, 1.0, 1.0, 1.0 );

    // compute the matrix M
    mat4 M1 = S * ( B * G1 );
    // start computation of second spline segments
    directions[0] = vec3( M1[0][3]/M1[3][3], M1[1][3]/M1[3][3], M1[2][3]/M1[3][3]);
    for( int k = 0; k < numSeg; k++ )
    {
        M1[0].w = M1[0].w + M1[0].z;
        M1[1].w = M1[1].w + M1[1].z;
        M1[2].w = M1[2].w + M1[2].z;
        M1[3].w = M1[3].w + M1[3].z;
        M1[0].z = M1[0].z + M1[0].y;
        M1[1].z = M1[1].z + M1[1].y;
        M1[2].z = M1[2].z + M1[2].y;
        M1[3].z = M1[3].z + M1[3].y;
        M1[0].y = M1[0].y + M1[0].x;
        M1[1].y = M1[1].y + M1[1].x;
        M1[2].y = M1[2].y + M1[2].x;
        M1[3].y = M1[3].y + M1[3].x;
        
        directions[k+1] = vec3( M1[0][3]/M1[3][3], M1[1][3]/M1[3][3], M1[2][3]/M1[3][3]);
    }
    
    // draw
    vec3 dir20;
    vec3 dir12;
    vec3 dir32;
    vec3 dir43;
    vec3 dir53;
    
    float factor = ( gl_FrontSecondaryColorIn[1].y / N ) * gl_FrontSecondaryColorIn[1].z;
    float f2;
    float f1 = gl_FrontSecondaryColorIn[1].y + factor;
    
    f2 = f1;
    f1 = f1 - factor;    
    // compute all needed directions
    dir20 = v3 - v1;
    dir12 = directions[0] - results[0];
    dir32 = results[1] - results[0];
    dir43 = directions[1] - results[1];
    dir53 = results[2] - results[1];
    compute( results[0], results[1], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, f2, f1 );
    
    for( int i = 0; i < numSeg-2; i++ )
    {
        f2 = f1;
        f1 = f1 - factor;
        // compute all needed directions
        dir20 = results[i+1] - results[i+0];
        dir12 = directions[i+1] - results[i+1];
        dir32 = results[i+2] - results[i+1];
        dir43 = directions[i+2] - results[i+2];
        dir53 = results[i+3] - results[i+2];
        compute( results[i+1], results[i+2], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, f2, f1 );
    }
    
    f2 = f1;
    f1 = f1 - factor;
    // compute all needed directions
    dir20 = results[numSeg-1] - results[numSeg-2];
    dir12 = directions[numSeg-1] - results[numSeg-1];
    dir32 = results[numSeg] - results[numSeg-1];
    dir43 = directions[numSeg] - results[numSeg];
    dir53 = v4 - v2;
    compute( results[numSeg-1], results[numSeg], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, f2, f1 );
}
-->
        </snippet>
      </shader>
      <shader name="helixGeometry">
        <snippet type="string">
          <!--
/* Geometry Shader: Arrow Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable

varying out vec3 normal;
varying out vec3 color;


void compute( vec3 v2, vec3 v3, vec3 dir20, vec3 dir12, vec3 dir32, vec3 dir43, vec3 dir53, float scale, float stretch1)
{
    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));
    
    dir1 = normalize( cross( dir1, ortho1))*stretch1;
    dir2 = normalize( cross( dir2, ortho2))*stretch1;
    
    vec3 norm1 = normalize( cross( dir1, ortho1));
    vec3 norm2 = normalize( cross( dir2, ortho2));
    
    /////////////////////
    // draw top ribbon //
    /////////////////////
    color = vec3( gl_FrontSecondaryColorIn[0]);
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
    normal = norm1;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
    normal = norm2;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
    EmitVertex();
    
    EndPrimitive();
    
    ////////////////////////
    // draw bottom ribbon //
    ////////////////////////
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
    normal =  -norm1;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
    normal = -norm2;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
    EmitVertex();
    
    EndPrimitive();
    
    /////////////////////
    // draw first side //
    /////////////////////
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
    normal = dir1;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
    normal = dir2;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
    EmitVertex();
    
    EndPrimitive();
    
    //////////////////////
    // draw second side //
    //////////////////////
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
    normal = -dir1;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
    normal = -dir2;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
    EmitVertex();
    
    EndPrimitive();
}

void main(void)
{
    // number of segments for each curve section
    const int numSeg = 6;
    const float N = float( numSeg);
    // dimension of 'results' and 'directions' MUST be numSeg+1 
    vec3 results[numSeg + 1];
    vec3 directions[numSeg + 1];
    // vertices and directions
    vec3 v1 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v2 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v3 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v4 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 n1 = vec3(gl_FrontColorIn[0].xyz) / gl_FrontColorIn[0].w;
    vec3 n2 = vec3(gl_FrontColorIn[1].xyz) / gl_FrontColorIn[1].w;
    vec3 n3 = vec3(gl_FrontColorIn[2].xyz) / gl_FrontColorIn[2].w;
    vec3 n4 = vec3(gl_FrontColorIn[3].xyz) / gl_FrontColorIn[3].w;
        
    // assign matrix S
  mat4 S;
    S[0] = vec4( 6.0/(N*N*N), 6.0/(N*N*N), 1.0/(N*N*N), 0.0 );
    S[1] = vec4(         0.0,   2.0/(N*N),   1.0/(N*N), 0.0 );
    S[2] = vec4(                 0.0,         0.0,       1.0/N, 0.0 );
    S[3] = vec4(                 0.0,         0.0,         0.0, 1.0 );
    // assign the basis matrix
  mat4 B;
    B[0] = vec4(-1.0/6.0, 3.0/6.0,-3.0/6.0, 1.0/6.0 );
    B[1] = vec4( 3.0/6.0,-6.0/6.0, 0.0/6.0, 4.0/6.0 );
    B[2] = vec4(-3.0/6.0, 3.0/6.0, 3.0/6.0, 1.0/6.0 );
    B[3] = vec4( 1.0/6.0, 0.0/6.0, 0.0/6.0, 0.0/6.0 );
    
    // assign the geometry matrix
    mat4 G;
    G[0] = vec4( v1.x, v2.x, v3.x, v4.x );
    G[1] = vec4( v1.y, v2.y, v3.y, v4.y );
    G[2] = vec4( v1.z, v2.z, v3.z, v4.z );
    G[3] = vec4( 1.0, 1.0, 1.0, 1.0 );
    // compute the matrix M
    mat4 M = S * ( B * G );
    // start computation of first spline segment 
    results[0] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    for( int k = 0; k < numSeg; k++ )
    {
        M[0].w = M[0].w + M[0].z;
        M[1].w = M[1].w + M[1].z;
        M[2].w = M[2].w + M[2].z;
        M[3].w = M[3].w + M[3].z;
        M[0].z = M[0].z + M[0].y;
        M[1].z = M[1].z + M[1].y;
        M[2].z = M[2].z + M[2].y;
        M[3].z = M[3].z + M[3].y;
        M[0].y = M[0].y + M[0].x;
        M[1].y = M[1].y + M[1].x;
        M[2].y = M[2].y + M[2].x;
        M[3].y = M[3].y + M[3].x;
        
        results[k+1] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    }
    
    G[0] = vec4( n1.x+v1.x, n2.x+v2.x, n3.x+v3.x, n4.x+v4.x );
    G[1] = vec4( n1.y+v1.y, n2.y+v2.y, n3.y+v3.y, n4.y+v4.y );
    G[2] = vec4( n1.z+v1.z, n2.z+v2.z, n3.z+v3.z, n4.z+v4.z );
    // compute the matrix M
    M = S * ( B * G );
    // start computation of second spline segments
    directions[0] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    for( int k = 0; k < numSeg; k++ )
    {
        M[0].w = M[0].w + M[0].z;
        M[1].w = M[1].w + M[1].z;
        M[2].w = M[2].w + M[2].z;
        M[3].w = M[3].w + M[3].z;
        M[0].z = M[0].z + M[0].y;
        M[1].z = M[1].z + M[1].y;
        M[2].z = M[2].z + M[2].y;
        M[3].z = M[3].z + M[3].y;
        M[0].y = M[0].y + M[0].x;
        M[1].y = M[1].y + M[1].x;
        M[2].y = M[2].y + M[2].x;
        M[3].y = M[3].y + M[3].x;
        directions[k+1] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    }
    
    // draw
    vec3 dir20;
    vec3 dir12;
    vec3 dir32;
    vec3 dir43;
    vec3 dir53;
    
    // compute all needed directions
    dir20 = v3 - v1;
    dir12 = directions[0] - results[0];
    dir32 = results[1] - results[0];
    dir43 = directions[1] - results[1];
    dir53 = results[2] - results[1];
    compute( results[0], results[1], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, gl_FrontSecondaryColorIn[1].y );
    
    for( int i = 0; i < numSeg-2; i++ )
    {
        // compute all needed directions
        dir20 = results[i+1] - results[i+0];
        dir12 = directions[i+1] - results[i+1];
        dir32 = results[i+2] - results[i+1];
        dir43 = directions[i+2] - results[i+2];
        dir53 = results[i+3] - results[i+2];
        compute( results[i+1], results[i+2], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, gl_FrontSecondaryColorIn[1].y );
    }
    
    // compute all needed directions
    dir20 = results[numSeg-1] - results[numSeg-2];
    dir12 = directions[numSeg-1] - results[numSeg-1];
    dir32 = results[numSeg] - results[numSeg-1];
    dir43 = directions[numSeg] - results[numSeg];
    dir53 = v4 - v2;
    compute( results[numSeg-1], results[numSeg], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, gl_FrontSecondaryColorIn[1].y );
}
-->
        </snippet>
      </shader>
    </namespace>

    <namespace name="perpixellight">
      <shader name="vertex">
        <snippet type="string">
          <!--
varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;

void main()
{    
    // transformation of the normal into eye space
    normal = normalize(gl_NormalMatrix * gl_Normal);
    
    // normalize the direction of the light
    lightDir = normalize(vec3(gl_LightSource[0].position));

    // normalize the halfVector to pass it to the fragment shader
    halfVector = normalize(gl_LightSource[0].halfVector.xyz);
                
    // compute the diffuse, ambient and globalAmbient terms
    //diffuse = gl_FrontMaterial.diffuse * gl_LightSource[0].diffuse;
    //ambient = gl_FrontMaterial.ambient * gl_LightSource[0].ambient;
    //ambient += gl_LightModel.ambient * gl_FrontMaterial.ambient;
    diffuse = gl_Color * gl_LightSource[0].diffuse;
    ambient = gl_Color * gl_LightSource[0].ambient;
    ambient += gl_LightModel.ambient * gl_Color;

    gl_Position = ftransform();
}
-->
        </snippet>
      </shader>

        <shader name="vertexOR">
            <snippet type="string">
<!--
varying vec4 color;
varying vec3 normal;

void main() {
normal = normalize(gl_NormalMatrix * gl_Normal);
color = gl_Color;
gl_Position = ftransform();
}
-->
            </snippet>
        </shader>
	
      <shader name="fragment">
        <snippet type="string">
          <!--
varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;

uniform float alpha = 1.0;

void main()
{
    vec3 n,halfV;
    float NdotL,NdotHV;
    
    // store the ambient term
    vec4 color = ambient;
    
    // store the normalized interpolated normal
    n = normalize(normal);

    // compute the dot product between normal and lightDir
    NdotL = max(dot(n,lightDir),0.0);
    if (NdotL > 0.0)
    {
        color += diffuse * NdotL;
        halfV = normalize(halfVector);
        NdotHV = max(dot(n,halfV),0.0);
        color += gl_FrontMaterial.specular * gl_LightSource[0].specular * pow(NdotHV, gl_FrontMaterial.shininess);
    }

    gl_FragColor = vec4(color.rgb, alpha);
}
-->
        </snippet>
      </shader>
	  
        <shader name="fragmentOR">
            <snippet type="string">
<!--
uniform vec2 zValues;
varying vec4 color;
varying vec3 normal;
uniform float alpha = 1.0;

void main() {
	gl_FragData[0] = vec4(color.rgb, alpha);
	gl_FragData[1].rgb = normalize( normal);
  
    float n = zValues.x;
    float f = zValues.y;
    float depthES;
    
    // Unproject depth and switch sign -> positive eye space depth
    depthES = 2.0*n*f/(f+n-gl_FragCoord.z*(f-n));
    // Map near ... far to 0 ... 1
    depthES = (depthES - n)/(f-n);
    
    gl_FragDepth = depthES;
}
-->
            </snippet>
        </shader>
    </namespace>
  </namespace>

  <namespace name="ses">
    <snippet name="rootsolver" type="string">
      <!--
// global constants
float doubtol = 0.00000001;      // min
float doubmin = 0.0;             // zero
float doubmax = 1000000000.0;    // max (inf)

// function prototypes
float acos3( float x);
float cubic( float p, float q, float r);
float curoot( float x);
void computeConstants();
int ferrari( float a, float b, float c, float d, out vec4 rts);
int neumark( float a, float b, float c, float d, out vec4 rts);
int quadratic( float b, float c, out vec4 rts, float dis);


/**
*    Solve quartic equation using either quadratic, Ferrari's or Neumark's algorithm.
*
*    input:
*        a, b, c, d - coefficients of equation.
*    output:
*        [return nquar] - number of real roots.
*        rts - array of root values.
*
*    calls:
*        quadratic, ferrari, neumark.
*/
int quartic( float a, float b, float c, float d, out vec4 rts)
{
    int j, k, nq, nr;
    float odd, even;
    vec4 roots;

    if( a < 0.0 )
        odd = -a;
    else
        odd = a;
    if( c < 0.0 )
        odd -= c;
    else
        odd += c;
    if( b < 0.0 )
        even = -b;
    else
        even = b;
    if( d < 0.0 )
        even -= d;
    else
        even += d;
    
    if( odd < even*doubtol )
    {
        nq = quadratic( b, d, roots, b*b-4.0*d);
        j = 0;
        if( nq == 1 )
        {
            if( roots.x > 0.0 )
            {
                rts.x = sqrt( roots.x);
                rts.y = -rts.x;
                ++j; ++j;
            }
        }
        else if( nq == 2 )
        {
            if( roots.x > 0.0 )
            {
                rts.x = sqrt( roots.x);
                rts.y = -rts.x;
                ++j; ++j;
            }
            if( roots.y > 0.0 )
            {
                rts.z = sqrt( roots.y);
                rts.w = -rts.z;
                ++j; ++j;
            }
        }
        nr = j;
    }
    else
    {
        if( a < 0.0 )
            k = 1;
        else
            k = 0;
        if( b < 0.0 )
            k += k+1;
        else
            k +=k; 
        if( c < 0.0 )
            k += k+1;
        else
            k +=k; 
        if( d < 0.0 )
            k += k+1;
        else
            k +=k; 
        
        if( k == 0 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 1 ) nr = neumark( a, b, c, d, rts);
        else if( k == 2 ) nr = neumark( a, b, c, d, rts);
        else if( k == 3 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 4 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 5 ) nr = neumark( a, b, c, d, rts);
        else if( k == 6 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 7 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 8 ) nr = neumark( a, b, c, d, rts);
        else if( k == 9 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 10 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 11 ) nr = neumark( a, b, c, d, rts);
        else if( k == 12 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 13 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 14 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 15 ) nr = ferrari( a, b, c, d, rts);
    }
    return nr;
} // ===== quartic =====

/**
*    compute constant values
*/
void computeConstants()
{
    int j;
    doubtol = 1.0;
    for( j = 1; 1.0+doubtol > 1.0; ++j )
    {
        doubtol *= 0.5;
    }
    doubtol = sqrt( doubtol);
    
    doubmin = 0.5;
    for( j = 1; j <= 100; ++j )
    {
        doubmin = doubmin*doubmin;
        if( (doubmin*doubmin) <= (doubmin*doubmin*0.5) )
            break;
    }
    doubmax = 0.7/sqrt( doubmin);
} // ===== setconstants =====

/**
*    solve the quartic equation
*        x**4 + a*x**3 + b*x**2 + c*x + d = 0
*
*    input:
*        a, b, c, d - coefficients of equation.
*    output:
*        [return nquar] - number of real roots.
*        rts - array of root values.
*
*    calls:
*        cubic
*        quadratic
*/
int ferrari( float a, float b, float c, float d, out vec4 rts)
{
    rts = vec4( 0.0, 0.0, 0.0, 0.0);
    
    int nquar, n1, n2;
    float asq, ainv2;
    vec4 v1, v2;
    float p, q, r;
    float y;
    float e, f, esq, fsq, ef;
    float g, gg, h, hh;

    asq = a*a;

    p = b;
    q = a * c - 4.0 * d;
    r = ( asq - 4.0 * b) * d + c*c;
    y = cubic( p, q, r);

    esq = 0.25 * asq - b - y;
    if( esq < 0.0 )
        return(0);
    else
    {
        fsq = 0.25*y*y - d;
        if( fsq < 0.0 )
            return 0;
        else
        {
            ef = -(0.25*a*y + 0.5*c);
            if( ((a > 0.0) && (y > 0.0) && (c > 0.0))
                || ((a > 0.0) && (y < 0.0) && (c < 0.0))
                || ((a < 0.0) && (y > 0.0) && (c < 0.0))
                || ((a < 0.0) && (y < 0.0) && (c > 0.0))
                ||  (a == 0.0) || (y == 0.0) || (c == 0.0) )
            // use ef
            {
                if( (b < 0.0) && (y < 0.0) && (esq > 0.0) )
                {
                    e = sqrt( esq);
                    f = ef/e;
                }
                else if( (d < 0.0) && (fsq > 0.0) )
                {
                    f = sqrt( fsq);
                    e = ef/f;
                }
                else
                {
                    e = sqrt( esq);
                    f = sqrt( fsq);
                    if( ef < 0.0 ) f = -f;
                }
            }
            else
            {
                e = sqrt( esq);
                f = sqrt( fsq);
                if( ef < 0.0 ) f = -f;
            }
            // note that e >= 0.0
            ainv2 = a*0.5;
            g = ainv2 - e;
            gg = ainv2 + e;
            if( ((b > 0.0) && (y > 0.0))
                || ((b < 0.0) && (y < 0.0)) )
            {
                if( ( a > 0.0) && (e != 0.0) )
                    g = (b + y)/gg;
                else if( e != 0.0 )
                    gg = (b + y)/g;
            }
            if( (y == 0.0) && (f == 0.0) )
            {
                h = 0.0;
                hh = 0.0;
            }
            else if( ((f > 0.0) && (y < 0.0))
                || ((f < 0.0) && (y > 0.0)) )
            {
                hh = -0.5*y + f;
                h = d/hh;
            }
            else
            {
                h = -0.5*y - f;
                hh = d/h;
            }
            n1 = quadratic( gg, hh, v1, gg*gg - 4.0 * hh);
            n2 = quadratic( g, h, v2, g*g - 4.0 * h);
            nquar = n1 + n2;
            rts.x = v1.x;
            rts.y = v1.y;
            if( n1 == 0 )
            {
                rts.x = v2.x;
                rts.y = v2.y;
            }
            else
            {
                rts.z = v2.x;
                rts.w = v2.y;
            }
            return nquar;
        }
    }
} // ===== ferrari =====


/**
*    solve the quartic equation
*        x**4 + a*x**3 + b*x**2 + c*x + d = 0
*
*    input:
*        a, b, c, e - coefficients of equation.
*
*    output:
*        [return nquar] - number of real roots.
*        rts - array of root values.
*
*     calls:
*        cubic
*        quadratic
*/
int neumark( float a, float b, float c, float d, out vec4 rts)
{
    int nquar, n1, n2;
    float y, g, gg, h, hh, gdis, gdisrt, hdis, hdisrt, g1, g2, h1, h2;
    float bmy, gerr, herr, y4, d4, bmysq;
    vec4 v1, v2;
    float asq;
    float p,q,r;
    float hmax,gmax;

    asq = a*a ;

    p = -b*2.0;
    q = b*b + a*c - 4.0*d;
    r = (c - a*b)*c + asq*d;
    y = cubic( p, q, r);

    bmy = b - y;
    y4 = y*4.0;
    d4 = d*4.0;
    bmysq = bmy*bmy ;
    gdis = asq - y4 ;
    hdis = bmysq - d4 ;
    if( (gdis < 0.0) || (hdis < 0.0) )
        return 0;
    else
    {
        g1 = a*0.5;
        h1 = bmy*0.5;
        gerr = asq + y4;
        herr = hdis;
        if( d > 0.0 )
            herr = bmysq + d4;
        if( (y < 0.0) || (herr*gdis > gerr*hdis) )
        {
            gdisrt = sqrt(gdis);
            g2 = gdisrt*0.5;
            if( gdisrt != 0.0 )
                h2 = (a*h1 - c)/gdisrt;
            else
                h2 = 0.0;
        }
        else
        {
            hdisrt = sqrt(hdis);
            h2 = hdisrt*0.5;
            if( hdisrt != 0.0 )
                g2 = (a*h1 - c)/hdisrt;
            else
                g2 = 0.0;
        } 
        //note that in the following, the tests ensure non-zero denominators
        h = h1 - h2 ;
        hh = h1 + h2 ;
        hmax = hh ;
        if( hmax < 0.0 ) hmax = -hmax;
        if( hmax < h ) hmax = h;
        if( hmax < -h ) hmax = -h;
        if( (h1 > 0.0 ) && (h2 > 0.0)) h = d/hh;
        if( (h1 < 0.0 ) && (h2 < 0.0)) h = d/hh;
        if( (h1 > 0.0 ) && (h2 < 0.0)) hh = d/h;
        if( (h1 < 0.0 ) && (h2 > 0.0)) hh = d/h;
        if( h > hmax ) h = hmax;
        if( h < -hmax ) h = -hmax;
        if( hh > hmax ) hh = hmax;
        if( hh < -hmax ) hh = -hmax;

        g = g1 - g2;
        gg = g1 + g2;
        gmax = gg;
        if( gmax < 0.0 ) gmax = -gmax;
        if( gmax < g ) gmax = g;
        if( gmax <  -g ) gmax = -g;
        if( (g1 > 0.0) && (g2 > 0.0) ) g = y/gg;
        if( (g1 < 0.0) && (g2 < 0.0) ) g = y/gg;
        if( (g1 > 0.0) && (g2 < 0.0) ) gg = y/g;
        if( (g1 < 0.0) && (g2 > 0.0) ) gg = y/g;
        if( g > gmax ) g = gmax;
        if( g <  -gmax ) g = -gmax;
        if( gg > gmax ) gg = gmax;
        if( gg <  -gmax ) gg = -gmax;

        n1 = quadratic( gg, hh, v1, gg*gg - 4.0*hh);
        n2 = quadratic( g, h, v2, g*g - 4.0*h);
        nquar = n1+n2;
        rts.x = v1.x;
        rts.x = v1.y;
        if( n1 == 0 )
        {
            rts.x = v2.x;
            rts.y = v2.y;
        }
        else
        {
            rts.z = v2.x;
            rts.w = v2.y;
        }

        return nquar;
    }
} // ===== neumark =====


/**
*    solve the quadratic equation
*        x**2+b*x+c = 0
*
*    input:
*        b, c - coefficients of equation.
*    output:
*        [return nquad] - number of real roots.
*        rts - array of root values.+
*        
*    called by:
*        ferrari
*        neumark
*/
int quadratic( float b, float c, out vec4 rts, float dis)
{
    int nquad;
    float rtdis;

    if( dis >= 0.0 )
    {
        nquad = 2;
        rtdis = sqrt( dis) ;
        if( b > 0.0 )
            rts.x = ( -b - rtdis) * 0.5;
        else
            rts.x = ( -b + rtdis) * 0.5;
        if( rts.x == 0.0 )
            rts.y = -b;
        else
            rts.y = c/rts.x;
    }
    else
    {
        nquad = 0;
        rts.x = 0.0;
        rts.y = 0.0;
    }
    return nquad;
} // ===== quadratic =====


/**
*    find the lowest real root of the cubic equation
*        x**3 + p*x**2 + q*x + r = 0 
*
*    input parameters:
*        p, q, r - coefficients of cubic equation. 
*    output:
*        cubic - a real root.
*
*    calls:
*        acos3
*        curoot
*    called by:
*        ferrari
*        neumark
*/
float cubic( float p, float q, float r)
{    
    int nrts;
    float po3, po3sq, qo3;
    float uo3, u2o3, uo3sq4, uo3cu4;
    float v, vsq, wsq;
    float m, mcube, n;
    float muo3, s, scube, t, cosk, sinsqk;
    float root;

    m = 0.0;
    nrts = 0;
    if( (p > doubmax) || (p <  -doubmax) )
        root = -p;
    else
    {
        if( (q > doubmax) || (q <  -doubmax) )
        {
            if (q > 0.0)
                root = -r/q;
            else
                root = -sqrt( -q);
        }
        else
        {
            if( (r > doubmax) || (r <  -doubmax) )
                root = -curoot( r);
            else
            {
                po3 = p * (1.0/3.0);
                po3sq = po3*po3 ;
                if( po3sq > doubmax )
                    root = -p;
                else
                {
                    v = r + po3*(po3sq + po3sq - q) ;
                    if( (v > doubmax) || (v < -doubmax) )
                        root = -p;
                    else
                    {
                        vsq = v*v ;
                        qo3 = q * (1.0/3.0);
                        uo3 = qo3 - po3sq ;
                        u2o3 = uo3 + uo3 ;
                        if( (u2o3 > doubmax) || (u2o3 < -doubmax) )
                        {
                            if (p == 0.0)
                            {
                                if (q > 0.0)
                                    root = -r/q;
                                else
                                    root = -sqrt( -q);
                            }
                            else
                                root = -q/p;
                        }
                        uo3sq4 = u2o3 * u2o3 ;
                        if( uo3sq4 > doubmax)
                        {
                            if (p == 0.0)
                            {
                                if( q > 0.0 )
                                    root = -r/q;
                                else
                                    root = -sqrt( abs( q));
                            }
                            else
                                root = -q/p;
                        }
                        uo3cu4 = uo3sq4 * uo3;
                        wsq = uo3cu4 + vsq;
                        if( wsq >= 0.0 )
                        {
                            // cubic has one real root
                            nrts = 1;
                            if( v <= 0.0 )
                                mcube = ( -v + sqrt( wsq))*0.5;
                            if( v  > 0.0 )
                                mcube = ( -v - sqrt( wsq))*0.5;
                            m = curoot( mcube);
                            if( m != 0.0 )
                                n = -uo3/m;
                            else
                                n = 0.0;
                            root = m + n - po3;
                        }
                        else
                        {
                            nrts = 3;
                            // cubic has three real roots
                            if( uo3 < 0.0 )
                            {
                                muo3 = -uo3;
                                s = sqrt( muo3);
                                scube = s*muo3;
                                t =  -v/(scube+scube);
                                cosk = acos3( t);
                                if( po3 < 0.0 )
                                    root = (s+s)*cosk - po3;
                                else
                                {
                                    sinsqk = 1.0 - cosk*cosk;
                                    if( sinsqk < 0.0 )
                                        sinsqk = 0.0;
                                    root = s*( -cosk - sqrt( 3.0)*sqrt( sinsqk)) - po3;
                                }
                            }
                            else
                                // cubic has multiple root
                                root = curoot( v) - po3;
                        }
                    }
                }
            }
        }
    }
    return root;
} // ===== cubic =====


/** 
*    find cube root of x.
*
*    called by:
*        cubic 
*/
float curoot( float x)
{
    float value;
    float absx;
    int neg;

    neg = 0;
    absx = x;
    if( x < 0.0 )
    {
        absx = -x;
        neg = 1;
    }
    value = exp( log( absx)*(1.0/3.0));
    if( neg == 1 )
        value = -value;
    return value;
} // ===== curoot =====


/** 
* find cos(acos(x)/3) 
*
* called by:
*    cubic 
*/
float acos3( float x)
{
    return cos( acos( x)*(1.0/3.0));
} // ===== acos3 =====


/**
*    solve the quartic equation
*        x**4 + a*x**3 + b*x**2 + c*x + d = 0
*
*    input:
*        a, b, c, d - coefficients of equation.
*    output:
*        [return nquar] - number of real roots.
*        rts - array of root values.
*
*    calls:
*        cubic
*        quadratic
*/
int simpleFerrari( float a, float b, float c, float d, out vec4 rts)
{
    int nquar, n1, n2;
    float asq, y;
    vec4 v1, v2;
    float p, q, r;
    float e, f, esq, fsq;
    float g, gg, h, hh;

    asq = a*a;

    p = -b;
    q = a*c-4.0*d;
    r = -asq*d - c*c + 4.0*b*d;
    y = cubic( p, q, r);

    esq = 0.25*asq - b + y;
    fsq = 0.25*y*y - d;
    if( esq < 0.0 )
        return 0;
    else
    {
        if( fsq < 0.0 )
            return 0;
        else
        {
            e = sqrt( esq);
            f = sqrt( fsq);
            g = 0.5*a - e;
            h = 0.5*y - f;
            gg = 0.5*a + e;
            hh = 0.5*y + f;
            n1 = quadratic( gg, hh, v1, gg*gg - 4.0*hh) ;
            n2 = quadratic( g, h, v2, g*g - 4.0*h) ;
            nquar = n1 + n2;
            rts.x = v1.x;
            rts.y = v1.y;
            if( n1 == 0 )
            {
                rts.x = v2.x;
                rts.y = v2.y;
            }
            else
            {
                rts.z = v2.x;
                rts.w = v2.y;
            }
            return nquar;
        }
    }
} // ===== simple =====


/**
*    solve the quartic equation
*        x**4 + a*x**3 + b*x**2 + c*x + d = 0
*
*    input:
*        a, b, c, d - coefficients of equation.
*    output:
*        [return nquar] - number of real roots.
*        rts - array of root values.
*
*    calls:
*        cubic
*        quadratic
*/
int descartes( float a, float b, float c, float d, out vec4 rts)
{
    int nrts;
    int r1,r2;
    vec4 v1, v2;
    float y;
    float p,q,r;
    float A,B,C;
    float m,n1,n2;
    float d3o8,d3o256;
    float inv8,inv16;
    float asq;
    float Binvm;

    d3o8 = 3.0/8.0;
    inv8 = 1.0/8.0;
    inv16 = 1.0/16.0;
    d3o256 = 3.0/256.0;

    asq = a*a;

    A = b - asq*d3o8;
    B = c + a*(asq*inv8 - b*0.5);
    C = d + asq*(b*inv16 - asq*d3o256) - a*c*0.25;

    p = 2.0*A;
    q = A*A - 4.0*C;
    r = -B*B;

    y = cubic( p, q, r) ;
    if( y <= 0.0 ) 
        nrts = 0;
    else
    {
        m = sqrt( y);
        Binvm = B/m;
        n1 = ( y + A + Binvm)*0.5;
        n2 = ( y + A - Binvm)*0.5;
        r1 = quadratic(-m, n1, v1, y-4.0*n1);
        r2 = quadratic( m, n2, v2, y-4.0*n2);
        rts.x = v1.x-a*0.25;
        rts.y = v1.y-a*0.25;
        if( r1 == 0 )
        {
            rts.x = v2.x-a*0.25;
            rts.y = v2.y-a*0.25;
        }
        else
        {
            rts.z = v2.x-a*0.25;
            rts.w = v2.y-a*0.25;
        }
        nrts = r1+r2;
    } 
    return nrts;
} // ===== descartes =====
-->
    </snippet>

    <snippet name="decodecolor" type="string">
      <!--

vec3 decodeColor( float codedColor)
{
    float col = codedColor;
    float red, green;
    if( col >= 1000000.0 )
        red = floor( col / 1000000.0);
    else
        red = 0.0;
    col = col - ( red * 1000000.0);
    if( col >= 1000.0)
        green = floor( col / 1000.0);
    else
        green = 0.0;
    col = col - ( green * 1000.0);
    if( col > 256.0 )
        col = 0.0;
    return vec3( red / 255.0, green / 255.0, col / 255.0 );
}

-->
    </snippet>

    <snippet name="dot1" type="string">
      <!--

float dot1( vec3 v1)
{
    return dot( v1, v1);
}

-->
    </snippet>

    <shader name="sphereVertex">
      <snippet type="version">120</snippet>
      <snippet name="commondefines"/>
      <snippet type="string">
        <!--
uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)
uniform vec3 zValues;
uniform vec3 fogCol;

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying float squarRad;
varying float rad;

#ifdef RETICLE
varying vec2 centerFragment;
#endif // RETICLE

void main(void) {

    // remove the sphere radius from the w coordinates to the rad varyings
    vec4 inPos = gl_Vertex;
    rad = inPos.w;
    squarRad = rad * rad;
    inPos.w = 1.0;

    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)

    // calculate cam position
    camPos = gl_ModelViewMatrixInverse[3]; // (C) by Christoph
    camPos.xyz -= objPos.xyz; // cam pos to glyph space

    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = gl_ModelViewMatrixInverse * gl_LightSource[0].position - objPos;
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    lightPos = gl_ModelViewMatrixInverse * normalize( gl_LightSource[0].position);

    // send color to fragment shader
    gl_FrontColor = gl_Color;

    // Sphere-Touch-Plane-Approach
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    vec2 d, p, q, h, dd;

    // get camera orthonormal coordinate system
    vec4 tmp;

#ifdef CALC_CAM_SYS
    // camera coordinate system in object space
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[2];
    vec3 camIn = normalize(tmp.xyz);
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[1];
    vec3 camUp = tmp.xyz;
    vec3 camRight = normalize(cross(camIn, camUp));
    camUp = cross(camIn, camRight);
#endif // CALC_CAM_SYS

    vec2 mins, maxs;
    vec3 testPos;
    vec4 projPos;

    // projected camera vector
    vec3 c2 = vec3(dot(camPos.xyz, camRight), dot(camPos.xyz, camUp), dot(camPos.xyz, camIn));

    vec3 cpj1 = camIn * c2.z + camRight * c2.x;
    vec3 cpm1 = camIn * c2.x - camRight * c2.z;

    vec3 cpj2 = camIn * c2.z + camUp * c2.y;
    vec3 cpm2 = camIn * c2.y - camUp * c2.z;

    d.x = length(cpj1);
    d.y = length(cpj2);

    dd = vec2(1.0) / d;

    p = squarRad * dd;
    q = d - p;
    h = sqrt(p * q);
    //h = vec2(0.0);

    p *= dd;
    h *= dd;

    cpj1 *= p.x;
    cpm1 *= h.x;
    cpj2 *= p.y;
    cpm2 *= h.y;

    // TODO: rewrite only using four projections, additions in homogenous coordinates and delayed perspective divisions.
    testPos = objPos.xyz + cpj1 + cpm1;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = projPos.xy;
    maxs = projPos.xy;

    testPos -= 2.0 * cpm1;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos = objPos.xyz + cpj2 + cpm2;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos -= 2.0 * cpm2;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    gl_PointSize = max((maxs.x - mins.x) * winHalf.x, (maxs.y - mins.y) * winHalf.y) * 0.5;

#ifdef SMALL_SPRITE_LIGHTING
    // for normal crowbaring on very small sprites
    lightPos.w = (clamp(gl_PointSize, 1.0, 5.0) - 1.0) / 4.0;
#endif // SMALL_SPRITE_LIGHTING
    
#ifdef RETICLE
    centerFragment = gl_Position.xy / gl_Position.w;
#endif // RETICLE

    // gl_PointSize = 32.0;
}
-->
      </snippet>
    </shader>
    
    <shader name="sphereGeom">
      <snippet type="version">120</snippet>
      <snippet type="string">
        <!--
void main(void) {
}
-->
      </snippet>
    </shader>

    <shader name="sphereFragment">
      <snippet type="version">120</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet type="string">
        <!--
uniform vec4 viewAttr;
uniform vec3 zValues;
uniform vec3 fogCol;
uniform float alpha = 0.5;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying float squarRad;
varying float rad;

void main(void) {
    vec4 coord;
    vec3 ray;
    float lambda;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);


    // transform fragment coordinates from view coordinates to object coordinates.
    coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;
    coord -= objPos; // ... and to glyph space


    // calc the viewing ray
    ray = normalize(coord.xyz - camPos.xyz);


    // calculate the geometry-ray-intersection
    float d1 = -dot(camPos.xyz, ray);                       // projected length of the cam-sphere-vector onto the ray
    float d2s = dot(camPos.xyz, camPos.xyz) - d1 * d1;      // off axis of cam-sphere-vector and ray
    float radicand = squarRad - d2s;                        // square of difference of projected length and lambda
    
    if (radicand < 0.0) { discard; }

#ifdef PUXELS
  // wenn wir puxeln, brauchen wir d1 + sqrt(...) und d1 - sqrt(...) = vorder + rueckseite der kugel
    for(float lambdaSign = -1.0; lambdaSign < 2.0; lambdaSign += 2.0)
    {
#else
    float lambdaSign = -1.0;
#endif // PUXELS

  
    lambda = d1 + (lambdaSign * sqrt(radicand));                           // lambda
    vec3 sphereintersection = lambda * ray + camPos.xyz;    // intersection point

    // "calc" normal at intersection point
    vec3 normal = sphereintersection / rad;
#ifdef SMALL_SPRITE_LIGHTING
    normal = mix(-ray, normal, lightPos.w);
#endif // SMALL_SPRITE_LIGHTING

    // chose color for lighting

#ifdef SFB_DEMO
    vec3 color = vec3( 0.70f, 0.8f, 0.4f);
#else
    vec3 color = gl_Color.rgb;
    // uniform color
    //color = vec3( 0.98, 0.23, 0.0); // for VIS
    //color = vec3( 0.17, 0.5, 0.8);
    //color = vec3( 0.19, 0.52, 0.82);
#endif
    
#ifdef COLOR_SES
    color = COLOR_BLUE;
#endif
#ifdef SET_COLOR
    color = COLOR1;
#endif

    // phong lighting with directional light
    gl_FragColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color), 1.0);

    // calculate depth
#ifdef DEPTH
    vec4 Ding = vec4(sphereintersection + objPos.xyz, 1.0);
    float depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
    float depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
#ifdef OGL_DEPTH_SES
    gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
#else
    //gl_FragDepth = ( depth + zValues.y) / zValues.z;
    gl_FragDepth = (depth + zValues.y)/( zValues.z + zValues.y);
#endif // OGL_DEPTH_SES
#endif // DEPTH

#ifdef FOGGING_SES
    float f = clamp( ( 1.0 - gl_FragDepth)/( 1.0 - zValues.x ), 0.0, 1.0);
    gl_FragColor.rgb = mix( fogCol, gl_FragColor.rgb, f);
#endif // FOGGING_SES
    gl_FragColor.a = alpha;

#ifdef AXISHINTS
    // debug-axis-hints
    vec3 colorX = vec3( 1.0, 1.0, 0.0);
    float mc = min(abs(normal.x), min(abs(normal.y), abs(normal.z)));
    if( abs(normal.x) - 0.05 < abs(normal.z) && abs(normal.x) + 0.05 > abs(normal.z) )
    { gl_FragColor = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); }
    if( abs(normal.x) - 0.05 < abs(normal.y) && abs(normal.x) + 0.05 > abs(normal.y) )
    { gl_FragColor = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); }
    if( abs(normal.z) - 0.05 < abs(normal.y) && abs(normal.z) + 0.05 > abs(normal.y) )
    { gl_FragColor = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); }
    if (mc < 0.05) { gl_FragColor = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); }
#endif // AXISHINTS
    // debug-axis-hints
    /*
    float mc = min(abs(normal.x), min(abs(normal.y), abs(normal.z)));
    if (mc < 0.05)            { gl_FragColor.a = 1.0; }
    if (abs(normal.x) > 0.98) { gl_FragColor.a = 1.0; }
    if (abs(normal.y) > 0.98) { gl_FragColor.a = 1.0; }
    if (abs(normal.z) > 0.98) { gl_FragColor.a = 1.0; }
    if (normal.x < -0.99)     { gl_FragColor.a = 1.0; }
    if (normal.y < -0.99)     { gl_FragColor.a = 1.0; }
    if (normal.z < -0.99)     { gl_FragColor.a = 1.0; }
    */
    
#ifdef PUXELS
    if(puxels_use != 0)
      puxels_store(makePuxel(packUnorm4x8(gl_FragColor), normal, gl_FragDepth));
    else
      break;
    } // for lambdaSign
#endif
}
-->
      </snippet>
    </shader>

    <shader name="sphereFragmentNew">
      <snippet type="version">120</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet type="string">
        <!--
uniform vec4 viewAttr;
uniform vec3 zValues;
uniform vec3 fogCol;
uniform float alpha = 0.5;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying float squarRad;
varying float rad;

void main(void) {
    vec4 coord;
    vec3 ray;
    float lambda;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);


    // transform fragment coordinates from view coordinates to object coordinates.
    coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;
    coord -= objPos; // ... and to glyph space


    // calc the viewing ray
    ray = normalize(coord.xyz - camPos.xyz);


    // calculate the geometry-ray-intersection
    float d1 = -dot(camPos.xyz, ray);                       // projected length of the cam-sphere-vector onto the ray
    float d2s = dot(camPos.xyz, camPos.xyz) - d1 * d1;      // off axis of cam-sphere-vector and ray
    float radicand = squarRad - d2s;                        // square of difference of projected length and lambda
    
    if (radicand < 0.0) { discard; }
    
    lambda = d1 - sqrt(radicand);                           // lambda
    vec3 sphereintersection = lambda * ray + camPos.xyz;    // intersection point

    // "calc" normal at intersection point
    vec3 normal = sphereintersection / rad;
#ifdef SMALL_SPRITE_LIGHTING
    normal = mix(-ray, normal, lightPos.w);
#endif // SMALL_SPRITE_LIGHTING

    // chose color for lighting
    vec3 color = gl_Color.rgb;
    // uniform color
    //color = vec3( 0.98, 0.23, 0.0); // for VIS
    //color = vec3( 0.17, 0.5, 0.8);
    //color = vec3( 0.19, 0.52, 0.82);
    
#ifdef COLOR_SES
    color = COLOR_BLUE;
#endif
#ifdef SET_COLOR
    color = COLOR1;
#endif

    // phong lighting with directional light
    gl_FragColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color), 1.0);

    // calculate depth
#ifdef DEPTH
    vec4 Ding = vec4(sphereintersection + objPos.xyz, 1.0);
    float depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
    float depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
#ifdef OGL_DEPTH_SES
    gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
#else
    //gl_FragDepth = ( depth + zValues.y) / zValues.z;
    gl_FragDepth = (depth + zValues.y)/( zValues.z + zValues.y);
#endif // OGL_DEPTH_SES
#endif // DEPTH

#ifdef FOGGING_SES
    float f = clamp( ( 1.0 - gl_FragDepth)/( 1.0 - zValues.x ), 0.0, 1.0);
    gl_FragColor.rgb = mix( fogCol, gl_FragColor.rgb, f);
#endif // FOGGING_SES
    gl_FragColor.a = alpha;

#ifdef AXISHINTS
    // debug-axis-hints
    vec3 colorX = vec3( 1.0, 1.0, 0.0);
    float mc = min(abs(normal.x), min(abs(normal.y), abs(normal.z)));
    if( abs(normal.x) - 0.05 < abs(normal.z) && abs(normal.x) + 0.05 > abs(normal.z) )
    { gl_FragColor = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); }
    if( abs(normal.x) - 0.05 < abs(normal.y) && abs(normal.x) + 0.05 > abs(normal.y) )
    { gl_FragColor = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); }
    if( abs(normal.z) - 0.05 < abs(normal.y) && abs(normal.z) + 0.05 > abs(normal.y) )
    { gl_FragColor = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); }
    if (mc < 0.05) { gl_FragColor = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); }
#endif // AXISHINTS
    // debug-axis-hints
    /*
    float mc = min(abs(normal.x), min(abs(normal.y), abs(normal.z)));
    if (mc < 0.05)            { gl_FragColor.a = 1.0; }
    if (abs(normal.x) > 0.98) { gl_FragColor.a = 1.0; }
    if (abs(normal.y) > 0.98) { gl_FragColor.a = 1.0; }
    if (abs(normal.z) > 0.98) { gl_FragColor.a = 1.0; }
    if (normal.x < -0.99)     { gl_FragColor.a = 1.0; }
    if (normal.y < -0.99)     { gl_FragColor.a = 1.0; }
    if (normal.z < -0.99)     { gl_FragColor.a = 1.0; }
    */
}
-->
      </snippet>
    </shader>

    <shader name="sphereFragmentOR">
      <snippet type="version">120</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet type="string">
        <!--
uniform vec4 viewAttr;
uniform vec3 zValues;
uniform vec3 fogCol;
uniform float alpha = 0.5;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying float squarRad;
varying float rad;

void main(void) {
    vec4 coord;
    vec3 ray;
    float lambda;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);


    // transform fragment coordinates from view coordinates to object coordinates.
    coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;
    coord -= objPos; // ... and to glyph space


    // calc the viewing ray
    ray = normalize(coord.xyz - camPos.xyz);


    // calculate the geometry-ray-intersection
    float d1 = -dot(camPos.xyz, ray);                       // projected length of the cam-sphere-vector onto the ray
    float d2s = dot(camPos.xyz, camPos.xyz) - d1 * d1;      // off axis of cam-sphere-vector and ray
    float radicand = squarRad - d2s;                        // square of difference of projected length and lambda
    
    if (radicand < 0.0) { discard; }
    
    lambda = d1 - sqrt(radicand);                           // lambda
    vec3 sphereintersection = lambda * ray + camPos.xyz;    // intersection point

    // "calc" normal at intersection point
    vec3 normal = sphereintersection / rad;
#ifdef SMALL_SPRITE_LIGHTING
    normal = mix(-ray, normal, lightPos.w);
#endif // SMALL_SPRITE_LIGHTING

    // chose color for lighting
    vec3 color = gl_Color.rgb;
    // uniform color
    //color = vec3( 0.98, 0.23, 0.0); // for VIS
    //color = vec3( 0.17, 0.5, 0.8);
    //color = vec3( 0.19, 0.52, 0.82);
    
#ifdef COLOR_SES
    color = COLOR_BLUE;
#endif
#ifdef SET_COLOR
    color = COLOR1;
#endif

    // phong lighting with directional light
    //gl_FragColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color), 1.0);
    gl_FragData[0] = vec4(color, 1.0);

    // calculate depth
#ifdef DEPTH

    vec4 Ding = vec4(sphereintersection + objPos.xyz, 1.0);
    float depth = -dot(gl_ModelViewMatrixTranspose[2], Ding);
    float depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);    
    
#ifdef OGL_DEPTH_SES
    
    //gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
    // Map near ... far to 0 ... 1
    gl_FragDepth = (depth - zValues.y) / (zValues.z - zValues.y);

#else
    //gl_FragDepth = ( depth + zValues.y) / zValues.z;
    
    //gl_FragDepth = (depth + zValues.y)/( zValues.z + zValues.y);
    // Map near ... far to 0 ... 1
    gl_FragDepth = (depth - zValues.y) / (zValues.z - zValues.y);

#endif // OGL_DEPTH_SES
#endif // DEPTH

#ifdef FOGGING_SES
    float f = clamp( ( 1.0 - gl_FragDepth)/( 1.0 - zValues.x ), 0.0, 1.0);
    gl_FragData[0].rgb = mix( fogCol, gl_FragData[0].rgb, f);
#endif // FOGGING_SES
    //gl_FragData[0].a = alpha;
    gl_FragData[0].a = 1.0;

#ifdef AXISHINTS
    // debug-axis-hints
    vec3 colorX = vec3( 1.0, 1.0, 0.0);
    float mc = min(abs(normal.x), min(abs(normal.y), abs(normal.z)));
    if( abs(normal.x) - 0.05 < abs(normal.z) && abs(normal.x) + 0.05 > abs(normal.z) )
    { gl_FragData[0] = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); }
    if( abs(normal.x) - 0.05 < abs(normal.y) && abs(normal.x) + 0.05 > abs(normal.y) )
    { gl_FragData[0] = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); }
    if( abs(normal.z) - 0.05 < abs(normal.y) && abs(normal.z) + 0.05 > abs(normal.y) )
    { gl_FragData[0] = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); }
    if (mc < 0.05) { gl_FragColor = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); }
#endif // AXISHINTS
    // debug-axis-hints
    /*
    float mc = min(abs(normal.x), min(abs(normal.y), abs(normal.z)));
    if (mc < 0.05)            { gl_FragColor.a = 1.0; }
    if (abs(normal.x) > 0.98) { gl_FragColor.a = 1.0; }
    if (abs(normal.y) > 0.98) { gl_FragColor.a = 1.0; }
    if (abs(normal.z) > 0.98) { gl_FragColor.a = 1.0; }
    if (normal.x < -0.99)     { gl_FragColor.a = 1.0; }
    if (normal.y < -0.99)     { gl_FragColor.a = 1.0; }
    if (normal.z < -0.99)     { gl_FragColor.a = 1.0; }
    */
    
    gl_FragData[1] = vec4(normalize(gl_NormalMatrix*normal), 1.0); // get eye space normal
}
-->
      </snippet>
    </shader>

    <shader name="torusVertex">
      <snippet type="version">120</snippet>
      <snippet name="commondefines"/>
      <snippet type="string">
        <!--
uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)
uniform vec3 zValues;
uniform vec3 fogCol;

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

attribute vec3 inParams;         // inner and outer radius of the torus (r and R) and maximum angle
attribute vec4 quatC;             // conjugate quaternion
attribute vec4 inSphere;        // everything inside this sphere (x,y,z,rad) is visible
attribute vec4 inColors;        // coded colors (x,y) and d of plane and maximum distance from plane
attribute vec3 inCuttingPlane;    // cutting plane for 'pie slice'-cutting

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying vec4 radii;
varying vec4 visibilitySphere;

varying vec3 rotMatT0;
varying vec3 rotMatT1; // rotation matrix from the quaternion
varying vec3 rotMatT2;

varying float maxAngle;

varying vec4 colors;
varying vec3 cuttingPlane;

void main(void) {
    const vec4 quatConst = vec4(1.0, -1.0, 0.5, 0.0);
    vec4 tmp, tmp1;

    // remove the sphere radius from the w coordinates to the rad varyings
    vec4 inPos = gl_Vertex;

    radii.x = inParams.x;
    radii.y = radii.x * radii.x;
    radii.z = inParams.y;
    radii.w =  radii.z * radii.z;
    
    maxAngle = inParams.z;
    
    colors = inColors;
    
    inPos.w = 1.0;
    
    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)

    // orientation quaternion to inverse rotation matrix conversion
    // Begin: Holy code!
    tmp = quatC.xzyw * quatC.yxzw;                        // tmp <- (xy, xz, yz, ww)
    tmp1 = quatC * quatC.w;                                    // tmp1 <- (xw, yw, zw, %)
    tmp1.w = -quatConst.z;                                // tmp1 <- (xw, yw, zw, -0.5)

    rotMatT0.xyz = tmp1.wzy * quatConst.xxy + tmp.wxy;    // matrix0 <- (ww-0.5, xy+zw, xz-yw, %)
    rotMatT0.x = quatC.x * quatC.x + rotMatT0.x;                // matrix0 <- (ww+x*x-0.5, xy+zw, xz-yw, %)
    rotMatT0 = rotMatT0 + rotMatT0;                     // matrix0 <- (2(ww+x*x)-1, 2(xy+zw), 2(xz-yw), %)

    rotMatT1.xyz = tmp1.zwx * quatConst.yxx + tmp.xwz;     // matrix1 <- (xy-zw, ww-0.5, yz+xw, %)
    rotMatT1.y = quatC.y * quatC.y + rotMatT1.y;             // matrix1 <- (xy-zw, ww+y*y-0.5, yz+xw, %)
    rotMatT1 = rotMatT1 + rotMatT1;                     // matrix1 <- (2(xy-zw), 2(ww+y*y)-1, 2(yz+xw), %)

    rotMatT2.xyz = tmp1.yxw * quatConst.xyx + tmp.yzw;     // matrix2 <- (xz+yw, yz-xw, ww-0.5, %)
    rotMatT2.z = quatC.z * quatC.z + rotMatT2.z;             // matrix2 <- (xz+yw, yz-xw, ww+zz-0.5, %)
    rotMatT2 = rotMatT2 + rotMatT2;                     // matrix2 <- (2(xz+yw), 2(yz-xw), 2(ww+zz)-1, %)    
    // End: Holy code!

    // rotate and copy the visibility sphere
    visibilitySphere.xyz = rotMatT0 * inSphere.x + rotMatT1 * inSphere.y + rotMatT2 * inSphere.z;
    visibilitySphere.w = inSphere.w;
    
    cuttingPlane = rotMatT0 * inCuttingPlane.x + rotMatT1 * inCuttingPlane.y + rotMatT2 * inCuttingPlane.z;
    
    // calculate cam position
    tmp = gl_ModelViewMatrixInverse[3]; // (C) by Christoph
    tmp.xyz -= objPos.xyz; // cam move
    camPos.xyz = rotMatT0 * tmp.x + rotMatT1 * tmp.y + rotMatT2 * tmp.z;

    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = gl_ModelViewMatrixInverse * gl_LightSource[0].position - objPos;
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    lightPos = gl_ModelViewMatrixInverse * normalize( gl_LightSource[0].position);
    lightPos.xyz = rotMatT0 * lightPos.x + rotMatT1 * lightPos.y + rotMatT2 * lightPos.z;
    
    // Sphere-Touch-Plane-Approach
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    vec2 d, p, q, h, dd;

    // get camera orthonormal coordinate system

#ifdef CALC_CAM_SYS
    // camera coordinate system in object space
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[2];
    vec3 camIn = normalize(tmp.xyz);
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[1];
    vec3 camUp = tmp.xyz;
    vec3 camRight = normalize(cross(camIn, camUp));
    camUp = cross(camIn, camRight);
#endif // CALC_CAM_SYS

    vec2 mins, maxs;
    vec3 testPos;
    vec4 projPos;

    // projected camera vector
    vec3 c2 = vec3(dot(tmp.xyz, camRight), dot(tmp.xyz, camUp), dot(tmp.xyz, camIn));

    vec3 cpj1 = camIn * c2.z + camRight * c2.x;
    vec3 cpm1 = camIn * c2.x - camRight * c2.z;

    vec3 cpj2 = camIn * c2.z + camUp * c2.y;
    vec3 cpm2 = camIn * c2.y - camUp * c2.z;

    d.x = length(cpj1);
    d.y = length(cpj2);

    dd = vec2(1.0) / d;

    ////p = (radii.x + radii.z)*(radii.x + radii.z) * dd;
    p = inSphere.w*inSphere.w * dd;
    q = d - p;
    h = sqrt(p * q);
    //h = vec2(0.0);

    p *= dd;
    h *= dd;

    cpj1 *= p.x;
    cpm1 *= h.x;
    cpj2 *= p.y;
    cpm2 *= h.y;

    // TODO: rewrite only using four projections, additions in homogenous coordinates and delayed perspective divisions.
    ////testPos = objPos.xyz + cpj1 + cpm1;
    testPos = inSphere.xyz + objPos.xyz + cpj1 + cpm1;    
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = projPos.xy;
    maxs = projPos.xy;

    testPos -= 2.0 * cpm1;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    ////testPos = objPos.xyz + cpj2 + cpm2;
    testPos = inSphere.xyz + objPos.xyz + cpj2 + cpm2;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos -= 2.0 * cpm2;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    // set position and point size
    gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    gl_PointSize = max((maxs.x - mins.x) * winHalf.x, (maxs.y - mins.y) * winHalf.y) * 0.5;
    
#ifdef SMALL_SPRITE_LIGHTING
    // for normal crowbaring on very small sprites
    lightPos.w = (clamp(gl_PointSize, 1.0, 5.0) - 1.0) / 4.0;
#endif // SMALL_SPRITE_LIGHTING

}
-->
      </snippet>
    </shader>

    <shader name="torusFragment">
      <snippet type="version">120</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet name="rootsolver"/>
      <snippet type="string">
        <!--
uniform vec4 viewAttr;
uniform vec3 zValues;
uniform vec3 fogCol;
uniform float alpha = 0.5;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying vec4 radii;
varying vec4 visibilitySphere;

varying vec3 rotMatT0;
varying vec3 rotMatT1; // rotation matrix from the quaternion
varying vec3 rotMatT2;

varying float maxAngle;

varying vec4 colors;
varying vec3 cuttingPlane;
-->
      </snippet>
      <snippet name="decodecolor"/>
      <snippet type="string">
        <!--
void main(void) {
    vec4 coord;
    vec3 ray, tmp;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);

    // transform fragment coordinates from view coordinates to object coordinates.
    coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;
    coord -= objPos; // ... and move

    // calc the viewing ray
    ray = rotMatT0 * coord.x + rotMatT1 * coord.y + rotMatT2 * coord.z;
    ray = normalize( ray - camPos.xyz);

    #define r radii.x
    #define r2 radii.y
    #define R radii.z
    #define R2 radii.w

    // calculate the base point of the ray
    vec3 a = camPos.xyz + ( length( camPos.xyz) - (R + r)) * ray;
    
    // compute coefficients of the quartic equation for the ray-torus-intersection
    float K = dot( a, a) - ( R2 + r2);
    float A = 4.0 * dot( a, ray);
    float B = 2.0 * ( 2.0 * dot( a, ray) * dot( a, ray) + K + 2.0 * R2 * ray.z*ray.z);
    float C = 4.0 * ( K * dot( a, ray) + 2.0 * R2 * a.z * ray.z);
    float D = K*K + 4.0 * R2 * ( a.z*a.z - r2);
    
    vec4 lambdas = vec4( 0.0, 0.0, 0.0, 0.0);
    vec3 intersection;
    // ==> various quartic root solvers (only stabilized ferrari shows good results and performance)
    //int numRoots = quartic( A, B, C, D, lambdas);
    int numRoots = ferrari( A, B, C, D, lambdas);
    //int numRoots = neumark( A, B, C, D, lambdas);
    //int numRoots = simpleFerrari( A, B, C, D, lambdas);
    //int numRoots = descartes( A, B, C, D, lambdas);
    if( numRoots < 2 ) { discard; }
    // get lambda of the first intersection
    /*
    // ==> this test is unnecessary, lambdas.x always holds the value of the second intersection [kroneml 31.8.2008]
    float lambda = lambdas.x;
    if( lambdas.y < lambda && numRoots > 1 && lambdas.y > 0.0 ) { lambda = lambdas.y; }
    if( lambdas.z < lambda && numRoots > 2 && lambdas.z > 0.0 ) { lambda = lambdas.z; }
    if( lambdas.w < lambda && numRoots > 3 && lambdas.w > 0.0 ) { lambda = lambdas.w; }
    // get lambda of the second intersection
    float second;
    if( lambdas.x > lambda ) { second = lambdas.x; } else { second = lambdas.y; }
    if( lambdas.y > lambda && lambdas.y < second && numRoots > 1 ) { second = lambdas.y; }
    if( lambdas.z > lambda && lambdas.z < second && numRoots > 2 ) { second = lambdas.z; }
    if( lambdas.w > lambda && lambdas.w < second && numRoots > 3 ) { second = lambdas.w; }
    */
    float second = lambdas.x;
    intersection = a + ray * second;
    // handle singularity
    bool sing = false;
    if( r > R )
    {
        //float radius2 = r2 - 2.0 * ( r2 -r*R) + r2 - 2.0 * r * R + R2;
        //float cutRad2 = r2 - radius2;
        //float cutRad2 = 2.0 * ( r2 - r * R) - r2 + 2.0 * r * R - R2;
        float cutRad2 = r2 - R2;
        if( dot( intersection, intersection) < cutRad2 )
        {
            second = lambdas.x;
            if( lambdas.y > second && numRoots > 1 ) { second = lambdas.y; }
            if( lambdas.z > second && numRoots > 2 ) { second = lambdas.z; }
            if( lambdas.w > second && numRoots > 3 ) { second = lambdas.w; }
            intersection = a + ray * second;
        }
    }
    // discard fragment if the intersection point lies outside the sphere
    if( length( intersection - visibilitySphere.xyz) > visibilitySphere.w ) { discard; }
    
    // discard fragment if the intersection point lies outside the 'pie slice'

    float d = ( dot( intersection, vec3( 0.0, 0.0, 1.0)) - colors.z) / colors.w;
    // chose color for lighting
    vec3 color = mix( decodeColor( colors.x), decodeColor( colors.y), d);

    /*
    vec3 normPlane;
    float epsilon = 0.001;
    if( maxAngle > 0.0 )
    {
        normPlane = normalize( cross( vec3( 0.0, 0.0, 1.0), intersection));
        if( acos( dot( normPlane, cuttingPlane)) > ( abs( maxAngle)/2.0 + epsilon) ) { discard; }
    }
    else
    {
        normPlane = normalize( cross( intersection, vec3( 0.0, 0.0, 1.0)));
        if( acos( dot( normPlane, cuttingPlane)) > ( abs( maxAngle)/2.0 + epsilon) ) { discard; }
    }
    */
    
    // compute inward-facing normal
    vec3 normal;
    float factor01 = ( dot( intersection, intersection) - r2 - R2);
    normal.x = 4.0*intersection.x*factor01;
    normal.y = 4.0*intersection.y*factor01;
    normal.z = 4.0*intersection.z*factor01 + 8.0*R2*intersection.z;
    normal = -normalize( normal);
    
#ifdef FLATSHADE_SES
    if( d <= 0.5 )
        color = decodeColor( colors.x);
    else
        color = decodeColor( colors.y);
#endif // FLATSHADE_SES
    // uniform color
    //color = vec3( 1.0, 0.75, 0.0);
    //color = vec3( 0.98, 0.82, 0.0 ); // for VIS
    //color = vec3( 0.02, 0.75, 0.02);
    //color = vec3( 0.19, 0.52, 0.82);

#ifdef COLOR_SES
    color = COLOR_GREEN;
#endif    
#ifdef SET_COLOR
    color = COLOR1;
#endif

    // phong lighting with directional light
    gl_FragColor = vec4( LocalLighting( ray, normal, lightPos.xyz, color), 1.0);
    gl_FragDepth = gl_FragCoord.z;
    
    // calculate depth
#ifdef DEPTH
    tmp = intersection;
    intersection.x = dot( rotMatT0, tmp.xyz);
    intersection.y = dot( rotMatT1, tmp.xyz);
    intersection.z = dot( rotMatT2, tmp.xyz);

    intersection += objPos.xyz;

    vec4 Ding = vec4( intersection, 1.0);
    float depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
    float depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
#ifdef OGL_DEPTH_SES
    gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
#else
    //gl_FragDepth = ( depth + zValues.y) / zValues.z;
    gl_FragDepth = (depth + zValues.y)/( zValues.z + zValues.y);
#endif // OGL_DEPTH_SES
#endif // DEPTH

#ifdef FOGGING_SES
    float f = clamp( ( 1.0 - gl_FragDepth)/( 1.0 - zValues.x ), 0.0, 1.0);
    gl_FragColor.rgb = mix( fogCol, gl_FragColor.rgb, f);
#endif // FOGGING_SES
    gl_FragColor.a = alpha;
    
    tmp = normal;
    normal.x = dot( rotMatT0, tmp.xyz);
    normal.y = dot( rotMatT1, tmp.xyz);
    normal.z = dot( rotMatT2, tmp.xyz);
    
#ifdef AXISHINTS    
    // debug-axis-hints
    vec3 colorX = vec3( 1.0, 1.0, 0.0);
    float mc = min(abs(normal.x), min(abs(normal.y), abs(normal.z)));
    if( abs(normal.x) - 0.05 < abs(normal.z) && abs(normal.x) + 0.05 > abs(normal.z) )
    { gl_FragColor = vec4( LocalLighting( ray, tmp, lightPos.xyz, colorX), 1.0); }
    if( abs(normal.x) - 0.05 < abs(normal.y) && abs(normal.x) + 0.05 > abs(normal.y) )
    { gl_FragColor = vec4( LocalLighting( ray, tmp, lightPos.xyz, colorX), 1.0); }
    if( abs(normal.z) - 0.05 < abs(normal.y) && abs(normal.z) + 0.05 > abs(normal.y) )
    { gl_FragColor = vec4( LocalLighting( ray, tmp, lightPos.xyz, colorX), 1.0); }
    if (mc < 0.05) { gl_FragColor = vec4( LocalLighting( ray, tmp, lightPos.xyz, colorX), 1.0); }
#endif // AXISHINTS

#ifdef PUXELS
        if(puxels_use != 0)
            puxels_store(makePuxel(packUnorm4x8(gl_FragColor), normal, gl_FragDepth));
#endif
}
-->
      </snippet>
    </shader>

    <shader name="torusFragmentOR">
      <snippet type="version">120</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet name="rootsolver"/>
      <snippet type="string">
        <!--
uniform vec4 viewAttr;
uniform vec3 zValues;
uniform vec3 fogCol;
uniform float alpha = 0.5;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying vec4 radii;
varying vec4 visibilitySphere;

varying vec3 rotMatT0;
varying vec3 rotMatT1; // rotation matrix from the quaternion
varying vec3 rotMatT2;

varying float maxAngle;

varying vec4 colors;
varying vec3 cuttingPlane;
-->
      </snippet>
      <snippet name="decodecolor"/>
      <snippet type="string">
        <!--
void main(void) {
    vec4 coord;
    vec3 ray, tmp;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);

    // transform fragment coordinates from view coordinates to object coordinates.
    coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;
    coord -= objPos; // ... and move

    // calc the viewing ray
    ray = rotMatT0 * coord.x + rotMatT1 * coord.y + rotMatT2 * coord.z;
    ray = normalize( ray - camPos.xyz);

    #define r radii.x
    #define r2 radii.y
    #define R radii.z
    #define R2 radii.w

    // calculate the base point of the ray
    vec3 a = camPos.xyz + ( length( camPos.xyz) - (R + r)) * ray;
    
    // compute coefficients of the quartic equation for the ray-torus-intersection
    float K = dot( a, a) - ( R2 + r2);
    float A = 4.0 * dot( a, ray);
    float B = 2.0 * ( 2.0 * dot( a, ray) * dot( a, ray) + K + 2.0 * R2 * ray.z*ray.z);
    float C = 4.0 * ( K * dot( a, ray) + 2.0 * R2 * a.z * ray.z);
    float D = K*K + 4.0 * R2 * ( a.z*a.z - r2);
    
    vec4 lambdas = vec4( 0.0, 0.0, 0.0, 0.0);
    vec3 intersection;
    // ==> various quartic root solvers (only stabilized ferrari shows good results and performance)
    //int numRoots = quartic( A, B, C, D, lambdas);
    int numRoots = ferrari( A, B, C, D, lambdas);
    //int numRoots = neumark( A, B, C, D, lambdas);
    //int numRoots = simpleFerrari( A, B, C, D, lambdas);
    //int numRoots = descartes( A, B, C, D, lambdas);
    if( numRoots < 2 ) { discard; }
    // get lambda of the first intersection
    /*
    // ==> this test is unnecessary, lambdas.x always holds the value of the second intersection [kroneml 31.8.2008]
    float lambda = lambdas.x;
    if( lambdas.y < lambda && numRoots > 1 && lambdas.y > 0.0 ) { lambda = lambdas.y; }
    if( lambdas.z < lambda && numRoots > 2 && lambdas.z > 0.0 ) { lambda = lambdas.z; }
    if( lambdas.w < lambda && numRoots > 3 && lambdas.w > 0.0 ) { lambda = lambdas.w; }
    // get lambda of the second intersection
    float second;
    if( lambdas.x > lambda ) { second = lambdas.x; } else { second = lambdas.y; }
    if( lambdas.y > lambda && lambdas.y < second && numRoots > 1 ) { second = lambdas.y; }
    if( lambdas.z > lambda && lambdas.z < second && numRoots > 2 ) { second = lambdas.z; }
    if( lambdas.w > lambda && lambdas.w < second && numRoots > 3 ) { second = lambdas.w; }
    */
    float second = lambdas.x;
    intersection = a + ray * second;
    // handle singularity
    bool sing = false;
    if( r > R )
    {
        //float radius2 = r2 - 2.0 * ( r2 -r*R) + r2 - 2.0 * r * R + R2;
        //float cutRad2 = r2 - radius2;
        //float cutRad2 = 2.0 * ( r2 - r * R) - r2 + 2.0 * r * R - R2;
        float cutRad2 = r2 - R2;
        if( dot( intersection, intersection) < cutRad2 )
        {
            second = lambdas.x;
            if( lambdas.y > second && numRoots > 1 ) { second = lambdas.y; }
            if( lambdas.z > second && numRoots > 2 ) { second = lambdas.z; }
            if( lambdas.w > second && numRoots > 3 ) { second = lambdas.w; }
            intersection = a + ray * second;
        }
    }
    // discard fragment if the intersection point lies outside the sphere
    if( length( intersection - visibilitySphere.xyz) > visibilitySphere.w ) { discard; }
    
    // discard fragment if the intersection point lies outside the 'pie slice'
    /*
    vec3 normPlane;
    float epsilon = 0.001;
    if( maxAngle > 0.0 )
    {
        normPlane = normalize( cross( vec3( 0.0, 0.0, 1.0), intersection));
        if( acos( dot( normPlane, cuttingPlane)) > ( abs( maxAngle)/2.0 + epsilon) ) { discard; }
    }
    else
    {
        normPlane = normalize( cross( intersection, vec3( 0.0, 0.0, 1.0)));
        if( acos( dot( normPlane, cuttingPlane)) > ( abs( maxAngle)/2.0 + epsilon) ) { discard; }
    }
    */
    
    // compute inward-facing normal
    vec3 normal;
    //normal = ( intersection - vec3( normalize( intersection.xy), 0.0));
    float factor01 = ( dot( intersection, intersection) - r2 - R2);
    normal.x = 4.0*intersection.x*factor01;
    normal.y = 4.0*intersection.y*factor01;
    normal.z = 4.0*intersection.z*factor01 + 8.0*R2*intersection.z;
    normal = -normalize( normal);
    
    float d = ( dot( intersection, vec3( 0.0, 0.0, 1.0)) - colors.z) / colors.w;
    // chose color for lighting
    vec3 color = mix( decodeColor( colors.x), decodeColor( colors.y), d);
#ifdef FLATSHADE_SES
    if( d <= 0.5 )
        color = decodeColor( colors.x);
    else
        color = decodeColor( colors.y);
#endif // FLATSHADE_SES
    // uniform color
    //color = vec3( 1.0, 0.75, 0.0);
    //color = vec3( 0.98, 0.82, 0.0 ); // for VIS
    //color = vec3( 0.02, 0.75, 0.02);
    //color = vec3( 0.19, 0.52, 0.82);

#ifdef COLOR_SES
    color = COLOR_GREEN;
#endif    
#ifdef SET_COLOR
    color = COLOR1;
#endif

    // phong lighting with directional light
    //gl_FragColor = vec4( LocalLighting( ray, normal, lightPos.xyz, color), 1.0);
    gl_FragData[0] = vec4(color,1.0);
    
    // calculate depth
#ifdef DEPTH
    tmp = intersection;
    intersection.x = dot( rotMatT0, tmp.xyz);
    intersection.y = dot( rotMatT1, tmp.xyz);
    intersection.z = dot( rotMatT2, tmp.xyz);

    intersection += objPos.xyz;

    vec4 Ding = vec4( intersection, 1.0);
    float depth = -dot(gl_ModelViewMatrixTranspose[2], Ding);
    //float depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
        
#ifdef OGL_DEPTH_SES
    //gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
    // Map near ... far to 0 ... 1
    gl_FragDepth = (depth - zValues.y) / (zValues.z - zValues.y);
#else
    
    //gl_FragDepth = ( depth + zValues.y) / zValues.z;
    //gl_FragDepth = (depth + zValues.y)/( zValues.z + zValues.y);
    // Map near ... far to 0 ... 1
    gl_FragDepth = (depth - zValues.y) / (zValues.z - zValues.y);
    
#endif // OGL_DEPTH_SES
#endif // DEPTH

#ifdef FOGGING_SES
    float f = clamp( ( 1.0 - gl_FragDepth)/( 1.0 - zValues.x ), 0.0, 1.0);
    gl_FragData[0].rgb = mix( fogCol, gl_FragData[0].rgb, f);
#endif // FOGGING_SES
    //gl_FragData[0].a = alpha;
    gl_FragData[0].a = 1.0;
    
    tmp = normal;
    normal.x = dot( rotMatT0, tmp.xyz);
    normal.y = dot( rotMatT1, tmp.xyz);
    normal.z = dot( rotMatT2, tmp.xyz);
    
#ifdef AXISHINTS    
    // debug-axis-hints
    vec3 colorX = vec3( 1.0, 1.0, 0.0);
    float mc = min(abs(normal.x), min(abs(normal.y), abs(normal.z)));
    if( abs(normal.x) - 0.05 < abs(normal.z) && abs(normal.x) + 0.05 > abs(normal.z) )
    { gl_FragData[0] = vec4( LocalLighting( ray, tmp, lightPos.xyz, colorX), 1.0); }
    if( abs(normal.x) - 0.05 < abs(normal.y) && abs(normal.x) + 0.05 > abs(normal.y) )
    { gl_FragData[0] = vec4( LocalLighting( ray, tmp, lightPos.xyz, colorX), 1.0); }
    if( abs(normal.z) - 0.05 < abs(normal.y) && abs(normal.z) + 0.05 > abs(normal.y) )
    { gl_FragData[0] = vec4( LocalLighting( ray, tmp, lightPos.xyz, colorX), 1.0); }
    if (mc < 0.05) { gl_FragColor = vec4( LocalLighting( ray, tmp, lightPos.xyz, colorX), 1.0); }
#endif // AXISHINTS

    gl_FragData[1] = vec4(normalize(gl_NormalMatrix*normal), 1.0);
}
-->
      </snippet>
    </shader>

        <shader name="torusFragmentPuxels">
      <snippet type="version">120</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet name="rootsolver"/>
      <snippet type="string">
        <!--
uniform vec4 viewAttr;
uniform vec3 zValues;
uniform vec3 fogCol;
uniform float alpha = 0.5;
uniform int flipNormals = 0;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying vec4 radii;
varying vec4 visibilitySphere;

varying vec3 rotMatT0;
varying vec3 rotMatT1; // rotation matrix from the quaternion
varying vec3 rotMatT2;

varying float maxAngle;

varying vec4 colors;
varying vec3 cuttingPlane;
-->
      </snippet>
      <snippet name="decodecolor"/>
      <snippet type="string">
        <!--
void main(void) {
    int numRoots;
    float K, A, B, C, D, first, second, third, cutRad2, d, factor01, depth, depthW, f, mc;
    float epsilon = 0.0001;
    vec3 ray, tmp, a, intersection, normPlane, normal, color, colorX;
    vec4 coord, lambdas, Ding;

    int i, j, rt;
    vec2 texCoordHist;
    vec3 minmaxDepth;
    vec4 fragColorInt, fragColorExt, histogram;
    float bucketInt, bucketExt, tmpIntDepth, lastDepth, fragData;
    bool discardInt, discardExt, breakFlag;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);

    // transform fragment coordinates from view coordinates to object coordinates.
    coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;
    coord -= objPos; // ... and move

    // calc the viewing ray
    ray = rotMatT0 * coord.x + rotMatT1 * coord.y + rotMatT2 * coord.z;
    ray = normalize( ray - camPos.xyz);

    #define r radii.x
    #define r2 radii.y
    #define R radii.z
    #define R2 radii.w

    // calculate the base point of the ray
    a = camPos.xyz + ( length( camPos.xyz) - (R + r)) * ray;
    
    // compute coefficients of the quartic equation for the ray-torus-intersection
    K = dot( a, a) - ( R2 + r2);
    A = 4.0 * dot( a, ray);
    B = 2.0 * ( 2.0 * dot( a, ray) * dot( a, ray) + K + 2.0 * R2 * ray.z*ray.z);
    C = 4.0 * ( K * dot( a, ray) + 2.0 * R2 * a.z * ray.z);
    D = K*K + 4.0 * R2 * ( a.z*a.z - r2);
    
    lambdas = vec4( 0.0, 0.0, 0.0, 0.0);
    // ==> various quartic root solvers (only stabilized ferrari shows good results and performance)
    //int numRoots = quartic( A, B, C, D, lambdas);
    numRoots = ferrari( A, B, C, D, lambdas);
    //int numRoots = neumark( A, B, C, D, lambdas);
    //int numRoots = simpleFerrari( A, B, C, D, lambdas);
    //int numRoots = descartes( A, B, C, D, lambdas);
    if( numRoots < 2 ) { discard; }


// INT fragment =========================================================
    discardInt = false;
    first = lambdas.y; // first intersection
    intersection = a + ray * first;

    // handle singularity
    if( r > R ) {
        cutRad2 = r2 - R2;
        if( dot( intersection, intersection) < cutRad2 )
        {
            //first = lambdas.y;
            if( lambdas.x > first && numRoots > 0 ) { first = lambdas.x; }
            if( lambdas.z > first && numRoots > 2 ) { first = lambdas.z; }
            if( lambdas.w > first && numRoots > 3 ) { first = lambdas.w; }
            intersection = a + ray * first;
        }
    }

    // discard fragment if the intersection point lies outside the sphere
    if( length( intersection - visibilitySphere.xyz) > visibilitySphere.w ) { discardInt = true; }

    if(!discardInt) {
        // discard fragment if the intersection point lies outside the 'pie slice'
        if( maxAngle > 0.0 )
        {
            normPlane = normalize( cross( vec3( 0.0, 0.0, 1.0), intersection));
        } else {
            normPlane = normalize( cross( intersection, vec3( 0.0, 0.0, 1.0)));
        }
        if( acos( dot( normPlane, cuttingPlane)) > ( abs( maxAngle)/2.0 + epsilon) ) { discardInt = true; }
    }

    // second INT fragment =========================================================
    if(discardInt && (numRoots > 2)) {
        discardInt = false;
        third = lambdas.w; // third intersection
        intersection = a + ray * third; 

        // handle singularity
        if( r > R ) {
            cutRad2 = r2 - R2;
            if( dot( intersection, intersection) < cutRad2 )
            {
                //third = lambdas.w;
                if( lambdas.x > third && numRoots > 0 ) { third = lambdas.x; }
                if( lambdas.y > third && numRoots > 1 ) { third = lambdas.y; }
                if( lambdas.z > third && numRoots > 2 ) { third = lambdas.z; }
                intersection = a + ray * third;
            }
        }

        // discard fragment if the intersection point lies outside the sphere
        if( length( intersection - visibilitySphere.xyz) > visibilitySphere.w ) { discardInt = true; }
        
        if(!discardInt) {
            // discard fragment if the intersection point lies outside the 'pie slice'
            if( maxAngle > 0.0 )
            {
                normPlane = normalize( cross( vec3( 0.0, 0.0, 1.0), intersection));
            } else {
                normPlane = normalize( cross( intersection, vec3( 0.0, 0.0, 1.0)));
            }
            if( acos( dot( normPlane, cuttingPlane)) > ( abs( maxAngle)/2.0 + epsilon) ) { discardInt = true; }
        }
    }

    if(!discardInt) {
        // compute inward-facing normal
        //normal = ( intersection - vec3( normalize( intersection.xy), 0.0));
        factor01 = ( dot( intersection, intersection) - r2 - R2);
        normal.x = 4.0*intersection.x*factor01;
        normal.y = 4.0*intersection.y*factor01;
        normal.z = 4.0*intersection.z*factor01 + 8.0*R2*intersection.z;
        normal = - normalize( normal);
        if(flipNormals == 1) {
            normal *= (-1.0);
        }
        d = ( dot( intersection, vec3( 0.0, 0.0, 1.0)) - colors.z) / colors.w;
        // chose color for lighting
        color = mix( decodeColor( colors.x), decodeColor( colors.y), d);

        // uniform color
        //color = vec3( 1.0, 0.75, 0.0);
        //color = vec3( 0.02, 0.75, 0.02);
        //color = vec3( 0.19, 0.52, 0.82);
    #ifdef DEBUG_COLOR
        color = vec3( 0.0, 0.98, 0.98 ); // int
    #endif // DEBUG_COLOR
        
        // phong lighting with directional light
        fragColorInt = vec4( LocalLighting( ray, normal, lightPos.xyz, color), alpha); // gl_FragColor
        
        // calculate depth
    #ifdef DEPTH
        tmp = intersection;
        intersection.x = dot( rotMatT0, tmp.xyz);
        intersection.y = dot( rotMatT1, tmp.xyz);
        intersection.z = dot( rotMatT2, tmp.xyz);

        intersection += objPos.xyz;

        Ding = vec4( intersection, 1.0);
        depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
        depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
    #ifdef OGL_DEPTH_SES
        gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
    #else
        //gl_FragDepth = ( depth + zValues.y) / zValues.z;
        gl_FragDepth = (depth + zValues.y)/( zValues.z + zValues.y);
    #endif // OGL_DEPTH_SES
    #endif // DEPTH


        if(puxels_use != 0)
            puxels_store(makePuxel(packUnorm4x8(fragColorInt), normal, gl_FragDepth));
    }

// EXT fragment =========================================================
    discardExt = false;
    second = lambdas.x;
    intersection = a + ray * second;

    // handle singularity
    if( r > R ) {
        //float radius2 = r2 - 2.0 * ( r2 -r*R) + r2 - 2.0 * r * R + R2;
        //float cutRad2 = r2 - radius2;
        //float cutRad2 = 2.0 * ( r2 - r * R) - r2 + 2.0 * r * R - R2;
        cutRad2 = r2 - R2;
        if( dot( intersection, intersection) < cutRad2 )
        {
            //second = lambdas.x;
            if( lambdas.y > second && numRoots > 1 ) { second = lambdas.y; }
            if( lambdas.z > second && numRoots > 2 ) { second = lambdas.z; }
            if( lambdas.w > second && numRoots > 3 ) { second = lambdas.w; }
            intersection = a + ray * second;
        }
    }

    // discard fragment if the intersection point lies outside the sphere
    if( length( intersection - visibilitySphere.xyz) > visibilitySphere.w ) { discardExt = true; }
    
    if(!discardExt) {
        // discard fragment if the intersection point lies outside the 'pie slice'
        if( maxAngle > 0.0 )
        {
            normPlane = normalize( cross( vec3( 0.0, 0.0, 1.0), intersection));
        } else  {
            normPlane = normalize( cross( intersection, vec3( 0.0, 0.0, 1.0)));
        }
        if( acos( dot( normPlane, cuttingPlane)) > ( abs( maxAngle)/2.0 + epsilon) ) { discardExt = true; }
    }

    if(!discardExt) {
        // compute inward-facing normal
        //normal = ( intersection - vec3( normalize( intersection.xy), 0.0));
        factor01 = ( dot( intersection, intersection) - r2 - R2);
        normal.x = 4.0*intersection.x*factor01;
        normal.y = 4.0*intersection.y*factor01;
        normal.z = 4.0*intersection.z*factor01 + 8.0*R2*intersection.z;
        normal = - normalize( normal);
        
        d = ( dot( intersection, vec3( 0.0, 0.0, 1.0)) - colors.z) / colors.w;
        // chose color for lighting
        color = mix( decodeColor( colors.x), decodeColor( colors.y), d);
        // uniform color
        //color = vec3( 1.0, 0.75, 0.0);
        //color = vec3( 0.02, 0.75, 0.02);
        //color = vec3( 0.19, 0.52, 0.82);
    #ifdef DEBUG_COLOR
        color = vec3( 0.98, 0.98, 0.0 ); // ext
    #endif // DEBUG_COLOR
        
        // phong lighting with directional light
        fragColorExt = vec4( LocalLighting( ray, normal, lightPos.xyz, color), alpha); // gl_FragColor
        
        // calculate depth
    #ifdef DEPTH
        tmp = intersection;
        intersection.x = dot( rotMatT0, tmp.xyz);
        intersection.y = dot( rotMatT1, tmp.xyz);
        intersection.z = dot( rotMatT2, tmp.xyz);

        intersection += objPos.xyz;

        Ding = vec4( intersection, 1.0);
        depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
        depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
    #ifdef OGL_DEPTH_SES
        gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
    #else
        //gl_FragDepth = ( depth + zValues.y) / zValues.z;
        gl_FragDepth = (depth + zValues.y)/( zValues.z + zValues.y);
    #endif // OGL_DEPTH_SES
    #endif // DEPTH

        gl_FragColor = fragColorExt;
        
        if(puxels_use != 0)
            puxels_store(makePuxel(packUnorm4x8(fragColorExt), normal, gl_FragDepth));
    }

    if(discardExt && discardInt) { discard; }

}
-->
      </snippet>
    </shader>
    
    <shader name="torusVertex2">
      <snippet type="version">120</snippet>
      <snippet name="commondefines"/>
      <snippet type="string">
        <!--
uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)
uniform vec3 zValues;
uniform vec3 fogCol;

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

attribute vec4 inTorusAxis;       // torus axis + probe radius (torus radius r)
attribute vec4 inSphere;        // everything inside this sphere (x,y,z,rad) is visible
attribute vec4 inColors;        // coded colors (x,y) and d of plane and maximum distance from plane

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying vec4 radii;
varying vec4 visibilitySphere;

varying vec3 rotMatT0;
varying vec3 rotMatT1; // rotation matrix from the quaternion
varying vec3 rotMatT2;

varying vec4 colors;

void main(void) {
    vec4 tmp, tmp1;

    // remove the sphere radius from the w coordinates to the rad varyings
    vec4 inPos = gl_Vertex;

    radii.x = inTorusAxis.w;
    radii.y = radii.x * radii.x;
    radii.z = inPos.w;
    radii.w =  radii.z * radii.z;
        
    colors = inColors;
    
    inPos.w = 1.0;
    
    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)
 
    rotMatT0 = inTorusAxis.xyz;
 
    rotMatT2 = ((rotMatT0.x > 0.9) || (rotMatT0.x < -0.9)) ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0); // normal on tmp
    rotMatT1 = cross(rotMatT0, rotMatT2);
    rotMatT1 = normalize(rotMatT1);
    rotMatT2 = cross(rotMatT1, rotMatT0);
 
    vec3 ttmp1 = rotMatT2;
    vec3 ttmp2 = rotMatT1;
    vec3 ttmp3 = rotMatT0;
 
    rotMatT0 = vec3(ttmp1.x, ttmp2.x, ttmp3.x);
    rotMatT1 = vec3(ttmp1.y, ttmp2.y, ttmp3.y);
    rotMatT2 = vec3(ttmp1.z, ttmp2.z, ttmp3.z);
 
    // rotate and copy the visibility sphere
    visibilitySphere.xyz = rotMatT0 * inSphere.x + rotMatT1 * inSphere.y + rotMatT2 * inSphere.z;
    visibilitySphere.w = inSphere.w;
        
    // calculate cam position
    tmp = gl_ModelViewMatrixInverse[3]; // (C) by Christoph
    tmp.xyz -= objPos.xyz; // cam move
    camPos.xyz = rotMatT0 * tmp.x + rotMatT1 * tmp.y + rotMatT2 * tmp.z;

    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = gl_ModelViewMatrixInverse * gl_LightSource[0].position - objPos;
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    lightPos = gl_ModelViewMatrixInverse * normalize( gl_LightSource[0].position);
    lightPos.xyz = rotMatT0 * lightPos.x + rotMatT1 * lightPos.y + rotMatT2 * lightPos.z;
    
    // Sphere-Touch-Plane-Approach
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    vec2 d, p, q, h, dd;

    // get camera orthonormal coordinate system

#ifdef CALC_CAM_SYS
    // camera coordinate system in object space
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[2];
    vec3 camIn = normalize(tmp.xyz);
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[1];
    vec3 camUp = tmp.xyz;
    vec3 camRight = normalize(cross(camIn, camUp));
    camUp = cross(camIn, camRight);
#endif // CALC_CAM_SYS

    vec2 mins, maxs;
    vec3 testPos;
    vec4 projPos;

    // projected camera vector
    vec3 c2 = vec3(dot(tmp.xyz, camRight), dot(tmp.xyz, camUp), dot(tmp.xyz, camIn));

    vec3 cpj1 = camIn * c2.z + camRight * c2.x;
    vec3 cpm1 = camIn * c2.x - camRight * c2.z;

    vec3 cpj2 = camIn * c2.z + camUp * c2.y;
    vec3 cpm2 = camIn * c2.y - camUp * c2.z;

    d.x = length(cpj1);
    d.y = length(cpj2);

    dd = vec2(1.0) / d;

    ////p = (radii.x + radii.z)*(radii.x + radii.z) * dd;
    p = inSphere.w*inSphere.w * dd;
    q = d - p;
    h = sqrt(p * q);
    //h = vec2(0.0);

    p *= dd;
    h *= dd;

    cpj1 *= p.x;
    cpm1 *= h.x;
    cpj2 *= p.y;
    cpm2 *= h.y;

    // TODO: rewrite only using four projections, additions in homogenous coordinates and delayed perspective divisions.
    ////testPos = objPos.xyz + cpj1 + cpm1;
    testPos = inSphere.xyz + objPos.xyz + cpj1 + cpm1;    
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = projPos.xy;
    maxs = projPos.xy;

    testPos -= 2.0 * cpm1;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    ////testPos = objPos.xyz + cpj2 + cpm2;
    testPos = inSphere.xyz + objPos.xyz + cpj2 + cpm2;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos -= 2.0 * cpm2;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    // set position and point size
    gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    gl_PointSize = max((maxs.x - mins.x) * winHalf.x, (maxs.y - mins.y) * winHalf.y) * 0.5;
    
#ifdef SMALL_SPRITE_LIGHTING
    // for normal crowbaring on very small sprites
    lightPos.w = (clamp(gl_PointSize, 1.0, 5.0) - 1.0) / 4.0;
#endif // SMALL_SPRITE_LIGHTING

}
-->
      </snippet>
    </shader>

    <shader name="torusFragment2">
      <snippet type="version">120</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet name="rootsolver"/>
      <snippet type="string">
        <!--
uniform vec4 viewAttr;
uniform vec3 zValues;
uniform vec3 fogCol;
uniform float alpha = 0.5;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying vec4 radii;
varying vec4 visibilitySphere;

varying vec3 rotMatT0;
varying vec3 rotMatT1; // rotation matrix from the quaternion
varying vec3 rotMatT2;

varying vec4 colors;
-->
      </snippet>
      <snippet name="decodecolor"/>
      <snippet type="string">
        <!--
void main(void) {
    vec4 coord;
    vec3 ray, tmp;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);

    // transform fragment coordinates from view coordinates to object coordinates.
    coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;
    coord -= objPos; // ... and move

    // calc the viewing ray
    ray = rotMatT0 * coord.x + rotMatT1 * coord.y + rotMatT2 * coord.z;
    ray = normalize( ray - camPos.xyz);

    #define r radii.x
    #define r2 radii.y
    #define R radii.z
    #define R2 radii.w

    // calculate the base point of the ray
    vec3 a = camPos.xyz + ( length( camPos.xyz) - (R + r)) * ray;
    
    // compute coefficients of the quartic equation for the ray-torus-intersection
    float K = dot( a, a) - ( R2 + r2);
    float A = 4.0 * dot( a, ray);
    float B = 2.0 * ( 2.0 * dot( a, ray) * dot( a, ray) + K + 2.0 * R2 * ray.z*ray.z);
    float C = 4.0 * ( K * dot( a, ray) + 2.0 * R2 * a.z * ray.z);
    float D = K*K + 4.0 * R2 * ( a.z*a.z - r2);
    
    vec4 lambdas = vec4( 0.0, 0.0, 0.0, 0.0);
    vec3 intersection;
    // ==> various quartic root solvers (only stabilized ferrari shows good results and performance)
    //int numRoots = quartic( A, B, C, D, lambdas);
    int numRoots = ferrari( A, B, C, D, lambdas);
    //int numRoots = neumark( A, B, C, D, lambdas);
    //int numRoots = simpleFerrari( A, B, C, D, lambdas);
    //int numRoots = descartes( A, B, C, D, lambdas);
    if( numRoots < 2 ) { discard; }
    // get lambda of the first intersection
    /*
    // ==> this test is unnecessary, lambdas.x always holds the value of the second intersection [kroneml 31.8.2008]
    float lambda = lambdas.x;
    if( lambdas.y < lambda && numRoots > 1 && lambdas.y > 0.0 ) { lambda = lambdas.y; }
    if( lambdas.z < lambda && numRoots > 2 && lambdas.z > 0.0 ) { lambda = lambdas.z; }
    if( lambdas.w < lambda && numRoots > 3 && lambdas.w > 0.0 ) { lambda = lambdas.w; }
    // get lambda of the second intersection
    float second;
    if( lambdas.x > lambda ) { second = lambdas.x; } else { second = lambdas.y; }
    if( lambdas.y > lambda && lambdas.y < second && numRoots > 1 ) { second = lambdas.y; }
    if( lambdas.z > lambda && lambdas.z < second && numRoots > 2 ) { second = lambdas.z; }
    if( lambdas.w > lambda && lambdas.w < second && numRoots > 3 ) { second = lambdas.w; }
    */
    float second = lambdas.x;
    intersection = a + ray * second;
    // handle singularity
    bool sing = false;
    if( r > R )
    {
        //float radius2 = r2 - 2.0 * ( r2 -r*R) + r2 - 2.0 * r * R + R2;
        //float cutRad2 = r2 - radius2;
        //float cutRad2 = 2.0 * ( r2 - r * R) - r2 + 2.0 * r * R - R2;
        float cutRad2 = r2 - R2;
        if( dot( intersection, intersection) < cutRad2 )
        {
            second = lambdas.x;
            if( lambdas.y > second && numRoots > 1 ) { second = lambdas.y; }
            if( lambdas.z > second && numRoots > 2 ) { second = lambdas.z; }
            if( lambdas.w > second && numRoots > 3 ) { second = lambdas.w; }
            intersection = a + ray * second;
        }
    }
    // discard fragment if the intersection point lies outside the sphere
    if( length( intersection - visibilitySphere.xyz) > visibilitySphere.w ) { discard; }
    
    // compute inward-facing normal
    vec3 normal;
    //normal = ( intersection - vec3( normalize( intersection.xy), 0.0));
    float factor01 = ( dot( intersection, intersection) - r2 - R2);
    normal.x = 4.0*intersection.x*factor01;
    normal.y = 4.0*intersection.y*factor01;
    normal.z = 4.0*intersection.z*factor01 + 8.0*R2*intersection.z;
    normal = -normalize( normal);
    
    vec3 color;
    /*
    float d = ( dot( intersection, vec3( 0.0, 0.0, 1.0)) - colors.z) / colors.w;
    // chose color for lighting
    color = mix( decodeColor( colors.x), decodeColor( colors.y), d);
#ifdef FLATSHADE_SES
    if( d <= 0.5 )
        color = decodeColor( colors.x);
    else
        color = decodeColor( colors.y);
#endif // FLATSHADE_SES
    */
    // uniform color
    color = vec3( 1.0, 0.75, 0.0);
    //color = vec3( 0.98, 0.82, 0.0 ); // for VIS
    //color = vec3( 0.02, 0.75, 0.02);
    //color = vec3( 0.19, 0.52, 0.82);

#ifdef COLOR_SES
    color = COLOR_GREEN;
#endif    
#ifdef SET_COLOR
    color = COLOR1;
#endif

#ifdef SFB_DEMO
    color = vec3(0.70f, 0.8f, 0.4f);
#endif

    // phong lighting with directional light
    gl_FragColor = vec4( LocalLighting( ray, normal, lightPos.xyz, color), 1.0);
    
    // calculate depth
#ifdef DEPTH
    tmp = intersection;
    intersection.x = dot( rotMatT0, tmp.xyz);
    intersection.y = dot( rotMatT1, tmp.xyz);
    intersection.z = dot( rotMatT2, tmp.xyz);

    intersection += objPos.xyz;

    vec4 Ding = vec4( intersection, 1.0);
    float depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
    float depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
#ifdef OGL_DEPTH_SES
    gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
#else
    //gl_FragDepth = ( depth + zValues.y) / zValues.z;
    gl_FragDepth = (depth + zValues.y)/( zValues.z + zValues.y);
#endif // OGL_DEPTH_SES
#endif // DEPTH

#ifdef FOGGING_SES
    float f = clamp( ( 1.0 - gl_FragDepth)/( 1.0 - zValues.x ), 0.0, 1.0);
    gl_FragColor.rgb = mix( fogCol, gl_FragColor.rgb, f);
#endif // FOGGING_SES
    gl_FragColor.a = alpha;
}
-->
      </snippet>
    </shader>

    <shader name="sphericaltriangleVertex">
      <snippet type="version">130</snippet>
      <snippet name="commondefines"/>
      <snippet type="string">
        <!--
    uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)
    uniform vec3 zValues;
    uniform vec3 fogCol;
    uniform vec2 texOffset;
    
    #ifndef CALC_CAM_SYS
    uniform vec3 camIn;
    uniform vec3 camUp;
    uniform vec3 camRight;
    #endif // CALC_CAM_SYS
    
    attribute vec4 attribVec1;
    attribute vec4 attribVec2;
    attribute vec4 attribVec3;
    attribute vec3 attribColors;
    attribute vec3 attribTexCoord1;
    attribute vec3 attribTexCoord2;
    attribute vec3 attribTexCoord3;
    
    varying vec4 objPos;
    varying vec4 camPos;
    varying vec4 lightPos;
    
    varying vec4 inVec1;
    varying vec4 inVec2;
    varying vec4 inVec3;
    varying vec3 inColors;
    varying vec3 texCoord1;
    varying vec3 texCoord2;
    varying vec3 texCoord3;
    
    void main(void) {
    inVec1 = attribVec1;
    inVec2 = attribVec2;
    inVec3 = attribVec3;
    inColors = attribColors;
    
    texCoord1 = attribTexCoord1;
    texCoord2 = attribTexCoord2;
    texCoord3 = attribTexCoord3;
    
    // remove the sphere radius from the w coordinates to the rad varyings
    vec4 inPos = gl_Vertex;
    inVec1.w = inPos.w;
    inVec2.w = inPos.w * inPos.w;
    inPos.w = 1.0;
    
    // DEBUG
    //texCoord2.xy = vec2( attribVec1.w, attribVec2.w);
    
    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)
    
    // calculate cam position
    camPos = gl_ModelViewMatrixInverse[3]; // (C) by Christoph
    camPos.xyz -= objPos.xyz; // cam pos to glyph space
    
    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = gl_ModelViewMatrixInverse * gl_LightSource[0].position - objPos;
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    lightPos = gl_ModelViewMatrixInverse * normalize( gl_LightSource[0].position);
    
    // Sphere-Touch-Plane-Approach
    vec2 winHalf = 2.0 / viewAttr.zw; // window size
    
    vec2 d, p, q, h, dd;
    
    // get camera orthonormal coordinate system
    vec4 tmp;
    
    #ifdef CALC_CAM_SYS
    // camera coordinate system in object space
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[2];
    vec3 camIn = normalize(tmp.xyz);
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[1];
    vec3 camUp = tmp.xyz;
    vec3 camRight = normalize(cross(camIn, camUp));
    camUp = cross(camIn, camRight);
    #endif // CALC_CAM_SYS
    
    vec2 mins, maxs;
    vec3 testPos;
    vec4 projPos;
    
    // projected camera vector
    vec3 c2 = vec3(dot(camPos.xyz, camRight), dot(camPos.xyz, camUp), dot(camPos.xyz, camIn));
    
    vec3 cpj1 = camIn * c2.z + camRight * c2.x;
    vec3 cpm1 = camIn * c2.x - camRight * c2.z;
    
    vec3 cpj2 = camIn * c2.z + camUp * c2.y;
    vec3 cpm2 = camIn * c2.y - camUp * c2.z;
    
    d.x = length(cpj1);
    d.y = length(cpj2);
    
    dd = vec2(1.0) / d;
    
    p = inVec2.w * dd;
    q = d - p;
    h = sqrt(p * q);
    //h = vec2(0.0);
    
    p *= dd;
    h *= dd;
    
    cpj1 *= p.x;
    cpm1 *= h.x;
    cpj2 *= p.y;
    cpm2 *= h.y;
    
    // TODO: rewrite only using four projections, additions in homogenous coordinates and delayed perspective divisions.
    testPos = objPos.xyz + cpj1 + cpm1;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = projPos.xy;
    maxs = projPos.xy;
    
    testPos -= 2.0 * cpm1;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);
    
    testPos = objPos.xyz + cpj2 + cpm2;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);
    
    testPos -= 2.0 * cpm2;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);
    
    gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    gl_PointSize = max((maxs.x - mins.x) * winHalf.x, (maxs.y - mins.y) * winHalf.y) * 0.5;
    
    #ifdef SMALL_SPRITE_LIGHTING
    // for normal crowbaring on very small sprites
    lightPos.w = (clamp(gl_PointSize, 1.0, 5.0) - 1.0) / 4.0;
    #endif // SMALL_SPRITE_LIGHTING
    
    }
-->
      </snippet>
    </shader>

    <shader name="sphericaltriangleFragment">
      <snippet type="version">130</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet type="string">
        <!--
#extension GL_EXT_gpu_shader4 : enable

uniform vec4 viewAttr;
uniform vec3 zValues;
uniform vec3 fogCol;
uniform vec2 texOffset;
// texture sampler
uniform sampler2D tex;
uniform float alpha = 0.5;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;

varying vec4 inVec1;
varying vec4 inVec2;
varying vec4 inVec3;
varying vec3 inColors;

varying vec3 texCoord1;
varying vec3 texCoord2;
varying vec3 texCoord3;

-->
      </snippet>
      <snippet name="decodecolor"/>
      <snippet name="dot1"/>
      <snippet type="string">
        <!--

void main(void) {
    vec4 coord;
    vec3 ray;
    float lambda;
    float rad = inVec1.w;
    float squarRad = inVec2.w;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    
    // transform fragment coordinates from view coordinates to object coordinates.
    coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;
    coord -= objPos; // ... and to glyph space

    // calc the viewing ray
    ray = normalize(coord.xyz - camPos.xyz);

    // calculate the geometry-ray-intersection
    float d1 = -dot(camPos.xyz, ray);                       // projected length of the cam-sphere-vector onto the ray
    float d2s = dot(camPos.xyz, camPos.xyz) - d1 * d1;      // off axis of cam-sphere-vector and ray
    float radicand = squarRad - d2s;                        // square of difference of projected length and lambda
    
    if (radicand < 0.0) { discard; }
    
    lambda = d1 + sqrt(radicand);                           // lambda
    vec3 sphereintersection = lambda * ray + camPos.xyz;    // intersection point

    // compute the actual position of the intersection with the sphere
    vec3 pos1 = sphereintersection + objPos.xyz;
    // cut with plane 1
    vec3 planeNormal = normalize( cross( inVec1.xyz, inVec2.xyz));
    float d = dot( objPos.xyz, planeNormal);
    float dist1 = dot( pos1, planeNormal) - d;
    float dist2 = dot( inVec3.xyz + objPos.xyz, planeNormal) - d;
    if( ( dist2 < 0.0 && dist1 > 0.0 ) || ( dist2 > 0.0 && dist1 < 0.0 ) ) { discard; }
    // cut with plane 2
    planeNormal = normalize( cross( inVec2.xyz, inVec3.xyz));
    d = dot( objPos.xyz, planeNormal);
    dist1 = dot( pos1, planeNormal) - d;
    dist2 = dot( inVec1.xyz + objPos.xyz, planeNormal) - d;
    if( ( dist2 < 0.0 && dist1 > 0.0 ) || ( dist2 > 0.0 && dist1 < 0.0 ) ) { discard; }
    // cut with plane 3
    planeNormal = normalize( cross( inVec1.xyz, inVec3.xyz));
    d = dot( objPos.xyz, planeNormal);
    dist1 = dot( pos1, planeNormal) - d;
    dist2 = dot( inVec2.xyz + objPos.xyz, planeNormal) - d;
    if( ( dist2 < 0.0 && dist1 > 0.0 ) || ( dist2 > 0.0 && dist1 < 0.0 ) ) { discard; }
    // discard the point if it is eaten away by one of the neighbouring probes
    // ==> check first, if one of the probes is nearly dual to the object position
    /*
    if( ( dot1( inProbe1.xyz - objPos.xyz) > 0.1 && ( dot1( pos1 - inProbe1.xyz) < squarRad ) ) || 
        ( dot1( inProbe2.xyz - objPos.xyz) > 0.1 && ( dot1( pos1 - inProbe2.xyz) < squarRad ) ) || 
            ( dot1( inProbe3.xyz - objPos.xyz) > 0.1 && ( dot1( pos1 - inProbe3.xyz) < squarRad ) ) ||
            ( dot1( pos1 - dualProbe) < inVec3.w ) ) { discard; }
    */
    int i;
    vec3 probePos;
    int numProbes = min( int(texCoord1.x), 32);
    if( numProbes > 0 ) {
        for( i = 0; i < numProbes; i++ ) {
            probePos = texelFetch2D( tex, ivec2( texCoord1.yz) + ivec2( i, 0), 0).xyz;
            if( dot1( probePos - objPos.xyz) > 0.1 && ( dot1( pos1 - probePos) < squarRad ) ) { discard; }
        }
    }
    numProbes = min( int(texCoord2.x), 16);
    if( numProbes > 0 )
    {
        for( i = 0; i < numProbes; i++ )
        {
            //probePos = texture2D( tex, ( texCoord2.yz + vec2( 0.5, 0.5) + vec2( float( i), 0.0))*texOffset).xyz;
            probePos = texelFetch2D( tex, ivec2( texCoord2.yz) + ivec2( i, 0), 0).xyz;
            if( dot1( probePos - objPos.xyz) > 0.1 && ( dot1( pos1 - probePos) < squarRad ) ) { discard; }
        }
    }
    numProbes = min( int(texCoord3.x), 16);
    if( numProbes > 0 )
    {
        for( i = 0; i < numProbes; i++ )
        {
            //probePos = texture2D( tex, ( texCoord3.yz + vec2( 0.5, 0.5) + vec2( float( i), 0.0))*texOffset).xyz;
            probePos = texelFetch2D( tex, ivec2( texCoord3.yz) + ivec2( i, 0), 0).xyz;
            if( dot1( probePos - objPos.xyz) > 0.1 && ( dot1( pos1 - probePos) < squarRad ) ) { discard; }
        }
    }
    // "calc" normal at intersection point
    vec3 normal = -sphereintersection / rad;
#ifdef SMALL_SPRITE_LIGHTING
    normal = mix(-ray, normal, lightPos.w);
#endif // SMALL_SPRITE_LIGHTING

    // ========== START compute color ==========
    // compute auxiliary direction vectors
    vec3 u = inVec1.xyz - inVec2.xyz;
    vec3 v = inVec3.xyz - inVec2.xyz;
    // base point and direction of ray from the origin to the intersection point
    vec3 w = -inVec2.xyz;
    vec3 dRay = normalize( sphereintersection);
    // cross products for computing the determinant
    vec3 wXu = cross( w, u);
    vec3 dXv = cross( dRay, v);
    // compute interse determinant
    float invdet = 1.0 / dot( dXv, u);
    // compute weights
    float beta = dot( dXv, w) * invdet;
    float gamma = dot( wXu, dRay) * invdet;
    float alpha2 = 1.0 - ( beta + gamma);
    // compute color
    vec3 color = decodeColor( inColors.y) * alpha2 + decodeColor( inColors.x) * beta + decodeColor( inColors.z) * gamma;
#ifdef FLATSHADE_SES
    if( alpha2 > beta && alpha2 > gamma )
        color = decodeColor( inColors.y);
    else if( beta > alpha2 && beta > gamma )
        color = decodeColor( inColors.x);
    else
        color = decodeColor( inColors.z);
#endif // FLATSHADE_SES
    // ========== END compute color ==========
    // uniform color
    //color = vec3( 0.0, 0.75, 1.0);
    //color = vec3( 0.0, 0.6, 0.6 ); // for VIS
    //color = vec3( texCoord2.xy, 0.0);
    //color = vec3( 0.8, 0.0, 0.2);
    //color = vec3( 0.19, 0.52, 0.82);

#ifdef COLOR_SES
    color = COLOR_YELLOW;
#endif    
#ifdef SET_COLOR
    color = COLOR1;
#endif

#ifdef SFB_DEMO
    color = vec3(0.70f, 0.8f, 0.4f);
#endif

    // phong lighting with directional light
    gl_FragColor = vec4( LocalLighting(ray, normal, lightPos.xyz, color), 1.0);
    gl_FragDepth = gl_FragCoord.z;
    
    // calculate depth
#ifdef DEPTH
    vec4 Ding = vec4(sphereintersection + objPos.xyz, 1.0);
    float depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
    float depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
#ifdef OGL_DEPTH_SES
    gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
#else
    //gl_FragDepth = ( depth + zValues.y) / zValues.z;
    gl_FragDepth = (depth + zValues.y)/( zValues.z + zValues.y);
#endif // OGL_DEPTH_SES
#endif // DEPTH

#ifdef FOGGING_SES
    float f = clamp( ( 1.0 - gl_FragDepth)/( 1.0 - zValues.x ), 0.0, 1.0);
    gl_FragColor.rgb = mix( fogCol, gl_FragColor.rgb, f);
#endif // FOGGING_SES
    gl_FragColor.a = alpha;
    
#ifdef AXISHINTS
    // debug-axis-hints
    vec3 colorX = vec3( 1.0, 1.0, 0.0);
    float mc = min(abs(normal.x), min(abs(normal.y), abs(normal.z)));
    if( abs(normal.x) - 0.05 < abs(normal.z) && abs(normal.x) + 0.05 > abs(normal.z) )
    { gl_FragColor = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); }
    if( abs(normal.x) - 0.05 < abs(normal.y) && abs(normal.x) + 0.05 > abs(normal.y) )
    { gl_FragColor = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); }
    if( abs(normal.z) - 0.05 < abs(normal.y) && abs(normal.z) + 0.05 > abs(normal.y) )
    { gl_FragColor = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); }
    if (mc < 0.05) { gl_FragColor = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); }
#endif // AXISHINTS

#ifdef PUXELS
if(puxels_use != 0)
    puxels_store(makePuxel(packUnorm4x8(gl_FragColor), normal, gl_FragDepth));
#endif

}
-->
      </snippet>
    </shader>

    <shader name="sphericaltriangleFragmentPuxels">
      <snippet type="version">130</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet type="string">
        <!--
#extension GL_EXT_gpu_shader4 : enable

uniform vec4 viewAttr;
uniform vec3 zValues;
uniform vec3 fogCol;
uniform vec2 texOffset;
// texture sampler
uniform sampler2D tex;
uniform float alpha = 0.5;
uniform int flipNormals = 0;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;

varying vec4 inVec1;
varying vec4 inVec2;
varying vec4 inVec3;
varying vec3 inColors;

varying vec3 texCoord1;
varying vec3 texCoord2;
varying vec3 texCoord3;

-->
      </snippet>
      <snippet name="decodecolor"/>
      <snippet name="dot1"/>
      <snippet type="string">
        <!--
void main(void) {

    float rad      = inVec1.w;
    float squarRad = inVec2.w;

    int numProbes;
    float d1, d2s, radicand, lambda, d, dist1, dist2, f, mc, depth, depthW, invdet, beta, gamma, alpha2;
    vec3 ray, sphereintersection, pos1, planeNormal, probePos, normal, color, colorX;
    vec3 u, v, w, dRay, wXu, dXv;
    vec4 coord, Ding;

    int i, j, rt;
    vec2 texCoordHist;
    vec3 minmaxDepth;
    vec4 fragColorInt, fragColorExt, histogram;
    float bucketInt, bucketExt, tmpIntDepth, lastDepth, fragData;
    bool discardInt, discardExt, breakFlag;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    
    // transform fragment coordinates from view coordinates to object coordinates.
    coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;
    coord -= objPos; // ... and to glyph space

    // calc the viewing ray
    ray = normalize(coord.xyz - camPos.xyz);

    // calculate the geometry-ray-intersection
    d1 = -dot(camPos.xyz, ray);                       // projected length of the cam-sphere-vector onto the ray
    d2s = dot(camPos.xyz, camPos.xyz) - d1 * d1;      // off axis of cam-sphere-vector and ray
    radicand = squarRad - d2s;                        // square of difference of projected length and lambda
    
    if (radicand < 0.0) { discard; }

// INT fragment =========================================================
    discardInt = false;
    lambda = d1 + sqrt(radicand);                     // lambda for interior face
    sphereintersection = lambda * ray + camPos.xyz;    // intersection point

    // compute the actual position of the intersection with the sphere
    pos1 = sphereintersection + objPos.xyz;
    // cut with plane 1
    planeNormal = normalize( cross( inVec1.xyz, inVec2.xyz));
    d = dot( objPos.xyz, planeNormal);
    dist1 = dot( pos1, planeNormal) - d;
    dist2 = dot( inVec3.xyz + objPos.xyz, planeNormal) - d;
    if( ( dist2 < 0.0 && dist1 > 0.0 ) || ( dist2 > 0.0 && dist1 < 0.0 ) ) { discardInt = true; }
    if(!discardInt) {
        // cut with plane 2
        planeNormal = normalize( cross( inVec2.xyz, inVec3.xyz));
        d = dot( objPos.xyz, planeNormal);
        dist1 = dot( pos1, planeNormal) - d;
        dist2 = dot( inVec1.xyz + objPos.xyz, planeNormal) - d;
        if( ( dist2 < 0.0 && dist1 > 0.0 ) || ( dist2 > 0.0 && dist1 < 0.0 ) ) { discardInt = true; }
    }
    if(!discardInt) {
        // cut with plane 3
        planeNormal = normalize( cross( inVec1.xyz, inVec3.xyz));
        d = dot( objPos.xyz, planeNormal);
        dist1 = dot( pos1, planeNormal) - d;
        dist2 = dot( inVec2.xyz + objPos.xyz, planeNormal) - d;
        if( ( dist2 < 0.0 && dist1 > 0.0 ) || ( dist2 > 0.0 && dist1 < 0.0 ) ) { discardInt = true; }
    }

    // Singularity handling:
    if(!discardInt) {
        numProbes = min( int(texCoord1.x), 16);
        if( numProbes > 0 )
        {
            for( i = 0; i < numProbes; i++ )
            {
                probePos = texture2D( tex, ( texCoord1.yz + vec2( 0.25, 0.25) + vec2( float( i), 0.0))*texOffset).xyz;
                if( dot1( probePos - objPos.xyz) > 0.1 && ( dot1( pos1 - probePos) < squarRad ) ) { discardInt = true; }
            }
        }
    }
    if(!discardInt) {
        numProbes = min( int(texCoord2.x), 16);
        if( numProbes > 0 )
        {
            for( i = 0; i < numProbes; i++ )
            {
                probePos = texture2D( tex, ( texCoord2.yz + vec2( 0.25, 0.25) + vec2( float( i), 0.0))*texOffset).xyz;
                if( dot1( probePos - objPos.xyz) > 0.1 && ( dot1( pos1 - probePos) < squarRad ) ) { discardInt = true; }
            }
        }
    }
    if(!discardInt) {
        numProbes = min( int(texCoord3.x), 16);
        if( numProbes > 0 )
        {
            for( i = 0; i < numProbes; i++ )
            {
                probePos = texture2D( tex, ( texCoord3.yz + vec2( 0.25, 0.25) + vec2( float( i), 0.0))*texOffset).xyz;
                if( dot1( probePos - objPos.xyz) > 0.1 && ( dot1( pos1 - probePos) < squarRad ) ) { discardInt = true; }
            }
        }
    }

    if(!discardInt) {
        // "calc" normal at intersection point
        normal = - sphereintersection / rad;
    #ifdef SMALL_SPRITE_LIGHTING
        normal = mix(-ray, normal, lightPos.w);
    #endif // SMALL_SPRITE_LIGHTING

        // ========== START compute color ==========
        // compute auxiliary direction vectors
        u = inVec1.xyz - inVec2.xyz;
        v = inVec3.xyz - inVec2.xyz;
        // base point and direction of ray from the origin to the intersection point
        w = -inVec2.xyz;
        dRay = normalize( sphereintersection);
        // cross products for computing the determinant
        wXu = cross( w, u);
        dXv = cross( dRay, v);
        // compute inverse determinant
        invdet = 1.0 / dot( dXv, u);
        // compute weights
        beta = dot( dXv, w) * invdet;
        gamma = dot( wXu, dRay) * invdet;
        alpha2 = 1.0 - ( beta + gamma);
        // compute color
        color = decodeColor( inColors.y) * alpha2 + decodeColor( inColors.x) * beta + decodeColor( inColors.z) * gamma;
        
        // ========== END compute color ==========
        // uniform color
        //color = vec3( 0.0, 0.75, 1.0);
        //color = vec3( texCoord2.xy, 0.0);
        //color = vec3( 0.8, 0.0, 0.2);
        //color = vec3( 0.19, 0.52, 0.82);
    #ifdef DEBUG_COLOR
        color = vec3( 0.98, 0.0, 0.98); //int
    #endif // DEBUG_COLOR
        
        // phong lighting with directional light
        fragColorInt = vec4( LocalLighting(ray, normal, lightPos.xyz, color), alpha);
        
        // calculate depth
    #ifdef DEPTH
        Ding = vec4(sphereintersection + objPos.xyz, 1.0);
        depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
        depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
    #ifdef OGL_DEPTH_SES
        gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
    #else
        //gl_FragDepth = ( depth + zValues.y) / zValues.z;
        gl_FragDepth = (depth + zValues.y)/( zValues.z + zValues.y);
    #endif // OGL_DEPTH_SES
    #endif // DEPTH
    
        if(puxels_use != 0)
            puxels_store(makePuxel(packUnorm4x8( fragColorInt), normal, gl_FragDepth));	
    }

// EXT fragment =========================================================

    discardExt = false;
    lambda = d1 - sqrt(radicand); 
    sphereintersection = lambda * ray + camPos.xyz;    // intersection point

    pos1 = sphereintersection + objPos.xyz;
    // cut with plane 1
    planeNormal = normalize( cross( inVec1.xyz, inVec2.xyz));
    d = dot( objPos.xyz, planeNormal);
    dist1 = dot( pos1, planeNormal) - d;
    dist2 = dot( inVec3.xyz + objPos.xyz, planeNormal) - d;
    if( ( dist2 < 0.0 && dist1 > 0.0 ) || ( dist2 > 0.0 && dist1 < 0.0 ) ) { discardExt = true; }
    if(!discardExt) {
        // cut with plane 2
        planeNormal = normalize( cross( inVec2.xyz, inVec3.xyz));
        d = dot( objPos.xyz, planeNormal);
        dist1 = dot( pos1, planeNormal) - d;
        dist2 = dot( inVec1.xyz + objPos.xyz, planeNormal) - d;
        if( ( dist2 < 0.0 && dist1 > 0.0 ) || ( dist2 > 0.0 && dist1 < 0.0 ) ) { discardExt = true; }
    }
    if(!discardExt) {
        // cut with plane 3
        planeNormal = normalize( cross( inVec1.xyz, inVec3.xyz));
        d = dot( objPos.xyz, planeNormal);
        dist1 = dot( pos1, planeNormal) - d;
        dist2 = dot( inVec2.xyz + objPos.xyz, planeNormal) - d;
        if( ( dist2 < 0.0 && dist1 > 0.0 ) || ( dist2 > 0.0 && dist1 < 0.0 ) ) { discardExt = true; }
    }

    // Singularity handling:
    if(!discardExt) {
        numProbes = min( int(texCoord1.x), 16);
        if( numProbes > 0 )
        {
            for( i = 0; i < numProbes; i++ )
            {
                probePos = texture2D( tex, ( texCoord1.yz + vec2( 0.25, 0.25) + vec2( float( i), 0.0))*texOffset).xyz;
                if( dot1( probePos - objPos.xyz) > 0.1 && ( dot1( pos1 - probePos) < squarRad ) ) { discardExt = true; }
            }
        }
    }
    if(!discardExt) {
        numProbes = min( int(texCoord2.x), 16);
        if( numProbes > 0 )
        {
            for( i = 0; i < numProbes; i++ )
            {
                probePos = texture2D( tex, ( texCoord2.yz + vec2( 0.25, 0.25) + vec2( float( i), 0.0))*texOffset).xyz;
                if( dot1( probePos - objPos.xyz) > 0.1 && ( dot1( pos1 - probePos) < squarRad ) ) { discardExt = true; }
            }
        }
    }
    if(!discardExt) {
        numProbes = min( int(texCoord3.x), 16);
        if( numProbes > 0 )
        {
            for( i = 0; i < numProbes; i++ )
            {
                probePos = texture2D( tex, ( texCoord3.yz + vec2( 0.25, 0.25) + vec2( float( i), 0.0))*texOffset).xyz;
                if( dot1( probePos - objPos.xyz) > 0.1 && ( dot1( pos1 - probePos) < squarRad ) ) { discardExt = true; }
            }
        }
    }

    if(!discardExt) {
        // "calc" normal at intersection point
        normal = - sphereintersection / rad;
        if(flipNormals == 1) {
            normal *= (-1.0);
        }
    #ifdef SMALL_SPRITE_LIGHTING
        normal = mix(-ray, normal, lightPos.w);
    #endif // SMALL_SPRITE_LIGHTING

        // ========== START compute color ==========
        // compute auxiliary direction vectors
        u = inVec1.xyz - inVec2.xyz;
        v = inVec3.xyz - inVec2.xyz;
        // base point and direction of ray from the origin to the intersection point
        w = -inVec2.xyz;
        dRay = normalize( sphereintersection);
        // cross products for computing the determinant
        wXu = cross( w, u);
        dXv = cross( dRay, v);
        // compute inverse determinant
        invdet = 1.0 / dot( dXv, u);
        // compute weights
        beta = dot( dXv, w) * invdet;
        gamma = dot( wXu, dRay) * invdet;
        alpha2 = 1.0 - ( beta + gamma);
        // compute color
        color = decodeColor( inColors.y) * alpha2 + decodeColor( inColors.x) * beta + decodeColor( inColors.z) * gamma;
        // ========== END compute color ==========

        // uniform color
        //color = vec3( 0.0, 0.75, 1.0);
        //color = vec3( texCoord2.xy, 0.0);
        //color = vec3( 0.8, 0.0, 0.2);
        //color = vec3( 0.19, 0.52, 0.82);
    #ifdef DEBUG_COLOR
        color = vec3( 0.98, 0.98, 0.0); // ext
    #endif // DEBUG_COLOR
        
        // phong lighting with directional light
        fragColorExt = vec4( LocalLighting(ray, normal, lightPos.xyz, color), alpha); // gl_FragColor
        
        // calculate depth
    #ifdef DEPTH
        Ding = vec4(sphereintersection + objPos.xyz, 1.0);
        depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
        depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
    #ifdef OGL_DEPTH_SES
        gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
    #else
        //gl_FragDepth = ( depth + zValues.y) / zValues.z;
        gl_FragDepth = (depth + zValues.y)/( zValues.z + zValues.y);
    #endif // OGL_DEPTH_SES
    #endif // DEPTH

        gl_FragColor = fragColorExt;
    
        if(puxels_use != 0)
            puxels_store(makePuxel(packUnorm4x8( fragColorExt), normal, gl_FragDepth));	
    }

    if(discardExt && discardInt) { discard; }
}
-->
      </snippet>
    </shader>

    <shader name="sphericaltriangleFragmentOR">
      <snippet type="version">130</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet type="string">
        <!--
#extension GL_EXT_gpu_shader4 : enable

uniform vec4 viewAttr;
uniform vec3 zValues;
uniform vec3 fogCol;
uniform vec2 texOffset;
// texture sampler
uniform sampler2D tex;
uniform float alpha = 0.5;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;

varying vec4 inVec1;
varying vec4 inVec2;
varying vec4 inVec3;
varying vec3 inColors;

varying vec3 texCoord1;
varying vec3 texCoord2;
varying vec3 texCoord3;

-->
      </snippet>
      <snippet name="decodecolor"/>
      <snippet name="dot1"/>
      <snippet type="string">
        <!--

void main(void) {
    vec4 coord;
    vec3 ray;
    float lambda;
    float rad = inVec1.w;
    float squarRad = inVec2.w;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    
    // transform fragment coordinates from view coordinates to object coordinates.
    coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;
    coord -= objPos; // ... and to glyph space

    // calc the viewing ray
    ray = normalize(coord.xyz - camPos.xyz);

    // calculate the geometry-ray-intersection
    float d1 = -dot(camPos.xyz, ray);                       // projected length of the cam-sphere-vector onto the ray
    float d2s = dot(camPos.xyz, camPos.xyz) - d1 * d1;      // off axis of cam-sphere-vector and ray
    float radicand = squarRad - d2s;                        // square of difference of projected length and lambda
    
    if (radicand < 0.0) { discard; }
    
    lambda = d1 + sqrt(radicand);                           // lambda
    vec3 sphereintersection = lambda * ray + camPos.xyz;    // intersection point

    // compute the actual position of the intersection with the sphere
    vec3 pos1 = sphereintersection + objPos.xyz;
    // cut with plane 1
    vec3 planeNormal = normalize( cross( inVec1.xyz, inVec2.xyz));
    float d = dot( objPos.xyz, planeNormal);
    float dist1 = dot( pos1, planeNormal) - d;
    float dist2 = dot( inVec3.xyz + objPos.xyz, planeNormal) - d;
    if( ( dist2 < 0.0 && dist1 > 0.0 ) || ( dist2 > 0.0 && dist1 < 0.0 ) ) { discard; }
    // cut with plane 2
    planeNormal = normalize( cross( inVec2.xyz, inVec3.xyz));
    d = dot( objPos.xyz, planeNormal);
    dist1 = dot( pos1, planeNormal) - d;
    dist2 = dot( inVec1.xyz + objPos.xyz, planeNormal) - d;
    if( ( dist2 < 0.0 && dist1 > 0.0 ) || ( dist2 > 0.0 && dist1 < 0.0 ) ) { discard; }
    // cut with plane 3
    planeNormal = normalize( cross( inVec1.xyz, inVec3.xyz));
    d = dot( objPos.xyz, planeNormal);
    dist1 = dot( pos1, planeNormal) - d;
    dist2 = dot( inVec2.xyz + objPos.xyz, planeNormal) - d;
    if( ( dist2 < 0.0 && dist1 > 0.0 ) || ( dist2 > 0.0 && dist1 < 0.0 ) ) { discard; }
    // discard the point if it is eaten away by one of the neighbouring probes
    // ==> check first, if one of the probes is nearly dual to the object position
    /*
    if( ( dot1( inProbe1.xyz - objPos.xyz) > 0.1 && ( dot1( pos1 - inProbe1.xyz) < squarRad ) ) || 
        ( dot1( inProbe2.xyz - objPos.xyz) > 0.1 && ( dot1( pos1 - inProbe2.xyz) < squarRad ) ) || 
            ( dot1( inProbe3.xyz - objPos.xyz) > 0.1 && ( dot1( pos1 - inProbe3.xyz) < squarRad ) ) ||
            ( dot1( pos1 - dualProbe) < inVec3.w ) ) { discard; }
    */
    int i;
    vec3 probePos;
    int numProbes = min( int(texCoord1.x), 32);
    if( numProbes > 0 ) {
        for( i = 0; i < numProbes; i++ ) {
            probePos = texelFetch2D( tex, ivec2( texCoord1.yz) + ivec2( i, 0), 0).xyz;
            if( dot1( probePos - objPos.xyz) > 0.1 && ( dot1( pos1 - probePos) < squarRad ) ) { discard; }
        }
    }
    numProbes = min( int(texCoord2.x), 16);
    if( numProbes > 0 )
    {
        for( i = 0; i < numProbes; i++ )
        {
            //probePos = texture2D( tex, ( texCoord2.yz + vec2( 0.5, 0.5) + vec2( float( i), 0.0))*texOffset).xyz;
            probePos = texelFetch2D( tex, ivec2( texCoord2.yz) + ivec2( i, 0), 0).xyz;
            if( dot1( probePos - objPos.xyz) > 0.1 && ( dot1( pos1 - probePos) < squarRad ) ) { discard; }
        }
    }
    numProbes = min( int(texCoord3.x), 16);
    if( numProbes > 0 )
    {
        for( i = 0; i < numProbes; i++ )
        {
            //probePos = texture2D( tex, ( texCoord3.yz + vec2( 0.5, 0.5) + vec2( float( i), 0.0))*texOffset).xyz;
            probePos = texelFetch2D( tex, ivec2( texCoord3.yz) + ivec2( i, 0), 0).xyz;
            if( dot1( probePos - objPos.xyz) > 0.1 && ( dot1( pos1 - probePos) < squarRad ) ) { discard; }
        }
    }
    // "calc" normal at intersection point
    vec3 normal = -sphereintersection / rad;
#ifdef SMALL_SPRITE_LIGHTING
    normal = mix(-ray, normal, lightPos.w);
#endif // SMALL_SPRITE_LIGHTING

    // ========== START compute color ==========
    // compute auxiliary direction vectors
    vec3 u = inVec1.xyz - inVec2.xyz;
    vec3 v = inVec3.xyz - inVec2.xyz;
    // base point and direction of ray from the origin to the intersection point
    vec3 w = -inVec2.xyz;
    vec3 dRay = normalize( sphereintersection);
    // cross products for computing the determinant
    vec3 wXu = cross( w, u);
    vec3 dXv = cross( dRay, v);
    // compute interse determinant
    float invdet = 1.0 / dot( dXv, u);
    // compute weights
    float beta = dot( dXv, w) * invdet;
    float gamma = dot( wXu, dRay) * invdet;
    float alpha2 = 1.0 - ( beta + gamma);
    // compute color
    vec3 color = decodeColor( inColors.y) * alpha2 + decodeColor( inColors.x) * beta + decodeColor( inColors.z) * gamma;
#ifdef FLATSHADE_SES
    if( alpha2 > beta && alpha2 > gamma )
        color = decodeColor( inColors.y);
    else if( beta > alpha2 && beta > gamma )
        color = decodeColor( inColors.x);
    else
        color = decodeColor( inColors.z);
#endif // FLATSHADE_SES
    // ========== END compute color ==========
    // uniform color
    //color = vec3( 0.0, 0.75, 1.0);
    //color = vec3( 0.0, 0.6, 0.6 ); // for VIS
    //color = vec3( texCoord2.xy, 0.0);
    //color = vec3( 0.8, 0.0, 0.2);
    //color = vec3( 0.19, 0.52, 0.82);

#ifdef COLOR_SES
    color = COLOR_YELLOW;
#endif    
#ifdef SET_COLOR
    color = COLOR1;
#endif

    // phong lighting with directional light
    //gl_FragColor = vec4( LocalLighting(ray, normal, lightPos.xyz, color), 1.0);
    gl_FragData[0] = vec4(color,1.0);
    
    // calculate depth
#ifdef DEPTH
    vec4 Ding = vec4(sphereintersection + objPos.xyz, 1.0);
    float depth = -dot(gl_ModelViewMatrixTranspose[2], Ding);
    //float depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
#ifdef OGL_DEPTH_SES
    
    //gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
    
    // Map near ... far to 0 ... 1
    gl_FragDepth = (depth - zValues.y) / (zValues.z - zValues.y);
    
#else
    
    //gl_FragDepth = ( depth + zValues.y) / zValues.z;
    //gl_FragDepth = (depth + zValues.y)/( zValues.z + zValues.y);
    
    // Map near ... far to 0 ... 1
    gl_FragDepth = (depth - zValues.y) / (zValues.z - zValues.y);

#endif // OGL_DEPTH_SES
#endif // DEPTH

#ifdef FOGGING_SES
    float f = clamp( ( 1.0 - gl_FragDepth)/( 1.0 - zValues.x ), 0.0, 1.0);
    gl_FragData[0].rgb = mix( fogCol, gl_FragData[0].rgb, f);
#endif // FOGGING_SES
    //gl_FragData[0].a = alpha;
    gl_FragData[0].a = 1.0;
    
#ifdef AXISHINTS
    // debug-axis-hints
    vec3 colorX = vec3( 1.0, 1.0, 0.0);
    float mc = min(abs(normal.x), min(abs(normal.y), abs(normal.z)));
    if( abs(normal.x) - 0.05 < abs(normal.z) && abs(normal.x) + 0.05 > abs(normal.z) )
    { gl_FragData[0] = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); }
    if( abs(normal.x) - 0.05 < abs(normal.y) && abs(normal.x) + 0.05 > abs(normal.y) )
    { gl_FragData[0] = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); }
    if( abs(normal.z) - 0.05 < abs(normal.y) && abs(normal.z) + 0.05 > abs(normal.y) )
    { gl_FragData[0] = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); }
    if (mc < 0.05) { gl_FragColor = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); }
#endif // AXISHINTS

    gl_FragData[1] = vec4(normalize(gl_NormalMatrix*normal), 1.0);


}
-->
      </snippet>
    </shader>


    <shader name="puxelsReducedSurfaceRenderVertex">
      <snippet type="version">120</snippet>
      <snippet type="string">
        <!--

varying out vec3 normal;
varying out vec4 color;

void main()
{
  normal = gl_Normal;
  color = gl_Color;
  gl_Position = ftransform();
}
      -->
      </snippet>
    </shader>

    <shader name="puxelsReducedSurfaceRenderFragment">
      <snippet type="version">430</snippet>
      <snippet name="puxels::puxeluniform"/>
      <snippet name="puxels::header"/>
      <snippet name="puxels::data"/>
      <snippet name="puxels::store"/>
      <snippet type="string">
        <!--

smooth in vec3 normal;
smooth in vec4 color;

void main()
{
  puxels_store(makePuxel(packUnorm4x8(color), normal, gl_FragDepth));
}
      -->
      </snippet>
    </shader>


  </namespace>



  //###############################################################################\\
  //###############################################################################\\
  //##                                                                           ##\\
  //##                                                                           ##\\
  //##                                                                           ##\\
  //##              ...  SHADER for BUCKET DEPTH PEELING  ...                    ##\\
  //##                                                                           ##\\
  //##                                                                           ##\\
  //##                                                                           ##\\
  //###############################################################################\\
  //###############################################################################\\




  <namespace name="bdp">
    <snippet name="rootsolver" type="string">
      <!--
// global constants
float doubtol = 0.00000001;      // min
float doubmin = 0.0;             // zero
float doubmax = 1000000000.0;    // max (inf)

// function prototypes
float acos3( float x);
float cubic( float p, float q, float r);
float curoot( float x);
void computeConstants();
int ferrari( float a, float b, float c, float d, out vec4 rts);
int neumark( float a, float b, float c, float d, out vec4 rts);
int quadratic( float b, float c, out vec4 rts, float dis);


/**
*    Solve quartic equation using either quadratic, Ferrari's or Neumark's algorithm.
*
*    input:
*        a, b, c, d - coefficients of equation.
*    output:
*        [return nquar] - number of real roots.
*        rts - array of root values.
*
*    calls:
*        quadratic, ferrari, neumark.
*/
int quartic( float a, float b, float c, float d, out vec4 rts)
{
    int j, k, nq, nr;
    float odd, even;
    vec4 roots;

    if( a < 0.0 )
        odd = -a;
    else
        odd = a;
    if( c < 0.0 )
        odd -= c;
    else
        odd += c;
    if( b < 0.0 )
        even = -b;
    else
        even = b;
    if( d < 0.0 )
        even -= d;
    else
        even += d;
    
    if( odd < even*doubtol )
    {
        nq = quadratic( b, d, roots, b*b-4.0*d);
        j = 0;
        if( nq == 1 )
        {
            if( roots.x > 0.0 )
            {
                rts.x = sqrt( roots.x);
                rts.y = -rts.x;
                ++j; ++j;
            }
        }
        else if( nq == 2 )
        {
            if( roots.x > 0.0 )
            {
                rts.x = sqrt( roots.x);
                rts.y = -rts.x;
                ++j; ++j;
            }
            if( roots.y > 0.0 )
            {
                rts.z = sqrt( roots.y);
                rts.w = -rts.z;
                ++j; ++j;
            }
        }
        nr = j;
    }
    else
    {
        if( a < 0.0 )
            k = 1;
        else
            k = 0;
        if( b < 0.0 )
            k += k+1;
        else
            k +=k; 
        if( c < 0.0 )
            k += k+1;
        else
            k +=k; 
        if( d < 0.0 )
            k += k+1;
        else
            k +=k; 
        
        if( k == 0 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 1 ) nr = neumark( a, b, c, d, rts);
        else if( k == 2 ) nr = neumark( a, b, c, d, rts);
        else if( k == 3 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 4 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 5 ) nr = neumark( a, b, c, d, rts);
        else if( k == 6 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 7 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 8 ) nr = neumark( a, b, c, d, rts);
        else if( k == 9 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 10 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 11 ) nr = neumark( a, b, c, d, rts);
        else if( k == 12 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 13 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 14 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 15 ) nr = ferrari( a, b, c, d, rts);
    }
    return nr;
} // ===== quartic =====

/**
*    compute constant values
*/
void computeConstants()
{
    int j;
    doubtol = 1.0;
    for( j = 1; 1.0+doubtol > 1.0; ++j )
    {
        doubtol *= 0.5;
    }
    doubtol = sqrt( doubtol);
    
    doubmin = 0.5;
    for( j = 1; j <= 100; ++j )
    {
        doubmin = doubmin*doubmin;
        if( (doubmin*doubmin) <= (doubmin*doubmin*0.5) )
            break;
    }
    doubmax = 0.7/sqrt( doubmin);
} // ===== setconstants =====

/**
*    solve the quartic equation
*        x**4 + a*x**3 + b*x**2 + c*x + d = 0
*
*    input:
*        a, b, c, d - coefficients of equation.
*    output:
*        [return nquar] - number of real roots.
*        rts - array of root values.
*
*    calls:
*        cubic
*        quadratic
*/
int ferrari( float a, float b, float c, float d, out vec4 rts)
{
    rts = vec4( 0.0, 0.0, 0.0, 0.0);
    
    int nquar, n1, n2;
    float asq, ainv2;
    vec4 v1, v2;
    float p, q, r;
    float y;
    float e, f, esq, fsq, ef;
    float g, gg, h, hh;

    asq = a*a;

    p = b;
    q = a * c - 4.0 * d;
    r = ( asq - 4.0 * b) * d + c*c;
    y = cubic( p, q, r);

    esq = 0.25 * asq - b - y;
    if( esq < 0.0 )
        return(0);
    else
    {
        fsq = 0.25*y*y - d;
        if( fsq < 0.0 )
            return 0;
        else
        {
            ef = -(0.25*a*y + 0.5*c);
            if( ((a > 0.0) && (y > 0.0) && (c > 0.0))
                || ((a > 0.0) && (y < 0.0) && (c < 0.0))
                || ((a < 0.0) && (y > 0.0) && (c < 0.0))
                || ((a < 0.0) && (y < 0.0) && (c > 0.0))
                ||  (a == 0.0) || (y == 0.0) || (c == 0.0) )
            // use ef
            {
                if( (b < 0.0) && (y < 0.0) && (esq > 0.0) )
                {
                    e = sqrt( esq);
                    f = ef/e;
                }
                else if( (d < 0.0) && (fsq > 0.0) )
                {
                    f = sqrt( fsq);
                    e = ef/f;
                }
                else
                {
                    e = sqrt( esq);
                    f = sqrt( fsq);
                    if( ef < 0.0 ) f = -f;
                }
            }
            else
            {
                e = sqrt( esq);
                f = sqrt( fsq);
                if( ef < 0.0 ) f = -f;
            }
            // note that e >= 0.0
            ainv2 = a*0.5;
            g = ainv2 - e;
            gg = ainv2 + e;
            if( ((b > 0.0) && (y > 0.0))
                || ((b < 0.0) && (y < 0.0)) )
            {
                if( ( a > 0.0) && (e != 0.0) )
                    g = (b + y)/gg;
                else if( e != 0.0 )
                    gg = (b + y)/g;
            }
            if( (y == 0.0) && (f == 0.0) )
            {
                h = 0.0;
                hh = 0.0;
            }
            else if( ((f > 0.0) && (y < 0.0))
                || ((f < 0.0) && (y > 0.0)) )
            {
                hh = -0.5*y + f;
                h = d/hh;
            }
            else
            {
                h = -0.5*y - f;
                hh = d/h;
            }
            n1 = quadratic( gg, hh, v1, gg*gg - 4.0 * hh);
            n2 = quadratic( g, h, v2, g*g - 4.0 * h);
            nquar = n1 + n2;
            rts.x = v1.x;
            rts.y = v1.y;
            if( n1 == 0 )
            {
                rts.x = v2.x;
                rts.y = v2.y;
            }
            else
            {
                rts.z = v2.x;
                rts.w = v2.y;
            }
            return nquar;
        }
    }
} // ===== ferrari =====


/**
*    solve the quartic equation
*        x**4 + a*x**3 + b*x**2 + c*x + d = 0
*
*    input:
*        a, b, c, e - coefficients of equation.
*
*    output:
*        [return nquar] - number of real roots.
*        rts - array of root values.
*
*     calls:
*        cubic
*        quadratic
*/
int neumark( float a, float b, float c, float d, out vec4 rts)
{
    int nquar, n1, n2;
    float y, g, gg, h, hh, gdis, gdisrt, hdis, hdisrt, g1, g2, h1, h2;
    float bmy, gerr, herr, y4, d4, bmysq;
    vec4 v1, v2;
    float asq;
    float p,q,r;
    float hmax,gmax;

    asq = a*a ;

    p = -b*2.0;
    q = b*b + a*c - 4.0*d;
    r = (c - a*b)*c + asq*d;
    y = cubic( p, q, r);

    bmy = b - y;
    y4 = y*4.0;
    d4 = d*4.0;
    bmysq = bmy*bmy ;
    gdis = asq - y4 ;
    hdis = bmysq - d4 ;
    if( (gdis < 0.0) || (hdis < 0.0) )
        return 0;
    else
    {
        g1 = a*0.5;
        h1 = bmy*0.5;
        gerr = asq + y4;
        herr = hdis;
        if( d > 0.0 )
            herr = bmysq + d4;
        if( (y < 0.0) || (herr*gdis > gerr*hdis) )
        {
            gdisrt = sqrt(gdis);
            g2 = gdisrt*0.5;
            if( gdisrt != 0.0 )
                h2 = (a*h1 - c)/gdisrt;
            else
                h2 = 0.0;
        }
        else
        {
            hdisrt = sqrt(hdis);
            h2 = hdisrt*0.5;
            if( hdisrt != 0.0 )
                g2 = (a*h1 - c)/hdisrt;
            else
                g2 = 0.0;
        } 
        //note that in the following, the tests ensure non-zero denominators
        h = h1 - h2 ;
        hh = h1 + h2 ;
        hmax = hh ;
        if( hmax < 0.0 ) hmax = -hmax;
        if( hmax < h ) hmax = h;
        if( hmax < -h ) hmax = -h;
        if( (h1 > 0.0 ) && (h2 > 0.0)) h = d/hh;
        if( (h1 < 0.0 ) && (h2 < 0.0)) h = d/hh;
        if( (h1 > 0.0 ) && (h2 < 0.0)) hh = d/h;
        if( (h1 < 0.0 ) && (h2 > 0.0)) hh = d/h;
        if( h > hmax ) h = hmax;
        if( h < -hmax ) h = -hmax;
        if( hh > hmax ) hh = hmax;
        if( hh < -hmax ) hh = -hmax;

        g = g1 - g2;
        gg = g1 + g2;
        gmax = gg;
        if( gmax < 0.0 ) gmax = -gmax;
        if( gmax < g ) gmax = g;
        if( gmax <  -g ) gmax = -g;
        if( (g1 > 0.0) && (g2 > 0.0) ) g = y/gg;
        if( (g1 < 0.0) && (g2 < 0.0) ) g = y/gg;
        if( (g1 > 0.0) && (g2 < 0.0) ) gg = y/g;
        if( (g1 < 0.0) && (g2 > 0.0) ) gg = y/g;
        if( g > gmax ) g = gmax;
        if( g <  -gmax ) g = -gmax;
        if( gg > gmax ) gg = gmax;
        if( gg <  -gmax ) gg = -gmax;

        n1 = quadratic( gg, hh, v1, gg*gg - 4.0*hh);
        n2 = quadratic( g, h, v2, g*g - 4.0*h);
        nquar = n1+n2;
        rts.x = v1.x;
        rts.x = v1.y;
        if( n1 == 0 )
        {
            rts.x = v2.x;
            rts.y = v2.y;
        }
        else
        {
            rts.z = v2.x;
            rts.w = v2.y;
        }

        return nquar;
    }
} // ===== neumark =====


/**
*    solve the quadratic equation
*        x**2+b*x+c = 0
*
*    input:
*        b, c - coefficients of equation.
*    output:
*        [return nquad] - number of real roots.
*        rts - array of root values.+
*        
*    called by:
*        ferrari
*        neumark
*/
int quadratic( float b, float c, out vec4 rts, float dis)
{
    int nquad;
    float rtdis;

    if( dis >= 0.0 )
    {
        nquad = 2;
        rtdis = sqrt( dis) ;
        if( b > 0.0 )
            rts.x = ( -b - rtdis) * 0.5;
        else
            rts.x = ( -b + rtdis) * 0.5;
        if( rts.x == 0.0 )
            rts.y = -b;
        else
            rts.y = c/rts.x;
    }
    else
    {
        nquad = 0;
        rts.x = 0.0;
        rts.y = 0.0;
    }
    return nquad;
} // ===== quadratic =====


/**
*    find the lowest real root of the cubic equation
*        x**3 + p*x**2 + q*x + r = 0 
*
*    input parameters:
*        p, q, r - coefficients of cubic equation. 
*    output:
*        cubic - a real root.
*
*    calls:
*        acos3
*        curoot
*    called by:
*        ferrari
*        neumark
*/
float cubic( float p, float q, float r)
{    
    int nrts;
    float po3, po3sq, qo3;
    float uo3, u2o3, uo3sq4, uo3cu4;
    float v, vsq, wsq;
    float m, mcube, n;
    float muo3, s, scube, t, cosk, sinsqk;
    float root;

    m = 0.0;
    nrts = 0;
    if( (p > doubmax) || (p <  -doubmax) )
        root = -p;
    else
    {
        if( (q > doubmax) || (q <  -doubmax) )
        {
            if (q > 0.0)
                root = -r/q;
            else
                root = -sqrt( -q);
        }
        else
        {
            if( (r > doubmax) || (r <  -doubmax) )
                root = -curoot( r);
            else
            {
                po3 = p * (1.0/3.0);
                po3sq = po3*po3 ;
                if( po3sq > doubmax )
                    root = -p;
                else
                {
                    v = r + po3*(po3sq + po3sq - q) ;
                    if( (v > doubmax) || (v < -doubmax) )
                        root = -p;
                    else
                    {
                        vsq = v*v ;
                        qo3 = q * (1.0/3.0);
                        uo3 = qo3 - po3sq ;
                        u2o3 = uo3 + uo3 ;
                        if( (u2o3 > doubmax) || (u2o3 < -doubmax) )
                        {
                            if (p == 0.0)
                            {
                                if (q > 0.0)
                                    root = -r/q;
                                else
                                    root = -sqrt( -q);
                            }
                            else
                                root = -q/p;
                        }
                        uo3sq4 = u2o3 * u2o3 ;
                        if( uo3sq4 > doubmax)
                        {
                            if (p == 0.0)
                            {
                                if( q > 0.0 )
                                    root = -r/q;
                                else
                                    root = -sqrt( abs( q));
                            }
                            else
                                root = -q/p;
                        }
                        uo3cu4 = uo3sq4 * uo3;
                        wsq = uo3cu4 + vsq;
                        if( wsq >= 0.0 )
                        {
                            // cubic has one real root
                            nrts = 1;
                            if( v <= 0.0 )
                                mcube = ( -v + sqrt( wsq))*0.5;
                            if( v  > 0.0 )
                                mcube = ( -v - sqrt( wsq))*0.5;
                            m = curoot( mcube);
                            if( m != 0.0 )
                                n = -uo3/m;
                            else
                                n = 0.0;
                            root = m + n - po3;
                        }
                        else
                        {
                            nrts = 3;
                            // cubic has three real roots
                            if( uo3 < 0.0 )
                            {
                                muo3 = -uo3;
                                s = sqrt( muo3);
                                scube = s*muo3;
                                t =  -v/(scube+scube);
                                cosk = acos3( t);
                                if( po3 < 0.0 )
                                    root = (s+s)*cosk - po3;
                                else
                                {
                                    sinsqk = 1.0 - cosk*cosk;
                                    if( sinsqk < 0.0 )
                                        sinsqk = 0.0;
                                    root = s*( -cosk - sqrt( 3.0)*sqrt( sinsqk)) - po3;
                                }
                            }
                            else
                                // cubic has multiple root
                                root = curoot( v) - po3;
                        }
                    }
                }
            }
        }
    }
    return root;
} // ===== cubic =====


/** 
*    find cube root of x.
*
*    called by:
*        cubic 
*/
float curoot( float x)
{
    float value;
    float absx;
    int neg;

    neg = 0;
    absx = x;
    if( x < 0.0 )
    {
        absx = -x;
        neg = 1;
    }
    value = exp( log( absx)*(1.0/3.0));
    if( neg == 1 )
        value = -value;
    return value;
} // ===== curoot =====


/** 
* find cos(acos(x)/3) 
*
* called by:
*    cubic 
*/
float acos3( float x)
{
    return cos( acos( x)*(1.0/3.0));
} // ===== acos3 =====


/**
*    solve the quartic equation
*        x**4 + a*x**3 + b*x**2 + c*x + d = 0
*
*    input:
*        a, b, c, d - coefficients of equation.
*    output:
*        [return nquar] - number of real roots.
*        rts - array of root values.
*
*    calls:
*        cubic
*        quadratic
*/
int simpleFerrari( float a, float b, float c, float d, out vec4 rts)
{
    int nquar, n1, n2;
    float asq, y;
    vec4 v1, v2;
    float p, q, r;
    float e, f, esq, fsq;
    float g, gg, h, hh;

    asq = a*a;

    p = -b;
    q = a*c-4.0*d;
    r = -asq*d - c*c + 4.0*b*d;
    y = cubic( p, q, r);

    esq = 0.25*asq - b + y;
    fsq = 0.25*y*y - d;
    if( esq < 0.0 )
        return 0;
    else
    {
        if( fsq < 0.0 )
            return 0;
        else
        {
            e = sqrt( esq);
            f = sqrt( fsq);
            g = 0.5*a - e;
            h = 0.5*y - f;
            gg = 0.5*a + e;
            hh = 0.5*y + f;
            n1 = quadratic( gg, hh, v1, gg*gg - 4.0*hh) ;
            n2 = quadratic( g, h, v2, g*g - 4.0*h) ;
            nquar = n1 + n2;
            rts.x = v1.x;
            rts.y = v1.y;
            if( n1 == 0 )
            {
                rts.x = v2.x;
                rts.y = v2.y;
            }
            else
            {
                rts.z = v2.x;
                rts.w = v2.y;
            }
            return nquar;
        }
    }
} // ===== simple =====


/**
*    solve the quartic equation
*        x**4 + a*x**3 + b*x**2 + c*x + d = 0
*
*    input:
*        a, b, c, d - coefficients of equation.
*    output:
*        [return nquar] - number of real roots.
*        rts - array of root values.
*
*    calls:
*        cubic
*        quadratic
*/
int descartes( float a, float b, float c, float d, out vec4 rts)
{
    int nrts;
    int r1,r2;
    vec4 v1, v2;
    float y;
    float p,q,r;
    float A,B,C;
    float m,n1,n2;
    float d3o8,d3o256;
    float inv8,inv16;
    float asq;
    float Binvm;

    d3o8 = 3.0/8.0;
    inv8 = 1.0/8.0;
    inv16 = 1.0/16.0;
    d3o256 = 3.0/256.0;

    asq = a*a;

    A = b - asq*d3o8;
    B = c + a*(asq*inv8 - b*0.5);
    C = d + asq*(b*inv16 - asq*d3o256) - a*c*0.25;

    p = 2.0*A;
    q = A*A - 4.0*C;
    r = -B*B;

    y = cubic( p, q, r) ;
    if( y <= 0.0 ) 
        nrts = 0;
    else
    {
        m = sqrt( y);
        Binvm = B/m;
        n1 = ( y + A + Binvm)*0.5;
        n2 = ( y + A - Binvm)*0.5;
        r1 = quadratic(-m, n1, v1, y-4.0*n1);
        r2 = quadratic( m, n2, v2, y-4.0*n2);
        rts.x = v1.x-a*0.25;
        rts.y = v1.y-a*0.25;
        if( r1 == 0 )
        {
            rts.x = v2.x-a*0.25;
            rts.y = v2.y-a*0.25;
        }
        else
        {
            rts.z = v2.x-a*0.25;
            rts.w = v2.y-a*0.25;
        }
        nrts = r1+r2;
    } 
    return nrts;
} // ===== descartes =====
-->
    </snippet>

    <snippet name="decodecolor" type="string">
      <!--

vec3 decodeColor( float codedColor)
{
    float col = codedColor;
    float red, green;
    if( col >= 1000000.0 )
        red = floor( col / 1000000.0);
    else
        red = 0.0;
    col = col - ( red * 1000000.0);
    if( col >= 1000.0)
        green = floor( col / 1000.0);
    else
        green = 0.0;
    col = col - ( green * 1000.0);
    if( col > 256.0 )
        col = 0.0;
    return vec3( red / 255.0, green / 255.0, col / 255.0 );
}

-->
    </snippet>

    <snippet name="dot1" type="string">
      <!--

float dot1( vec3 v1)
{
    return dot( v1, v1);
}

-->
    </snippet>

    <snippet name="codeColorBDP" type="string">
      <!--

#extension GL_EXT_gpu_shader4 : enable

float codeColorBDP( vec4 fragColor)
{
    vec4 fc = clamp(fragColor, vec4(0.0), vec4(1.0));
    float codedColor;

    uint r = uint(fc.r*255.0) << uint(24);
    uint g = uint(fc.g*255.0) << uint(16);
    uint b = uint(fc.b*255.0) << uint(8);
    uint a = uint( 0); //uint(fc.a*127.0);

    codedColor = float(r | g | b | a);

    return codedColor;
}


vec4 decodeColorBDP( float codedColor)
{
    uint cc = uint(codedColor);
    vec4 decodedColor;

    decodedColor.r = float(cc >> uint(24)) / 255.0;
    decodedColor.g = float((cc << uint(8))  >> uint(24)) / 255.0;
    decodedColor.b = float((cc << uint(16)) >> uint(24)) / 255.0;
    decodedColor.a = 0.0; //float((cc << uint(24)) >> uint(24)) / 127.0;

    return decodedColor;
}

-->
    </snippet>

    <snippet name="simpleLighting" type="string">
      <!--
// TODO: Implementation is wrong! Does positional Lighting instead of directional lighting!

// ray:      the eye to fragment ray vector
// normal:   the normal of this fragment
// lightPos: the position of the light source
// color:    the base material color
vec3 LocalLightingExt(const in vec3 ray, const in vec3 normal, const in vec3 lightPos, const in vec3 color) {
    // TODO: rewrite!
    vec3 lightDir = normalize(lightPos);

    vec4 lightparams = vec4(0.2, 0.8, 0.9, 10.0);
#define LIGHT_AMBIENT lightparams.x
#define LIGHT_DIFFUSE lightparams.y
#define LIGHT_SPECULAR lightparams.z
#define LIGHT_EXPONENT lightparams.w
    float nDOTl = dot(normal, lightDir);

    vec3 r = normalize(2.0 * vec3(nDOTl) * normal - lightDir);
    return LIGHT_AMBIENT * color 
        + LIGHT_DIFFUSE * color * max(nDOTl, 0.0);
        //+ LIGHT_SPECULAR * vec3(pow(max(dot(r, -ray), 0.0), LIGHT_EXPONENT));
}

vec3 LocalLightingInt(const in vec3 ray, const in vec3 normal, const in vec3 lightPos, const in vec3 color) {

    vec3 lightDir = normalize(lightPos);

    vec4 lightparams = vec4(0.2, 0.8, 0.9, 10.0);
#define LIGHT_AMBIENT lightparams.x
#define LIGHT_DIFFUSE lightparams.y
#define LIGHT_SPECULAR lightparams.z
#define LIGHT_EXPONENT lightparams.w
    float nDOTl = dot(normal, lightDir);

    vec3 r = normalize(2.0 * vec3(nDOTl) * normal - lightDir);
    return LIGHT_AMBIENT * color 
        + LIGHT_DIFFUSE * color * max(nDOTl, 0.0);
        //+ LIGHT_SPECULAR * vec3(pow(max(dot(r, -ray), 0.0), LIGHT_EXPONENT));
}
-->
    </snippet>

    <shader name="sphereVertex">
      <snippet type="version">120</snippet>
      <snippet name="commondefines"/>
      <snippet type="string">
        <!--
uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)
uniform vec3 zValues;
uniform vec3 fogCol;

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying float squarRad;
varying float rad;

varying vec3 texCoord;
varying vec4 surfVector;

#ifdef RETICLE
varying vec2 centerFragment;
#endif // RETICLE

attribute vec3 attribTexCoord;
attribute vec4 attribSurfVector;

void main(void) {

    texCoord   = attribTexCoord;
    surfVector = attribSurfVector;

    // remove the sphere radius from the w coordinates to the rad varyings
    vec4 inPos = gl_Vertex;
    rad = inPos.w;
    squarRad = rad * rad;
    inPos.w = 1.0;

    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)

    // calculate cam position
    camPos = gl_ModelViewMatrixInverse[3]; // (C) by Christoph
    camPos.xyz -= objPos.xyz; // cam pos to glyph space

    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = gl_ModelViewMatrixInverse * gl_LightSource[0].position - objPos;
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    lightPos = gl_ModelViewMatrixInverse * normalize( gl_LightSource[0].position);

    // send color to fragment shader
    gl_FrontColor = gl_Color;

    // Sphere-Touch-Plane-Approach
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    vec2 d, p, q, h, dd;

    // get camera orthonormal coordinate system
    vec4 tmp;

#ifdef CALC_CAM_SYS
    // camera coordinate system in object space
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[2];
    vec3 camIn = normalize(tmp.xyz);
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[1];
    vec3 camUp = tmp.xyz;
    vec3 camRight = normalize(cross(camIn, camUp));
    camUp = cross(camIn, camRight);
#endif // CALC_CAM_SYS

    vec2 mins, maxs;
    vec3 testPos;
    vec4 projPos;

    // projected camera vector
    vec3 c2 = vec3(dot(camPos.xyz, camRight), dot(camPos.xyz, camUp), dot(camPos.xyz, camIn));

    vec3 cpj1 = camIn * c2.z + camRight * c2.x;
    vec3 cpm1 = camIn * c2.x - camRight * c2.z;

    vec3 cpj2 = camIn * c2.z + camUp * c2.y;
    vec3 cpm2 = camIn * c2.y - camUp * c2.z;

    d.x = length(cpj1);
    d.y = length(cpj2);

    dd = vec2(1.0) / d;

    p = squarRad * dd;
    q = d - p;
    h = sqrt(p * q);
    //h = vec2(0.0);

    p *= dd;
    h *= dd;

    cpj1 *= p.x;
    cpm1 *= h.x;
    cpj2 *= p.y;
    cpm2 *= h.y;

    // TODO: rewrite only using four projections, additions in homogenous coordinates and delayed perspective divisions.
    testPos = objPos.xyz + cpj1 + cpm1;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = projPos.xy;
    maxs = projPos.xy;

    testPos -= 2.0 * cpm1;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos = objPos.xyz + cpj2 + cpm2;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos -= 2.0 * cpm2;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    gl_PointSize = max((maxs.x - mins.x) * winHalf.x, (maxs.y - mins.y) * winHalf.y) * 0.5;

#ifdef SMALL_SPRITE_LIGHTING
    // for normal crowbaring on very small sprites
    lightPos.w = (clamp(gl_PointSize, 1.0, 5.0) - 1.0) / 4.0;
#endif // SMALL_SPRITE_LIGHTING
    
#ifdef RETICLE
    centerFragment = gl_Position.xy / gl_Position.w;
#endif // RETICLE

    // gl_PointSize = 32.0;
}
-->
      </snippet>
    </shader>

    <shader name="sphereFragment">
      <snippet type="version">120</snippet>
      <snippet name="commondefines"/>
      <snippet name="codeColorBDP"/>
      <snippet name="simpleLighting"/>
      <snippet type="string">
        <!--

uniform vec4 viewAttr;
uniform vec3 zValues;
uniform vec3 fogCol;
uniform float alpha;
uniform float alphaGradient;
uniform int DPmode = 0;
uniform int geometryPass = 1;
uniform int flipNormals = 0;

uniform vec2 texOffset;
uniform sampler2D depthBuffer;

uniform sampler2D equalHistTex0;
uniform sampler2D equalHistTex1;
uniform sampler2D equalHistTex2;
uniform sampler2D equalHistTex3;
uniform sampler2D equalHistTex4;
uniform sampler2D equalHistTex5;
uniform sampler2D equalHistTex6;
uniform sampler2D equalHistTex7;

uniform vec2 texOffsetCutPlanes;
uniform sampler2D cutPlaneTex;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying float squarRad;
varying float rad;
varying vec3 texCoord;
varying vec4 surfVector;

void main(void) {

    float lambda, d1, d2s, radicand, f, depthW, depth, mc;
    vec3 ray, planeNormal, planePos, surfPos, sphereintersection, normal, color, colorX;
    vec4 coord, Ding;

    int i, j, rt;
    vec2 texCoordHist;
    vec3 minmaxDepth;
    vec4 fragColorInt, fragColorExt, histogram;
    float bucketInt, bucketExt, tmpIntDepth, lastDepth, fragData;
    bool discardInt, discardExt, breakFlag;

    if(DPmode != 0) {
        // get min and max depth of pixel location
         minmaxDepth.xy = texture2D( depthBuffer, (gl_FragCoord.xy + vec2( 0.25, 0.25))*texOffset).xy;
         minmaxDepth.x = minmaxDepth.x - 1.0;
         minmaxDepth.z = (minmaxDepth.y + minmaxDepth.x);
        // init fragment data with zero
        for(i = 0; i < gl_MaxDrawBuffers; ++i) {
            gl_FragData[i] = vec4(0.0, 0.0, 0.0, 0.0);
        }
    }

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);

    // transform fragment coordinates from view coordinates to object coordinates.
    coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;
    coord -= objPos; // ... and to glyph space

    // calc the viewing ray
    ray = normalize(coord.xyz - camPos.xyz);

    // calculate the geometry-ray-intersection
    d1 = -dot(camPos.xyz, ray);                           // projected length of the cam-sphere-vector onto the ray
    d2s = dot(camPos.xyz, camPos.xyz) - d1 * d1;          // off axis of cam-sphere-vector and ray
    radicand = squarRad - d2s;                            // square of difference of projected length and lambda
    
    if (radicand < 0.0) { discard; }

// INT fragment =========================================================
    lambda = d1 + sqrt(radicand);                              
    sphereintersection = lambda * ray + camPos.xyz;      // interior intersection point
    discardInt = false;

    // clip fragment out of surfVectors max range
    surfPos = sphereintersection - surfVector.xyz;
    if(dot(surfPos, surfPos) > surfVector.w) { discardInt = true; }

    if(!discardInt) {
        // clip sphereintersection against edge cutting planes
        for(i = 0; i < int(texCoord.x); i++) {
            planePos = texture2D( cutPlaneTex, ( texCoord.yz + vec2( 0.5, 0.5) + vec2( float( i), 0.0))*texOffsetCutPlanes).xyz;
            planeNormal = normalize(planePos);
            if(dot(planeNormal, (sphereintersection - planePos)) > 0.0) { discardInt = true; }
            if(discardInt) break;
        }
    }

    if(!discardInt) {
        // "calc" normal at intersection point
        normal = sphereintersection / rad;
        if(flipNormals == 1) {
            normal *= (-1.0);
        }
    #ifdef SMALL_SPRITE_LIGHTING
        normal = mix(-ray, normal, lightPos.w);
    #endif // SMALL_SPRITE_LIGHTING

        // chose color for lighting
        color = gl_Color.rgb;
        // uniform color
        //color = vec3( 0.98, 0.23, 0.0); // for VIS
        //color = vec3( 0.17, 0.5, 0.8);
        //color = vec3( 0.19, 0.52, 0.82);
    #ifdef DEBUG_COLOR
        color = vec3( 0.98, 0.0, 0.98); // int
    #endif // DEBUG_COLOR
#ifdef SFB_DEMO
    color = vec3(  0.70f, 0.8f, 0.4f); // int
#endif

        // phong lighting with directional light
        fragColorInt = vec4(LocalLightingInt(ray, normal, lightPos.xyz, color), 1.0); // gl_FragColor

        // calculate depth
    #ifdef DEPTH
        Ding = vec4(sphereintersection + objPos.xyz, 1.0);
        depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
        depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
    #ifdef OGL_DEPTH_SES
        gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
    #else
        //gl_FragDepth = ( depth + zValues.y) / zValues.z;
        gl_FragDepth = (depth + zValues.y)/( zValues.z + zValues.y);
    #endif // OGL_DEPTH_SES
    #endif // DEPTH

    #ifdef FOGGING_SES
        f = clamp( ( 1.0 - gl_FragDepth)/( 1.0 - zValues.x ), 0.0, 1.0);
        fragColorInt.rgb = mix( fogCol, fragColorInt.rgb, f); // gl_FragColor.rgb
    #endif // FOGGING_SES

        fragColorInt.a = 1.0;

    #ifdef AXISHINTS
        // debug-axis-hints
        colorX = vec3( 1.0, 1.0, 0.0);
        mc = min(abs(normal.x), min(abs(normal.y), abs(normal.z)));
        if( abs(normal.x) - 0.05 < abs(normal.z) && abs(normal.x) + 0.05 > abs(normal.z) )
        { fragColorInt = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); } // gl_FragColor
        if( abs(normal.x) - 0.05 < abs(normal.y) && abs(normal.x) + 0.05 > abs(normal.y) )
        { fragColorInt = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); } // gl_FragColor
        if( abs(normal.z) - 0.05 < abs(normal.y) && abs(normal.z) + 0.05 > abs(normal.y) )
        { fragColorInt = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); } // gl_FragColor
        if (mc < 0.05) { fragColorInt = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); } // gl_FragColor
    #endif // AXISHINTS

        // ============ sort fragment into right bucket ============
        // USE OGL_DEPTH_SES depth has to be in [0.0, 1.0]
        //if((gl_FragDepth < -minmaxDepth.x) || (gl_FragDepth > minmaxDepth.y)) { discard; }
        // minmaxDepth.x is the negative min depth !!!
        if(DPmode == 0) {
            gl_FragData[0] = fragColorInt;
        } else if(DPmode == 1) {
            // calculate bucket pair (16 pairs -> 32 depth values)
            bucketInt = floor(16.0*(gl_FragDepth + minmaxDepth.x) / minmaxDepth.z);
            // index of render target
            rt = int(floor(bucketInt/2.0));
            // choose right pair in render target
            if(mod(int(bucketInt), 2) == 0) {
                gl_FragData[rt].x = 1.0 - gl_FragDepth;
                gl_FragData[rt].y = gl_FragDepth;
            } else {
                gl_FragData[rt].z = 1.0 - gl_FragDepth;
                gl_FragData[rt].w = gl_FragDepth;
            }
            tmpIntDepth = gl_FragDepth;
        } else if(DPmode == 2) {
            // calculate right subintervall
            bucketInt = floor(32.0*(gl_FragDepth + minmaxDepth.x) / minmaxDepth.z );
            // choose right component in render target
            gl_FragData[int(floor(bucketInt / 4.0))][int(mod(bucketInt, 4.0))] = codeColorBDP(fragColorInt);
        } else if((geometryPass == 1) && ((DPmode == 3) || (DPmode == 4))) {
            // calculate right subintervall for histogramm
            bucketInt = floor(1024.0*(gl_FragDepth + minmaxDepth.x) / minmaxDepth.z );
            // choose right component in render target
            gl_FragData[int(floor(bucketInt / 128.0))][int(floor(mod(bucketInt, 128.0)/32.0))] = int(1 << int(mod(bucketInt,32.0)));
        } else if((geometryPass == 2) && ((DPmode == 3) || (DPmode == 4))) {
            // search histogram component with right depth intervall
            if(DPmode == 4) {
                fragData = codeColorBDP(fragColorInt);
            } else {
                fragData = gl_FragDepth;
            }
            texCoordHist = (gl_FragCoord.xy + vec2(0.25, 0.25)) * texOffset;
            lastDepth = 0.0;
            breakFlag = false;
            for(i = 0; i < 8; ++i) {
                if(i == 0) { histogram = texture2D(equalHistTex0, texCoordHist); }
                if(i == 1) { histogram = texture2D(equalHistTex1, texCoordHist); }
                if(i == 2) { histogram = texture2D(equalHistTex2, texCoordHist); }
                if(i == 3) { histogram = texture2D(equalHistTex3, texCoordHist); }
                if(i == 4) { histogram = texture2D(equalHistTex4, texCoordHist); }
                if(i == 5) { histogram = texture2D(equalHistTex5, texCoordHist); }
                if(i == 6) { histogram = texture2D(equalHistTex6, texCoordHist); }
                if(i == 7) { histogram = texture2D(equalHistTex7, texCoordHist); }
        
                for(j = 0; j < 4; ++j) {
                    if((gl_FragDepth >= lastDepth) && (gl_FragDepth < histogram[j])) {
                        gl_FragData[i][j] = fragData;
                        breakFlag = true;
                        break;
                    }
                    lastDepth = histogram[j];
                }
                if(breakFlag) break;
            }
        }
    }

// EXT fragment =========================================================
    lambda = d1 - sqrt(radicand);
    sphereintersection = lambda * ray + camPos.xyz;      // exterior intersection point
    discardExt = false;

    // clip fragment out of surfVectors max range
    surfPos = sphereintersection - surfVector.xyz;
    if(dot(surfPos, surfPos) > surfVector.w) { discardExt = true; }

    if(!discardExt) {
        // clip sphereintersection against edge cutting planes
        for(i = 0; i < int(texCoord.x); i++) {
            planePos = texture2D( cutPlaneTex, ( texCoord.yz + vec2( 0.25, 0.25) + vec2( float( i), 0.0))*texOffsetCutPlanes).xyz;
            planeNormal = normalize(planePos);
            if(dot(planeNormal, (sphereintersection - planePos)) > 0.0) {discardExt = true;}
            if(discardExt) break;
        }
    }

    if(!discardExt) {
        // "calc" normal at intersection point
        normal = sphereintersection / rad;
    #ifdef SMALL_SPRITE_LIGHTING
        normal = mix(-ray, normal, lightPos.w);
    #endif // SMALL_SPRITE_LIGHTING

        // chose color for lighting
        color = gl_Color.rgb;
        // uniform color
        //color = vec3( 0.98, 0.23, 0.0); // for VIS
        //color = vec3( 0.17, 0.5, 0.8);
        //color = vec3( 0.19, 0.52, 0.82);
    #ifdef DEBUG_COLOR
        color = vec3( 0.0, 0.98, 0.0); // ext
    #endif // DEBUG_COLOR

        // phong lighting with directional light
        fragColorExt = vec4(LocalLightingExt(ray, normal, lightPos.xyz, color), 1.0); // gl_FragColor

        // calculate depth
    #ifdef DEPTH
        Ding = vec4(sphereintersection + objPos.xyz, 1.0);
        depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
        depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
    #ifdef OGL_DEPTH_SES
        gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
    #else
        //gl_FragDepth = ( depth + zValues.y) / zValues.z;
        gl_FragDepth = (depth + zValues.y)/( zValues.z + zValues.y);
    #endif // OGL_DEPTH_SES
    #endif // DEPTH

    #ifdef FOGGING_SES
        f = clamp( ( 1.0 - gl_FragDepth)/( 1.0 - zValues.x ), 0.0, 1.0);
        fragColorExt.rgb = mix( fogCol, fragColorExt.rgb, f); // gl_FragColor.rgb
    #endif // FOGGING_SES

        fragColorExt.a = 1.0;

    #ifdef AXISHINTS
        // debug-axis-hints
        colorX = vec3( 1.0, 1.0, 0.0);
        mc = min(abs(normal.x), min(abs(normal.y), abs(normal.z)));
        if( abs(normal.x) - 0.05 < abs(normal.z) && abs(normal.x) + 0.05 > abs(normal.z) )
        { fragColorExt = vec4( LocalLightingExt( ray, normal, lightPos.xyz, colorX), 1.0); } // gl_FragColor
        if( abs(normal.x) - 0.05 < abs(normal.y) && abs(normal.x) + 0.05 > abs(normal.y) )
        { fragColorExt = vec4( LocalLightingExt( ray, normal, lightPos.xyz, colorX), 1.0); } // gl_FragColor
        if( abs(normal.z) - 0.05 < abs(normal.y) && abs(normal.z) + 0.05 > abs(normal.y) )
        { fragColorExt = vec4( LocalLightingExt( ray, normal, lightPos.xyz, colorX), 1.0); } // gl_FragColor
        if (mc < 0.05) { fragColorExt = vec4( LocalLightingExt( ray, normal, lightPos.xyz, colorX), 1.0); } // gl_FragColor
    #endif // AXISHINTS

        // ============ sort fragment into right bucket ============
        // USE OGL_DEPTH_SES depth has to be in [0.0, 1.0]
        // minmaxDepth.x is the negative min depth !!!
        //if((gl_FragDepth < -minmaxDepth.x) || (gl_FragDepth > minmaxDepth.y)) { discard; }
        if(DPmode == 0) {
            gl_FragData[0] = fragColorExt;
        } else if(DPmode == 1) {
            // calculate bucket pair (16 pairs -> 32 depth values)
            bucketExt = floor(16.0*(gl_FragDepth + minmaxDepth.x) / minmaxDepth.z);
            // index of render target
            rt = int(floor(bucketExt/2.0));
            // choose right pair in render target
            // (set maximum value because first fragment could have been writing too)
            if(!discardInt && (bucketExt == bucketInt)) {
                if(mod(int(bucketExt), 2) == 0) {
                    gl_FragData[rt].x = max(1.0 - tmpIntDepth, 1.0 - gl_FragDepth);
                    gl_FragData[rt].y = max(tmpIntDepth, gl_FragDepth);
                } else {
                    gl_FragData[rt].z = max(1.0 - tmpIntDepth, 1.0 - gl_FragDepth);
                    gl_FragData[rt].w = max(tmpIntDepth, gl_FragDepth);
                }
            } else {
                if(mod(int(bucketExt), 2) == 0) {
                    gl_FragData[rt].x = 1.0 - gl_FragDepth;
                    gl_FragData[rt].y = gl_FragDepth;
                } else {
                    gl_FragData[rt].z = 1.0 - gl_FragDepth;
                    gl_FragData[rt].w = gl_FragDepth;
                }
            }
        } else if(DPmode == 2) {
            // calculate right subintervall
            bucketExt = floor(32.0*(gl_FragDepth + minmaxDepth.x) / minmaxDepth.z);
            // choose right component in render target
            if(!discardInt && (bucketExt == bucketInt)) {
                if(alphaGradient > 0.0) {
                    fragColorExt = fragColorInt*(1.0 - clamp((2.0 - (float(4*(7-int(floor(bucketExt/4.0)))+(3-int(mod(bucketExt, 4.0)))) / 32.0 * alphaGradient)), 0.0, 1.0)) + fragColorExt;
                } else {
                    fragColorExt = fragColorInt*(1.0 - alpha) + fragColorExt;
                }
                fragColorExt.a = 0.25;
            }
            gl_FragData[int(floor(bucketExt/4.0))][int(mod(bucketExt, 4.0))] = codeColorBDP(fragColorExt);
        } else if((geometryPass == 1) && ((DPmode == 3) || (DPmode == 4))) {
            // calculate right subintervall for histogramm
            bucketExt = floor(1024.0*(gl_FragDepth + minmaxDepth.x) / minmaxDepth.z );
            // choose right component in render target
            if(!discardInt && (bucketInt == bucketExt)) bucketExt -= 1.0;
            gl_FragData[int(floor(bucketExt/128.0))][int(floor(mod(bucketExt, 128.0)/32.0))] = int(1 << int(mod(bucketExt,32.0)));
        } else if((geometryPass == 2) && ((DPmode == 3) || (DPmode == 4))) {
            // search histogram component with right depth intervall
            if(DPmode == 4) {
                fragData = codeColorBDP(fragColorExt);
            } else {
                fragData = gl_FragDepth;
            }
            texCoordHist = (gl_FragCoord.xy + vec2(0.25, 0.25)) * texOffset;
            lastDepth = 0.0;
            breakFlag = false;
            for(i = 0; i < 8; ++i) {
                if(i == 0) { histogram = texture2D(equalHistTex0, texCoordHist); }
                if(i == 1) { histogram = texture2D(equalHistTex1, texCoordHist); }
                if(i == 2) { histogram = texture2D(equalHistTex2, texCoordHist); }
                if(i == 3) { histogram = texture2D(equalHistTex3, texCoordHist); }
                if(i == 4) { histogram = texture2D(equalHistTex4, texCoordHist); }
                if(i == 5) { histogram = texture2D(equalHistTex5, texCoordHist); }
                if(i == 6) { histogram = texture2D(equalHistTex6, texCoordHist); }
                if(i == 7) { histogram = texture2D(equalHistTex7, texCoordHist); }
        
                for(j = 0; j < 4; ++j) {
                    if((gl_FragDepth >= lastDepth) && (gl_FragDepth < histogram[j])) {
                        gl_FragData[i][j] = fragData;
                        breakFlag = true;
                        break;
                    }
                    lastDepth = histogram[j];
                }
                if(breakFlag) break;
            }
        }
    }

    if(discardExt && discardInt) { discard; }
}
-->
      </snippet>
    </shader>

    <shader name="torusVertex">
      <snippet type="version">120</snippet>
      <snippet name="commondefines"/>
      <snippet type="string">
        <!--
uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)
uniform vec3 zValues;
uniform vec3 fogCol;

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

attribute vec3 inParams;         // inner and outer radius of the torus (r and R) and maximum angle
attribute vec4 quatC;             // conjugate quaternion
attribute vec4 inSphere;        // everything inside this sphere (x,y,z,rad) is visible
attribute vec4 inColors;        // coded colors (x,y) and d of plane and maximum distance from plane
attribute vec3 inCuttingPlane;    // cutting plane for 'pie slice'-cutting

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying vec4 radii;
varying vec4 visibilitySphere;

varying vec3 rotMatT0;
varying vec3 rotMatT1; // rotation matrix from the quaternion
varying vec3 rotMatT2;

varying float maxAngle;

varying vec4 colors;
varying vec3 cuttingPlane;

void main(void) {
    const vec4 quatConst = vec4(1.0, -1.0, 0.5, 0.0);
    vec4 tmp, tmp1;

    // remove the sphere radius from the w coordinates to the rad varyings
    vec4 inPos = gl_Vertex;

    radii.x = inParams.x;
    radii.y = radii.x * radii.x;
    radii.z = inParams.y;
    radii.w =  radii.z * radii.z;
    
    maxAngle = inParams.z;
    
    colors = inColors;
    
    inPos.w = 1.0;
    
    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)

    // orientation quaternion to inverse rotation matrix conversion
    // Begin: Holy code!
    tmp = quatC.xzyw * quatC.yxzw;                        // tmp <- (xy, xz, yz, ww)
    tmp1 = quatC * quatC.w;                                    // tmp1 <- (xw, yw, zw, %)
    tmp1.w = -quatConst.z;                                // tmp1 <- (xw, yw, zw, -0.5)

    rotMatT0.xyz = tmp1.wzy * quatConst.xxy + tmp.wxy;    // matrix0 <- (ww-0.5, xy+zw, xz-yw, %)
    rotMatT0.x = quatC.x * quatC.x + rotMatT0.x;                // matrix0 <- (ww+x*x-0.5, xy+zw, xz-yw, %)
    rotMatT0 = rotMatT0 + rotMatT0;                     // matrix0 <- (2(ww+x*x)-1, 2(xy+zw), 2(xz-yw), %)

    rotMatT1.xyz = tmp1.zwx * quatConst.yxx + tmp.xwz;     // matrix1 <- (xy-zw, ww-0.5, yz+xw, %)
    rotMatT1.y = quatC.y * quatC.y + rotMatT1.y;             // matrix1 <- (xy-zw, ww+y*y-0.5, yz+xw, %)
    rotMatT1 = rotMatT1 + rotMatT1;                     // matrix1 <- (2(xy-zw), 2(ww+y*y)-1, 2(yz+xw), %)

    rotMatT2.xyz = tmp1.yxw * quatConst.xyx + tmp.yzw;     // matrix2 <- (xz+yw, yz-xw, ww-0.5, %)
    rotMatT2.z = quatC.z * quatC.z + rotMatT2.z;             // matrix2 <- (xz+yw, yz-xw, ww+zz-0.5, %)
    rotMatT2 = rotMatT2 + rotMatT2;                     // matrix2 <- (2(xz+yw), 2(yz-xw), 2(ww+zz)-1, %)    
    // End: Holy code!

    // rotate and copy the visibility sphere
    visibilitySphere.xyz = rotMatT0 * inSphere.x + rotMatT1 * inSphere.y + rotMatT2 * inSphere.z;
    visibilitySphere.w = inSphere.w;
    
    cuttingPlane = rotMatT0 * inCuttingPlane.x + rotMatT1 * inCuttingPlane.y + rotMatT2 * inCuttingPlane.z;
    
    // calculate cam position
    tmp = gl_ModelViewMatrixInverse[3]; // (C) by Christoph
    tmp.xyz -= objPos.xyz; // cam move
    camPos.xyz = rotMatT0 * tmp.x + rotMatT1 * tmp.y + rotMatT2 * tmp.z;

    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = gl_ModelViewMatrixInverse * gl_LightSource[0].position - objPos;
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    lightPos = gl_ModelViewMatrixInverse * normalize( gl_LightSource[0].position);
    lightPos.xyz = rotMatT0 * lightPos.x + rotMatT1 * lightPos.y + rotMatT2 * lightPos.z;
    
    // Sphere-Touch-Plane-Approach
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    vec2 d, p, q, h, dd;

    // get camera orthonormal coordinate system

#ifdef CALC_CAM_SYS
    // camera coordinate system in object space
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[2];
    vec3 camIn = normalize(tmp.xyz);
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[1];
    vec3 camUp = tmp.xyz;
    vec3 camRight = normalize(cross(camIn, camUp));
    camUp = cross(camIn, camRight);
#endif // CALC_CAM_SYS

    vec2 mins, maxs;
    vec3 testPos;
    vec4 projPos;

    // projected camera vector
    vec3 c2 = vec3(dot(tmp.xyz, camRight), dot(tmp.xyz, camUp), dot(tmp.xyz, camIn));

    vec3 cpj1 = camIn * c2.z + camRight * c2.x;
    vec3 cpm1 = camIn * c2.x - camRight * c2.z;

    vec3 cpj2 = camIn * c2.z + camUp * c2.y;
    vec3 cpm2 = camIn * c2.y - camUp * c2.z;

    d.x = length(cpj1);
    d.y = length(cpj2);

    dd = vec2(1.0) / d;

    ////p = (radii.x + radii.z)*(radii.x + radii.z) * dd;
    p = inSphere.w*inSphere.w * dd;
    q = d - p;
    h = sqrt(p * q);
    //h = vec2(0.0);

    p *= dd;
    h *= dd;

    cpj1 *= p.x;
    cpm1 *= h.x;
    cpj2 *= p.y;
    cpm2 *= h.y;

    // TODO: rewrite only using four projections, additions in homogenous coordinates and delayed perspective divisions.
    ////testPos = objPos.xyz + cpj1 + cpm1;
    testPos = inSphere.xyz + objPos.xyz + cpj1 + cpm1;    
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = projPos.xy;
    maxs = projPos.xy;

    testPos -= 2.0 * cpm1;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    ////testPos = objPos.xyz + cpj2 + cpm2;
    testPos = inSphere.xyz + objPos.xyz + cpj2 + cpm2;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos -= 2.0 * cpm2;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    // set position and point size
    gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    gl_PointSize = max((maxs.x - mins.x) * winHalf.x, (maxs.y - mins.y) * winHalf.y) * 0.5;
    
#ifdef SMALL_SPRITE_LIGHTING
    // for normal crowbaring on very small sprites
    lightPos.w = (clamp(gl_PointSize, 1.0, 5.0) - 1.0) / 4.0;
#endif // SMALL_SPRITE_LIGHTING

}
-->
      </snippet>
    </shader>

    <shader name="torusFragment">
      <snippet type="version">120</snippet>
      <snippet name="commondefines"/>
      <snippet name="simpleLighting"/>
      <snippet name="rootsolver"/>
      <snippet type="string">
        <!--

uniform vec4 viewAttr;
uniform vec3 zValues;
uniform vec3 fogCol;
uniform float alpha = 0.5;
uniform float alphaGradient;
uniform int DPmode = 0;
uniform int geometryPass = 1;
uniform int flipNormals = 0;

uniform vec2 texOffset;
uniform sampler2D depthBuffer;

uniform sampler2D equalHistTex0;
uniform sampler2D equalHistTex1;
uniform sampler2D equalHistTex2;
uniform sampler2D equalHistTex3;
uniform sampler2D equalHistTex4;
uniform sampler2D equalHistTex5;
uniform sampler2D equalHistTex6;
uniform sampler2D equalHistTex7;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying vec4 radii;
varying vec4 visibilitySphere;

varying vec3 rotMatT0;
varying vec3 rotMatT1; // rotation matrix from the quaternion
varying vec3 rotMatT2;

varying float maxAngle;

varying vec4 colors;
varying vec3 cuttingPlane;

-->
      </snippet>
      <snippet name="decodecolor"/>
      <snippet name="codeColorBDP"/>
      <snippet type="string">
        <!--

void main(void) {

    int numRoots;
    float K, A, B, C, D, first, second, third, cutRad2, d, factor01, depth, depthW, f, mc;
    float epsilon = 0.0001;
    vec3 ray, tmp, a, intersection, normPlane, normal, color, colorX;
    vec4 coord, lambdas, Ding;

    int i, j, rt;
    vec2 texCoordHist;
    vec3 minmaxDepth;
    vec4 fragColorInt, fragColorExt, histogram;
    float bucketInt, bucketExt, tmpIntDepth, lastDepth, fragData;
    bool discardInt, discardExt, breakFlag;

    if(DPmode != 0) {
        // get min and max depth of pixel location
         minmaxDepth.xy = texture2D( depthBuffer, (gl_FragCoord.xy + vec2( 0.25, 0.25))*texOffset).xy;
         minmaxDepth.x = minmaxDepth.x - 1.0;
         minmaxDepth.z = (minmaxDepth.y + minmaxDepth.x);
        // init fragment data with zero
        for(i = 0; i < gl_MaxDrawBuffers; ++i) {
            gl_FragData[i] = vec4(0.0, 0.0, 0.0, 0.0);
        }
    }

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);

    // transform fragment coordinates from view coordinates to object coordinates.
    coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;
    coord -= objPos; // ... and move

    // calc the viewing ray
    ray = rotMatT0 * coord.x + rotMatT1 * coord.y + rotMatT2 * coord.z;
    ray = normalize( ray - camPos.xyz);

    #define r radii.x
    #define r2 radii.y
    #define R radii.z
    #define R2 radii.w

    // calculate the base point of the ray
    a = camPos.xyz + ( length( camPos.xyz) - (R + r)) * ray;
    
    // compute coefficients of the quartic equation for the ray-torus-intersection
    K = dot( a, a) - ( R2 + r2);
    A = 4.0 * dot( a, ray);
    B = 2.0 * ( 2.0 * dot( a, ray) * dot( a, ray) + K + 2.0 * R2 * ray.z*ray.z);
    C = 4.0 * ( K * dot( a, ray) + 2.0 * R2 * a.z * ray.z);
    D = K*K + 4.0 * R2 * ( a.z*a.z - r2);
    
    lambdas = vec4( 0.0, 0.0, 0.0, 0.0);
    // ==> various quartic root solvers (only stabilized ferrari shows good results and performance)
    //int numRoots = quartic( A, B, C, D, lambdas);
    numRoots = ferrari( A, B, C, D, lambdas);
    //int numRoots = neumark( A, B, C, D, lambdas);
    //int numRoots = simpleFerrari( A, B, C, D, lambdas);
    //int numRoots = descartes( A, B, C, D, lambdas);
    if( numRoots < 2 ) { discard; }
    // get lambda of the first intersection
    /*
    // ==> this test is unnecessary, lambdas.x always holds the value of the second intersection [kroneml 31.8.2008]
    float lambda = lambdas.x;
    if( lambdas.y < lambda && numRoots > 1 && lambdas.y > 0.0 ) { lambda = lambdas.y; }
    if( lambdas.z < lambda && numRoots > 2 && lambdas.z > 0.0 ) { lambda = lambdas.z; }
    if( lambdas.w < lambda && numRoots > 3 && lambdas.w > 0.0 ) { lambda = lambdas.w; }
    // get lambda of the second intersection
    float second;
    if( lambdas.x > lambda ) { second = lambdas.x; } else { second = lambdas.y; }
    if( lambdas.y > lambda && lambdas.y < second && numRoots > 1 ) { second = lambdas.y; }
    if( lambdas.z > lambda && lambdas.z < second && numRoots > 2 ) { second = lambdas.z; }
    if( lambdas.w > lambda && lambdas.w < second && numRoots > 3 ) { second = lambdas.w; }
    */


// INT fragment =========================================================
    discardInt = false;
    first = lambdas.y; // first intersection
    intersection = a + ray * first;

    // handle singularity
    if( r > R ) {
        cutRad2 = r2 - R2;
        if( dot( intersection, intersection) < cutRad2 )
        {
            //first = lambdas.y;
            if( lambdas.x > first && numRoots > 0 ) { first = lambdas.x; }
            if( lambdas.z > first && numRoots > 2 ) { first = lambdas.z; }
            if( lambdas.w > first && numRoots > 3 ) { first = lambdas.w; }
            intersection = a + ray * first;
        }
    }

    // discard fragment if the intersection point lies outside the sphere
    if( length( intersection - visibilitySphere.xyz) > visibilitySphere.w ) { discardInt = true; }

    if(!discardInt) {
        // discard fragment if the intersection point lies outside the 'pie slice'
        if( maxAngle > 0.0 )
        {
            normPlane = normalize( cross( vec3( 0.0, 0.0, 1.0), intersection));
        } else {
            normPlane = normalize( cross( intersection, vec3( 0.0, 0.0, 1.0)));
        }
        if( acos( dot( normPlane, cuttingPlane)) > ( abs( maxAngle)/2.0 + epsilon) ) { discardInt = true; }
    }

    // second INT fragment =========================================================
    if(discardInt && (numRoots > 2)) {
        discardInt = false;
        third = lambdas.w; // third intersection
        intersection = a + ray * third; 

        // handle singularity
        if( r > R ) {
            cutRad2 = r2 - R2;
            if( dot( intersection, intersection) < cutRad2 )
            {
                //third = lambdas.w;
                if( lambdas.x > third && numRoots > 0 ) { third = lambdas.x; }
                if( lambdas.y > third && numRoots > 1 ) { third = lambdas.y; }
                if( lambdas.z > third && numRoots > 2 ) { third = lambdas.z; }
                intersection = a + ray * third;
            }
        }

        // discard fragment if the intersection point lies outside the sphere
        if( length( intersection - visibilitySphere.xyz) > visibilitySphere.w ) { discardInt = true; }
        
        if(!discardInt) {
            // discard fragment if the intersection point lies outside the 'pie slice'
            if( maxAngle > 0.0 )
            {
                normPlane = normalize( cross( vec3( 0.0, 0.0, 1.0), intersection));
            } else {
                normPlane = normalize( cross( intersection, vec3( 0.0, 0.0, 1.0)));
            }
            if( acos( dot( normPlane, cuttingPlane)) > ( abs( maxAngle)/2.0 + epsilon) ) { discardInt = true; }
        }
    }

    if(!discardInt) {
        // compute inward-facing normal
        //normal = ( intersection - vec3( normalize( intersection.xy), 0.0));
        factor01 = ( dot( intersection, intersection) - r2 - R2);
        normal.x = 4.0*intersection.x*factor01;
        normal.y = 4.0*intersection.y*factor01;
        normal.z = 4.0*intersection.z*factor01 + 8.0*R2*intersection.z;
        normal = - normalize( normal);
        if(flipNormals == 1) {
            normal *= (-1.0);
        }
        d = ( dot( intersection, vec3( 0.0, 0.0, 1.0)) - colors.z) / colors.w;
        // chose color for lighting
        color = mix( decodeColor( colors.x), decodeColor( colors.y), d);
    #ifdef FLATSHADE_SES
        if( d <= 0.5 )
            color = decodeColor( colors.x);
        else
            color = decodeColor( colors.y);
    #endif // FLATSHADE_SES
        // uniform color
        //color = vec3( 1.0, 0.75, 0.0);
        //color = vec3( 0.02, 0.75, 0.02);
        //color = vec3( 0.19, 0.52, 0.82);
    #ifdef DEBUG_COLOR
        color = vec3( 0.0, 0.98, 0.98 ); // int
    #endif // DEBUG_COLOR
        
        // phong lighting with directional light
        fragColorInt = vec4( LocalLightingInt( ray, normal, lightPos.xyz, color), 1.0); // gl_FragColor
        
        // calculate depth
    #ifdef DEPTH
        tmp = intersection;
        intersection.x = dot( rotMatT0, tmp.xyz);
        intersection.y = dot( rotMatT1, tmp.xyz);
        intersection.z = dot( rotMatT2, tmp.xyz);

        intersection += objPos.xyz;

        Ding = vec4( intersection, 1.0);
        depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
        depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
    #ifdef OGL_DEPTH_SES
        gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
    #else
        //gl_FragDepth = ( depth + zValues.y) / zValues.z;
        gl_FragDepth = (depth + zValues.y)/( zValues.z + zValues.y);
    #endif // OGL_DEPTH_SES
    #endif // DEPTH

    #ifdef FOGGING_SES
        f = clamp( ( 1.0 - gl_FragDepth)/( 1.0 - zValues.x ), 0.0, 1.0);
        fragColorInt.rgb = mix( fogCol, fragColorInt.rgb, f); // gl_FragColor
    #endif // FOGGING_SES
        
        fragColorInt.a = 1.0;

    #ifdef AXISHINTS    
        tmp = normal;
        normal.x = dot( rotMatT0, tmp.xyz);
        normal.y = dot( rotMatT1, tmp.xyz);
        normal.z = dot( rotMatT2, tmp.xyz);
        
        // debug-axis-hints
        colorX = vec3( 1.0, 1.0, 0.0);
        mc = min(abs(normal.x), min(abs(normal.y), abs(normal.z)));
        if( abs(normal.x) - 0.05 < abs(normal.z) && abs(normal.x) + 0.05 > abs(normal.z) )
        { fragColorInt = vec4( LocalLighting( ray, tmp, lightPos.xyz, colorX), 1.0); } // gl_FragColor
        if( abs(normal.x) - 0.05 < abs(normal.y) && abs(normal.x) + 0.05 > abs(normal.y) )
        { fragColorInt = vec4( LocalLighting( ray, tmp, lightPos.xyz, colorX), 1.0); } // gl_FragColor
        if( abs(normal.z) - 0.05 < abs(normal.y) && abs(normal.z) + 0.05 > abs(normal.y) )
        { fragColorInt = vec4( LocalLighting( ray, tmp, lightPos.xyz, colorX), 1.0); } // gl_FragColor
        if (mc < 0.05) { fragColorInt = vec4( LocalLighting( ray, tmp, lightPos.xyz, colorX), 1.0); } // gl_FragColor
    #endif // AXISHINTS

        // ============ sort fragment into right bucket ============
        // USE OGL_DEPTH_SES depth has to be in [0.0, 1.0]
        //if((gl_FragDepth < -minmaxDepth.x) || (gl_FragDepth > minmaxDepth.y)) { discard; }
        // minmaxDepth.x is the negative min depth !!!
        if(DPmode == 0) {
            gl_FragData[0] = fragColorInt;
        } else if(DPmode == 1) {
            // calculate bucket pair (16 pairs -> 32 depth values)
            bucketInt = floor(16.0*(gl_FragDepth + minmaxDepth.x) / minmaxDepth.z);
            // index of render target
            rt = int(floor(bucketInt/2.0));
            // choose right pair in render target
            if(mod(int(bucketInt), 2) == 0) {
                gl_FragData[rt].x = 1.0 - gl_FragDepth;
                gl_FragData[rt].y = gl_FragDepth;
            } else {
                gl_FragData[rt].z = 1.0 - gl_FragDepth;
                gl_FragData[rt].w = gl_FragDepth;
            }
            tmpIntDepth = gl_FragDepth;
        } else if(DPmode == 2) {
            // calculate right subintervall
            bucketInt = floor(32.0*(gl_FragDepth + minmaxDepth.x) / minmaxDepth.z);
            // choose right component in render target
            gl_FragData[int(floor(bucketInt / 4.0))][int(mod(bucketInt, 4.0))] = codeColorBDP(fragColorInt);
        } else if((geometryPass == 1) && ((DPmode == 3) || (DPmode == 4))) {
            // calculate right subintervall for histogramm
            bucketInt = floor(1024.0*(gl_FragDepth + minmaxDepth.x) / minmaxDepth.z );
            // choose right component in render target
            gl_FragData[int(floor(bucketInt / 128.0))][int(floor(mod(bucketInt, 128.0)/32.0))] = int(1 << int(mod(bucketInt,32.0)));
        } else if((geometryPass == 2) && ((DPmode == 3) || (DPmode == 4))) {
            // search histogram component with right depth intervall
            if(DPmode == 4) {
                fragData = codeColorBDP(fragColorInt);
            } else {
                fragData = gl_FragDepth;
            }
            texCoordHist = (gl_FragCoord.xy + vec2(0.25, 0.25)) * texOffset;
            lastDepth = 0.0;
            breakFlag = false;
            for(i = 0; i < 8; ++i) {
                if(i == 0) { histogram = texture2D(equalHistTex0, texCoordHist); }
                if(i == 1) { histogram = texture2D(equalHistTex1, texCoordHist); }
                if(i == 2) { histogram = texture2D(equalHistTex2, texCoordHist); }
                if(i == 3) { histogram = texture2D(equalHistTex3, texCoordHist); }
                if(i == 4) { histogram = texture2D(equalHistTex4, texCoordHist); }
                if(i == 5) { histogram = texture2D(equalHistTex5, texCoordHist); }
                if(i == 6) { histogram = texture2D(equalHistTex6, texCoordHist); }
                if(i == 7) { histogram = texture2D(equalHistTex7, texCoordHist); }
        
                for(j = 0; j < 4; ++j) {
                    if((gl_FragDepth >= lastDepth) && (gl_FragDepth < histogram[j])) {
                        gl_FragData[i][j] = fragData;
                        breakFlag = true;
                        break;
                    }
                    lastDepth = histogram[j];
                }
                if(breakFlag) break;
            }
        }
    }

// EXT fragment =========================================================
    discardExt = false;
    second = lambdas.x;
    intersection = a + ray * second;

    // handle singularity
    if( r > R ) {
        //float radius2 = r2 - 2.0 * ( r2 -r*R) + r2 - 2.0 * r * R + R2;
        //float cutRad2 = r2 - radius2;
        //float cutRad2 = 2.0 * ( r2 - r * R) - r2 + 2.0 * r * R - R2;
        cutRad2 = r2 - R2;
        if( dot( intersection, intersection) < cutRad2 )
        {
            //second = lambdas.x;
            if( lambdas.y > second && numRoots > 1 ) { second = lambdas.y; }
            if( lambdas.z > second && numRoots > 2 ) { second = lambdas.z; }
            if( lambdas.w > second && numRoots > 3 ) { second = lambdas.w; }
            intersection = a + ray * second;
        }
    }

    // discard fragment if the intersection point lies outside the sphere
    if( length( intersection - visibilitySphere.xyz) > visibilitySphere.w ) { discardExt = true; }
    
    if(!discardExt) {
        // discard fragment if the intersection point lies outside the 'pie slice'
        if( maxAngle > 0.0 )
        {
            normPlane = normalize( cross( vec3( 0.0, 0.0, 1.0), intersection));
        } else  {
            normPlane = normalize( cross( intersection, vec3( 0.0, 0.0, 1.0)));
        }
        if( acos( dot( normPlane, cuttingPlane)) > ( abs( maxAngle)/2.0 + epsilon) ) { discardExt = true; }
    }

    if(!discardExt) {
        // compute inward-facing normal
        //normal = ( intersection - vec3( normalize( intersection.xy), 0.0));
        factor01 = ( dot( intersection, intersection) - r2 - R2);
        normal.x = 4.0*intersection.x*factor01;
        normal.y = 4.0*intersection.y*factor01;
        normal.z = 4.0*intersection.z*factor01 + 8.0*R2*intersection.z;
        normal = - normalize( normal);
        
        d = ( dot( intersection, vec3( 0.0, 0.0, 1.0)) - colors.z) / colors.w;
        // chose color for lighting
        color = mix( decodeColor( colors.x), decodeColor( colors.y), d);
    #ifdef FLATSHADE_SES
        if( d <= 0.5 )
            color = decodeColor( colors.x);
        else
            color = decodeColor( colors.y);
    #endif // FLATSHADE_SES
        // uniform color
        //color = vec3( 1.0, 0.75, 0.0);
        //color = vec3( 0.02, 0.75, 0.02);
        //color = vec3( 0.19, 0.52, 0.82);
    #ifdef DEBUG_COLOR
        color = vec3( 0.98, 0.98, 0.0 ); // ext
    #endif // DEBUG_COLOR
        
        // phong lighting with directional light
        fragColorExt = vec4( LocalLightingExt( ray, normal, lightPos.xyz, color), 1.0); // gl_FragColor
        
        // calculate depth
    #ifdef DEPTH
        tmp = intersection;
        intersection.x = dot( rotMatT0, tmp.xyz);
        intersection.y = dot( rotMatT1, tmp.xyz);
        intersection.z = dot( rotMatT2, tmp.xyz);

        intersection += objPos.xyz;

        Ding = vec4( intersection, 1.0);
        depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
        depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
    #ifdef OGL_DEPTH_SES
        gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
    #else
        //gl_FragDepth = ( depth + zValues.y) / zValues.z;
        gl_FragDepth = (depth + zValues.y)/( zValues.z + zValues.y);
    #endif // OGL_DEPTH_SES
    #endif // DEPTH

    #ifdef FOGGING_SES
        f = clamp( ( 1.0 - gl_FragDepth)/( 1.0 - zValues.x ), 0.0, 1.0);
        fragColorExt.rgb = mix( fogCol, fragColorExt.rgb, f); // gl_FragColor
    #endif // FOGGING_SES

        fragColorExt.a = 1.0;
        
    #ifdef AXISHINTS    
        tmp = normal;
        normal.x = dot( rotMatT0, tmp.xyz);
        normal.y = dot( rotMatT1, tmp.xyz);
        normal.z = dot( rotMatT2, tmp.xyz);
        
        // debug-axis-hints
        colorX = vec3( 1.0, 1.0, 0.0);
        mc = min(abs(normal.x), min(abs(normal.y), abs(normal.z)));
        if( abs(normal.x) - 0.05 < abs(normal.z) && abs(normal.x) + 0.05 > abs(normal.z) )
        { fragColorExt = vec4( LocalLightingExt( ray, tmp, lightPos.xyz, colorX), 1.0); } // gl_FragColor
        if( abs(normal.x) - 0.05 < abs(normal.y) && abs(normal.x) + 0.05 > abs(normal.y) )
        { fragColorExt = vec4( LocalLightingExt( ray, tmp, lightPos.xyz, colorX), 1.0); } // gl_FragColor
        if( abs(normal.z) - 0.05 < abs(normal.y) && abs(normal.z) + 0.05 > abs(normal.y) )
        { fragColorExt = vec4( LocalLightingExt( ray, tmp, lightPos.xyz, colorX), 1.0); } // gl_FragColor
        if (mc < 0.05) { fragColorExt = vec4( LocalLightingExt( ray, tmp, lightPos.xyz, colorX), 1.0); } // gl_FragColor
    #endif // AXISHINTS

        // ============ sort fragment into right bucket ============
        // USE OGL_DEPTH_SES depth has to be in [0.0, 1.0]
        // minmaxDepth.x is the negative min depth !!!
        //if((gl_FragDepth < -minmaxDepth.x) || (gl_FragDepth > minmaxDepth.y)) { discard; }
        if(DPmode == 0) {
            gl_FragData[0] = fragColorExt;
        } else if(DPmode == 1) {
            // calculate bucket pair (16 pairs -> 32 depth values)
            bucketExt = floor(16.0*(gl_FragDepth + minmaxDepth.x) / minmaxDepth.z);
            // index of render target
            rt = int(floor(bucketExt/2.0));
            // choose right pair in render target
            // (set maximum value because first fragment could have been writing too)
            if(!discardInt && (bucketExt == bucketInt)) {
                if(mod(int(bucketExt), 2) == 0) {
                    gl_FragData[rt].x = max(1.0 - tmpIntDepth, 1.0 - gl_FragDepth);
                    gl_FragData[rt].y = max(tmpIntDepth, gl_FragDepth);
                } else {
                    gl_FragData[rt].z = max(1.0 - tmpIntDepth, 1.0 - gl_FragDepth);
                    gl_FragData[rt].w = max(tmpIntDepth, gl_FragDepth);
                }
            } else {
                if(mod(int(bucketExt), 2) == 0) {
                    gl_FragData[rt].x = 1.0 - gl_FragDepth;
                    gl_FragData[rt].y = gl_FragDepth;
                } else {
                    gl_FragData[rt].z = 1.0 - gl_FragDepth;
                    gl_FragData[rt].w = gl_FragDepth;
                }
            }
        } else if(DPmode == 2) {
            // calculate right subintervall
            bucketExt = floor(32.0*(gl_FragDepth + minmaxDepth.x) / minmaxDepth.z);
            // choose right component in render target
            if(!discardInt && (bucketExt == bucketInt)) {
                if(alphaGradient > 0.0) {
                    fragColorExt = fragColorInt*(1.0 - clamp((2.0 - (float(4*(7-int(floor(bucketExt/4.0)))+(3-int(mod(bucketExt, 4.0)))) / 32.0 * alphaGradient)), 0.0, 1.0)) + fragColorExt;
                } else {
                    fragColorExt = fragColorInt*(1.0 - alpha) + fragColorExt;
                }
                fragColorExt.a = 0.25;
            }
            gl_FragData[int(floor(bucketExt/4.0))][int(mod(bucketExt, 4.0))] = codeColorBDP(fragColorExt);
        } else if((geometryPass == 1) && ((DPmode == 3) || (DPmode == 4))) {
            // calculate right subintervall for histogramm
            bucketExt = floor(1024.0*(gl_FragDepth + minmaxDepth.x) / minmaxDepth.z );
            // choose right component in render target
            if(!discardInt && (bucketInt == bucketExt)) bucketExt -= 1.0;
            gl_FragData[int(floor(bucketExt/128.0))][int(floor(mod(bucketExt, 128.0)/32.0))] = int(1 << int(mod(bucketExt,32.0)));
        } else if((geometryPass == 2) && ((DPmode == 3) || (DPmode == 4))) {
            // search histogram component with right depth intervall
            if(DPmode == 4) {
                fragData = codeColorBDP(fragColorExt);
            } else {
                fragData = gl_FragDepth;
            }
            texCoordHist = (gl_FragCoord.xy + vec2(0.25, 0.25)) * texOffset;
            lastDepth = 0.0;
            breakFlag = false;
            for(i = 0; i < 8; ++i) {
                if(i == 0) { histogram = texture2D(equalHistTex0, texCoordHist); }
                if(i == 1) { histogram = texture2D(equalHistTex1, texCoordHist); }
                if(i == 2) { histogram = texture2D(equalHistTex2, texCoordHist); }
                if(i == 3) { histogram = texture2D(equalHistTex3, texCoordHist); }
                if(i == 4) { histogram = texture2D(equalHistTex4, texCoordHist); }
                if(i == 5) { histogram = texture2D(equalHistTex5, texCoordHist); }
                if(i == 6) { histogram = texture2D(equalHistTex6, texCoordHist); }
                if(i == 7) { histogram = texture2D(equalHistTex7, texCoordHist); }
        
                for(j = 0; j < 4; ++j) {
                    if((gl_FragDepth >= lastDepth) && (gl_FragDepth < histogram[j])) {
                        gl_FragData[i][j] = fragData;
                        breakFlag = true;
                        break;
                    }
                    lastDepth = histogram[j];
                }
                if(breakFlag) break;
            }
        }
    }

    if(discardExt && discardInt) { discard; }
}
-->
      </snippet>
    </shader>

    <shader name="sphericalTriangleVertex">
      <snippet type="version">120</snippet>
      <snippet name="commondefines"/>
      <snippet type="string">
        <!--
uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)
uniform vec3 zValues;
uniform vec3 fogCol;
uniform vec2 texOffset;

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

attribute vec4 attribVec1;
attribute vec4 attribVec2;
attribute vec4 attribVec3;
attribute vec3 attribColors;
attribute vec3 attribTexCoord1;
attribute vec3 attribTexCoord2;
attribute vec3 attribTexCoord3;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;

varying vec4 inVec1;
varying vec4 inVec2;
varying vec4 inVec3;
varying vec3 inColors;
varying vec3 texCoord1;
varying vec3 texCoord2;
varying vec3 texCoord3;

void main(void) {
    inVec1 = attribVec1;
    inVec2 = attribVec2;
    inVec3 = attribVec3;
    inColors = attribColors;
    
    texCoord1 = attribTexCoord1;
    texCoord2 = attribTexCoord2;
    texCoord3 = attribTexCoord3;
    
    // remove the sphere radius from the w coordinates to the rad varyings
    vec4 inPos = gl_Vertex;
    inVec1.w = inPos.w;
    inVec2.w = inPos.w * inPos.w;
    inPos.w = 1.0;
    
    // DEBUG
    //texCoord2.xy = vec2( attribVec1.w, attribVec2.w);
    
    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)
    
    // calculate cam position
    camPos = gl_ModelViewMatrixInverse[3]; // (C) by Christoph
    camPos.xyz -= objPos.xyz; // cam pos to glyph space
    
    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = gl_ModelViewMatrixInverse * gl_LightSource[0].position - objPos;
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    lightPos = gl_ModelViewMatrixInverse * normalize( gl_LightSource[0].position);
    
    // Sphere-Touch-Plane-Approach
    vec2 winHalf = 2.0 / viewAttr.zw; // window size
    
    vec2 d, p, q, h, dd;
    
    // get camera orthonormal coordinate system
    vec4 tmp;
    
    #ifdef CALC_CAM_SYS
    // camera coordinate system in object space
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[2];
    vec3 camIn = normalize(tmp.xyz);
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[1];
    vec3 camUp = tmp.xyz;
    vec3 camRight = normalize(cross(camIn, camUp));
    camUp = cross(camIn, camRight);
    #endif // CALC_CAM_SYS
    
    vec2 mins, maxs;
    vec3 testPos;
    vec4 projPos;
    
    // projected camera vector
    vec3 c2 = vec3(dot(camPos.xyz, camRight), dot(camPos.xyz, camUp), dot(camPos.xyz, camIn));
    
    vec3 cpj1 = camIn * c2.z + camRight * c2.x;
    vec3 cpm1 = camIn * c2.x - camRight * c2.z;
    
    vec3 cpj2 = camIn * c2.z + camUp * c2.y;
    vec3 cpm2 = camIn * c2.y - camUp * c2.z;
    
    d.x = length(cpj1);
    d.y = length(cpj2);
    
    dd = vec2(1.0) / d;
    
    p = inVec2.w * dd;
    q = d - p;
    h = sqrt(p * q);
    //h = vec2(0.0);
    
    p *= dd;
    h *= dd;
    
    cpj1 *= p.x;
    cpm1 *= h.x;
    cpj2 *= p.y;
    cpm2 *= h.y;
    
    // TODO: rewrite only using four projections, additions in homogenous coordinates and delayed perspective divisions.
    testPos = objPos.xyz + cpj1 + cpm1;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = projPos.xy;
    maxs = projPos.xy;
    
    testPos -= 2.0 * cpm1;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);
    
    testPos = objPos.xyz + cpj2 + cpm2;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);
    
    testPos -= 2.0 * cpm2;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);
    
    gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    gl_PointSize = max((maxs.x - mins.x) * winHalf.x, (maxs.y - mins.y) * winHalf.y) * 0.5;
    
    #ifdef SMALL_SPRITE_LIGHTING
    // for normal crowbaring on very small sprites
    lightPos.w = (clamp(gl_PointSize, 1.0, 5.0) - 1.0) / 4.0;
    #endif // SMALL_SPRITE_LIGHTING
    
}

-->
      </snippet>
    </shader>

    <shader name="sphericalTriangleFragment">
      <snippet type="version">120</snippet>
      <snippet name="commondefines"/>
      <snippet name="simpleLighting"/>
      <snippet type="string">
        <!--
#extension GL_EXT_gpu_shader4 : enable

uniform vec4 viewAttr;
uniform vec3 zValues;
uniform vec3 fogCol;
uniform float alpha = 0.5;
uniform float alphaGradient;
uniform int DPmode = 0;
uniform int geometryPass = 1;
uniform int flipNormals = 0;

uniform vec2 texOffset;
uniform sampler2D depthBuffer;

uniform sampler2D equalHistTex0;
uniform sampler2D equalHistTex1;
uniform sampler2D equalHistTex2;
uniform sampler2D equalHistTex3;
uniform sampler2D equalHistTex4;
uniform sampler2D equalHistTex5;
uniform sampler2D equalHistTex6;
uniform sampler2D equalHistTex7;

uniform vec2 texOffsetSingularity;
uniform sampler2D singTex;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;

varying vec4 inVec1;
varying vec4 inVec2;
varying vec4 inVec3;
varying vec3 inColors;

varying vec3 texCoord1;
varying vec3 texCoord2;
varying vec3 texCoord3;

-->
      </snippet>
      <snippet name="decodecolor"/>
      <snippet name="dot1"/>
      <snippet name="codeColorBDP"/>
      <snippet type="string">
        <!--

void main(void) {

    float rad      = inVec1.w;
    float squarRad = inVec2.w;

    int numProbes;
    float d1, d2s, radicand, lambda, d, dist1, dist2, f, mc, depth, depthW, invdet, beta, gamma, alpha2;
    vec3 ray, sphereintersection, pos1, planeNormal, probePos, normal, color, colorX;
    vec3 u, v, w, dRay, wXu, dXv;
    vec4 coord, Ding;

    int i, j, rt;
    vec2 texCoordHist;
    vec3 minmaxDepth;
    vec4 fragColorInt, fragColorExt, histogram;
    float bucketInt, bucketExt, tmpIntDepth, lastDepth, fragData;
    bool discardInt, discardExt, breakFlag;

    if(DPmode != 0) {
        // get min and max depth of pixel location
         minmaxDepth.xy = texture2D( depthBuffer, (gl_FragCoord.xy + vec2( 0.25, 0.25))*texOffset).xy;
         minmaxDepth.x = minmaxDepth.x - 1.0;
         minmaxDepth.z = (minmaxDepth.y + minmaxDepth.x);
        // init fragment data with zero
        for(i = 0; i < gl_MaxDrawBuffers; ++i) {
            gl_FragData[i] = vec4(0.0, 0.0, 0.0, 0.0);
        }
    }

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    
    // transform fragment coordinates from view coordinates to object coordinates.
    coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;
    coord -= objPos; // ... and to glyph space

    // calc the viewing ray
    ray = normalize(coord.xyz - camPos.xyz);

    // calculate the geometry-ray-intersection
    d1 = -dot(camPos.xyz, ray);                       // projected length of the cam-sphere-vector onto the ray
    d2s = dot(camPos.xyz, camPos.xyz) - d1 * d1;      // off axis of cam-sphere-vector and ray
    radicand = squarRad - d2s;                        // square of difference of projected length and lambda
    
    if (radicand < 0.0) { discard; }

// INT fragment =========================================================
    discardInt = false;
    lambda = d1 + sqrt(radicand);                     // lambda for interior face
    sphereintersection = lambda * ray + camPos.xyz;    // intersection point

    // compute the actual position of the intersection with the sphere
    pos1 = sphereintersection + objPos.xyz;
    // cut with plane 1
    planeNormal = normalize( cross( inVec1.xyz, inVec2.xyz));
    d = dot( objPos.xyz, planeNormal);
    dist1 = dot( pos1, planeNormal) - d;
    dist2 = dot( inVec3.xyz + objPos.xyz, planeNormal) - d;
    if( ( dist2 < 0.0 && dist1 > 0.0 ) || ( dist2 > 0.0 && dist1 < 0.0 ) ) { discardInt = true; }
    if(!discardInt) {
        // cut with plane 2
        planeNormal = normalize( cross( inVec2.xyz, inVec3.xyz));
        d = dot( objPos.xyz, planeNormal);
        dist1 = dot( pos1, planeNormal) - d;
        dist2 = dot( inVec1.xyz + objPos.xyz, planeNormal) - d;
        if( ( dist2 < 0.0 && dist1 > 0.0 ) || ( dist2 > 0.0 && dist1 < 0.0 ) ) { discardInt = true; }
    }
    if(!discardInt) {
        // cut with plane 3
        planeNormal = normalize( cross( inVec1.xyz, inVec3.xyz));
        d = dot( objPos.xyz, planeNormal);
        dist1 = dot( pos1, planeNormal) - d;
        dist2 = dot( inVec2.xyz + objPos.xyz, planeNormal) - d;
        if( ( dist2 < 0.0 && dist1 > 0.0 ) || ( dist2 > 0.0 && dist1 < 0.0 ) ) { discardInt = true; }
    }

    // Singularity handling:
    if(!discardInt) {
        numProbes = min( int(texCoord1.x), 16);
        if( numProbes > 0 )
        {
            for( i = 0; i < numProbes; i++ )
            {
                probePos = texture2D( singTex, ( texCoord1.yz + vec2( 0.25, 0.25) + vec2( float( i), 0.0))*texOffsetSingularity).xyz;
                if( dot1( probePos - objPos.xyz) > 0.1 && ( dot1( pos1 - probePos) < squarRad ) ) { discardInt = true; }
            }
        }
    }
    if(!discardInt) {
        numProbes = min( int(texCoord2.x), 16);
        if( numProbes > 0 )
        {
            for( i = 0; i < numProbes; i++ )
            {
                probePos = texture2D( singTex, ( texCoord2.yz + vec2( 0.25, 0.25) + vec2( float( i), 0.0))*texOffsetSingularity).xyz;
                if( dot1( probePos - objPos.xyz) > 0.1 && ( dot1( pos1 - probePos) < squarRad ) ) { discardInt = true; }
            }
        }
    }
    if(!discardInt) {
        numProbes = min( int(texCoord3.x), 16);
        if( numProbes > 0 )
        {
            for( i = 0; i < numProbes; i++ )
            {
                probePos = texture2D( singTex, ( texCoord3.yz + vec2( 0.25, 0.25) + vec2( float( i), 0.0))*texOffsetSingularity).xyz;
                if( dot1( probePos - objPos.xyz) > 0.1 && ( dot1( pos1 - probePos) < squarRad ) ) { discardInt = true; }
            }
        }
    }

    if(!discardInt) {
        // "calc" normal at intersection point
        normal = - sphereintersection / rad;
    #ifdef SMALL_SPRITE_LIGHTING
        normal = mix(-ray, normal, lightPos.w);
    #endif // SMALL_SPRITE_LIGHTING

        // ========== START compute color ==========
        // compute auxiliary direction vectors
        u = inVec1.xyz - inVec2.xyz;
        v = inVec3.xyz - inVec2.xyz;
        // base point and direction of ray from the origin to the intersection point
        w = -inVec2.xyz;
        dRay = normalize( sphereintersection);
        // cross products for computing the determinant
        wXu = cross( w, u);
        dXv = cross( dRay, v);
        // compute inverse determinant
        invdet = 1.0 / dot( dXv, u);
        // compute weights
        beta = dot( dXv, w) * invdet;
        gamma = dot( wXu, dRay) * invdet;
        alpha2 = 1.0 - ( beta + gamma);
        // compute color
        color = decodeColor( inColors.y) * alpha2 + decodeColor( inColors.x) * beta + decodeColor( inColors.z) * gamma;
    #ifdef FLATSHADE_SES
        if( alpha2 > beta && alpha2 > gamma )
            color = decodeColor( inColors.y);
        else if( beta > alpha2 && beta > gamma )
            color = decodeColor( inColors.x);
        else
            color = decodeColor( inColors.z);
    #endif // FLATSHADE_SES
        // ========== END compute color ==========
        // uniform color
        //color = vec3( 0.0, 0.75, 1.0);
        //color = vec3( texCoord2.xy, 0.0);
        //color = vec3( 0.8, 0.0, 0.2);
        //color = vec3( 0.19, 0.52, 0.82);
    #ifdef DEBUG_COLOR
        color = vec3( 0.98, 0.0, 0.98); //int
    #endif // DEBUG_COLOR
        
        // phong lighting with directional light
        fragColorInt = vec4( LocalLightingInt(ray, normal, lightPos.xyz, color), 1.0); // gl_FragColor
        
        // calculate depth
    #ifdef DEPTH
        Ding = vec4(sphereintersection + objPos.xyz, 1.0);
        depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
        depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
    #ifdef OGL_DEPTH_SES
        gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
    #else
        //gl_FragDepth = ( depth + zValues.y) / zValues.z;
        gl_FragDepth = (depth + zValues.y)/( zValues.z + zValues.y);
    #endif // OGL_DEPTH_SES
    #endif // DEPTH

    #ifdef FOGGING_SES
        f = clamp( ( 1.0 - gl_FragDepth)/( 1.0 - zValues.x ), 0.0, 1.0);
        fragColorInt.rgb = mix( fogCol, fragColorInt.rgb, f); // gl_FragColor
    #endif // FOGGING_SES
        
        fragColorInt.a = 1.0;

    #ifdef AXISHINTS
        // debug-axis-hints
        colorX = vec3( 1.0, 1.0, 0.0);
        mc = min(abs(normal.x), min(abs(normal.y), abs(normal.z)));
        if( abs(normal.x) - 0.05 < abs(normal.z) && abs(normal.x) + 0.05 > abs(normal.z) )
        { fragColorInt = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); } // gl_FragColor
        if( abs(normal.x) - 0.05 < abs(normal.y) && abs(normal.x) + 0.05 > abs(normal.y) )
        { fragColorInt = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); } // gl_FragColor
        if( abs(normal.z) - 0.05 < abs(normal.y) && abs(normal.z) + 0.05 > abs(normal.y) )
        { fragColorInt = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); } // gl_FragColor
        if (mc < 0.05) { fragColorInt = vec4( LocalLighting( ray, normal, lightPos.xyz, colorX), 1.0); } // gl_FragColor
    #endif // AXISHINTS

        // ============ sort fragment into right bucket ============
        // USE OGL_DEPTH_SES depth has to be in [0.0, 1.0]
        //if((gl_FragDepth < -minmaxDepth.x) || (gl_FragDepth > minmaxDepth.y)) { discard; }
        // minmaxDepth.x is the negative min depth !!!
        if(DPmode == 0) {
            gl_FragData[0] = fragColorInt;
        } else if(DPmode == 1) {
            // calculate bucket pair (16 pairs -> 32 depth values)
            bucketInt = floor(16.0*(gl_FragDepth + minmaxDepth.x) / minmaxDepth.z);
            // index of render target
            rt = int(floor(bucketInt/2.0));
            // choose right pair in render target
            if(mod(int(bucketInt), 2) == 0) {
                gl_FragData[rt].x = 1.0 - gl_FragDepth;
                gl_FragData[rt].y = gl_FragDepth;
            } else {
                gl_FragData[rt].z = 1.0 - gl_FragDepth;
                gl_FragData[rt].w = gl_FragDepth;
            }
            tmpIntDepth = gl_FragDepth;
        } else if(DPmode == 2) {
            // calculate right subintervall
            bucketInt = floor(32.0*(gl_FragDepth + minmaxDepth.x) / minmaxDepth.z);
            // choose right component in render target
            gl_FragData[int(floor(bucketInt / 4.0))][int(mod(bucketInt, 4.0))] = codeColorBDP(fragColorInt);
        } else if((geometryPass == 1) && ((DPmode == 3) || (DPmode == 4))) {
            // calculate right subintervall for histogramm
            bucketInt = floor(1024.0*(gl_FragDepth + minmaxDepth.x) / minmaxDepth.z );
            // choose right component in render target
            gl_FragData[int(floor(bucketInt / 128.0))][int(floor(mod(bucketInt, 128.0)/32.0))] = int(1 << int(mod(bucketInt,32.0)));
        } else if((geometryPass == 2) && ((DPmode == 3) || (DPmode == 4))) {
            // search histogram component with right depth intervall
            if(DPmode == 4) {
                fragData = codeColorBDP(fragColorInt);
            } else {
                fragData = gl_FragDepth;
            }
            texCoordHist = (gl_FragCoord.xy + vec2(0.25, 0.25)) * texOffset;
            lastDepth = 0.0;
            breakFlag = false;
            for(i = 0; i < 8; ++i) {
                if(i == 0) { histogram = texture2D(equalHistTex0, texCoordHist); }
                if(i == 1) { histogram = texture2D(equalHistTex1, texCoordHist); }
                if(i == 2) { histogram = texture2D(equalHistTex2, texCoordHist); }
                if(i == 3) { histogram = texture2D(equalHistTex3, texCoordHist); }
                if(i == 4) { histogram = texture2D(equalHistTex4, texCoordHist); }
                if(i == 5) { histogram = texture2D(equalHistTex5, texCoordHist); }
                if(i == 6) { histogram = texture2D(equalHistTex6, texCoordHist); }
                if(i == 7) { histogram = texture2D(equalHistTex7, texCoordHist); }
        
                for(j = 0; j < 4; ++j) {
                    if((gl_FragDepth >= lastDepth) && (gl_FragDepth < histogram[j])) {
                        gl_FragData[i][j] = fragData;
                        breakFlag = true;
                        break;
                    }
                    lastDepth = histogram[j];
                }
                if(breakFlag) break;
            }
        }
    }

// EXT fragment =========================================================

    discardExt = false;
    lambda = d1 - sqrt(radicand); 
    sphereintersection = lambda * ray + camPos.xyz;    // intersection point

    pos1 = sphereintersection + objPos.xyz;
    // cut with plane 1
    planeNormal = normalize( cross( inVec1.xyz, inVec2.xyz));
    d = dot( objPos.xyz, planeNormal);
    dist1 = dot( pos1, planeNormal) - d;
    dist2 = dot( inVec3.xyz + objPos.xyz, planeNormal) - d;
    if( ( dist2 < 0.0 && dist1 > 0.0 ) || ( dist2 > 0.0 && dist1 < 0.0 ) ) { discardExt = true; }
    if(!discardExt) {
        // cut with plane 2
        planeNormal = normalize( cross( inVec2.xyz, inVec3.xyz));
        d = dot( objPos.xyz, planeNormal);
        dist1 = dot( pos1, planeNormal) - d;
        dist2 = dot( inVec1.xyz + objPos.xyz, planeNormal) - d;
        if( ( dist2 < 0.0 && dist1 > 0.0 ) || ( dist2 > 0.0 && dist1 < 0.0 ) ) { discardExt = true; }
    }
    if(!discardExt) {
        // cut with plane 3
        planeNormal = normalize( cross( inVec1.xyz, inVec3.xyz));
        d = dot( objPos.xyz, planeNormal);
        dist1 = dot( pos1, planeNormal) - d;
        dist2 = dot( inVec2.xyz + objPos.xyz, planeNormal) - d;
        if( ( dist2 < 0.0 && dist1 > 0.0 ) || ( dist2 > 0.0 && dist1 < 0.0 ) ) { discardExt = true; }
    }

    // Singularity handling:
    if(!discardExt) {
        numProbes = min( int(texCoord1.x), 16);
        if( numProbes > 0 )
        {
            for( i = 0; i < numProbes; i++ )
            {
                probePos = texture2D( singTex, ( texCoord1.yz + vec2( 0.25, 0.25) + vec2( float( i), 0.0))*texOffsetSingularity).xyz;
                if( dot1( probePos - objPos.xyz) > 0.1 && ( dot1( pos1 - probePos) < squarRad ) ) { discardExt = true; }
            }
        }
    }
    if(!discardExt) {
        numProbes = min( int(texCoord2.x), 16);
        if( numProbes > 0 )
        {
            for( i = 0; i < numProbes; i++ )
            {
                probePos = texture2D( singTex, ( texCoord2.yz + vec2( 0.25, 0.25) + vec2( float( i), 0.0))*texOffsetSingularity).xyz;
                if( dot1( probePos - objPos.xyz) > 0.1 && ( dot1( pos1 - probePos) < squarRad ) ) { discardExt = true; }
            }
        }
    }
    if(!discardExt) {
        numProbes = min( int(texCoord3.x), 16);
        if( numProbes > 0 )
        {
            for( i = 0; i < numProbes; i++ )
            {
                probePos = texture2D( singTex, ( texCoord3.yz + vec2( 0.25, 0.25) + vec2( float( i), 0.0))*texOffsetSingularity).xyz;
                if( dot1( probePos - objPos.xyz) > 0.1 && ( dot1( pos1 - probePos) < squarRad ) ) { discardExt = true; }
            }
        }
    }

    if(!discardExt) {
        // "calc" normal at intersection point
        normal = - sphereintersection / rad;
        if(flipNormals == 1) {
            normal *= (-1.0);
        }
    #ifdef SMALL_SPRITE_LIGHTING
        normal = mix(-ray, normal, lightPos.w);
    #endif // SMALL_SPRITE_LIGHTING

        // ========== START compute color ==========
        // compute auxiliary direction vectors
        u = inVec1.xyz - inVec2.xyz;
        v = inVec3.xyz - inVec2.xyz;
        // base point and direction of ray from the origin to the intersection point
        w = -inVec2.xyz;
        dRay = normalize( sphereintersection);
        // cross products for computing the determinant
        wXu = cross( w, u);
        dXv = cross( dRay, v);
        // compute inverse determinant
        invdet = 1.0 / dot( dXv, u);
        // compute weights
        beta = dot( dXv, w) * invdet;
        gamma = dot( wXu, dRay) * invdet;
        alpha2 = 1.0 - ( beta + gamma);
        // compute color
        color = decodeColor( inColors.y) * alpha2 + decodeColor( inColors.x) * beta + decodeColor( inColors.z) * gamma;
    #ifdef FLATSHADE_SES
        if( alpha2 > beta && alpha2 > gamma )
            color = decodeColor( inColors.y);
        else if( beta > alpha2 && beta > gamma )
            color = decodeColor( inColors.x);
        else
            color = decodeColor( inColors.z);
    #endif // FLATSHADE_SES
        // ========== END compute color ==========

        // uniform color
        //color = vec3( 0.0, 0.75, 1.0);
        //color = vec3( texCoord2.xy, 0.0);
        //color = vec3( 0.8, 0.0, 0.2);
        //color = vec3( 0.19, 0.52, 0.82);
    #ifdef DEBUG_COLOR
        color = vec3( 0.98, 0.98, 0.0); // ext
    #endif // DEBUG_COLOR
        
        // phong lighting with directional light
        fragColorExt = vec4( LocalLightingExt(ray, normal, lightPos.xyz, color), 1.0); // gl_FragColor
        
        // calculate depth
    #ifdef DEPTH
        Ding = vec4(sphereintersection + objPos.xyz, 1.0);
        depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
        depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
    #ifdef OGL_DEPTH_SES
        gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
    #else
        //gl_FragDepth = ( depth + zValues.y) / zValues.z;
        gl_FragDepth = (depth + zValues.y)/( zValues.z + zValues.y);
    #endif // OGL_DEPTH_SES
    #endif // DEPTH

    #ifdef FOGGING_SES
        f = clamp( ( 1.0 - gl_FragDepth)/( 1.0 - zValues.x ), 0.0, 1.0);
        fragColorExt.rgb = mix( fogCol, fragColorExt.rgb, f); // gl_FragColor
    #endif // FOGGING_SES

        fragColorExt.a = 1.0;
        
    #ifdef AXISHINTS
        // debug-axis-hints
        colorX = vec3( 1.0, 1.0, 0.0);
        mc = min(abs(normal.x), min(abs(normal.y), abs(normal.z)));
        if( abs(normal.x) - 0.05 < abs(normal.z) && abs(normal.x) + 0.05 > abs(normal.z) )
        { fragColorExt = vec4( LocalLightingExt( ray, normal, lightPos.xyz, colorX), 1.0); } // gl_FragColor
        if( abs(normal.x) - 0.05 < abs(normal.y) && abs(normal.x) + 0.05 > abs(normal.y) )
        { fragColorExt = vec4( LocalLightingExt( ray, normal, lightPos.xyz, colorX), 1.0); } // gl_FragColor
        if( abs(normal.z) - 0.05 < abs(normal.y) && abs(normal.z) + 0.05 > abs(normal.y) )
        { fragColorExt = vec4( LocalLightingExt( ray, normal, lightPos.xyz, colorX), 1.0); } // gl_FragColor
        if (mc < 0.05) { fragColorExt = vec4( LocalLightingExt( ray, normal, lightPos.xyz, colorX), 1.0); } // gl_FragColor
    #endif // AXISHINTS

        // ============ sort fragment into right bucket ============
        // USE OGL_DEPTH_SES depth has to be in [0.0, 1.0]
        // minmaxDepth.x is the negative min depth !!!
        //if((gl_FragDepth < -minmaxDepth.x) || (gl_FragDepth > minmaxDepth.y)) { discard; }
        if(DPmode == 0) {
            gl_FragData[0] = fragColorExt;
        } else if(DPmode == 1) {
            // calculate bucket pair (16 pairs -> 32 depth values)
            bucketExt = floor(16.0*(gl_FragDepth + minmaxDepth.x) / minmaxDepth.z);
            // index of render target
            rt = int(floor(bucketExt/2.0));
            // choose right pair in render target
            // (set maximum value because first fragment could have been writing too)
            if(!discardInt && (bucketExt == bucketInt)) {
                if(mod(int(bucketExt), 2) == 0) {
                    gl_FragData[rt].x = max(1.0 - tmpIntDepth, 1.0 - gl_FragDepth);
                    gl_FragData[rt].y = max(tmpIntDepth, gl_FragDepth);
                } else {
                    gl_FragData[rt].z = max(1.0 - tmpIntDepth, 1.0 - gl_FragDepth);
                    gl_FragData[rt].w = max(tmpIntDepth, gl_FragDepth);
                }
            } else {
                if(mod(int(bucketExt), 2) == 0) {
                    gl_FragData[rt].x = 1.0 - gl_FragDepth;
                    gl_FragData[rt].y = gl_FragDepth;
                } else {
                    gl_FragData[rt].z = 1.0 - gl_FragDepth;
                    gl_FragData[rt].w = gl_FragDepth;
                }
            }
        } else if(DPmode == 2) {
            // calculate right subintervall
            bucketExt = floor(32.0*(gl_FragDepth + minmaxDepth.x) / minmaxDepth.z);
            // choose right component in render target
            if(!discardInt && (bucketExt == bucketInt)) {
                if(alphaGradient > 0.0) {
                    fragColorExt = fragColorInt*(1.0 - clamp((2.0 - (float(4*(7-int(floor(bucketExt/4.0)))+(3-int(mod(bucketExt, 4.0)))) / 32.0 * alphaGradient)), 0.0, 1.0)) + fragColorExt;
                } else {
                    fragColorExt = fragColorInt*(1.0 - alpha) + fragColorExt;
                }
                fragColorExt.a = 0.25;
            }
            gl_FragData[int(floor(bucketExt/4.0))][int(mod(bucketExt, 4.0))] = codeColorBDP(fragColorExt);
        } else if((geometryPass == 1) && ((DPmode == 3) || (DPmode == 4))) {
            // calculate right subintervall for histogramm
            bucketExt = floor(1024.0*(gl_FragDepth + minmaxDepth.x) / minmaxDepth.z );
            // choose right component in render target
            if(!discardInt && (bucketInt == bucketExt)) bucketExt -= 1.0;
            gl_FragData[int(floor(bucketExt/128.0))][int(floor(mod(bucketExt, 128.0)/32.0))] = int(1 << int(mod(bucketExt,32.0)));
        } else if((geometryPass == 2) && ((DPmode == 3) || (DPmode == 4))) {
            // search histogram component with right depth intervall
            if(DPmode == 4) {
                fragData = codeColorBDP(fragColorExt);
            } else {
                fragData = gl_FragDepth;
            }
            texCoordHist = (gl_FragCoord.xy + vec2(0.25, 0.25)) * texOffset;
            lastDepth = 0.0;
            breakFlag = false;
            for(i = 0; i < 8; ++i) {
                if(i == 0) { histogram = texture2D(equalHistTex0, texCoordHist); }
                if(i == 1) { histogram = texture2D(equalHistTex1, texCoordHist); }
                if(i == 2) { histogram = texture2D(equalHistTex2, texCoordHist); }
                if(i == 3) { histogram = texture2D(equalHistTex3, texCoordHist); }
                if(i == 4) { histogram = texture2D(equalHistTex4, texCoordHist); }
                if(i == 5) { histogram = texture2D(equalHistTex5, texCoordHist); }
                if(i == 6) { histogram = texture2D(equalHistTex6, texCoordHist); }
                if(i == 7) { histogram = texture2D(equalHistTex7, texCoordHist); }
        
                for(j = 0; j < 4; ++j) {
                    if((gl_FragDepth >= lastDepth) && (gl_FragDepth < histogram[j])) {
                        gl_FragData[i][j] = fragData;
                        breakFlag = true;
                        break;
                    }
                    lastDepth = histogram[j];
                }
                if(breakFlag) break;
            }
        }
    }

#ifdef PUXELS
if(puxels_use != 0)
    puxels_store(makePuxel(packUnorm4x8(gl_FragColor), normal, gl_FragDepth));
#endif

    if(discardExt && discardInt) { discard; }
}
-->
      </snippet>
    </shader>

    <shader name="createDepthBufferVertex">
      <snippet type="version">120</snippet>
      <snippet type="string">
        <!--

void main(void) {

    gl_Position  = ftransform();

}
-->
      </snippet>
    </shader>

    <shader name="createDepthBufferFragment">
      <snippet type="version">120</snippet>
      <snippet type="string">
        <!--

void main(void) {

    // gl_FragCoord.z is in [0.0, 1.0]
    gl_FragColor.xy = vec2(1.0 - gl_FragCoord.z, gl_FragCoord.z);

}
-->
      </snippet>
    </shader>

    <shader name="renderDepthBufferVertex">
      <snippet type="version">120</snippet>
      <snippet type="string">
        <!--

void main(void) {

    gl_Position  = ftransform();

}
-->
      </snippet>
    </shader>

    <shader name="renderDepthBufferFragment">
      <snippet type="version">120</snippet>
      <snippet type="string">
        <!--

uniform float scaleFactor = 4.0;

uniform vec2 texOffset;
uniform sampler2D depthBuffer;

void main(void) {

    vec2 texCoord = (gl_FragCoord.xy * scaleFactor + vec2(0.25, 0.25)) * texOffset;
    if((texCoord.x > 1.0) || (texCoord.y > 1.0)) { discard; }
    vec2 depthValues = texture2D(depthBuffer, texCoord).xy;
    gl_FragColor = vec4( 1.0 + (depthValues.x - 1.0), 0.0 , depthValues.y, 1.0); 
}

-->
      </snippet>
    </shader>

    <shader name="depthPeelingVertex">
      <snippet type="version">120</snippet>
      <snippet type="string">
        <!--

void main(void) {

    gl_Position  = ftransform();

}
-->
      </snippet>
    </shader>

    <shader name="depthPeelingFragment">
      <snippet type="version">120</snippet>
      <snippet name="codeColorBDP"/>
      <snippet type="string">
        <!--

uniform sampler2D bucket0;
uniform sampler2D bucket1;
uniform sampler2D bucket2;
uniform sampler2D bucket3;
uniform sampler2D bucket4;
uniform sampler2D bucket5;
uniform sampler2D bucket6;
uniform sampler2D bucket7;

uniform sampler2D interiorDepth;
uniform sampler2D interiorColor;
uniform sampler2D depthBuffer;

uniform vec2 texOffset;
uniform float alpha;
uniform float absorption;
uniform float interiorProtAlpha;
uniform float alphaGradient;
uniform int DPmode = 1;

void main(void) {

    int i, j, k;
    float thickness, tmpFirst, first, last, usedAlpha, intDepth, lastDepth;
    bool gotfirst;
    vec3 minmaxDepth;
    vec3 firstColorSkipped, color;
    vec4 layer, decodecolor, intColor;

    float epsilon = 0.001;

    vec2 texCoord = (gl_FragCoord.xy + vec2(0.25, 0.25)) * texOffset;

    if(DPmode == 1) {// depth_BDP

        thickness = 0.0f;
        first = 10.0; // max depth
        last = 0.0; // min depth
        tmpFirst = 0.0;
        gotfirst = false;
        color = vec3(0.0, 1.0, 0.0);

        for(i = 0; i < 8; ++i) {
            if(i == 0) { layer = texture2D(bucket0, texCoord); }
            if(i == 1) { layer = texture2D(bucket1, texCoord); }
            if(i == 2) { layer = texture2D(bucket2, texCoord); }
            if(i == 3) { layer = texture2D(bucket3, texCoord); }
            if(i == 4) { layer = texture2D(bucket4, texCoord); }
            if(i == 5) { layer = texture2D(bucket5, texCoord); }
            if(i == 6) { layer = texture2D(bucket6, texCoord); }
            if(i == 7) { layer = texture2D(bucket7, texCoord); }

            if(layer[0] > 0.0) {
                if((layer[1] - (1.0 - layer[0])) > epsilon) { 
                    if(gotfirst) {
                        thickness += ((1.0-layer[0]) - tmpFirst);
                        tmpFirst = layer[1];
                    } else {
                        thickness += (layer[1] - (1.0-layer[0]));
                    }
                } else {  
                    if(gotfirst) {
                        thickness += (layer[1] - tmpFirst);
                        gotfirst = false;
                    } else {
                        gotfirst = true;
                        tmpFirst = layer[1];
                    }
                }
                first = ((1.0 - layer[0]) < first)?((1.0 - layer[0])):(first);
                last = (layer[1] > last)?(layer[1]):(last);
            }
            if(layer[2] > 0.0) {
                if((layer[3] - (1.0 - layer[2])) > epsilon) {
                    if(gotfirst) {
                        thickness += ((1.0-layer[2]) - tmpFirst);
                        tmpFirst = layer[3];
                    } else {
                        thickness += (layer[3] - (1.0-layer[2]));
                    }
                } else {  
                    if(gotfirst) {
                        thickness += (layer[3] - tmpFirst);
                        gotfirst = false;
                    } else {
                        gotfirst = true;
                        tmpFirst = layer[3];
                    }
                }
                first = ((1.0 - layer[2]) < first)?((1.0 - layer[2])):(first);
                last = (layer[3]  > last)?(layer[3]):(last);
            }
        }

        if(gotfirst) {
            thickness = last - first;
            //color = vec3(1.0, 0.0, 0.0);
        }

        gl_FragColor.rgb = color * exp(-absorption*thickness);
        if(gl_FragColor.rgb != vec3(0.0, 1.0, 0.0)) {
            gl_FragColor.a = 1.0;
        } else {
            gl_FragColor.a = 0.0;
        }

    } else if(DPmode == 2) {  // color_BDP

        // back to front alpha blending: C_new = C_back*(1.0- alpha) + C_front*alpha

        color = vec3(1.0, 1.0, 1.0);
        firstColorSkipped = vec3(0.0, 0.0, 0.0);

        if(interiorProtAlpha > 0.0) {
            intDepth = texture2D(interiorDepth, texCoord).x;
            intColor = texture2D(interiorColor, texCoord);
            // get min and max depth of pixel location
            minmaxDepth.xy = texture2D( depthBuffer, texCoord).xy;
            minmaxDepth.x = minmaxDepth.x - 1.0;
            minmaxDepth.z = (minmaxDepth.y + minmaxDepth.x);
            k = int(floor(32.0*(intDepth + minmaxDepth.x) / minmaxDepth.z));
        }

        for(i = 0; i < 8; ++i) {
            if(i == 0) { layer = texture2D(bucket7, texCoord); }
            if(i == 1) { layer = texture2D(bucket6, texCoord); }
            if(i == 2) { layer = texture2D(bucket5, texCoord); }
            if(i == 3) { layer = texture2D(bucket4, texCoord); }
            if(i == 4) { layer = texture2D(bucket3, texCoord); }
            if(i == 5) { layer = texture2D(bucket2, texCoord); }
            if(i == 6) { layer = texture2D(bucket1, texCoord); }
            if(i == 7) { layer = texture2D(bucket0, texCoord); }

            for(j = 0; j < 4; ++j) {

                if((interiorProtAlpha > 0.0) && ((4*(7-i) + (3-j)) == k)) {
                    color = color*(1.0 - interiorProtAlpha) + intColor.rgb*interiorProtAlpha;
                }

                if(layer[3-j] > 0.0) { 
                    //firstColorSkipped = color; 
                    decodecolor = decodeColorBDP(layer[3-j]);

                    usedAlpha = alpha;
                    if(alphaGradient > 0.0) {
                        usedAlpha = clamp((2.0 - (float(4*i+j+1) / 32.0 * alphaGradient)), 0.0, 1.0);
                    }

                    //if(abs(decodecolor.a - 0.5) < 0.01) {
                    //  color = color*(1.0 - usedAlpha)*(1.0 - usedAlpha) + decodecolor.rgb*usedAlpha;
                    //} else {
                    //  color = color*(1.0 - usedAlpha) + decodecolor.rgb*usedAlpha; 
                    //}
                    color = color*(1.0 - usedAlpha) + decodecolor.rgb*usedAlpha; 
                }
            }
        }

        //gl_FragColor.rgb = firstColorSkipped;
        gl_FragColor.rgb = color;

        // set alpha value for fragment
        if(color == vec3(0.0, 0.0, 0.0)) {
            gl_FragColor.a = 0.0;
        } else {
            gl_FragColor.a = 1.0;
        }

    } else if(DPmode == 3) { //adaptive_depth_BDP

        thickness = 0.0f;
        first = 10.0; // max depth
        last = 0.0; // min depth
        tmpFirst = 0.0;
        gotfirst = false;
        color = vec3(0.0, 1.0, 0.0);

        for(i = 0; i < 8; ++i) {
            if(i == 0) { layer = texture2D(bucket0, texCoord); }
            if(i == 1) { layer = texture2D(bucket1, texCoord); }
            if(i == 2) { layer = texture2D(bucket2, texCoord); }
            if(i == 3) { layer = texture2D(bucket3, texCoord); }
            if(i == 4) { layer = texture2D(bucket4, texCoord); }
            if(i == 5) { layer = texture2D(bucket5, texCoord); }
            if(i == 6) { layer = texture2D(bucket6, texCoord); }
            if(i == 7) { layer = texture2D(bucket7, texCoord); }

            if(layer[0] > 0.0) {
                if(gotfirst) {
                    thickness += (layer[0] - tmpFirst);
                    gotfirst = false;
                } else {
                    tmpFirst = layer[0];
                    gotfirst = true;
                }
                first = (layer[0] < first)?(layer[0]):(first);
                last = (layer[0] > last)?(layer[0]):(last);
            }
            if(layer[1] > 0.0) {
                if(gotfirst) {
                    thickness += (layer[1] - tmpFirst);
                    gotfirst = false;
                } else {
                    tmpFirst = layer[1];
                    gotfirst = true;
                }
                first = (layer[1] < first)?(layer[1]):(first);
                last = (layer[1] > last)?(layer[1]):(last);
            }
            if(layer[2] > 0.0) {
                if(gotfirst) {
                    thickness += (layer[2] - tmpFirst);
                    gotfirst = false;
                } else {
                    tmpFirst = layer[2];
                    gotfirst = true;
                }
                first = (layer[2] < first)?(layer[2]):(first);
                last = (layer[2] > last)?(layer[2]):(last);
            }
            if(layer[3] > 0.0) {
                if(gotfirst) {
                    thickness += (layer[3] - tmpFirst);
                    gotfirst = false;
                } else {
                    tmpFirst = layer[3];
                    gotfirst = true;
                }
                first = (layer[3] < first)?(layer[3]):(first);
                last = (layer[3] > last)?(layer[3]):(last);
            }
        }

        if(gotfirst) {
            thickness = last - first;
            //color = vec3(1.0, 0.0, 0.0);
        }

        gl_FragColor.rgb = color * exp(-absorption*thickness);
        if(gl_FragColor.rgb != vec3(0.0, 1.0, 0.0)) {
            gl_FragColor.a = 1.0;
        } else {
            gl_FragColor.a = 0.0;
        }

    } else if(DPmode == 4) { // adaptive_color_BDP

        color = vec3(1.0, 1.0, 1.0);

        for(i = 0; i < 8; ++i) {
            if(i == 0) { layer = texture2D(bucket7, texCoord); }
            if(i == 1) { layer = texture2D(bucket6, texCoord); }
            if(i == 2) { layer = texture2D(bucket5, texCoord); }
            if(i == 3) { layer = texture2D(bucket4, texCoord); }
            if(i == 4) { layer = texture2D(bucket3, texCoord); }
            if(i == 5) { layer = texture2D(bucket2, texCoord); }
            if(i == 6) { layer = texture2D(bucket1, texCoord); }
            if(i == 7) { layer = texture2D(bucket0, texCoord); }

            for(j = 0; j < 4; ++j) {
                if(layer[3-j] > 0.0) { 

                    //firstColorSkipped = color; 
                    decodecolor = decodeColorBDP(layer[3-j]);

                    color = color*(1.0 - alpha) + decodecolor.rgb*alpha; 
                }
            }
        }

        gl_FragColor.rgb = color;
        //gl_FragColor.rgb = firstColorSkipped;

        // set alpha value for fragment
        if(color == vec3(0.0, 0.0, 0.0)) {
            gl_FragColor.a = 0.0;
        } else {
            gl_FragColor.a = 1.0;
        }
    }
}

-->
      </snippet>
    </shader>

    <shader name="histogramEqualVertex">
      <snippet type="version">120</snippet>
      <snippet type="string">
        <!--

void main(void) {

    gl_Position  = ftransform();

}

-->
      </snippet>
    </shader>

    <shader name="histogramEqualFragment">
      <snippet type="version">130</snippet>
      <snippet type="string">
        <!--

#extension GL_EXT_gpu_shader4 : enable

uniform sampler2D depthBuffer;

uniform isampler2D histTex0;
uniform isampler2D histTex1;
uniform isampler2D histTex2;
uniform isampler2D histTex3;
uniform isampler2D histTex4;
uniform isampler2D histTex5;
uniform isampler2D histTex6;
uniform isampler2D histTex7;

uniform vec2 texOffset;

void main(void) {

    int i, j, k, counter, tmpInt;
    int tmpVal;
    ivec4 histogram;
    vec3 minmaxDepth;
    vec2 texCoord = (gl_FragCoord.xy + vec2(0.25, 0.25)) * texOffset;

    // get min and max depth of pixel location
    minmaxDepth.xy = texture2D( depthBuffer, texCoord).xy;
    minmaxDepth.x = minmaxDepth.x - 1.0;
    minmaxDepth.z = (minmaxDepth.y + minmaxDepth.x);

    for(i = 0; i < gl_MaxDrawBuffers; ++i) {
        gl_FragData[i] = vec4(0.0, 0.0, 0.0, 0.0);
    }

    counter = 0;

/*
    for(i = 0; i < 8; ++i) {
        if(i == 0) { histogram = texture2D(histTex0, texCoord); }
        if(i == 1) { histogram = texture2D(histTex1, texCoord); }
        if(i == 2) { histogram = texture2D(histTex2, texCoord); }
        if(i == 3) { histogram = texture2D(histTex3, texCoord); }
        if(i == 4) { histogram = texture2D(histTex4, texCoord); }
        if(i == 5) { histogram = texture2D(histTex5, texCoord); }
        if(i == 6) { histogram = texture2D(histTex6, texCoord); }
        if(i == 7) { histogram = texture2D(histTex7, texCoord); }

        for(j = 0; j < 4; ++j) {
            tmpVal = histogram[j];
            if(tmpVal == 0) continue;
            for(k = 0; k < 32; ++k) {
                if(int(tmpVal & int(int(1) << int(k))) == int(int(1) << int(k))) {
                    gl_FragData[int(counter/4)][int(mod(counter,4))] = -minmaxDepth.x + (float(128*i+32*j+k+1) / 1024.0 * minmaxDepth.z);    
                    counter++;
                    if(counter > 31) return;
                }
            }
        }
    }
*/
}

-->
      </snippet>
    </shader>
  </namespace>

    <namespace name="halo">
      <shader name="GenerateVertex">
        <snippet type="version">110</snippet>
        <snippet type="string">
          <!--
          void main(void) {
            vec4 vertexPos = gl_Vertex;
  
            
            gl_Position = gl_ModelViewProjectionMatrix * vertexPos;
              
            gl_FrontColor = gl_Color;
            gl_BackColor = gl_Color;
          }
        
          -->
        </snippet>
      </shader>

      <shader name="GenerateFragment">
        <snippet type="version">110</snippet>
        <snippet type="string">
          <!--
          uniform vec4 haloColor;
          void main(void) {
            vec3 col = abs(gl_Color.rgb - vec3(0.5, 0.5, 0.5));
            float epsilon = 0.01;
            if( col.r < epsilon && col.g < epsilon && col.b < epsilon)
              discard;
            else
              gl_FragColor = haloColor;
          }
        
          -->
        </snippet>
      </shader>

      <shader name="fragmentHoriz">
        <snippet type="version">120</snippet>
        <snippet type="string">
          <!--
#define GAUSS_3x3
#undef GAUSS_3x3

//#define VERTICAL_FILTER

uniform sampler2D sourceTex;
uniform vec2 screenResInv;

#ifdef GAUSS_3x3
#   define FILTERSAMPLES 3
#   define FILTEROFFSET  1
    float gaussTable[3] = float[3]( 0.25, 0.5, 0.25 );
#else
#   define FILTERSAMPLES 5
#   define FILTEROFFSET  2
    float gaussTable[5] = float[5]( 2.0/30.0, 7.0/30.0, 12.0/30.0, 7.0/30.0, 2.0/30.0 );
#endif



void main(void)
{
    vec4 cOut = vec4(0.0);
    vec4 src = texture2D(sourceTex, gl_TexCoord[0].xy);

    vec2 stepSize = screenResInv;
#ifdef VERTICAL_FILTER
    stepSize.x = 0.0;
#else
    stepSize.y = 0.0;
#endif

    for (int i=0; i<FILTERSAMPLES; ++i)
    {
        vec2 texPos = gl_TexCoord[0].xy + stepSize * (i-FILTEROFFSET);
        vec4 sample = texture2D(sourceTex, texPos);
        cOut += gaussTable[i] * sample;
    }

    gl_FragColor =  cOut;
}
-->
        </snippet>
      </shader>
      <shader name="fragmentVert">
        <snippet type="version">120</snippet>
        <snippet type="string">
          <!--
#define GAUSS_3x3
#undef GAUSS_3x3

#define VERTICAL_FILTER

uniform sampler2D sourceTex;
uniform vec2 screenResInv;

#ifdef GAUSS_3x3
#   define FILTERSAMPLES 3
#   define FILTEROFFSET  1
    float gaussTable[3] = float[3]( 0.25, 0.5, 0.25 );
#else
#   define FILTERSAMPLES 5
#   define FILTEROFFSET  2
    float gaussTable[5] = float[5]( 2.0/30.0, 7.0/30.0, 12.0/30.0, 7.0/30.0, 2.0/30.0 );
#endif



void main(void)
{
    vec4 cOut = vec4(0.0);
    vec4 src = texture2D(sourceTex, gl_TexCoord[0].xy);

    vec2 stepSize = screenResInv;
#ifdef VERTICAL_FILTER
    stepSize.x = 0.0;
#else
    stepSize.y = 0.0;
#endif

    for (int i=0; i<FILTERSAMPLES; ++i)
    {
        vec2 texPos = gl_TexCoord[0].xy + stepSize * (i-FILTEROFFSET);
        vec4 sample = texture2D(sourceTex, texPos);
        cOut += gaussTable[i] * sample;
    }

    gl_FragColor =  cOut;
}
-->
        </snippet>
      </shader>

      <shader name="growFragment">
        <snippet type="version">120</snippet>
        <snippet type="string">
          <!--
uniform sampler2D sourceTex;
uniform vec2 screenResInv;

#define FILTERSAMPLES 5
#define FILTEROFFSET  2

void main(void)
{
    vec4 cOut = vec4(0.0);
    vec4 src = texture2D(sourceTex, gl_TexCoord[0].xy);

    vec2 stepSize = screenResInv;

    for(int y = -FILTERSAMPLES-1; y < FILTERSAMPLES; ++y)
      for(int x = -FILTERSAMPLES-1; x < FILTERSAMPLES; ++x)
      {
        vec2 texPos = gl_TexCoord[0].xy + stepSize * vec2(x, y);
        vec4 sample = texture2D(sourceTex, texPos);
        vec3 col = abs(sample.rgb);
        float epsilon = 0.01;
        if( col.r > epsilon && col.g > epsilon && col.b > epsilon)
        {
          gl_FragColor = sample;
          return;
        }
      }
    discard;
}
-->
        </snippet>
      </shader>
      

      <shader name="SubstractFragment">
        <snippet type="version">110</snippet>
        <snippet type="string">
          <!--
          uniform sampler2D originalTex;
          uniform sampler2D blurredTex;
          void main(void) {
            vec4 orig = texture2D(originalTex, gl_TexCoord[0].xy);
            vec3 col = abs(orig.rgb);
            float epsilon = 0.01;
            if( col.r < epsilon && col.g < epsilon && col.b < epsilon)
              gl_FragColor = texture2D(blurredTex, gl_TexCoord[0].xy);
            else
              discard;
          }
        
          -->
        </snippet>
      </shader>
  </namespace>
  
      <namespace name="slice">
        <shader name="vertex">
        <snippet type="version">130</snippet>
        <snippet type="string">
        <!--
void main(void) {
    gl_Position = gl_ModelViewProjectionMatrix*gl_Vertex;
    gl_TexCoord[0] = gl_MultiTexCoord0;
}
-->
            </snippet>
        </shader>
        <shader name="fragment">
            <snippet type="version">130</snippet>
            <snippet name="electrostatics::colorMix" />
            <snippet name="colormaps::MSH2RGB" />
            <snippet name="colormaps::COOLWARM" />
            <snippet type="string">
        <!--
#extension GL_EXT_gpu_shader4 : enable

uniform sampler3D tex;
uniform float minTex;
uniform float maxTex;
uniform int mode;

// LIC stuff
uniform sampler3D randNoiseTex;
uniform float licContrast;
uniform float licBrightness;
uniform float licDirScl;
uniform float licTCScl;
uniform float isoval;
uniform float isoThresh;
uniform float isoDistribution;

/*
 * GetGradient
 * 
 * Computes the gradient at the respective texel
 */
vec3 GetGradient(vec3 stp) {
    vec3 grad;
    grad.x = texture3D(tex, stp+vec3(0.01, 0.0, 0.0)).a - texture3D(tex, stp-vec3(0.01, 0.0, 0.0)).a;
    grad.y = texture3D(tex, stp+vec3(0.0, 0.01, 0.0)).a - texture3D(tex, stp-vec3(0.0, 0.01, 0.0)).a;
    grad.z = texture3D(tex, stp+vec3(0.0, 0.0, 0.01)).a - texture3D(tex, stp-vec3(0.0, 0.0, 0.01)).a;
    return normalize(grad);
}

/*
 * CalcLIC
 * 
 * Compute Line Integral Convolution. Rather slow because gradient is
 * computed in the fly.
 */
float CalcLIC(int l) {
   
    int i;
    vec3 v;    
    vec3 stp = gl_TexCoord[0].stp;
    float vecScl = licDirScl;
    float randTCScl = licTCScl*float(textureSize(tex, 0).x)/float(textureSize(randNoiseTex, 0).x);
    
    float colLic = texture3D(randNoiseTex, stp*randTCScl).a;
    //v = normalize(texture3D(uniGridTex, stp).xyz)*0.01;
    v = GetGradient(stp)*0.01;    
    
    for(i = 0; i < l; i++) {
        stp -= v*vecScl; 
        stp = clamp(stp, 0.0f, 1.0f);
        colLic += texture3D(randNoiseTex, stp*randTCScl).a;
        //v = normalize(texture3D(uniGridTex, stp).xyz)*0.01;
        v = GetGradient(stp)*0.01;
    }
    
    stp = gl_TexCoord[0].stp;
    
    for(i = 0; i < l; i++) {
        stp += v*vecScl; 
        stp = clamp(stp, 0.0f, 1.0f);
        colLic += texture3D(randNoiseTex, stp*randTCScl).a;
        //v = normalize(texture3D(uniGridTex, stp).xyz)*0.01;
        v = GetGradient(stp)*0.01;
    }
    
    colLic /= float(l+l+1);
    
    // Apply contrast stretching to enhance the final image
    colLic -= licContrast;
    colLic /= (1.0 - 2.0*licContrast);
    colLic += licBrightness;
    
    return colLic;
}

/*
 * main
 */
void main() {
    
    // Get texel coordinates
    ivec3 texelCoords;
    texelCoords.x = int(textureSize(tex, 0).x*gl_TexCoord[0].s);
    texelCoords.y = int(textureSize(tex, 0).y*gl_TexCoord[0].t);
    texelCoords.z = int(textureSize(tex, 0).z*gl_TexCoord[0].p);
    
    if (mode == 0) { // Density map
        gl_FragColor =  vec4(MixColors(texture3D(tex, gl_TexCoord[0].stp).a, 
        minTex, maxTex, 
        vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0)), 1.0);        
    } else if (mode == 1) { // Potential map map
        // Interpolation in MSH color space
        vec3 colMsh = CoolWarmMsh(texture3D(tex, 
            gl_TexCoord[0].stp).a, minTex, 0.0, maxTex);
        gl_FragColor = vec4(MSH2RGB(colMsh.x, colMsh.y, colMsh.z), 1.0);
    } else if (mode == 2) { // LIC
        float lic = CalcLIC(10);
        gl_FragColor = vec4(lic,lic, lic, 1.0);
    } else if (mode == 3) { // Isolines
        // Interpolation in MSH color space
        float val = texture3D(tex, gl_TexCoord[0].stp).a;
        vec3 colMsh = CoolWarmMsh(val, minTex, 0.0, maxTex);
        //gl_FragColor = vec4(0.5, 0.0, 0.0, 1.0);
        //float col = float((abs(val-isoval)/isoDistribution) < isoThresh);
        float col = float(abs(val-isoval)/isoDistribution - float(int(abs(val-isoval)/isoDistribution)) < isoThresh);
        gl_FragColor = vec4(MSH2RGB(colMsh.x, colMsh.y, colMsh.z)*col, col);
		if( abs(col) < 0.001 ) discard;
    } else { // Invalid color mode
        gl_FragColor = vec4(0.5, 1.0, 0.0, 1.0);
    }    
}
-->
            </snippet>
        </shader>
    </namespace>

</btf>
