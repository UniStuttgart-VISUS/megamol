<?xml version="1.0" encoding="utf-8"?>
<btf type="MegaMolGLSLShader" version="1.0" namespace="protein_cuda">
  <include file="common"/>
  <include file="colormaps"/>
  <include file="electrostatics"/>

  <snippet name="commondefines" type="string">
    <!-- 
//#define FOGGING_SES
//#define FLATSHADE_SES
#define OGL_DEPTH_SES
//#define SFB_DEMO

#define CLIP
#define DEPTH
#define SMALL_SPRITE_LIGHTING
//#define CALC_CAM_SYS

#ifdef DEBUG
#undef CLIP
#define RETICLE
#define AXISHINTS
#endif // DEBUG

//#define BULLSHIT

#ifndef FLACH
#define FLACH
#endif

//#define SET_COLOR
//#define COLOR1 vec3( 249.0/255.0, 187.0/255.0, 103.0/255.0)
#define COLOR1 vec3( 183.0/255.0, 204.0/255.0, 220.0/255.0)

//#define COLOR_SES
#define COLOR_BLUE vec3( 145.0/255.0, 191.0/255.0, 219.0/255.0)
#define COLOR_GREEN vec3( 161.0/255.0, 215.0/255.0, 106.0/255.0)
#define COLOR_YELLOW vec3( 255.0/255.0, 255.0/255.0, 191.0/255.0)
#define COLOR_RED vec3( 228.0/255.0, 37.0/255.0, 34.0/255.0)

-->
  </snippet>

  <namespace name="std">
    <shader name="sphereVertex">
      <snippet type="version">110</snippet>
      <snippet name="commondefines"/>
      <snippet type="string">
        <!--

#undef HALO
//#define HALO
#undef HALO_RAD
#define HALO_RAD  0.1

uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)
uniform mat4 invview;
uniform mat4 mvp;

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying float squarRad;
varying float rad;

#ifdef RETICLE
varying vec2 centerFragment;
#endif // RETICLE

void main(void) {

    // remove the sphere radius from the w coordinates to the rad varyings
    vec4 inPos = gl_Vertex;
    rad = inPos.w;
    squarRad = rad * rad;
    inPos.w = 1.0;

    
    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)


    // calculate cam position
    camPos = invview[3]; // (C) by Christoph
    camPos.xyz -= objPos.xyz; // cam pos to glyph space
    

    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = invview * gl_LightSource[0].position - objPos;
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    lightPos = invview * normalize( gl_LightSource[0].position);
    
    

    // send color to fragment shader
    gl_FrontColor = gl_Color;


    // Sphere-Touch-Plane-Approach
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    vec2 d, p, q, h, dd;

    // get camera orthonormal coordinate system
    vec4 tmp;

#ifdef CALC_CAM_SYS
    // camera coordinate system in object space
    tmp = invview[3] + invview[2];
    vec3 camIn = normalize(tmp.xyz);
    tmp = invview[3] + invview[1];
    vec3 camUp = tmp.xyz;
    vec3 camRight = normalize(cross(camIn, camUp));
    camUp = cross(camIn, camRight);
#endif // CALC_CAM_SYS

    vec2 mins, maxs;
    vec3 testPos;
    vec4 projPos;

    
#ifdef HALO
    squarRad = (rad + HALO_RAD) * (rad + HALO_RAD);
#endif // HALO
    
    // projected camera vector
    vec3 c2 = vec3(dot(camPos.xyz, camRight), dot(camPos.xyz, camUp), dot(camPos.xyz, camIn));

    vec3 cpj1 = camIn * c2.z + camRight * c2.x;
    vec3 cpm1 = camIn * c2.x - camRight * c2.z;

    vec3 cpj2 = camIn * c2.z + camUp * c2.y;
    vec3 cpm2 = camIn * c2.y - camUp * c2.z;
    
    d.x = length(cpj1);
    d.y = length(cpj2);

    dd = vec2(1.0) / d;

    p = squarRad * dd;
    q = d - p;
    h = sqrt(p * q);
    //h = vec2(0.0);
    
    p *= dd;
    h *= dd;

    cpj1 *= p.x;
    cpm1 *= h.x;
    cpj2 *= p.y;
    cpm2 *= h.y;

    // TODO: rewrite only using four projections, additions in homogenous coordinates and delayed perspective divisions.
    testPos = objPos.xyz + cpj1 + cpm1;
    projPos = mvp * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = projPos.xy;
    maxs = projPos.xy;

    testPos -= 2.0 * cpm1;
    projPos = mvp * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos = objPos.xyz + cpj2 + cpm2;
    projPos = mvp * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos -= 2.0 * cpm2;
    projPos = mvp * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    gl_PointSize = max((maxs.x - mins.x) * winHalf.x, (maxs.y - mins.y) * winHalf.y) * 0.5;

#ifdef SMALL_SPRITE_LIGHTING
    // for normal crowbaring on very small sprites
    lightPos.w = (clamp(gl_PointSize, 1.0, 5.0) - 1.0) / 4.0;
#endif // SMALL_SPRITE_LIGHTING
    
#ifdef RETICLE
    centerFragment = gl_Position.xy / gl_Position.w;
#endif // RETICLE

    // gl_PointSize = 32.0;
    
#ifdef HALO
    squarRad = rad * rad;
#endif // HALO
}
-->
      </snippet>
    </shader>

    <shader name="sphereFragment">
      <snippet type="version">110</snippet>
      <snippet name="commondefines"/>
      <snippet name="LightDirectional" type="file">lightdirectional.glsl</snippet>
      <snippet type="string">
        <!--

#undef HALO
//#define HALO
#undef HALO_RAD
#define HALO_RAD  0.1

uniform vec4 viewAttr;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying float squarRad;
varying float rad;

#ifdef RETICLE
varying vec2 centerFragment;
#endif // RETICLE

void main(void) {
    vec4 coord;
    vec3 ray;
    float lambda;
    vec3 color;
    vec3 sphereintersection = vec3( 0.0);
    vec3 normal;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    

    // transform fragment coordinates from view coordinates to object coordinates.
    coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;
    coord -= objPos; // ... and to glyph space
    

    // calc the viewing ray
    ray = normalize(coord.xyz - camPos.xyz);


    // calculate the geometry-ray-intersection
    float d1 = -dot(camPos.xyz, ray);                       // projected length of the cam-sphere-vector onto the ray
    float d2s = dot(camPos.xyz, camPos.xyz) - d1 * d1;      // off axis of cam-sphere-vector and ray
    float radicand = squarRad - d2s;                        // square of difference of projected length and lambda
#ifdef CLIP
    lambda = d1 - sqrt(radicand);                           // lambda

    float radicand2 = 0.0;
#ifdef HALO
    radicand2 = (rad+HALO_RAD)*(rad+HALO_RAD) - d2s;
    if( radicand2 < 0.0 ) {
        discard;
    }
    else if( radicand < 0.0 ) {
        // idea for halo from Tarini et al. (tvcg 2006)
        color = vec3(0.1);
        normal = vec3(0.0, 1.0, 0.0);
    }
#else
    if( radicand < 0.0 ) {
        discard;
    }
#endif // HALO
    else {
        // chose color for lighting
        color = gl_Color.rgb;
        sphereintersection = lambda * ray + camPos.xyz;    // intersection point
        // "calc" normal at intersection point
        normal = sphereintersection / rad;
    }
    
#endif // CLIP

#ifdef SMALL_SPRITE_LIGHTING
    normal = mix(-ray, normal, lightPos.w);
#endif // SMALL_SPRITE_LIGHTING

#ifdef AXISHINTS
    // debug-axis-hints
    float mc = min(abs(normal.x), min(abs(normal.y), abs(normal.z)));
    if (mc < 0.05)            { color = vec3(0.5); }
    if (abs(normal.x) > 0.98) { color = vec3(1.0, 0.0, 0.0); }
    if (abs(normal.y) > 0.98) { color = vec3(0.0, 1.0, 0.0); }
    if (abs(normal.z) > 0.98) { color = vec3(0.0, 0.0, 1.0); }
    if (normal.x < -0.99)     { color = vec3(0.5); }
    if (normal.y < -0.99)     { color = vec3(0.5); }
    if (normal.z < -0.99)     { color = vec3(0.5); }
#endif // AXISHINTS

    // phong lighting with directional light
    //gl_FragColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color), 1.0);
    gl_FragColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color), gl_Color.w);
    gl_FragDepth = gl_FragCoord.z;

    // calculate depth
#ifdef DEPTH
    vec4 Ding = vec4( sphereintersection + objPos.xyz, 1.0);
    float depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
    float depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
    gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
    
#ifndef CLIP
    gl_FragDepth = (radicand < 0.0) ? 1.0 : ((depth / depthW) + 1.0) * 0.5;
    gl_FragColor.rgb = (radicand < 0.0) ? gl_Color.rgb : gl_FragColor.rgb;
#endif // CLIP

#endif // DEPTH

    
#ifdef RETICLE
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    if (min(abs(coord.x - centerFragment.x), abs(coord.y - centerFragment.y)) < 0.002) {
        //gl_FragColor.rgb = vec3(1.0, 1.0, 0.5);
        gl_FragColor.rgb += vec3(0.3, 0.3, 0.5);
    }
#endif // RETICLE

#ifdef PUXELS
if(puxels_use != 0)
    puxels_store(makePuxel(packUnorm4x8(gl_FragColor), normal, gl_FragDepth));
#endif

    //gl_FragColor.rgb = normal;
    //gl_FragColor.rgb = lightPos.xyz;
}
-->
      </snippet>
    </shader>

    <shader name="cylinderVertex">
      <snippet type="version">110</snippet>
      <snippet name="commondefines"/>
      <snippet type="string">
        <!--

uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

#ifdef DEBUG
uniform vec2 circleAttr;
#endif // DEBUG

//
attribute vec2 inParams;
attribute vec4 quatC; // conjugate quaternion
//

// colors of cylinder
attribute vec3 color1;
attribute vec3 color2;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying vec3 radz;

varying vec3 rotMatT0;
varying vec3 rotMatT1; // rotation matrix from the quaternion
varying vec3 rotMatT2;

#ifdef RETICLE
varying vec2 centerFragment;
#endif // RETICLE

void main(void) {
    const vec4 quatConst = vec4(1.0, -1.0, 0.5, 0.0);
    vec4 tmp, tmp1;

    // remove the sphere radius from the w coordinates to the rad varyings
    vec4 inPos = gl_Vertex;

    radz.x = inParams.x;
    radz.y = radz.x * radz.x;
    radz.z = inParams.y * 0.5;

    inPos.w = 1.0;

    
    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)


    // orientation quaternion to inverse rotation matrix conversion
    // Begin: Holy code!
    tmp = quatC.xzyw * quatC.yxzw;                        // tmp <- (xy, xz, yz, ww)
    tmp1 = quatC * quatC.w;                                // tmp1 <- (xw, yw, zw, %)
    tmp1.w = -quatConst.z;                                // tmp1 <- (xw, yw, zw, -0.5)

    rotMatT0.xyz = tmp1.wzy * quatConst.xxy + tmp.wxy;    // matrix0 <- (ww-0.5, xy+zw, xz-yw, %)
    rotMatT0.x = quatC.x * quatC.x + rotMatT0.x;        // matrix0 <- (ww+x*x-0.5, xy+zw, xz-yw, %)
    rotMatT0 = rotMatT0 + rotMatT0;                     // matrix0 <- (2(ww+x*x)-1, 2(xy+zw), 2(xz-yw), %)

    rotMatT1.xyz = tmp1.zwx * quatConst.yxx + tmp.xwz;     // matrix1 <- (xy-zw, ww-0.5, yz+xw, %)
    rotMatT1.y = quatC.y * quatC.y + rotMatT1.y;         // matrix1 <- (xy-zw, ww+y*y-0.5, yz+xw, %)
    rotMatT1 = rotMatT1 + rotMatT1;                     // matrix1 <- (2(xy-zw), 2(ww+y*y)-1, 2(yz+xw), %)

    rotMatT2.xyz = tmp1.yxw * quatConst.xyx + tmp.yzw;     // matrix2 <- (xz+yw, yz-xw, ww-0.5, %)
    rotMatT2.z = quatC.z * quatC.z + rotMatT2.z;         // matrix2 <- (xz+yw, yz-xw, ww+zz-0.5, %)
    rotMatT2 = rotMatT2 + rotMatT2;                     // matrix2 <- (2(xz+yw), 2(yz-xw), 2(ww+zz)-1, %)    
    // End: Holy code!


    // calculate cam position
    tmp = gl_ModelViewMatrixInverse[3]; // (C) by Christoph
    tmp.xyz -= objPos.xyz; // cam move
    camPos.xyz = rotMatT0 * tmp.x + rotMatT1 * tmp.y + rotMatT2 * tmp.z;
    

    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = gl_ModelViewMatrixInverse * gl_LightSource[0].position - objPos; // note: w is bullshit now!
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    lightPos = gl_ModelViewMatrixInverse * normalize( gl_LightSource[0].position);
    lightPos.xyz = rotMatT0 * lightPos.x + rotMatT1 * lightPos.y + rotMatT2 * lightPos.z;
    

    // send color to fragment shader
    gl_FrontColor = gl_Color;

    // calculate point sprite
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    // lumberjack approach
    vec4 pos, projPos;
    vec4 pX, pY, pZ, pOP;
    vec2 mins, maxs, pp;

#define CYL_HALF_LEN radz.z
#define CYL_RAD radz.x

    projPos.w = 0.0;

    //pos = vec4(0.0, 0.0, 0.0, 1.0);
    //projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    //projPos.y = dot(rotMatT1.xyz, pos.xyz);
    //projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos; // + projPos; // move
    pos.w = 1.0; // now we're in object space
    pOP = gl_ModelViewProjectionMatrix * pos;

    pos = vec4(1.0, 0.0, 0.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = gl_ModelViewProjectionMatrix * pos;
    pX = (projPos - pOP) * CYL_HALF_LEN;

    pos = vec4(0.0, 1.0, 0.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = gl_ModelViewProjectionMatrix * pos;
    pY = (projPos - pOP) * CYL_RAD;

    pos = vec4(0.0, 0.0, 1.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = gl_ModelViewProjectionMatrix * pos;
    pZ = (projPos - pOP) * CYL_RAD;

    // 8 corners of doom
    pos = pOP + pX;
    projPos = pos + pY + pZ;
    mins = maxs = projPos.xy / projPos.w;

    projPos = pos - pY + pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos + pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);


    pos = pOP - pX;
    projPos = pos + pY + pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY + pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos + pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);


    gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    maxs = (maxs - mins) * 0.5 * winHalf;
    gl_PointSize = max(maxs.x, maxs.y);


//    // oabb-approach
//    // calculate pOP, pX, pY, and pZ as above
//
//    pos = pOP + pX * circleAttr.x;
//    gl_Position = vec4(pos.xyz / pos.w, 1.0);
//
//    float l = camPos.y * camPos.y + camPos.z * camPos.z;
//    if (l < radz.y) { // radius-square
//        // camera is inside the cylinder
//        //  so choose nearest cap and we are done
//        gl_FrontSecondaryColor = vec4(0.5, 0.0, 0.0, 1.0);
//
//        // calculate 4 points of doom
//        pos = pOP + pX * sign(camPos.x);
//
//        projPos = pos + pY + pZ;
//        mins = maxs = projPos.xy / projPos.w;
//
//        projPos = pos - pY + pZ;
//        pp = projPos.xy / projPos.w;
//        mins = min(mins, pp);
//        maxs = max(maxs, pp);
//
//        projPos = pos + pY - pZ;
//        pp = projPos.xy / projPos.w;
//        mins = min(mins, pp);
//        maxs = max(maxs, pp);
//
//        projPos = pos - pY - pZ;
//        pp = projPos.xy / projPos.w;
//        mins = min(mins, pp);
//        maxs = max(maxs, pp);
//
//        gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
//        maxs = (maxs - mins) * 0.5 * winHalf;
//        gl_PointSize = max(maxs.x, maxs.y);
//
//    } else {
//        // camera is outside the cylinder
//        //  so find touching planes
//        gl_FrontSecondaryColor = vec4(0.0, 0.5, 0.0, 1.0);
//
//        vec2 j = vec2(camPos.y, camPos.z);
//        float d = length(j);
//        j /= d;
//        vec2 m = vec2(j.y, -j.x);
//        float p = radz.y / d;
//        float q = d - p;
//        float h = sqrt(p * q);
//
//        vec2 i = j * p + m * h * circleAttr.x;
//
//        i /= radz.x;
//
////        pos = pOP + pX * circleAttr.x + pY * n.y + pZ * n.z;
////        pos = pOP + pX + pY * circleAttr.y + pZ * circleAttr.x;
//
//        float minCylX = -CYL_HALF_LEN + (((radz.x - p * sign(-CYL_HALF_LEN - camPos.x)) * (-CYL_HALF_LEN - camPos.x)) / (-d * sign(-CYL_HALF_LEN - camPos.x) + radz.x)); // tut net so ganz
//        float maxCylX =  CYL_HALF_LEN + (((radz.x + p * sign(CYL_HALF_LEN - camPos.x)) * (CYL_HALF_LEN - camPos.x)) / (d * sign(CYL_HALF_LEN - camPos.x) + radz.x)); // tut, keine Ahnung warum
//
//
//        float fX = mix(minCylX, maxCylX, (circleAttr.y + 1.0) * 0.5);
//
//        pX /= CYL_HALF_LEN;
//
//        pos = pOP + pX * fX + pY * i.x + pZ * i.y;
//      
//        gl_Position = vec4(pos.xyz / pos.w, 1.0);
//
//    }


#ifdef RETICLE
    centerFragment = gl_Position.xy / gl_Position.w;
#endif // RETICLE
    
    // set colors
    gl_FrontColor.r = color1.r;
    gl_FrontColor.g = color1.g;
    gl_FrontColor.b = color1.b;

    gl_FrontSecondaryColor.r = color2.r;
    gl_FrontSecondaryColor.g = color2.g;
    gl_FrontSecondaryColor.b = color2.b;
    
}
-->
      </snippet>
    </shader>

    <shader name="cylinderFragment">
      <snippet type="version">110</snippet>
      <snippet name="commondefines"/>
      <snippet name="LightDirectional" type="file">lightdirectional.glsl</snippet>
      <snippet type="string">
        <!--

//#undef CLIP

// #define RENDER_CAPS

uniform vec4 viewAttr;

FLACH varying vec4 objPos;
FLACH varying vec4 camPos;
FLACH varying vec4 lightPos;
FLACH varying vec3 radz;

FLACH varying vec3 rotMatT0;
FLACH varying vec3 rotMatT1; // rotation matrix from the quaternion
FLACH varying vec3 rotMatT2;

#ifdef RETICLE
FLACH varying vec2 centerFragment;
#endif // RETICLE

void main(void) {
    vec4 coord;
    vec3 ray, tmp;
    const float maxLambda = 50000.0;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    

    // transform fragment coordinates from view coordinates to object coordinates.
    coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;
    coord -= objPos; // ... and move


    // calc the viewing ray
    ray = rotMatT0 * coord.x + rotMatT1 * coord.y + rotMatT2 * coord.z;
    ray = normalize(ray - camPos.xyz);


    // calculate the geometry-ray-intersection

    // cylinder parameters
#define CYL_RAD radz.x
#define CYL_RAD_SQ radz.y
#define CYL_HALF_LEN radz.z

    float rDc = dot(ray.yz, camPos.yz);
    float rDr = dot(ray.yz, ray.yz);

    float radicand = (rDc * rDc) - (rDr * (dot(camPos.yz, camPos.yz) - CYL_RAD_SQ));

#ifdef CLIP
    if (radicand < 0.0) { discard; }
#endif // CLIP

   float radix = sqrt(radicand);
    vec2 lambdas = vec2((-rDc - radix) / rDr, (-rDc + radix) / rDr);

    // calculations for cylinder caps
    vec3 cylPt1 = camPos.xyz + ray * lambdas.x;
    vec3 cylPt2 = camPos.xyz + ray * lambdas.y;

#ifdef RENDER_CAPS
    bool cylPt1Right = (cylPt1.x > 0.0);
#endif // RENDER_CAPS
    bool cylPt1Valid = (cylPt1.x <= CYL_HALF_LEN) && (cylPt1.x >= -CYL_HALF_LEN); // trim cylinder
#ifdef RENDER_CAPS
    bool cylPt2Valid = cylPt1Right ? (cylPt2.x <= CYL_HALF_LEN) : (cylPt2.x >= -CYL_HALF_LEN);
#else
    bool cylPt2Valid = (cylPt2.x <= CYL_HALF_LEN) && (cylPt2.x >= -CYL_HALF_LEN);
#endif // RENDER_CAPS

#ifdef RENDER_CAPS
    lambdas.x = cylPt1Valid ? lambdas.x : (((cylPt1Right ? CYL_HALF_LEN : -CYL_HALF_LEN) - camPos.x) / ray.x);
    lambdas.x = (cylPt1Valid || cylPt2Valid) ? lambdas.x : maxLambda;

#ifdef CLIP
    if (lambdas.x >= maxLambda) { discard; }
#else // CLIP
    if (lambdas.x >= maxLambda) { radicand = -1.0; }
#endif // CLIP

#else // RENDER_CAPS
    lambdas.x = (cylPt1Valid) ? lambdas.x : lambdas.y;    

#ifdef CLIP
    if ((!cylPt1Valid && !cylPt2Valid)) { discard; }
#else // CLIP
    if ((!cylPt1Valid && !cylPt2Valid)) { radicand = -1.0; }
#endif // CLIP
#endif // RENDER_CAPS

    vec3 intersection = camPos.xyz + ray * lambdas.x;
#ifdef RENDER_CAPS
    vec3 normal = (cylPt1Valid ? vec3(0.0, normalize(intersection.yz)) : (cylPt1Right ? vec3(1.0, 0.0, 0.0) : vec3(-1.0, 0.0, 0.0)));
#else // RENDER_CAPS
    vec3 normal = vec3(0.0, normalize(intersection.yz));
#endif // RENDER_CAPS


    // chose color for lighting
    vec3 color = gl_Color.rgb;

    // set fragment color (kroneml)
    if( cylPt1.x > 0.0 )
    {
        color = gl_SecondaryColor.rgb;
    }
    else
    {
        color = gl_Color.rgb;
    }

    // phong lighting with directional light
    gl_FragColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color), 1.0);


    // calculate depth
#ifdef DEPTH
    tmp = intersection;
    intersection.x = dot(rotMatT0, tmp.xyz);
    intersection.y = dot(rotMatT1, tmp.xyz);
    intersection.z = dot(rotMatT2, tmp.xyz);

    intersection += objPos.xyz;

    vec4 Ding = vec4(intersection, 1.0);
    float depth = dot(gl_ModelViewProjectionMatrixTranspose[2], Ding);
    float depthW = dot(gl_ModelViewProjectionMatrixTranspose[3], Ding);
#ifndef CLIP
    if (radicand < 0.0) { 
        gl_FragColor = gl_SecondaryColor;
        depth = 1.0;
        depthW = 1.0;
    }
#endif // CLIP
    gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
#endif // DEPTH

#ifdef RETICLE
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    if (min(abs(coord.x - centerFragment.x), abs(coord.y - centerFragment.y)) < 0.002) {
        gl_FragColor.rgb += vec3(0.3, 0.3, 0.5);
    }
#endif // RETICLE
//    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
//    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
}
-->
      </snippet>
    </shader>

    <shader name="perpixellightVertex">
      <snippet type="version">120</snippet>
      <snippet type="string">
        <!--
varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;
varying vec4 col;

void main()
{    
    // transformation of the normal into eye space
    normal = normalize(gl_NormalMatrix * gl_Normal);
    
    // normalize the direction of the light
    lightDir = normalize(vec3(gl_LightSource[0].position));

    // normalize the halfVector to pass it to the fragment shader
    halfVector = normalize(gl_LightSource[0].halfVector.xyz);
                
    // compute the diffuse, ambient and globalAmbient terms
    /*
    diffuse = gl_FrontMaterial.diffuse * gl_LightSource[0].diffuse;
    ambient = gl_FrontMaterial.ambient * gl_LightSource[0].ambient;
    ambient += gl_LightModel.ambient * gl_FrontMaterial.ambient;
    */
    diffuse = gl_Color * gl_LightSource[0].diffuse;
    ambient = gl_Color * gl_LightSource[0].ambient;
    ambient += gl_LightModel.ambient * gl_Color;

    gl_Position = ftransform();
    gl_FrontColor = gl_Color;
    gl_BackColor = gl_Color;
}
-->
      </snippet>
    </shader>

    <shader name="perpixellightFragment">
      <snippet type="version">120</snippet>
      <snippet type="string">
        <!--
uniform int twoSidedLight = 0;

varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;


void main() {
    float tsl = clamp(float(twoSidedLight), 0.0, 1.0);
    vec3 n,halfV;
    float NdotL,NdotHV;
    
    // store the ambient term
    vec4 color = ambient;
    
    // store the normalized interpolated normal
    n = normalize(normal);

    // compute the dot product between normal and lightDir
    NdotL = dot(n,lightDir);
    if (NdotL > 0.0) {
        // front side
        color += diffuse * NdotL;
        halfV = normalize(halfVector);
        NdotHV = max(dot(n,halfV),4.88e-04);
        color += gl_FrontMaterial.specular * gl_LightSource[0].specular * pow(NdotHV, gl_FrontMaterial.shininess);
    } else {
        // back side
        color += diffuse * (-NdotL) * tsl;
        //halfV = normalize(halfVector);
        //NdotHV = max(dot(-n,halfV),4.88e-04);
        //color += gl_FrontMaterial.specular * gl_LightSource[0].specular * pow(NdotHV, gl_FrontMaterial.shininess) * tsl;
    }

    gl_FragColor = color;
}
-->
      </snippet>
    </shader>

    <shader name="arrowVertexGeom">
      <snippet type="version">140</snippet>
      <snippet name="commondefines"/>
      <snippet name="LightDirectional" type="file">lightdirectional.glsl</snippet>
      <snippet type="string">
        <!--
uniform mat4 modelview;
uniform mat4 proj;

in vec4 pos0;
in vec4 pos1;
in vec4 color;

out vec4 inPos0;
out vec4 inPos1;
out vec4 inColor;

void main(void) {
    inPos0 = pos0;
    inPos1 = pos1;
    inColor = color;
}
-->
      </snippet>
    </shader>
    
    <shader name="arrowGeom">
      <snippet type="version">140</snippet>
      <snippet name="commondefines"/>
      <snippet name="LightDirectional" type="file">lightdirectional.glsl</snippet>
      <snippet type="string">
        <!--
#extension GL_ARB_gpu_shader5 : enable
#extension GL_EXT_geometry_shader4 : enable

layout (points) in;
layout (triangle_strip, max_vertices = 4) out;

uniform mat4 modelview;
uniform mat4 proj;
uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)
uniform vec4 lightPos;

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

#ifdef DEBUG
uniform vec2 circleAttr;
#endif // DEBUG

uniform float radScale;

in vec4 inPos0[1];
in vec4 inPos1[1];
in vec4 inColor[1];

out vec4 objPos;
out vec4 camPos;
out vec4 light;
out vec4 radz; /* (cyl-Rad, tip-Rad, overall-Len, tip-Len) */
out vec3 rotMatT0;
out vec3 rotMatT1; // rotation matrix from the quaternion
out vec3 rotMatT2;
out vec4 colOut;

#ifdef RETICLE
out vec2 centerFragment;
#endif // RETICLE

mat4 modelviewproj = proj*modelview; // TODO Move this to the CPU?
mat4 modelviewInv = inverse(modelview);

void main(void) {
    //const vec4 quatConst = vec4(1.0, -1.0, 0.5, 0.0);
    vec4 tmp, tmp1;

    //vec4 vertex2 = gl_MultiTexCoord0;

    //vec4 quatC = vec4(0.0, 0.0, 0.0, 1.0);
    vec2 inParams = vec2(inPos0[0].w, length(inPos0[0].xyz - inPos1[0].xyz));

    //vec3 xAxis = gl_Vertex.xyz - gl_MultiTexCoord0.xyz;
    vec3 xAxis = inPos1[0].xyz - inPos0[0].xyz;
    xAxis /= inParams.y;

    // remove the sphere radius from the w coordinates to the rad varyings
    vec4 inPos = inPos0[0];

    radz.x = inParams.x * radScale;
    radz.y = radz.x * 1.5;
    radz.z = inParams.y;
//    radz.w = min(gl_MultiTexCoord0.w, radz.z);
    radz.w = radz.z * 0.4;

    inPos.w = 1.0;
    
    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)


    // orientation matrix based on direction vector
    vec3 tmpy = (xAxis.x == 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0);
    vec3 tmpz = normalize(cross(tmpy, xAxis));
    tmpy = normalize(cross(xAxis, tmpz));

    rotMatT0 = vec3(xAxis.x, tmpy.x, tmpz.x);
    rotMatT1 = vec3(xAxis.y, tmpy.y, tmpz.y);
    rotMatT2 = vec3(xAxis.z, tmpy.z, tmpz.z);

    //rotMatT0 = xAxis;
    //rotMatT0 = normalize(rotMatT0);
    //rotMatT1 = ((rotMatT0.x > 0.9) || (rotMatT0.x < -0.9)) ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0); // normal on tmp
    //rotMatT1 = cross(rotMatT1, rotMatT0);
    //rotMatT1 = normalize(rotMatT1);    
    //rotMatT2 = cross(rotMatT0, rotMatT1);


    //rotMatT0 = xAxis;
    //rotMatT1 = (xAxis.x == 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0);
    //rotMatT2 = normalize(cross(rotMatT0, rotMatT1));
    //rotMatT1 = normalize(cross(rotMatT0, rotMatT2));


    // calculate cam position
    tmp = modelviewInv[3]; // (C) by Christoph
    tmp.xyz -= objPos.xyz; // cam move
    camPos.xyz = rotMatT0 * tmp.x + rotMatT1 * tmp.y + rotMatT2 * tmp.z;
    

    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = gl_ModelViewMatrixInverse * gl_LightSource[0].position - objPos; // note: w is bullshit now!
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    light = modelviewInv * normalize(lightPos);
    light.xyz = rotMatT0 * light.x + rotMatT1 * light.y + rotMatT2 * light.z;
    

    // send color to fragment shader
    colOut = inColor[0];
/*
    float sc = 1.0 - inParams.x;
    sc *= sc;
    gl_FrontColor = vec4(0.0, 1.0 - sc, sc, 1.0);
*/

    // calculate point sprite
    //vec2 winHalf = 2.0 / viewAttr.zw; // window size

    // lumberjack approach
    vec4 pos, projPos;
    vec4 pX, pY, pZ, pOP;
    vec2 mins, maxs, pp;

#define CYL_LEN radz.z
#define CYL_RAD radz.y

    projPos.w = 0.0;

    //pos = vec4(0.0, 0.0, 0.0, 1.0);
    //projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    //projPos.y = dot(rotMatT1.xyz, pos.xyz);
    //projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos; // + projPos; // move
    pos.w = 1.0; // now we're in object space
    pOP = modelviewproj * pos;

    pos = vec4(1.0, 0.0, 0.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = modelviewproj * pos;
    pX = (projPos - pOP) * CYL_LEN;

    pos = vec4(0.0, 1.0, 0.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = modelviewproj * pos;
    pY = (projPos - pOP) * CYL_RAD;

    pos = vec4(0.0, 0.0, 1.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = modelviewproj * pos;
    pZ = (projPos - pOP) * CYL_RAD;

    // 8 corners of doom
    pos = pOP + pX;
    projPos = pos + pY + pZ;
    mins = maxs = projPos.xy / projPos.w;

    projPos = pos - pY + pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos + pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    pos = pOP;
    projPos = pos + pY + pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY + pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos + pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

/*    gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    maxs = (maxs - mins) * 0.5 * winHalf;
    gl_PointSize = max(maxs.x, maxs.y);

#ifdef RETICLE
    centerFragment = gl_Position.xy / gl_Position.w;
#endif // RETICLE*/

    gl_Position = vec4(mins.x, maxs.y, 0.0, inPos.w); EmitVertex();
    gl_Position = vec4(mins.x, mins.y, 0.0, inPos.w); EmitVertex();
    gl_Position = vec4(maxs.x, maxs.y, 0.0, inPos.w); EmitVertex();
    gl_Position = vec4(maxs.x, mins.y, 0.0, inPos.w); EmitVertex();
    EndPrimitive();
}
-->
      </snippet>
    </shader>

    <shader name="arrowFragmentGeom">
      <snippet type="version">140</snippet>
      <snippet name="commondefines"/>
      <snippet name="LightDirectional" type="file">lightdirectional.glsl</snippet>
      <snippet type="string">
        <!--
// #undef CLIP
#extension GL_ARB_gpu_shader5 : enable
#extension GL_EXT_geometry_shader4 : enable

#define RENDER_CAPS

uniform vec4 viewAttr;
uniform mat4 modelview;
uniform mat4 proj;

in vec4 objPos;
in vec4 camPos;
in vec4 light;
in vec4 radz; /* (cyl-Rad, tip-Rad, overall-Len, tip-Len) */
in vec3 rotMatT0;
in vec3 rotMatT1; // rotation matrix from the quaternion
in vec3 rotMatT2;
in vec4 colOut;

#ifdef RETICLE
in vec2 centerFragment;
#endif // RETICLE

mat4 modelviewproj = proj*modelview; // TODO Move this to the CPU?
mat4 modelviewProjInv = inverse(modelviewproj);
mat4 modelviewProjTrans = transpose(modelviewproj);

void main(void) {
    vec4 coord;
    vec3 ray, tmp;
    const float maxLambda = 50000.0;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);

    // transform fragment coordinates from view coordinates to object coordinates.
    coord = modelviewProjInv * coord;
    coord /= coord.w;
    coord -= objPos; // ... and move


    // calc the viewing ray
    ray = rotMatT0 * coord.x + rotMatT1 * coord.y + rotMatT2 * coord.z;
    ray = normalize(ray - camPos.xyz);


    // calculate the geometry-ray-intersection

    // cylinder parameters
#define CYL_RAD radz.x
#define CYL_RAD_SQ radz.x * radz.x
#define CYL_LEN radz.z
#define TIP_RAD radz.y
#define TIP_LEN radz.w

    // super unoptimized cone code

    float coneF = TIP_RAD / TIP_LEN;
    coneF *= coneF;
    float coneA = coneF * ray.x * ray.x - ray.y * ray.y - ray.z * ray.z;
    float coneB = 2.0 * (coneF * ray.x * camPos.x - ray.y * camPos.y - ray.z * camPos.z);
    float coneC = coneF * camPos.x * camPos.x - camPos.y * camPos.y - camPos.z * camPos.z;

    float rDc = dot(ray.yz, camPos.yz);
    float rDr = dot(ray.yz, ray.yz);

    vec2 radicand = vec2(
        (rDc * rDc) - (rDr * (dot(camPos.yz, camPos.yz) - CYL_RAD_SQ)),
        coneB * coneB - 4.0 * coneA * coneC);
    vec2 divisor = vec2(rDr, 2.0 * coneA);
    vec2 radix = sqrt(radicand);
    vec2 minusB = vec2(-rDc, -coneB);

    vec4 lambda = vec4(
        (minusB.x - radix.x) / divisor.x,
        (minusB.y + radix.y) / divisor.y,
        (minusB.x + radix.x) / divisor.x,
        (minusB.y - radix.y) / divisor.y);

    bvec4 invalid = bvec4(
        (divisor.x == 0.0) || (radicand.x < 0.0),
        (divisor.y == 0.0) || (radicand.y < 0.0),
        (divisor.x == 0.0) || (radicand.x < 0.0),
        (divisor.y == 0.0) || (radicand.y < 0.0));

    vec4 ix = camPos.xxxx + ray.xxxx * lambda;


    invalid.x = invalid.x || (ix.x < TIP_LEN) || (ix.x > CYL_LEN);
    invalid.y = invalid.y || (ix.y < 0.0) || (ix.y > TIP_LEN);
    invalid.z = invalid.z || !(((ix.z > TIP_LEN) || (ix.x > CYL_LEN)) && (ix.z < CYL_LEN));
    invalid.w = invalid.w || !((ix.w > 0.0) && (ix.w < TIP_LEN));

    if (invalid.x && invalid.y && invalid.z && invalid.w) {
#ifdef CLIP
        discard;
#endif // CLIP
    }

    vec3 intersection, color;
    vec3 normal = vec3(1.0, 0.0, 0.0);
    color = colOut.rgb;

    if (!invalid.y) {
        invalid.xzw = bvec3(true, true, true);
        intersection = camPos.xyz + ray * lambda.y;
        normal = normalize(vec3(-TIP_RAD / TIP_LEN, normalize(intersection.yz)));
//        color = vec3(1.0, 0.0, 0.0);
    }
    if (!invalid.x) {
        invalid.zw = bvec2(true, true);
        intersection = camPos.xyz + ray * lambda.x;
        normal = vec3(0.0, normalize(intersection.yz));
    }
    if (!invalid.z) {
        invalid.w = true;
        lambda.z = (CYL_LEN - camPos.x) / ray.x;
        intersection = camPos.xyz + ray * lambda.z;
    }
    if (!invalid.w) {
        lambda.w = (TIP_LEN - camPos.x) / ray.x;
        intersection = camPos.xyz + ray * lambda.w;
    }

    //color.r = 1.0 - intersection.x / CYL_LEN;
    //color.g = 0.0; // intersection.x / CYL_LEN;
    //color.b = intersection.x / CYL_LEN;

    // phong lighting with directional light
    gl_FragColor = vec4(LocalLighting(ray, normal, light.xyz, color), 1.0);
/*    vec4 lightparams = vec4(0.2, 0.8, 0.4, 10.0);
#define LIGHT_AMBIENT lightparams.x
#define LIGHT_DIFFUSE lightparams.y
#define LIGHT_SPECULAR lightparams.z
#define LIGHT_EXPONENT lightparams.w
    gl_FragColor = vec4(LIGHT_AMBIENT*color, 1.0);*/
    gl_FragColor.rgb = 0.75 * gl_FragColor.rgb + 0.25 * color;


    // calculate depth
#ifdef DEPTH
    tmp = intersection;
    intersection.x = dot(rotMatT0, tmp.xyz);
    intersection.y = dot(rotMatT1, tmp.xyz);
    intersection.z = dot(rotMatT2, tmp.xyz);

    intersection += objPos.xyz;

    vec4 Ding = vec4(intersection, 1.0);
    float depth = dot(modelviewProjTrans[2], Ding);
    float depthW = dot(modelviewProjTrans[3], Ding);
#ifndef CLIP
    if (invalid.x && invalid.y && invalid.z && invalid.w) { 
        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
        gl_FragDepth = 0.99999;
    } else {
#endif // CLIP
    gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
#ifndef CLIP
    }
#endif // CLIP

//    gl_FragColor.rgb *= ;

#endif // DEPTH

#ifdef RETICLE
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    if (min(abs(coord.x - centerFragment.x), abs(coord.y - centerFragment.y)) < 0.002) {
        gl_FragColor.rgb += vec3(0.3, 0.3, 0.5);
    }
#endif // RETICLE*/
}
-->
      </snippet>
    </shader>
  </namespace>

    <namespace name="halo">
      <shader name="GenerateVertex">
        <snippet type="version">110</snippet>
        <snippet type="string">
          <!--
          void main(void) {
            vec4 vertexPos = gl_Vertex;
  
            
            gl_Position = gl_ModelViewProjectionMatrix * vertexPos;
              
            gl_FrontColor = gl_Color;
            gl_BackColor = gl_Color;
          }
        
          -->
        </snippet>
      </shader>

      <shader name="GenerateFragment">
        <snippet type="version">110</snippet>
        <snippet type="string">
          <!--
          uniform vec4 haloColor;
          void main(void) {
            vec3 col = abs(gl_Color.rgb - vec3(0.5, 0.5, 0.5));
            float epsilon = 0.01;
            if( col.r < epsilon && col.g < epsilon && col.b < epsilon)
              discard;
            else
              gl_FragColor = haloColor;
          }
        
          -->
        </snippet>
      </shader>

      <shader name="fragmentHoriz">
        <snippet type="version">120</snippet>
        <snippet type="string">
          <!--
#define GAUSS_3x3
#undef GAUSS_3x3

//#define VERTICAL_FILTER

uniform sampler2D sourceTex;
uniform vec2 screenResInv;

#ifdef GAUSS_3x3
#   define FILTERSAMPLES 3
#   define FILTEROFFSET  1
    float gaussTable[3] = float[3]( 0.25, 0.5, 0.25 );
#else
#   define FILTERSAMPLES 5
#   define FILTEROFFSET  2
    float gaussTable[5] = float[5]( 2.0/30.0, 7.0/30.0, 12.0/30.0, 7.0/30.0, 2.0/30.0 );
#endif



void main(void)
{
    vec4 cOut = vec4(0.0);
    vec4 src = texture2D(sourceTex, gl_TexCoord[0].xy);

    vec2 stepSize = screenResInv;
#ifdef VERTICAL_FILTER
    stepSize.x = 0.0;
#else
    stepSize.y = 0.0;
#endif

    for (int i=0; i<FILTERSAMPLES; ++i)
    {
        vec2 texPos = gl_TexCoord[0].xy + stepSize * (i-FILTEROFFSET);
        vec4 sample = texture2D(sourceTex, texPos);
        cOut += gaussTable[i] * sample;
    }

    gl_FragColor =  cOut;
}
-->
        </snippet>
      </shader>
      <shader name="fragmentVert">
        <snippet type="version">120</snippet>
        <snippet type="string">
          <!--
#define GAUSS_3x3
#undef GAUSS_3x3

#define VERTICAL_FILTER

uniform sampler2D sourceTex;
uniform vec2 screenResInv;

#ifdef GAUSS_3x3
#   define FILTERSAMPLES 3
#   define FILTEROFFSET  1
    float gaussTable[3] = float[3]( 0.25, 0.5, 0.25 );
#else
#   define FILTERSAMPLES 5
#   define FILTEROFFSET  2
    float gaussTable[5] = float[5]( 2.0/30.0, 7.0/30.0, 12.0/30.0, 7.0/30.0, 2.0/30.0 );
#endif



void main(void)
{
    vec4 cOut = vec4(0.0);
    vec4 src = texture2D(sourceTex, gl_TexCoord[0].xy);

    vec2 stepSize = screenResInv;
#ifdef VERTICAL_FILTER
    stepSize.x = 0.0;
#else
    stepSize.y = 0.0;
#endif

    for (int i=0; i<FILTERSAMPLES; ++i)
    {
        vec2 texPos = gl_TexCoord[0].xy + stepSize * (i-FILTEROFFSET);
        vec4 sample = texture2D(sourceTex, texPos);
        cOut += gaussTable[i] * sample;
    }

    gl_FragColor =  cOut;
}
-->
        </snippet>
      </shader>

      <shader name="growFragment">
        <snippet type="version">120</snippet>
        <snippet type="string">
          <!--
uniform sampler2D sourceTex;
uniform vec2 screenResInv;

#define FILTERSAMPLES 5
#define FILTEROFFSET  2

void main(void)
{
    vec4 cOut = vec4(0.0);
    vec4 src = texture2D(sourceTex, gl_TexCoord[0].xy);

    vec2 stepSize = screenResInv;

    for(int y = -FILTERSAMPLES-1; y < FILTERSAMPLES; ++y)
      for(int x = -FILTERSAMPLES-1; x < FILTERSAMPLES; ++x)
      {
        vec2 texPos = gl_TexCoord[0].xy + stepSize * vec2(x, y);
        vec4 sample = texture2D(sourceTex, texPos);
        vec3 col = abs(sample.rgb);
        float epsilon = 0.01;
        if( col.r > epsilon && col.g > epsilon && col.b > epsilon)
        {
          gl_FragColor = sample;
          return;
        }
      }
    discard;
}
-->
        </snippet>
      </shader>
      

      <shader name="SubstractFragment">
        <snippet type="version">110</snippet>
        <snippet type="string">
          <!--
          uniform sampler2D originalTex;
          uniform sampler2D blurredTex;
          void main(void) {
            vec4 orig = texture2D(originalTex, gl_TexCoord[0].xy);
            vec3 col = abs(orig.rgb);
            float epsilon = 0.01;
            if( col.r < epsilon && col.g < epsilon && col.b < epsilon)
              gl_FragColor = texture2D(blurredTex, gl_TexCoord[0].xy);
            else
              discard;
          }
        
          -->
        </snippet>
      </shader>
  </namespace>
</btf>
