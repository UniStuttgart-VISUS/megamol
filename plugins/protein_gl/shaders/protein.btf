<?xml version="1.0" encoding="utf-8"?>
<btf type="MegaMolGLSLShader" version="1.0" namespace="protein">
  <include file="common"/>
  <include file="colormaps"/>

  <snippet name="commondefines" type="string">
    <!-- 
//#define FOGGING_SES
//#define FLATSHADE_SES
#define OGL_DEPTH_SES
//#define SFB_DEMO

#define CLIP
#define DEPTH
#define SMALL_SPRITE_LIGHTING
//#define CALC_CAM_SYS

#ifdef DEBUG
#undef CLIP
#define RETICLE
#define AXISHINTS
#endif // DEBUG

//#define BULLSHIT

#ifndef FLACH
#define FLACH
#endif

//#define SET_COLOR
//#define COLOR1 vec3( 249.0/255.0, 187.0/255.0, 103.0/255.0)
#define COLOR1 vec3( 183.0/255.0, 204.0/255.0, 220.0/255.0)

//#define COLOR_SES
//#define COLOR_BLUE vec3( 145.0/255.0, 191.0/255.0, 219.0/255.0)
#define COLOR_BLUE vec3( 0.0/255.0, 173.0/255.0, 238.0/255.0)
//#define COLOR_GREEN vec3( 161.0/255.0, 215.0/255.0, 106.0/255.0)
//#define COLOR_GREEN vec3( 236.0/255.0, 28.0/255.0, 36.0/255.0) // actually red...
#define COLOR_GREEN vec3( 0.0/255.0, 165.0/255.0, 81.0/255.0)
//#define COLOR_YELLOW vec3( 255.0/255.0, 255.0/255.0, 191.0/255.0)
#define COLOR_YELLOW vec3( 255.0/255.0, 221.0/255.0, 21.0/255.0)
#define COLOR_RED vec3( 228.0/255.0, 37.0/255.0, 34.0/255.0)

-->
  </snippet>

  <!-- shaders for the cartoon protein renderer -->
  <namespace name="cartoon">
    <namespace name="cartoon">
      <shader name="vertex">
        <snippet type="string">
          <!--
/*
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120

varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;

void main(void)
{
    gl_FrontColor=gl_Color;
    gl_BackColor=gl_Color;
    
    // do not ftransform(), geometry shader needs the original vertices
    gl_Position= gl_Vertex;
}
-->
        </snippet>
      </shader>
      <shader name="geometry">
        <snippet type="string">
          <!--
/* Geometry Shader: Cartoon Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable

varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;


void lighting( vec3 norm)
{
    // transformation of the normal into eye space
    normal = normalize(gl_NormalMatrix * norm);
    // normalize the direction of the light
    lightDir = normalize(vec3(gl_LightSource[0].position));
    // normalize the halfVector to pass it to the fragment shader
    halfVector = normalize(gl_LightSource[0].halfVector.xyz);
    // compute the diffuse, ambient and globalAmbient terms
    diffuse = gl_FrontColor * gl_LightSource[0].diffuse;
    ambient = gl_FrontColor * gl_LightSource[0].ambient;
    ambient += gl_LightModel.ambient * gl_FrontColor;
}

void main(void)
{
    // get all vertex positions
    vec3 v0 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v1 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v2 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v3 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 v4 = vec3(gl_PositionIn[4].xyz) / gl_PositionIn[4].w;
    vec3 v5 = vec3(gl_PositionIn[5].xyz) / gl_PositionIn[5].w;
    // compute all needed directions
    vec3 dir20 = v2 - v0;
    vec3 dir12 = v1 - v2;
    vec3 dir32 = v3 - v2;
    vec3 dir43 = v4 - v3;
    vec3 dir53 = v5 - v3;
    
    // number of segments
    const int n = 6;
    // scale factor for the width of the tube
    float scale = gl_FrontColorIn[1].x;
    float stretch1 = gl_FrontColorIn[1].y;
    float stretch2 = gl_FrontColorIn[1].z;

    vec3 dir1 = normalize( cross( dir12, dir32));
    vec3 dir2 = normalize( cross( dir43, dir53));
    
    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    // coil/turn
    if( gl_FrontColorIn[2].x < 1.0 )
    {
        // angle for the rotation
        float alpha;
        // matrices for rotation
        mat3 e = mat3( 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
        mat3 m1 = mat3( 0.0,-ortho1.z, ortho1.y, ortho1.z, 0.0,-ortho1.x,-ortho1.y, ortho1.x, 0.0);
        mat3 m2 = mat3( 0.0,-ortho2.z, ortho2.y, ortho2.z, 0.0,-ortho2.x,-ortho2.y, ortho2.x, 0.0);
        mat3 m1quat = m1 * m1;
        mat3 m2quat = m2 * m2;
        
        vec3 res1;
        vec3 res2;
        
        dir1 = dir1 * scale;
        dir2 = dir2 * scale;
        
        for( int i = 0; i < n; i++ )
        {
            alpha = (360.0/float(n))*float(i);
            res1 = ( e + sin( radians( alpha)) * m1 + ( 1.0 - cos( radians( alpha))) * m1quat ) * dir1;
            res2 = ( e + sin( radians( alpha)) * m2 + ( 1.0 - cos( radians( alpha))) * m2quat ) * dir2;
            
            // copy color 
            gl_FrontColor = gl_FrontColorIn[0];
            // copy position 
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + res1).xyz, 1.0);
            // compute lighting
            lighting( normalize( res1));
            // done with the vertex 
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + res2).xyz, 1.0);
            lighting( normalize( res2));
            EmitVertex();
        }
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1).xyz, 1.0);
        lighting( normalize( dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2).xyz, 1.0);
        lighting( normalize( dir2));
        EmitVertex();
        
        EndPrimitive();
/*
        ////////////////
        // draw start //
        ////////////////
        for( int i = 0; i < n; i++ )
        {
            alpha = (360.0/float(n))*float(i);
            res1 = ( e + sin( radians( alpha)) * m2 + ( 1.0 - cos( radians( alpha))) * m2quat ) * dir2;
            alpha = (360.0/float(n))*float(i+1);
            res2 = ( e + sin( radians( alpha)) * m2 + ( 1.0 - cos( radians( alpha))) * m2quat ) * dir2;
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + res1).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + res2).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( v3, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            EndPrimitive();
        }
*/
/*
        //////////////
        // draw end //
        //////////////
        for( int i = 0; i < n; i++ )
        {
            alpha = (360.0/float(n))*float(i);
            res1 = ( e + sin( radians( alpha)) * m1 + ( 1.0 - cos( radians( alpha))) * m1quat ) * dir1;
            alpha = (360.0/float(n))*float(i+1);
            res2 = ( e + sin( radians( alpha)) * m1 + ( 1.0 - cos( radians( alpha))) * m1quat ) * dir1;
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + res1).xyz, 1.0);
            lighting( normalize(-dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + res2).xyz, 1.0);
            lighting( normalize(-dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( v2, 1.0);
            lighting( normalize(-dir20));
            EmitVertex();
            
            EndPrimitive();
        }
*/
    }
    // sheet ribbon
    else if( gl_FrontColorIn[2].x > 0.5 && gl_FrontColorIn[2].x < 1.5 )
    {
        dir1 = normalize( cross( dir1, ortho1))*stretch1;
        dir2 = normalize( cross( dir2, ortho2))*stretch2;
        vec3 norm1 = normalize( cross( dir1, ortho1));
        vec3 norm2 = normalize( cross( dir2, ortho2));
        
        /////////////////////
        // draw top ribbon //
        /////////////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
        lighting( normalize( norm1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
        lighting( normalize( norm1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
        lighting( normalize( norm2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
        lighting( normalize( norm2));
        EmitVertex();
        
        EndPrimitive();
        
        ////////////////////////
        // draw bottom ribbon //
        ////////////////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
        lighting( normalize(-norm1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
        lighting( normalize(-norm1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
        lighting( normalize(-norm2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
        lighting( normalize(-norm2));
        EmitVertex();
        
        EndPrimitive();
        
        /////////////////////
        // draw first side //
        /////////////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
        lighting( normalize( dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
        lighting( normalize( dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir2));
        EmitVertex();
        
        EndPrimitive();
        
        //////////////////////
        // draw second side //
        //////////////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
        lighting( normalize(-dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
        lighting( normalize(-dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
        lighting( normalize(-dir2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
        lighting( normalize(-dir2));
        EmitVertex();
        
        EndPrimitive();
        
        if( gl_FrontColorIn[2].y > 0.0 )
        {
            ////////////////
            // draw start //
            ////////////////
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            EndPrimitive();
        }
        
        if( gl_FrontColorIn[2].z > 0.0 )
        {
            //////////////
            // draw end //
            //////////////
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
            lighting( normalize(-dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
            lighting( normalize(-dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
            lighting( normalize(-dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
            lighting( normalize(-dir20));
            EmitVertex();
            
            EndPrimitive();
        }
    }
    // helix ribbon
    else if( gl_FrontColorIn[2].x > 1.5 && gl_FrontColorIn[2].x < 2.5 )
    {
        dir1 = normalize( cross( dir1, ortho1))*stretch1;
        dir2 = normalize( cross( dir2, ortho2))*stretch2;
        vec3 norm1 = normalize( cross( dir1, ortho1));
        vec3 norm2 = normalize( cross( dir2, ortho2));
        
        /////////////////////
        // draw top ribbon //
        /////////////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
        lighting( normalize(-dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
        lighting( normalize(-dir2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 + norm1*scale).xyz, 1.0);
        lighting( normalize( norm1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 + norm2*scale).xyz, 1.0);
        lighting( normalize( norm2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 + norm1*scale).xyz, 1.0);
        lighting( normalize( norm1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 + norm2*scale).xyz, 1.0);
        lighting( normalize( norm2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir2));
        EmitVertex();
        
        EndPrimitive();
        
        ////////////////////////
        // draw bottom ribbon //
        ////////////////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
        lighting( normalize(-dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
        lighting( normalize(-dir2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 - norm1*scale).xyz, 1.0);
        lighting( normalize(-norm1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 - norm2*scale).xyz, 1.0);
        lighting( normalize(-norm2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 - norm1*scale).xyz, 1.0);
        lighting( normalize(-norm1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 - norm2*scale).xyz, 1.0);
        lighting( normalize(-norm2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir2));
        EmitVertex();
        
        EndPrimitive();
        
        /////////////////////
        // draw first side //
        /////////////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir2));
        EmitVertex();
        
        EndPrimitive();
        
        //////////////////////
        // draw second side //
        //////////////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
        lighting( normalize(-dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
        lighting( normalize(-dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
        lighting( normalize(-dir2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
        lighting( normalize(-dir2));
        EmitVertex();
        
        EndPrimitive();
        
        if( gl_FrontColorIn[2].y > 0.0 )
        {
            ////////////////
            // draw start //
            ////////////////
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 + norm2*scale).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 + norm2*scale).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 - norm2*scale).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 - norm2*scale).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            EndPrimitive();
        }

        if( gl_FrontColorIn[2].z > 0.0 )
        {
            //////////////
            // draw end //
            //////////////
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 + norm1*scale).xyz, 1.0);
            lighting( normalize( -dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 + norm1*scale).xyz, 1.0);
            lighting( normalize( -dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
            lighting( normalize( -dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
            lighting( normalize( -dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
            lighting( normalize( -dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
            lighting( normalize( -dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 - norm1*scale).xyz, 1.0);
            lighting( normalize( -dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 - norm1*scale).xyz, 1.0);
            lighting( normalize( -dir20));
            EmitVertex();
            
            EndPrimitive();
        }
    }
}
-->
        </snippet>
      </shader>
      <shader name="fragment">
        <snippet type="string">
          <!--
/*
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120

varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;


void main(void)
{    
    //gl_FragColor = gl_Color;

    vec3 n,halfV;
    float NdotL,NdotHV;
    
    // store the ambient term
    vec4 color = ambient;
    
    // store the normalized interpolated normal
    n = normalize(normal);
    
    // compute the dot product between normal and ldir
    NdotL = max(dot(n,lightDir),0.0);
    if (NdotL > 0.0) {
        color += diffuse * NdotL;
        halfV = normalize(halfVector);
        NdotHV = max(dot(n,halfV),0.0);
        color += gl_FrontMaterial.specular * gl_LightSource[0].specular * 
                pow(NdotHV, gl_FrontMaterial.shininess);
    }

    gl_FragColor = color;
    
    /*
    vec3 fogCol = vec3( 1.0, 1.0, 1.0);
    const float LOG2 = 1.442695;
    float fogDensity = 0.35;
    float z = gl_FragCoord.z / gl_FragCoord.w;
    float fogFactor = exp2( - fogDensity * fogDensity * z * z * LOG2 );
    fogFactor = clamp(fogFactor, 0.0, 1.0);
    gl_FragColor.rgb = mix( fogCol, gl_FragColor.rgb, fogFactor );
    */
}
-->
        </snippet>
      </shader>
    </namespace>
    <shader name="tubeGeometry">
      <snippet type="string">
        <!-- 
/* Geometry Shader: Tube Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable

varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;


void lighting( vec3 norm)
{
    // transformation of the normal into eye space
    normal = normalize(gl_NormalMatrix * norm);
    // normalize the direction of the light
    lightDir = normalize(vec3(gl_LightSource[0].position));
    // normalize the halfVector to pass it to the fragment shader
    halfVector = normalize(gl_LightSource[0].halfVector.xyz);
    // compute the diffuse, ambient and globalAmbient terms
    diffuse = gl_FrontColor * gl_LightSource[0].diffuse;
    ambient = gl_FrontColor * gl_LightSource[0].ambient;
    ambient += gl_LightModel.ambient * gl_FrontColor;
}

void main(void)
{
    // get all vertex positions
    vec3 v0 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v1 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v2 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v3 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 v4 = vec3(gl_PositionIn[4].xyz) / gl_PositionIn[4].w;
    vec3 v5 = vec3(gl_PositionIn[5].xyz) / gl_PositionIn[5].w;
    // compute all needed directions
    vec3 dir20 = v2 - v0;
    vec3 dir12 = v1 - v2;
    vec3 dir32 = v3 - v2;
    vec3 dir43 = v4 - v3;
    vec3 dir53 = v5 - v3;
    
    // number of segments
    const int n = 12;
    // scale factor for the width of the tube
    float scale = gl_FrontColorIn[1].x;
    float stretch1 = gl_FrontColorIn[1].y;
    float stretch2 = gl_FrontColorIn[1].z;

    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));

    // angle for the rotation
    float alpha;
    // matrices for rotation
    mat3 e = mat3( 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
    mat3 m1 = mat3( 0.0,-ortho1.z, ortho1.y, ortho1.z, 0.0,-ortho1.x,-ortho1.y, ortho1.x, 0.0);
    mat3 m2 = mat3( 0.0,-ortho2.z, ortho2.y, ortho2.z, 0.0,-ortho2.x,-ortho2.y, ortho2.x, 0.0);
    mat3 m1quat = m1 * m1;
    mat3 m2quat = m2 * m2;
    
    vec3 res1;
    vec3 res2;
    
    dir1 = dir1 * scale;
    dir2 = dir2 * scale;
    
    for( int i = 0; i < n; i++ )
    {
        alpha = (360.0/float(n))*float(i);
        res1 = ( e + sin( radians( alpha)) * m1 + ( 1.0 - cos( radians( alpha))) * m1quat ) * dir1;
        res2 = ( e + sin( radians( alpha)) * m2 + ( 1.0 - cos( radians( alpha))) * m2quat ) * dir2;
        
        // copy color 
        gl_FrontColor = gl_FrontColorIn[0];
        // copy position 
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + res1).xyz, 1.0);
        // compute lighting
        lighting( normalize( res1));
        // done with the vertex 
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + res2).xyz, 1.0);
        lighting( normalize( res2));
        EmitVertex();
    }
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
}
-->
      </snippet>
    </shader>
    <shader name="arrowGeometry">
      <snippet type="string">
        <!--
/* Geometry Shader: Arrow Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable

varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;


void lighting( vec3 norm)
{
    // transformation of the normal into eye space
    normal = normalize(gl_NormalMatrix * norm);
    // normalize the direction of the light
    lightDir = normalize(vec3(gl_LightSource[0].position));
    // normalize the halfVector to pass it to the fragment shader
    halfVector = normalize(gl_LightSource[0].halfVector.xyz);
    // compute the diffuse, ambient and globalAmbient terms
    diffuse = gl_FrontColor * gl_LightSource[0].diffuse;
    ambient = gl_FrontColor * gl_LightSource[0].ambient;
    ambient += gl_LightModel.ambient * gl_FrontColor;
}

void main(void)
{
    // get all vertex positions
    vec3 v0 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v1 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v2 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v3 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 v4 = vec3(gl_PositionIn[4].xyz) / gl_PositionIn[4].w;
    vec3 v5 = vec3(gl_PositionIn[5].xyz) / gl_PositionIn[5].w;
    // compute all needed directions
    vec3 dir20 = v2 - v0;
    vec3 dir12 = v1 - v2;
    vec3 dir32 = v3 - v2;
    vec3 dir43 = v4 - v3;
    vec3 dir53 = v5 - v3;
    
    // scale factor for the width of the tube
    float scale = gl_FrontColorIn[1].x;
    float stretch1 = gl_FrontColorIn[1].y;
    float stretch2 = gl_FrontColorIn[1].z;

    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));

    dir1 = normalize( cross( dir1, ortho1))*stretch1;
    dir2 = normalize( cross( dir2, ortho2))*stretch2;
    
    vec3 norm1 = normalize( cross( dir1, ortho1));
    vec3 norm2 = normalize( cross( dir2, ortho2));
    
    /////////////////////
    // draw top ribbon //
    /////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
    lighting( normalize( norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
    lighting( normalize( norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
    lighting( normalize( norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
    lighting( normalize( norm2));
    EmitVertex();
    
    EndPrimitive();
    
    ////////////////////////
    // draw bottom ribbon //
    ////////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
    lighting( normalize(-norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
    lighting( normalize(-norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
    lighting( normalize(-norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
    lighting( normalize(-norm2));
    EmitVertex();
    
    EndPrimitive();
    
    /////////////////////
    // draw first side //
    /////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
    
    //////////////////////
    // draw second side //
    //////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    EndPrimitive();
    
    if( gl_FrontColorIn[2].y > 0.0 )
    {
        ////////////////
        // draw start //
        ////////////////
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        EndPrimitive();
    }
    
    if( gl_FrontColorIn[2].z > 0.0 )
    {
        //////////////
        // draw end //
        //////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
        lighting( normalize(-dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
        lighting( normalize(-dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
        lighting( normalize(-dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
        lighting( normalize(-dir20));
        EmitVertex();
        
        EndPrimitive();
    }

}
-->
      </snippet>
    </shader>
    <shader name="helixGeometry">
      <snippet type="string">
        <!--
/* Geometry Shader: Helix Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable

varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;


void lighting( vec3 norm)
{
    // transformation of the normal into eye space
    normal = normalize(gl_NormalMatrix * norm);
    // normalize the direction of the light
    lightDir = normalize(vec3(gl_LightSource[0].position));
    // normalize the halfVector to pass it to the fragment shader
    halfVector = normalize(gl_LightSource[0].halfVector.xyz);
    // compute the diffuse, ambient and globalAmbient terms
    diffuse = gl_FrontColor * gl_LightSource[0].diffuse;
    ambient = gl_FrontColor * gl_LightSource[0].ambient;
    ambient += gl_LightModel.ambient * gl_FrontColor;
}

void main(void)
{
    // get all vertex positions
    vec3 v0 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v1 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v2 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v3 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 v4 = vec3(gl_PositionIn[4].xyz) / gl_PositionIn[4].w;
    vec3 v5 = vec3(gl_PositionIn[5].xyz) / gl_PositionIn[5].w;
    // compute all needed directions
    vec3 dir20 = v2 - v0;
    vec3 dir12 = v1 - v2;
    vec3 dir32 = v3 - v2;
    vec3 dir43 = v4 - v3;
    vec3 dir53 = v5 - v3;
    
    // scale factor for the width of the tube
    float scale = gl_FrontColorIn[1].x;
    float stretch1 = gl_FrontColorIn[1].y;
    float stretch2 = gl_FrontColorIn[1].z;

    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));
    
    dir1 = normalize( cross( dir1, ortho1))*stretch1;
    dir2 = normalize( cross( dir2, ortho2))*stretch2;
    vec3 norm1 = normalize( cross( dir1, ortho1));
    vec3 norm2 = normalize( cross( dir2, ortho2));
    
    /////////////////////
    // draw top ribbon //
    /////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 + norm1*scale).xyz, 1.0);
    lighting( normalize( norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 + norm2*scale).xyz, 1.0);
    lighting( normalize( norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 + norm1*scale).xyz, 1.0);
    lighting( normalize( norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 + norm2*scale).xyz, 1.0);
    lighting( normalize( norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
    
    ////////////////////////
    // draw bottom ribbon //
    ////////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 - norm1*scale).xyz, 1.0);
    lighting( normalize(-norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 - norm2*scale).xyz, 1.0);
    lighting( normalize(-norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 - norm1*scale).xyz, 1.0);
    lighting( normalize(-norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 - norm2*scale).xyz, 1.0);
    lighting( normalize(-norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
    
    /////////////////////
    // draw first side //
    /////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
    
    //////////////////////
    // draw second side //
    //////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    EndPrimitive();
    
    if( gl_FrontColorIn[2].y > 0.0 )
    {
        ////////////////
        // draw start //
        ////////////////
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        EndPrimitive();
    }

    if( gl_FrontColorIn[2].z > 0.0 )
    {
        //////////////
        // draw end //
        //////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 + norm1*scale).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 + norm1*scale).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 - norm1*scale).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 - norm1*scale).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        EndPrimitive();
    }
}
-->
      </snippet>
    </shader>

    <namespace name="simple">
      <shader name="vertex">
        <snippet type="string">
          <!--
/*
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120


void main(void)
{
    gl_FrontColor=gl_Color;
    gl_BackColor=gl_Color;
    
    // do not ftransform(), geometry shader needs the original vertices
    gl_Position= gl_Vertex;
}
-->
        </snippet>
      </shader>
      <shader name="fragment">
        <snippet type="string">
          <!--
/*
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120


void main(void)
{    
    gl_FragColor = gl_Color;
}
-->
        </snippet>
      </shader>
      <shader name="tubeGeometry">
        <snippet type="string">
          <!--
/* Geometry Shader: Cartoon Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable


void lighting( vec3 norm)
{
    vec3 normal, lightDir;
    vec4 diffuse, ambient, globalAmbient;
    float NdotL;
    
    normal = normalize(gl_NormalMatrix * norm);
    lightDir = normalize(vec3(gl_LightSource[0].position));
    NdotL = max(dot(normal, lightDir), 0.0);
    diffuse = gl_FrontColor * gl_LightSource[0].diffuse;
    
    /* Compute the ambient and globalAmbient terms */
    ambient = gl_FrontColor * gl_LightSource[0].ambient;
    globalAmbient = gl_LightModel.ambient * gl_FrontColor;
    
    gl_FrontColor =  NdotL * diffuse + globalAmbient + ambient;
    gl_BackColor =  NdotL * diffuse + globalAmbient + ambient;
}

void main(void)
{
    // get all vertex positions
    vec3 v0 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v1 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v2 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v3 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 v4 = vec3(gl_PositionIn[4].xyz) / gl_PositionIn[4].w;
    vec3 v5 = vec3(gl_PositionIn[5].xyz) / gl_PositionIn[5].w;
    // compute all needed directions
    vec3 dir20 = v2 - v0;
    vec3 dir12 = v1 - v2;
    vec3 dir32 = v3 - v2;
    vec3 dir43 = v4 - v3;
    vec3 dir53 = v5 - v3;
    
    // number of segments
    const int n = 12;
    // scale factor for the width of the tube
    float scale = gl_FrontColorIn[1].x;
    float stretch1 = gl_FrontColorIn[1].y;
    float stretch2 = gl_FrontColorIn[1].z;

    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));
    
    // angle for the rotation
    float alpha;
    // matrices for rotation
    mat3 e = mat3( 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
    mat3 m1 = mat3( 0.0,-ortho1.z, ortho1.y, ortho1.z, 0.0,-ortho1.x,-ortho1.y, ortho1.x, 0.0);
    mat3 m2 = mat3( 0.0,-ortho2.z, ortho2.y, ortho2.z, 0.0,-ortho2.x,-ortho2.y, ortho2.x, 0.0);
    mat3 m1quat = m1 * m1;
    mat3 m2quat = m2 * m2;
    
    vec3 res1;
    vec3 res2;
    
    dir1 = dir1 * scale;
    dir2 = dir2 * scale;
    
    for( int i = 0; i < n; i++ )
    {
        alpha = (360.0/float(n))*float(i);
        res1 = ( e + sin( radians( alpha)) * m1 + ( 1.0 - cos( radians( alpha))) * m1quat ) * dir1;
        res2 = ( e + sin( radians( alpha)) * m2 + ( 1.0 - cos( radians( alpha))) * m2quat ) * dir2;
        
        // copy color 
        gl_FrontColor = gl_FrontColorIn[0];
        // copy position
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + res1).xyz, 1.0);
        // compute lighting
        lighting( normalize( res1));
        // done with the vertex 
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + res2).xyz, 1.0);
        lighting( normalize( res2));
        EmitVertex();
    }
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
}
-->
        </snippet>
      </shader>
      <shader name="arrowGeometry">
        <snippet type="string">
          <!--
/* Geometry Shader: Cartoon Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable


void lighting( vec3 norm)
{
    vec3 normal, lightDir;
    vec4 diffuse, ambient, globalAmbient;
    float NdotL;
    
    normal = normalize(gl_NormalMatrix * norm);
    lightDir = normalize(vec3(gl_LightSource[0].position));
    NdotL = max(dot(normal, lightDir), 0.0);
    diffuse = gl_FrontColor * gl_LightSource[0].diffuse;
    
    /* Compute the ambient and globalAmbient terms */
    ambient = gl_FrontColor * gl_LightSource[0].ambient;
    globalAmbient = gl_LightModel.ambient * gl_FrontColor;
    
    gl_FrontColor =  NdotL * diffuse + globalAmbient + ambient;
    gl_BackColor =  NdotL * diffuse + globalAmbient + ambient;
}

void main(void)
{
    // get all vertex positions
    vec3 v0 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v1 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v2 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v3 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 v4 = vec3(gl_PositionIn[4].xyz) / gl_PositionIn[4].w;
    vec3 v5 = vec3(gl_PositionIn[5].xyz) / gl_PositionIn[5].w;
    // compute all needed directions
    vec3 dir20 = v2 - v0;
    vec3 dir12 = v1 - v2;
    vec3 dir32 = v3 - v2;
    vec3 dir43 = v4 - v3;
    vec3 dir53 = v5 - v3;
    
    // scale factor for the width of the tube
    float scale = gl_FrontColorIn[1].x;
    float stretch1 = gl_FrontColorIn[1].y;
    float stretch2 = gl_FrontColorIn[1].z;

    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));

    dir1 = normalize( cross( dir1, ortho1))*stretch1;
    dir2 = normalize( cross( dir2, ortho2))*stretch2;
    vec3 norm1 = normalize( cross( dir1, ortho1));
    vec3 norm2 = normalize( cross( dir2, ortho2));
    
    /////////////////////
    // draw top ribbon //
    /////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
    lighting( normalize( norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
    lighting( normalize( norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
    lighting( normalize( norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
    lighting( normalize( norm2));
    EmitVertex();
    
    EndPrimitive();
    
    ////////////////////////
    // draw bottom ribbon //
    ////////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
    lighting( normalize(-norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
    lighting( normalize(-norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
    lighting( normalize(-norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
    lighting( normalize(-norm2));
    EmitVertex();
    
    EndPrimitive();
    
    /////////////////////
    // draw first side //
    /////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
    
    //////////////////////
    // draw second side //
    //////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    EndPrimitive();
    
    if( gl_FrontColorIn[2].y > 0.0 )
    {
        ////////////////
        // draw start //
        ////////////////
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        EndPrimitive();
    }
    
    if( gl_FrontColorIn[2].z > 0.0 )
    {
        //////////////
        // draw end //
        //////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
        lighting( normalize(-dir20));
        EmitVertex();
        
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
        lighting( normalize(-dir20));
        EmitVertex();
        
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
        lighting( normalize(-dir20));
        EmitVertex();
        
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
        lighting( normalize(-dir20));
        EmitVertex();
        
        EndPrimitive();
    }
}
-->
        </snippet>
      </shader>
      <shader name="helixGeometry">
        <snippet type="string">
          <!--
/* Geometry Shader: Cartoon Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable


void lighting( vec3 norm)
{
    vec3 normal, lightDir;
    vec4 diffuse, ambient, globalAmbient;
    float NdotL;
    
    normal = normalize(gl_NormalMatrix * norm);
    lightDir = normalize(vec3(gl_LightSource[0].position));
    NdotL = max(dot(normal, lightDir), 0.0);
    diffuse = gl_FrontColor * gl_LightSource[0].diffuse;
    
    /* Compute the ambient and globalAmbient terms */
    ambient = gl_FrontColor * gl_LightSource[0].ambient;
    globalAmbient = gl_LightModel.ambient * gl_FrontColor;
    
    gl_FrontColor =  NdotL * diffuse + globalAmbient + ambient;
    gl_BackColor =  NdotL * diffuse + globalAmbient + ambient;
}

void main(void)
{
    // get all vertex positions
    vec3 v0 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v1 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v2 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v3 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 v4 = vec3(gl_PositionIn[4].xyz) / gl_PositionIn[4].w;
    vec3 v5 = vec3(gl_PositionIn[5].xyz) / gl_PositionIn[5].w;
    // compute all needed directions
    vec3 dir20 = v2 - v0;
    vec3 dir12 = v1 - v2;
    vec3 dir32 = v3 - v2;
    vec3 dir43 = v4 - v3;
    vec3 dir53 = v5 - v3;
    
    // scale factor for the width of the tube
    float scale = gl_FrontColorIn[1].x;
    float stretch1 = gl_FrontColorIn[1].y;
    float stretch2 = gl_FrontColorIn[1].z;

    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));
    
    dir1 = normalize( cross( dir1, ortho1))*stretch1;
    dir2 = normalize( cross( dir2, ortho2))*stretch2;
    vec3 norm1 = normalize( cross( dir1, ortho1));
    vec3 norm2 = normalize( cross( dir2, ortho2));
        
    /////////////////////
    // draw top ribbon //
    /////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 + norm1*scale).xyz, 1.0);
    lighting( normalize( norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 + norm2*scale).xyz, 1.0);
    lighting( normalize( norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 + norm1*scale).xyz, 1.0);
    lighting( normalize( norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 + norm2*scale).xyz, 1.0);
    lighting( normalize( norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
    
    ////////////////////////
    // draw bottom ribbon //
    ////////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 - norm1*scale).xyz, 1.0);
    lighting( normalize(-norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 - norm2*scale).xyz, 1.0);
    lighting( normalize(-norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 - norm1*scale).xyz, 1.0);
    lighting( normalize(-norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 - norm2*scale).xyz, 1.0);
    lighting( normalize(-norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
    
    /////////////////////
    // draw first side //
    /////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
    
    //////////////////////
    // draw second side //
    //////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    EndPrimitive();
    
    if( gl_FrontColorIn[2].y > 0.0 )
    {
        ////////////////
        // draw start //
        ////////////////
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        EndPrimitive();
    }

    if( gl_FrontColorIn[2].z > 0.0 )
    {
        //////////////
        // draw end //
        //////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 + norm1*scale).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 + norm1*scale).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 - norm1*scale).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 - norm1*scale).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        EndPrimitive();
    }
}
-->
        </snippet>
      </shader>
    </namespace>

    <namespace name="spline">
      <shader name="vertex">
        <snippet type="string">
          <!--
/*
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120

void main(void)
{
    gl_FrontColor = gl_Color;
    gl_BackColor = gl_Color;
    gl_FrontSecondaryColor = gl_SecondaryColor;
    gl_BackSecondaryColor = gl_SecondaryColor;
    
    // do not ftransform(), geometry shader needs the original vertices
    gl_Position = gl_Vertex;
}
-->
        </snippet>
      </shader>
      <shader name="fragment">
        <snippet type="string">
          <!--
/*
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120

varying vec3 normal;
varying vec3 color;

void main(void) {
#if 0
    vec3 norm, lightDir;
    vec4 diffuse, ambient, globalAmbient;
    float NdotL;
    
    norm = normalize(gl_NormalMatrix * normal);
    lightDir = normalize(vec3(gl_LightSource[0].position));
    NdotL = max(dot(norm, lightDir), 0.0);
    diffuse = vec4( color, 1.0) * gl_LightSource[0].diffuse;
    
    /* Compute the ambient and globalAmbient terms */
    ambient = vec4( color, 1.0) * gl_LightSource[0].ambient;
    globalAmbient = gl_LightModel.ambient * vec4( color, 1.0);
    gl_FragColor = NdotL * diffuse + globalAmbient + ambient;
#else    
    // normalize the direction of the light
    vec3 lightDir = normalize(vec3(gl_LightSource[0].position));

    // normalize the halfVector to pass it to the fragment shader
    vec3 halfVector = normalize(gl_LightSource[0].halfVector.xyz);
    
    vec4 diffuse, ambient;
    // compute the diffuse, ambient and globalAmbient terms
    diffuse = vec4( color, 1.0) * gl_LightSource[0].diffuse;
    ambient = vec4( color, 1.0) * gl_LightSource[0].ambient;
    ambient += gl_LightModel.ambient * vec4( color, 1.0);
    
    vec3 n;
    float NdotL,NdotHV;
    
    // store the ambient term
    vec4 colorOut = ambient;
    
    // transformation of the normal into eye space
    n = normalize(gl_NormalMatrix * normal);

    // compute the dot product between normal and lightDir
    NdotL = dot(n,lightDir);
    if (NdotL > 0.0) {
        // front side
        colorOut += diffuse * NdotL;
        NdotHV = max(dot(n,halfVector),4.88e-04);
        colorOut += gl_FrontMaterial.specular * gl_LightSource[0].specular * pow(NdotHV, gl_FrontMaterial.shininess);
    }

    gl_FragColor = colorOut;
#endif
    //gl_FragColor = gl_Color;
}
-->
        </snippet>
      </shader>
      <shader name="tubeGeometry">
        <snippet type="string">
          <!--
/* Geometry Shader: Arrow Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable

varying out vec3 normal;
varying out vec3 color;

void compute( vec3 v2, vec3 v3, vec3 dir20, vec3 dir12, vec3 dir32, vec3 dir43, vec3 dir53, float scale, int n)
{
    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));

    // angle for the rotation
    float alpha;
    // matrices for rotation
    mat3 e = mat3( 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
    mat3 m1 = mat3( 0.0,-ortho1.z, ortho1.y, ortho1.z, 0.0,-ortho1.x,-ortho1.y, ortho1.x, 0.0);
    mat3 m2 = mat3( 0.0,-ortho2.z, ortho2.y, ortho2.z, 0.0,-ortho2.x,-ortho2.y, ortho2.x, 0.0);
    mat3 m1quat = m1 * m1;
    mat3 m2quat = m2 * m2;
    
    vec3 res1;
    vec3 res2;
    
    dir1 = dir1 * scale;
    dir2 = dir2 * scale;
    
    for( int i = 0; i < n; i++ )
    {
        alpha = (360.0/float(n))*float(i);
        res1 = ( e + sin( radians( alpha)) * m1 + ( 1.0 - cos( radians( alpha))) * m1quat ) * dir1;
        res2 = ( e + sin( radians( alpha)) * m2 + ( 1.0 - cos( radians( alpha))) * m2quat ) * dir2;
        
        // copy color 
        color = vec3( gl_FrontSecondaryColorIn[0]);
        // copy position 
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + res1).xyz, 1.0);
        // compute lighting
        normal = normalize( res1);
        // done with the vertex 
        EmitVertex();
        
        color = vec3( gl_FrontSecondaryColorIn[0]);
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + res2).xyz, 1.0);
        normal = normalize( res2);
        EmitVertex();
    }
    color = vec3( gl_FrontSecondaryColorIn[0]);
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1).xyz, 1.0);
    normal = normalize( dir1);
    EmitVertex();
    
    color = vec3( gl_FrontSecondaryColorIn[0]);
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2).xyz, 1.0);
    normal = normalize( dir2);
    EmitVertex();
    
    EndPrimitive();
}

void main(void)
{
    // number of segments for the tube
    int numSegTube = 6;
    // number of segments for each curve section
    const int numSeg = 6;
    const float N = float( numSeg);
    // dimension of 'results' and 'directions' MUST be numSeg+1 
    vec3 results[numSeg + 1];
    vec3 directions[numSeg + 1];
    // vertices and directions
    /*
    vec3 v0 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v1 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v2 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v3 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 v4 = vec3(gl_PositionIn[4].xyz) / gl_PositionIn[4].w;
    vec3 v5 = vec3(gl_PositionIn[5].xyz) / gl_PositionIn[5].w;
    vec3 n1 = vec3(gl_FrontColorIn[1].xyz) / gl_FrontColorIn[1].w;
    vec3 n2 = vec3(gl_FrontColorIn[2].xyz) / gl_FrontColorIn[2].w;
    vec3 n3 = vec3(gl_FrontColorIn[3].xyz) / gl_FrontColorIn[3].w;
    vec3 n4 = vec3(gl_FrontColorIn[4].xyz) / gl_FrontColorIn[4].w;
    */
    vec3 v1 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v2 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v3 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v4 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 n1 = vec3(gl_FrontColorIn[0].xyz) / gl_FrontColorIn[0].w;
    vec3 n2 = vec3(gl_FrontColorIn[1].xyz) / gl_FrontColorIn[1].w;
    vec3 n3 = vec3(gl_FrontColorIn[2].xyz) / gl_FrontColorIn[2].w;
    vec3 n4 = vec3(gl_FrontColorIn[3].xyz) / gl_FrontColorIn[3].w;
        
    // assign matrix S
  mat4 S;
    S[0] = vec4( 6.0/(N*N*N), 6.0/(N*N*N), 1.0/(N*N*N), 0.0 );
    S[1] = vec4(         0.0,   2.0/(N*N),   1.0/(N*N), 0.0 );
    S[2] = vec4(                 0.0,         0.0,       1.0/N, 0.0 );
    S[3] = vec4(                 0.0,         0.0,         0.0, 1.0 );
    // assign the basis matrix
  mat4 B;
    B[0] = vec4(-1.0/6.0, 3.0/6.0,-3.0/6.0, 1.0/6.0 );
    B[1] = vec4( 3.0/6.0,-6.0/6.0, 0.0/6.0, 4.0/6.0 );
    B[2] = vec4(-3.0/6.0, 3.0/6.0, 3.0/6.0, 1.0/6.0 );
    B[3] = vec4( 1.0/6.0, 0.0/6.0, 0.0/6.0, 0.0/6.0 );
    
    // assign the geometry matrix
    mat4 G;
    G[0] = vec4( v1.x, v2.x, v3.x, v4.x );
    G[1] = vec4( v1.y, v2.y, v3.y, v4.y );
    G[2] = vec4( v1.z, v2.z, v3.z, v4.z );
    G[3] = vec4( 1.0, 1.0, 1.0, 1.0 );
    // compute the matrix M
    mat4 M = S * ( B * G );
    // start computation of first spline segment 
    results[0] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    for( int k = 0; k < numSeg; k++ )
    {
        M[0].w = M[0].w + M[0].z;
        M[1].w = M[1].w + M[1].z;
        M[2].w = M[2].w + M[2].z;
        M[3].w = M[3].w + M[3].z;
        M[0].z = M[0].z + M[0].y;
        M[1].z = M[1].z + M[1].y;
        M[2].z = M[2].z + M[2].y;
        M[3].z = M[3].z + M[3].y;
        M[0].y = M[0].y + M[0].x;
        M[1].y = M[1].y + M[1].x;
        M[2].y = M[2].y + M[2].x;
        M[3].y = M[3].y + M[3].x;
        
        results[k+1] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    }
    
    G[0] = vec4( n1.x+v1.x, n2.x+v2.x, n3.x+v3.x, n4.x+v4.x );
    G[1] = vec4( n1.y+v1.y, n2.y+v2.y, n3.y+v3.y, n4.y+v4.y );
    G[2] = vec4( n1.z+v1.z, n2.z+v2.z, n3.z+v3.z, n4.z+v4.z );
    // compute the matrix M
    M = S * ( B * G );
    // start computation of second spline segments
    directions[0] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    for( int k = 0; k < numSeg; k++ )
    {
        M[0].w = M[0].w + M[0].z;
        M[1].w = M[1].w + M[1].z;
        M[2].w = M[2].w + M[2].z;
        M[3].w = M[3].w + M[3].z;
        M[0].z = M[0].z + M[0].y;
        M[1].z = M[1].z + M[1].y;
        M[2].z = M[2].z + M[2].y;
        M[3].z = M[3].z + M[3].y;
        M[0].y = M[0].y + M[0].x;
        M[1].y = M[1].y + M[1].x;
        M[2].y = M[2].y + M[2].x;
        M[3].y = M[3].y + M[3].x;
        directions[k+1] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    }
    
    // draw
    vec3 dir20;
    vec3 dir12;
    vec3 dir32;
    vec3 dir43;
    vec3 dir53;
    
    // compute all needed directions
    dir20 = v3 - v1;
    dir12 = directions[0] - results[0];
    dir32 = results[1] - results[0];
    dir43 = directions[1] - results[1];
    dir53 = results[2] - results[1];
    compute( results[0], results[1], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, numSegTube );
    
    for( int i = 0; i < numSeg-2; i++ )
    {
        // compute all needed directions
        dir20 = results[i+1] - results[i+0];
        dir12 = directions[i+1] - results[i+1];
        dir32 = results[i+2] - results[i+1];
        dir43 = directions[i+2] - results[i+2];
        dir53 = results[i+3] - results[i+2];
        compute( results[i+1], results[i+2], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, numSegTube );
    }
    
    // compute all needed directions
    dir20 = results[numSeg-1] - results[numSeg-2];
    dir12 = directions[numSeg-1] - results[numSeg-1];
    dir32 = results[numSeg] - results[numSeg-1];
    dir43 = directions[numSeg] - results[numSeg];
    dir53 = v4 - v2;
    compute( results[numSeg-1], results[numSeg], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, numSegTube );
}
-->
        </snippet>
      </shader>
      <shader name="arrowGeometry">
        <snippet type="string">
          <!--
/* Geometry Shader: Arrow Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable

varying out vec3 normal;
varying out vec3 color;

void compute( vec3 v2, vec3 v3, vec3 dir20, vec3 dir12, vec3 dir32, vec3 dir43, vec3 dir53, float scale, float stretch1, float stretch2)
{
    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));

    dir1 = normalize( cross( dir1, ortho1))*stretch1;
    dir2 = normalize( cross( dir2, ortho2))*stretch2;
    
    vec3 norm1 = normalize( cross( dir1, ortho1));
    vec3 norm2 = normalize( cross( dir2, ortho2));
    
    /////////////////////
    // draw top ribbon //
    /////////////////////
    color = vec3( gl_FrontSecondaryColorIn[0]);
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
    normal = norm1;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
    normal = norm2;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
    EmitVertex();
    
    EndPrimitive();
    
    ////////////////////////
    // draw bottom ribbon //
    ////////////////////////
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
    normal = -norm1;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
    normal = -norm2;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
    EmitVertex();
    
    EndPrimitive();
    
    /////////////////////
    // draw first side //
    /////////////////////
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
    normal = dir1;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
    normal = dir2;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
    EmitVertex();
    
    EndPrimitive();
    
    //////////////////////
    // draw second side //
    //////////////////////
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
    normal = -dir1;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
    normal = -dir2;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
    EmitVertex();
    
    EndPrimitive();
}

void main(void)
{
    // number of segments for each curve section
    const int numSeg = 6;
    const float N = float( numSeg);
    // dimension of 'results' and 'directions' MUST be numSeg+1 
    vec3 results[numSeg + 1];
    vec3 directions[numSeg + 1];
    // vertices and directions
    // vertices and directions
    vec3 v1 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v2 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v3 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v4 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 n1 = vec3(gl_FrontColorIn[0].xyz) / gl_FrontColorIn[0].w;
    vec3 n2 = vec3(gl_FrontColorIn[1].xyz) / gl_FrontColorIn[1].w;
    vec3 n3 = vec3(gl_FrontColorIn[2].xyz) / gl_FrontColorIn[2].w;
    vec3 n4 = vec3(gl_FrontColorIn[3].xyz) / gl_FrontColorIn[3].w;
        
    // assign matrix S
  mat4 S;
    S[0] = vec4( 6.0/(N*N*N), 6.0/(N*N*N), 1.0/(N*N*N), 0.0 );
    S[1] = vec4(         0.0,   2.0/(N*N),   1.0/(N*N), 0.0 );
    S[2] = vec4(                 0.0,         0.0,       1.0/N, 0.0 );
    S[3] = vec4(                 0.0,         0.0,         0.0, 1.0 );
    // assign the basis matrix
  mat4 B;
    B[0] = vec4(-1.0/6.0, 3.0/6.0,-3.0/6.0, 1.0/6.0 );
    B[1] = vec4( 3.0/6.0,-6.0/6.0, 0.0/6.0, 4.0/6.0 );
    B[2] = vec4(-3.0/6.0, 3.0/6.0, 3.0/6.0, 1.0/6.0 );
    B[3] = vec4( 1.0/6.0, 0.0/6.0, 0.0/6.0, 0.0/6.0 );
    
    // assign the geometry matrix
    mat4 G;
    G[0] = vec4( v1.x, v2.x, v3.x, v4.x );
    G[1] = vec4( v1.y, v2.y, v3.y, v4.y );
    G[2] = vec4( v1.z, v2.z, v3.z, v4.z );
    G[3] = vec4( 1.0, 1.0, 1.0, 1.0 );
    // compute the matrix M
    mat4 M = S * ( B * G );
    // start computation of first spline segment 
    results[0] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    for( int k = 0; k < numSeg; k++ )
    {
        M[0].w = M[0].w + M[0].z;
        M[1].w = M[1].w + M[1].z;
        M[2].w = M[2].w + M[2].z;
        M[3].w = M[3].w + M[3].z;
        M[0].z = M[0].z + M[0].y;
        M[1].z = M[1].z + M[1].y;
        M[2].z = M[2].z + M[2].y;
        M[3].z = M[3].z + M[3].y;
        M[0].y = M[0].y + M[0].x;
        M[1].y = M[1].y + M[1].x;
        M[2].y = M[2].y + M[2].x;
        M[3].y = M[3].y + M[3].x;
        
        results[k+1] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    }
    
    mat4 G1;
    G1[0] = vec4( n1.x+v1.x, n2.x+v2.x, n3.x+v3.x, n4.x+v4.x );
    G1[1] = vec4( n1.y+v1.y, n2.y+v2.y, n3.y+v3.y, n4.y+v4.y );
    G1[2] = vec4( n1.z+v1.z, n2.z+v2.z, n3.z+v3.z, n4.z+v4.z );
    G1[3] = vec4( 1.0, 1.0, 1.0, 1.0 );

    // compute the matrix M
    mat4 M1 = S * ( B * G1 );
    // start computation of second spline segments
    directions[0] = vec3( M1[0][3]/M1[3][3], M1[1][3]/M1[3][3], M1[2][3]/M1[3][3]);
    for( int k = 0; k < numSeg; k++ )
    {
        M1[0].w = M1[0].w + M1[0].z;
        M1[1].w = M1[1].w + M1[1].z;
        M1[2].w = M1[2].w + M1[2].z;
        M1[3].w = M1[3].w + M1[3].z;
        M1[0].z = M1[0].z + M1[0].y;
        M1[1].z = M1[1].z + M1[1].y;
        M1[2].z = M1[2].z + M1[2].y;
        M1[3].z = M1[3].z + M1[3].y;
        M1[0].y = M1[0].y + M1[0].x;
        M1[1].y = M1[1].y + M1[1].x;
        M1[2].y = M1[2].y + M1[2].x;
        M1[3].y = M1[3].y + M1[3].x;
        
        directions[k+1] = vec3( M1[0][3]/M1[3][3], M1[1][3]/M1[3][3], M1[2][3]/M1[3][3]);
    }
    
    // draw
    vec3 dir20;
    vec3 dir12;
    vec3 dir32;
    vec3 dir43;
    vec3 dir53;
    
    float factor = ( gl_FrontSecondaryColorIn[1].y / N ) * gl_FrontSecondaryColorIn[1].z;
    float f2;
    float f1 = gl_FrontSecondaryColorIn[1].y + factor;
    
    f2 = f1;
    f1 = f1 - factor;    
    // compute all needed directions
    dir20 = v3 - v1;
    dir12 = directions[0] - results[0];
    dir32 = results[1] - results[0];
    dir43 = directions[1] - results[1];
    dir53 = results[2] - results[1];
    compute( results[0], results[1], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, f2, f1 );
    
    for( int i = 0; i < numSeg-2; i++ )
    {
        f2 = f1;
        f1 = f1 - factor;
        // compute all needed directions
        dir20 = results[i+1] - results[i+0];
        dir12 = directions[i+1] - results[i+1];
        dir32 = results[i+2] - results[i+1];
        dir43 = directions[i+2] - results[i+2];
        dir53 = results[i+3] - results[i+2];
        compute( results[i+1], results[i+2], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, f2, f1 );
    }
    
    f2 = f1;
    f1 = f1 - factor;
    // compute all needed directions
    dir20 = results[numSeg-1] - results[numSeg-2];
    dir12 = directions[numSeg-1] - results[numSeg-1];
    dir32 = results[numSeg] - results[numSeg-1];
    dir43 = directions[numSeg] - results[numSeg];
    dir53 = v4 - v2;
    compute( results[numSeg-1], results[numSeg], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, f2, f1 );
}
-->
        </snippet>
      </shader>
      <shader name="helixGeometry">
        <snippet type="string">
          <!--
/* Geometry Shader: Arrow Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable

varying out vec3 normal;
varying out vec3 color;


void compute( vec3 v2, vec3 v3, vec3 dir20, vec3 dir12, vec3 dir32, vec3 dir43, vec3 dir53, float scale, float stretch1)
{
    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));
    
    dir1 = normalize( cross( dir1, ortho1))*stretch1;
    dir2 = normalize( cross( dir2, ortho2))*stretch1;
    
    vec3 norm1 = normalize( cross( dir1, ortho1));
    vec3 norm2 = normalize( cross( dir2, ortho2));
    
    /////////////////////
    // draw top ribbon //
    /////////////////////
    color = vec3( gl_FrontSecondaryColorIn[0]);
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
    normal = norm1;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
    normal = norm2;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
    EmitVertex();
    
    EndPrimitive();
    
    ////////////////////////
    // draw bottom ribbon //
    ////////////////////////
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
    normal =  -norm1;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
    normal = -norm2;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
    EmitVertex();
    
    EndPrimitive();
    
    /////////////////////
    // draw first side //
    /////////////////////
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
    normal = dir1;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
    normal = dir2;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
    EmitVertex();
    
    EndPrimitive();
    
    //////////////////////
    // draw second side //
    //////////////////////
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
    normal = -dir1;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
    normal = -dir2;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
    EmitVertex();
    
    EndPrimitive();
}

void main(void)
{
    // number of segments for each curve section
    const int numSeg = 6;
    const float N = float( numSeg);
    // dimension of 'results' and 'directions' MUST be numSeg+1 
    vec3 results[numSeg + 1];
    vec3 directions[numSeg + 1];
    // vertices and directions
    vec3 v1 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v2 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v3 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v4 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 n1 = vec3(gl_FrontColorIn[0].xyz) / gl_FrontColorIn[0].w;
    vec3 n2 = vec3(gl_FrontColorIn[1].xyz) / gl_FrontColorIn[1].w;
    vec3 n3 = vec3(gl_FrontColorIn[2].xyz) / gl_FrontColorIn[2].w;
    vec3 n4 = vec3(gl_FrontColorIn[3].xyz) / gl_FrontColorIn[3].w;
        
    // assign matrix S
  mat4 S;
    S[0] = vec4( 6.0/(N*N*N), 6.0/(N*N*N), 1.0/(N*N*N), 0.0 );
    S[1] = vec4(         0.0,   2.0/(N*N),   1.0/(N*N), 0.0 );
    S[2] = vec4(                 0.0,         0.0,       1.0/N, 0.0 );
    S[3] = vec4(                 0.0,         0.0,         0.0, 1.0 );
    // assign the basis matrix
  mat4 B;
    B[0] = vec4(-1.0/6.0, 3.0/6.0,-3.0/6.0, 1.0/6.0 );
    B[1] = vec4( 3.0/6.0,-6.0/6.0, 0.0/6.0, 4.0/6.0 );
    B[2] = vec4(-3.0/6.0, 3.0/6.0, 3.0/6.0, 1.0/6.0 );
    B[3] = vec4( 1.0/6.0, 0.0/6.0, 0.0/6.0, 0.0/6.0 );
    
    // assign the geometry matrix
    mat4 G;
    G[0] = vec4( v1.x, v2.x, v3.x, v4.x );
    G[1] = vec4( v1.y, v2.y, v3.y, v4.y );
    G[2] = vec4( v1.z, v2.z, v3.z, v4.z );
    G[3] = vec4( 1.0, 1.0, 1.0, 1.0 );
    // compute the matrix M
    mat4 M = S * ( B * G );
    // start computation of first spline segment 
    results[0] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    for( int k = 0; k < numSeg; k++ )
    {
        M[0].w = M[0].w + M[0].z;
        M[1].w = M[1].w + M[1].z;
        M[2].w = M[2].w + M[2].z;
        M[3].w = M[3].w + M[3].z;
        M[0].z = M[0].z + M[0].y;
        M[1].z = M[1].z + M[1].y;
        M[2].z = M[2].z + M[2].y;
        M[3].z = M[3].z + M[3].y;
        M[0].y = M[0].y + M[0].x;
        M[1].y = M[1].y + M[1].x;
        M[2].y = M[2].y + M[2].x;
        M[3].y = M[3].y + M[3].x;
        
        results[k+1] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    }
    
    G[0] = vec4( n1.x+v1.x, n2.x+v2.x, n3.x+v3.x, n4.x+v4.x );
    G[1] = vec4( n1.y+v1.y, n2.y+v2.y, n3.y+v3.y, n4.y+v4.y );
    G[2] = vec4( n1.z+v1.z, n2.z+v2.z, n3.z+v3.z, n4.z+v4.z );
    // compute the matrix M
    M = S * ( B * G );
    // start computation of second spline segments
    directions[0] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    for( int k = 0; k < numSeg; k++ )
    {
        M[0].w = M[0].w + M[0].z;
        M[1].w = M[1].w + M[1].z;
        M[2].w = M[2].w + M[2].z;
        M[3].w = M[3].w + M[3].z;
        M[0].z = M[0].z + M[0].y;
        M[1].z = M[1].z + M[1].y;
        M[2].z = M[2].z + M[2].y;
        M[3].z = M[3].z + M[3].y;
        M[0].y = M[0].y + M[0].x;
        M[1].y = M[1].y + M[1].x;
        M[2].y = M[2].y + M[2].x;
        M[3].y = M[3].y + M[3].x;
        directions[k+1] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    }
    
    // draw
    vec3 dir20;
    vec3 dir12;
    vec3 dir32;
    vec3 dir43;
    vec3 dir53;
    
    // compute all needed directions
    dir20 = v3 - v1;
    dir12 = directions[0] - results[0];
    dir32 = results[1] - results[0];
    dir43 = directions[1] - results[1];
    dir53 = results[2] - results[1];
    compute( results[0], results[1], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, gl_FrontSecondaryColorIn[1].y );
    
    for( int i = 0; i < numSeg-2; i++ )
    {
        // compute all needed directions
        dir20 = results[i+1] - results[i+0];
        dir12 = directions[i+1] - results[i+1];
        dir32 = results[i+2] - results[i+1];
        dir43 = directions[i+2] - results[i+2];
        dir53 = results[i+3] - results[i+2];
        compute( results[i+1], results[i+2], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, gl_FrontSecondaryColorIn[1].y );
    }
    
    // compute all needed directions
    dir20 = results[numSeg-1] - results[numSeg-2];
    dir12 = directions[numSeg-1] - results[numSeg-1];
    dir32 = results[numSeg] - results[numSeg-1];
    dir43 = directions[numSeg] - results[numSeg];
    dir53 = v4 - v2;
    compute( results[numSeg-1], results[numSeg], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, gl_FrontSecondaryColorIn[1].y );
}
-->
        </snippet>
      </shader>
    </namespace>

    <namespace name="perpixellight">
      <shader name="vertex">
        <snippet type="string">
          <!--
varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;

void main()
{    
    // transformation of the normal into eye space
    normal = normalize(gl_NormalMatrix * gl_Normal);
    
    // normalize the direction of the light
    lightDir = normalize(vec3(gl_LightSource[0].position));

    // normalize the halfVector to pass it to the fragment shader
    halfVector = normalize(gl_LightSource[0].halfVector.xyz);
                
    // compute the diffuse, ambient and globalAmbient terms
    //diffuse = gl_FrontMaterial.diffuse * gl_LightSource[0].diffuse;
    //ambient = gl_FrontMaterial.ambient * gl_LightSource[0].ambient;
    //ambient += gl_LightModel.ambient * gl_FrontMaterial.ambient;
    diffuse = gl_Color * gl_LightSource[0].diffuse;
    ambient = gl_Color * gl_LightSource[0].ambient;
    ambient += gl_LightModel.ambient * gl_Color;

    gl_Position = ftransform();
}
-->
        </snippet>
      </shader>
    
      <shader name="fragment">
        <snippet type="string">
          <!--
varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;


void main()
{
    vec3 n,halfV;
    float NdotL,NdotHV;
    
    // store the ambient term
    vec4 color = ambient;
    
    // store the normalized interpolated normal
    n = normalize(normal);

    // compute the dot product between normal and lightDir
    NdotL = max(dot(n,lightDir),0.0);
    if (NdotL > 0.0)
    {
        color += diffuse * NdotL;
        halfV = normalize(halfVector);
        NdotHV = max(dot(n,halfV),0.0);
        color += gl_FrontMaterial.specular * gl_LightSource[0].specular * pow(NdotHV, gl_FrontMaterial.shininess);
    }

    gl_FragColor = color;
}
-->
        </snippet>
      </shader>
    </namespace>
  </namespace>
</btf>
