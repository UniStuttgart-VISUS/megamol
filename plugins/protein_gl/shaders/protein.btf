<?xml version="1.0" encoding="utf-8"?>
<btf type="MegaMolGLSLShader" version="1.0" namespace="protein">
  <include file="common"/>
  <include file="colormaps"/>

  <snippet name="commondefines" type="string">
    <!-- 
//#define FOGGING_SES
//#define FLATSHADE_SES
#define OGL_DEPTH_SES
//#define SFB_DEMO

#define CLIP
#define DEPTH
#define SMALL_SPRITE_LIGHTING
//#define CALC_CAM_SYS

#ifdef DEBUG
#undef CLIP
#define RETICLE
#define AXISHINTS
#endif // DEBUG

//#define BULLSHIT

#ifndef FLACH
#define FLACH
#endif

//#define SET_COLOR
//#define COLOR1 vec3( 249.0/255.0, 187.0/255.0, 103.0/255.0)
#define COLOR1 vec3( 183.0/255.0, 204.0/255.0, 220.0/255.0)

//#define COLOR_SES
//#define COLOR_BLUE vec3( 145.0/255.0, 191.0/255.0, 219.0/255.0)
#define COLOR_BLUE vec3( 0.0/255.0, 173.0/255.0, 238.0/255.0)
//#define COLOR_GREEN vec3( 161.0/255.0, 215.0/255.0, 106.0/255.0)
//#define COLOR_GREEN vec3( 236.0/255.0, 28.0/255.0, 36.0/255.0) // actually red...
#define COLOR_GREEN vec3( 0.0/255.0, 165.0/255.0, 81.0/255.0)
//#define COLOR_YELLOW vec3( 255.0/255.0, 255.0/255.0, 191.0/255.0)
#define COLOR_YELLOW vec3( 255.0/255.0, 221.0/255.0, 21.0/255.0)
#define COLOR_RED vec3( 228.0/255.0, 37.0/255.0, 34.0/255.0)

-->
  </snippet>

  <namespace name="std">
    <shader name="sphereVertex">
      <snippet type="version">110</snippet>
      <snippet name="commondefines"/>
      <snippet type="string">
        <!--

#undef HALO
//#define HALO
#undef HALO_RAD
#define HALO_RAD  0.1

uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

uniform mat4 MVinv;
uniform mat4 MVP;
uniform mat4 MVPinv;
uniform mat4 MVPtransp;

out vec4 objPos;
out vec4 camPos;
out vec4 lightPos;
out float squarRad;
out float rad;

#ifdef RETICLE
out vec2 centerFragment;
#endif // RETICLE

void main(void) {

    // remove the sphere radius from the w coordinates to the rad varyings
    vec4 inPos = gl_Vertex;
    rad = inPos.w;
    squarRad = rad * rad;
    inPos.w = 1.0;

    
    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)


    // calculate cam position
    camPos = MVinv[3]; // (C) by Christoph
    camPos.xyz -= objPos.xyz; // cam pos to glyph space
    

    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = MVinv * gl_LightSource[0].position - objPos;
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    lightPos = MVinv * normalize( gl_LightSource[0].position);
    
    

    // send color to fragment shader
    gl_FrontColor = gl_Color;


    // Sphere-Touch-Plane-Approach
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    vec2 d, p, q, h, dd;

    // get camera orthonormal coordinate system
    vec4 tmp;

#ifdef CALC_CAM_SYS
    // camera coordinate system in object space
    tmp = MVinv[3] + MVinv[2];
    vec3 camIn = normalize(tmp.xyz);
    tmp = MVinv[3] + MVinv[1];
    vec3 camUp = tmp.xyz;
    vec3 camRight = normalize(cross(camIn, camUp));
    camUp = cross(camIn, camRight);
#endif // CALC_CAM_SYS

    vec2 mins, maxs;
    vec3 testPos;
    vec4 projPos;

    
#ifdef HALO
    squarRad = (rad + HALO_RAD) * (rad + HALO_RAD);
#endif // HALO
    
    // projected camera vector
    vec3 c2 = vec3(dot(camPos.xyz, camRight), dot(camPos.xyz, camUp), dot(camPos.xyz, camIn));

    vec3 cpj1 = camIn * c2.z + camRight * c2.x;
    vec3 cpm1 = camIn * c2.x - camRight * c2.z;

    vec3 cpj2 = camIn * c2.z + camUp * c2.y;
    vec3 cpm2 = camIn * c2.y - camUp * c2.z;
    
    d.x = length(cpj1);
    d.y = length(cpj2);

    dd = vec2(1.0) / d;

    p = squarRad * dd;
    q = d - p;
    h = sqrt(p * q);
    //h = vec2(0.0);
    
    p *= dd;
    h *= dd;

    cpj1 *= p.x;
    cpm1 *= h.x;
    cpj2 *= p.y;
    cpm2 *= h.y;

    // TODO: rewrite only using four projections, additions in homogenous coordinates and delayed perspective divisions.
    testPos = objPos.xyz + cpj1 + cpm1;
    projPos = MVP * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = projPos.xy;
    maxs = projPos.xy;

    testPos -= 2.0 * cpm1;
    projPos = MVP * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos = objPos.xyz + cpj2 + cpm2;
    projPos = MVP * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos -= 2.0 * cpm2;
    projPos = MVP * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    gl_PointSize = max((maxs.x - mins.x) * winHalf.x, (maxs.y - mins.y) * winHalf.y) * 0.5;

#ifdef SMALL_SPRITE_LIGHTING
    // for normal crowbaring on very small sprites
    lightPos.w = (clamp(gl_PointSize, 1.0, 5.0) - 1.0) / 4.0;
#endif // SMALL_SPRITE_LIGHTING
    
#ifdef RETICLE
    centerFragment = gl_Position.xy / gl_Position.w;
#endif // RETICLE

    // gl_PointSize = 32.0;
    
#ifdef HALO
    squarRad = rad * rad;
#endif // HALO
}
-->
      </snippet>
    </shader>

    <shader name="sphereFragment">
      <snippet type="version">110</snippet>
      <snippet name="commondefines"/>
      <snippet name="LightDirectional" type="file">lightdirectional.glsl</snippet>
      <snippet type="string">
        <!--

#undef HALO
//#define HALO
#undef HALO_RAD
#define HALO_RAD  0.1

uniform vec4 viewAttr;

uniform mat4 MVinv;
uniform mat4 MVP;
uniform mat4 MVPinv;
uniform mat4 MVPtransp;

in vec4 objPos;
in vec4 camPos;
in vec4 lightPos;
in float squarRad;
in float rad;

#ifdef RETICLE
in vec2 centerFragment;
#endif // RETICLE

void main(void) {

    vec4 coord;
    vec3 ray;
    float lambda;
    vec3 color;
    vec3 sphereintersection = vec3( 0.0);
    vec3 normal;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    

    // transform fragment coordinates from view coordinates to object coordinates.
    coord = MVPinv * coord;
    coord /= coord.w;
    coord -= objPos; // ... and to glyph space
    

    // calc the viewing ray
    ray = normalize(coord.xyz - camPos.xyz);


    // calculate the geometry-ray-intersection
    float d1 = -dot(camPos.xyz, ray);                       // projected length of the cam-sphere-vector onto the ray
    float d2s = dot(camPos.xyz, camPos.xyz) - d1 * d1;      // off axis of cam-sphere-vector and ray
    float radicand = squarRad - d2s;                        // square of difference of projected length and lambda
#ifdef CLIP
    lambda = d1 - sqrt(radicand);                           // lambda

    float radicand2 = 0.0;
#ifdef HALO
    radicand2 = (rad+HALO_RAD)*(rad+HALO_RAD) - d2s;
    if( radicand2 < 0.0 ) {
        discard;
    }
    else if( radicand < 0.0 ) {
        // idea for halo from Tarini et al. (tvcg 2006)
        color = vec3(0.1);
        normal = vec3(0.0, 1.0, 0.0);
    }
#else
    if( radicand < 0.0 ) {
        discard;
    }
#endif // HALO
    else {
        // chose color for lighting
        color = gl_Color.rgb;
        if( lambda < 0.0 ) discard;
        sphereintersection = lambda * ray + camPos.xyz;    // intersection point
        // "calc" normal at intersection point
        normal = sphereintersection / rad;
    }
    
#endif // CLIP

#ifdef SMALL_SPRITE_LIGHTING
    normal = mix(-ray, normal, lightPos.w);
#endif // SMALL_SPRITE_LIGHTING

#ifdef AXISHINTS
    // debug-axis-hints
    float mc = min(abs(normal.x), min(abs(normal.y), abs(normal.z)));
    if (mc < 0.05)            { color = vec3(0.5); }
    if (abs(normal.x) > 0.98) { color = vec3(1.0, 0.0, 0.0); }
    if (abs(normal.y) > 0.98) { color = vec3(0.0, 1.0, 0.0); }
    if (abs(normal.z) > 0.98) { color = vec3(0.0, 0.0, 1.0); }
    if (normal.x < -0.99)     { color = vec3(0.5); }
    if (normal.y < -0.99)     { color = vec3(0.5); }
    if (normal.z < -0.99)     { color = vec3(0.5); }
#endif // AXISHINTS

    // phong lighting with directional light
    //gl_FragColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color), 1.0);
    gl_FragColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color), gl_Color.w);
    gl_FragDepth = gl_FragCoord.z;

    // calculate depth
#ifdef DEPTH
    vec4 Ding = vec4( sphereintersection + objPos.xyz, 1.0);
    float depth = dot(MVPtransp[2], Ding);
    float depthW = dot(MVPtransp[3], Ding);
    gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
    
#ifndef CLIP
    gl_FragDepth = (radicand < 0.0) ? 1.0 : ((depth / depthW) + 1.0) * 0.5;
    gl_FragColor.rgb = (radicand < 0.0) ? gl_Color.rgb : gl_FragColor.rgb;
#endif // CLIP

#endif // DEPTH

    
#ifdef RETICLE
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    if (min(abs(coord.x - centerFragment.x), abs(coord.y - centerFragment.y)) < 0.002) {
        //gl_FragColor.rgb = vec3(1.0, 1.0, 0.5);
        gl_FragColor.rgb += vec3(0.3, 0.3, 0.5);
    }
#endif // RETICLE

    //gl_FragColor.rgb = normal;
    //gl_FragColor.rgb = lightPos.xyz;
}
-->
      </snippet>
    </shader>

    <shader name="sphereClipPlaneVertex">
      <snippet type="version">110</snippet>
      <snippet name="commondefines"/>
      <snippet type="string">
        <!--
uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

uniform mat4 MVinv;
uniform mat4 MVP;
uniform mat4 MVPinv;
uniform mat4 MVPtransp;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying float squarRad;
varying float rad;

#ifdef RETICLE
varying vec2 centerFragment;
#endif // RETICLE

void main(void) {

    // remove the sphere radius from the w coordinates to the rad varyings
    vec4 inPos = gl_Vertex;
    rad = inPos.w;
    squarRad = rad * rad;
    inPos.w = 1.0;

    
    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)


    // calculate cam position
    camPos = MVinv[3]; // (C) by Christoph
    camPos.xyz -= objPos.xyz; // cam pos to glyph space
    

    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = MVinv * gl_LightSource[0].position - objPos; // note: w is bullshit now!
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    lightPos = MVinv * normalize( gl_LightSource[0].position);
    

    // send color to fragment shader
    gl_FrontColor = gl_Color;


    // Sphere-Touch-Plane-Approach
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    vec2 d, p, q, h, dd;

    // get camera orthonormal coordinate system
    vec4 tmp;

#ifdef CALC_CAM_SYS
    // camera coordinate system in object space
    tmp = MVinv[3] + MVinv[2];
    vec3 camIn = normalize(tmp.xyz);
    tmp = MVinv[3] + MVinv[1];
    vec3 camUp = tmp.xyz;
    vec3 camRight = normalize(cross(camIn, camUp));
    camUp = cross(camIn, camRight);
#endif // CALC_CAM_SYS

    vec2 mins, maxs;
    vec3 testPos;
    vec4 projPos;

    // projected camera vector
    vec3 c2 = vec3(dot(camPos.xyz, camRight), dot(camPos.xyz, camUp), dot(camPos.xyz, camIn));

    vec3 cpj1 = camIn * c2.z + camRight * c2.x;
    vec3 cpm1 = camIn * c2.x - camRight * c2.z;

    vec3 cpj2 = camIn * c2.z + camUp * c2.y;
    vec3 cpm2 = camIn * c2.y - camUp * c2.z;
    
    d.x = length(cpj1);
    d.y = length(cpj2);

    dd = vec2(1.0) / d;

    p = squarRad * dd;
    q = d - p;
    h = sqrt(p * q);
    //h = vec2(0.0);
    
    p *= dd;
    h *= dd;

    cpj1 *= p.x;
    cpm1 *= h.x;
    cpj2 *= p.y;
    cpm2 *= h.y;

    // TODO: rewrite only using four projections, additions in homogenous coordinates and delayed perspective divisions.
    testPos = objPos.xyz + cpj1 + cpm1;
    projPos = MVP * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = projPos.xy;
    maxs = projPos.xy;

    testPos -= 2.0 * cpm1;
    projPos = MVP * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos = objPos.xyz + cpj2 + cpm2;
    projPos = MVP * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos -= 2.0 * cpm2;
    projPos = MVP * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    gl_PointSize = max((maxs.x - mins.x) * winHalf.x, (maxs.y - mins.y) * winHalf.y) * 0.5;

#ifdef SMALL_SPRITE_LIGHTING
    // for normal crowbaring on very small sprites
    lightPos.w = (clamp(gl_PointSize, 1.0, 5.0) - 1.0) / 4.0;
#endif // SMALL_SPRITE_LIGHTING
    
#ifdef RETICLE
    centerFragment = gl_Position.xy / gl_Position.w;
#endif // RETICLE

    // gl_PointSize = 32.0;
}
-->
      </snippet>
    </shader>

    <shader name="sphereClipPlaneFragment">
      <snippet type="version">110</snippet>
      <snippet name="commondefines"/>
      <snippet name="LightDirectional" type="file">lightdirectional.glsl</snippet>
      <snippet type="string">
        <!--
uniform vec4 viewAttr;

uniform vec3 clipPlaneDir;
uniform vec3 clipPlaneBase;

uniform mat4 MVinv;
uniform mat4 MVP;
uniform mat4 MVPinv;
uniform mat4 MVPtransp;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying float squarRad;
varying float rad;

#ifdef RETICLE
varying vec2 centerFragment;
#endif // RETICLE

void main(void) {
    vec4 coord;
    vec3 ray;
    float lambda;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    
    // transform fragment coordinates from view coordinates to object coordinates.
    coord = MVPinv * coord;
    coord /= coord.w;
    coord -= objPos; // ... and to glyph space

    // calc the viewing ray
    ray = normalize(coord.xyz - camPos.xyz);

    // calculate the geometry-ray-intersection
    float d1 = -dot(camPos.xyz, ray);                       // projected length of the cam-sphere-vector onto the ray
    float d2s = dot(camPos.xyz, camPos.xyz) - d1 * d1;      // off axis of cam-sphere-vector and ray
    float radicand = squarRad - d2s;                        // square of difference of projected length and lambda
#ifdef CLIP
    if (radicand < 0.0) { discard; }
#endif // CLIP
    lambda = d1 - sqrt(radicand);                           // lambda
    vec3 sphereintersection = lambda * ray + camPos.xyz;    // intersection point

    // "calc" normal at intersection point
    vec3 normal = sphereintersection / rad;
#ifdef SMALL_SPRITE_LIGHTING
    normal = mix(-ray, normal, lightPos.w);
#endif // SMALL_SPRITE_LIGHTING

    // chose color for lighting
    vec3 color = gl_Color.rgb;
  
    // cut with clipping plane
    vec3 planeNormal = normalize( clipPlaneDir);
    float d = -dot( planeNormal, clipPlaneBase - objPos.xyz);
    float dist1 = dot( sphereintersection, planeNormal) + d;
  float dist2 = d;
  float t = -( dot( planeNormal, camPos.xyz) + d ) / dot( planeNormal, ray);
  vec3 planeintersect = camPos.xyz + t * ray;
    if( dist1 > 0.0 )
  {
    if( dist2 < rad )
    {
      if( length( planeintersect) < rad )
      {
        sphereintersection = planeintersect;
        normal = planeNormal;
        color *= 0.6;
      }
      else
      {
        discard;
      }
    }
    else
    {
      discard;
    }
  }
  
#ifdef AXISHINTS
    // debug-axis-hints
    float mc = min(abs(normal.x), min(abs(normal.y), abs(normal.z)));
    if (mc < 0.05)            { color = vec3(0.5); }
    if (abs(normal.x) > 0.98) { color = vec3(1.0, 0.0, 0.0); }
    if (abs(normal.y) > 0.98) { color = vec3(0.0, 1.0, 0.0); }
    if (abs(normal.z) > 0.98) { color = vec3(0.0, 0.0, 1.0); }
    if (normal.x < -0.99)     { color = vec3(0.5); }
    if (normal.y < -0.99)     { color = vec3(0.5); }
    if (normal.z < -0.99)     { color = vec3(0.5); }
#endif // AXISHINTS

    // phong lighting with directional light
    gl_FragColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color), 1.0);
    
    // calculate depth
#ifdef DEPTH
    vec4 Ding = vec4(sphereintersection + objPos.xyz, 1.0);
    float depth = dot(MVPtransp[2], Ding);
    float depthW = dot(MVPtransp[3], Ding);
    gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
#ifndef CLIP
    gl_FragDepth = (radicand < 0.0) ? 1.0 : ((depth / depthW) + 1.0) * 0.5;
    gl_FragColor.rgb = (radicand < 0.0) ? gl_Color.rgb : gl_FragColor.rgb;
#endif // CLIP
#endif // DEPTH

#ifdef RETICLE
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    if (min(abs(coord.x - centerFragment.x), abs(coord.y - centerFragment.y)) < 0.002) {
        //gl_FragColor.rgb = vec3(1.0, 1.0, 0.5);
        gl_FragColor.rgb += vec3(0.3, 0.3, 0.5);
    }
#endif // RETICLE

//    gl_FragColor.rgb = normal;
}
-->
      </snippet>
    </shader>

    <shader name="cylinderVertex">
      <snippet type="version">110</snippet>
      <snippet name="commondefines"/>
      <snippet type="string">
        <!--

uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

uniform mat4 MVinv;
uniform mat4 MVP;
uniform mat4 MVPinv;
uniform mat4 MVPtransp;

#ifdef DEBUG
uniform vec2 circleAttr;
#endif // DEBUG

//
attribute vec2 inParams;
attribute vec4 quatC; // conjugate quaternion
//

// colors of cylinder
attribute vec3 color1;
attribute vec3 color2;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying vec3 radz;

varying vec3 rotMatT0;
varying vec3 rotMatT1; // rotation matrix from the quaternion
varying vec3 rotMatT2;

#ifdef RETICLE
varying vec2 centerFragment;
#endif // RETICLE

void main(void) {
    const vec4 quatConst = vec4(1.0, -1.0, 0.5, 0.0);
    vec4 tmp, tmp1;

    // remove the sphere radius from the w coordinates to the rad varyings
    vec4 inPos = gl_Vertex;

    radz.x = inParams.x;
    radz.y = radz.x * radz.x;
    radz.z = inParams.y * 0.5;

    inPos.w = 1.0;

    
    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)


    // orientation quaternion to inverse rotation matrix conversion
    // Begin: Holy code!
    tmp = quatC.xzyw * quatC.yxzw;                        // tmp <- (xy, xz, yz, ww)
    tmp1 = quatC * quatC.w;                                // tmp1 <- (xw, yw, zw, %)
    tmp1.w = -quatConst.z;                                // tmp1 <- (xw, yw, zw, -0.5)

    rotMatT0.xyz = tmp1.wzy * quatConst.xxy + tmp.wxy;    // matrix0 <- (ww-0.5, xy+zw, xz-yw, %)
    rotMatT0.x = quatC.x * quatC.x + rotMatT0.x;        // matrix0 <- (ww+x*x-0.5, xy+zw, xz-yw, %)
    rotMatT0 = rotMatT0 + rotMatT0;                     // matrix0 <- (2(ww+x*x)-1, 2(xy+zw), 2(xz-yw), %)

    rotMatT1.xyz = tmp1.zwx * quatConst.yxx + tmp.xwz;     // matrix1 <- (xy-zw, ww-0.5, yz+xw, %)
    rotMatT1.y = quatC.y * quatC.y + rotMatT1.y;         // matrix1 <- (xy-zw, ww+y*y-0.5, yz+xw, %)
    rotMatT1 = rotMatT1 + rotMatT1;                     // matrix1 <- (2(xy-zw), 2(ww+y*y)-1, 2(yz+xw), %)

    rotMatT2.xyz = tmp1.yxw * quatConst.xyx + tmp.yzw;     // matrix2 <- (xz+yw, yz-xw, ww-0.5, %)
    rotMatT2.z = quatC.z * quatC.z + rotMatT2.z;         // matrix2 <- (xz+yw, yz-xw, ww+zz-0.5, %)
    rotMatT2 = rotMatT2 + rotMatT2;                     // matrix2 <- (2(xz+yw), 2(yz-xw), 2(ww+zz)-1, %)    
    // End: Holy code!


    // calculate cam position
    tmp = MVinv[3]; // (C) by Christoph
    tmp.xyz -= objPos.xyz; // cam move
    camPos.xyz = rotMatT0 * tmp.x + rotMatT1 * tmp.y + rotMatT2 * tmp.z;
    

    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = MVinv * gl_LightSource[0].position - objPos; // note: w is bullshit now!
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    lightPos = MVinv * normalize( gl_LightSource[0].position);
    lightPos.xyz = rotMatT0 * lightPos.x + rotMatT1 * lightPos.y + rotMatT2 * lightPos.z;
    

    // send color to fragment shader
    gl_FrontColor = gl_Color;

    // calculate point sprite
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    // lumberjack approach
    vec4 pos, projPos;
    vec4 pX, pY, pZ, pOP;
    vec2 mins, maxs, pp;

#define CYL_HALF_LEN radz.z
#define CYL_RAD radz.x

    projPos.w = 0.0;

    //pos = vec4(0.0, 0.0, 0.0, 1.0);
    //projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    //projPos.y = dot(rotMatT1.xyz, pos.xyz);
    //projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos; // + projPos; // move
    pos.w = 1.0; // now we're in object space
    pOP = MVP * pos;

    pos = vec4(1.0, 0.0, 0.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = MVP * pos;
    pX = (projPos - pOP) * CYL_HALF_LEN;

    pos = vec4(0.0, 1.0, 0.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = MVP * pos;
    pY = (projPos - pOP) * CYL_RAD;

    pos = vec4(0.0, 0.0, 1.0, 1.0);
    projPos.x = dot(rotMatT0.xyz, pos.xyz); // rotate
    projPos.y = dot(rotMatT1.xyz, pos.xyz);
    projPos.z = dot(rotMatT2.xyz, pos.xyz);
    pos = objPos + projPos; // move
    pos.w = 1.0; // now we're in object space
    projPos = MVP * pos;
    pZ = (projPos - pOP) * CYL_RAD;

    // 8 corners of doom
    pos = pOP + pX;
    projPos = pos + pY + pZ;
    mins = maxs = projPos.xy / projPos.w;

    projPos = pos - pY + pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos + pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);


    pos = pOP - pX;
    projPos = pos + pY + pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY + pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos + pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);

    projPos = pos - pY - pZ;
    pp = projPos.xy / projPos.w;
    mins = min(mins, pp);
    maxs = max(maxs, pp);


    gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    maxs = (maxs - mins) * 0.5 * winHalf;
    gl_PointSize = max(maxs.x, maxs.y);

#ifdef RETICLE
    centerFragment = gl_Position.xy / gl_Position.w;
#endif // RETICLE
    
    // set colors
    gl_FrontColor.r = color1.r;
    gl_FrontColor.g = color1.g;
    gl_FrontColor.b = color1.b;

    gl_FrontSecondaryColor.r = color2.r;
    gl_FrontSecondaryColor.g = color2.g;
    gl_FrontSecondaryColor.b = color2.b;
    
}
-->
      </snippet>
    </shader>

    <shader name="cylinderFragment">
      <snippet type="version">110</snippet>
      <snippet name="commondefines"/>
      <snippet name="LightDirectional" type="file">lightdirectional.glsl</snippet>
      <snippet type="string">
        <!--

//#undef CLIP

// #define RENDER_CAPS

uniform vec4 viewAttr;

uniform mat4 MVinv;
uniform mat4 MVP;
uniform mat4 MVPinv;
uniform mat4 MVPtransp;

FLACH varying vec4 objPos;
FLACH varying vec4 camPos;
FLACH varying vec4 lightPos;
FLACH varying vec3 radz;

FLACH varying vec3 rotMatT0;
FLACH varying vec3 rotMatT1; // rotation matrix from the quaternion
FLACH varying vec3 rotMatT2;

#ifdef RETICLE
FLACH varying vec2 centerFragment;
#endif // RETICLE

void main(void) {
    vec4 coord;
    vec3 ray, tmp;
    const float maxLambda = 50000.0;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    

    // transform fragment coordinates from view coordinates to object coordinates.
    coord = MVPinv * coord;
    coord /= coord.w;
    coord -= objPos; // ... and move


    // calc the viewing ray
    ray = rotMatT0 * coord.x + rotMatT1 * coord.y + rotMatT2 * coord.z;
    ray = normalize(ray - camPos.xyz);


    // calculate the geometry-ray-intersection

    // cylinder parameters
#define CYL_RAD radz.x
#define CYL_RAD_SQ radz.y
#define CYL_HALF_LEN radz.z

    float rDc = dot(ray.yz, camPos.yz);
    float rDr = dot(ray.yz, ray.yz);

    float radicand = (rDc * rDc) - (rDr * (dot(camPos.yz, camPos.yz) - CYL_RAD_SQ));

#ifdef CLIP
    if (radicand < 0.0) { discard; }
#endif // CLIP

   float radix = sqrt(radicand);
    vec2 lambdas = vec2((-rDc - radix) / rDr, (-rDc + radix) / rDr);

    // calculations for cylinder caps
    vec3 cylPt1 = camPos.xyz + ray * lambdas.x;
    vec3 cylPt2 = camPos.xyz + ray * lambdas.y;

#ifdef RENDER_CAPS
    bool cylPt1Right = (cylPt1.x > 0.0);
#endif // RENDER_CAPS
    bool cylPt1Valid = (cylPt1.x <= CYL_HALF_LEN) && (cylPt1.x >= -CYL_HALF_LEN); // trim cylinder
#ifdef RENDER_CAPS
    bool cylPt2Valid = cylPt1Right ? (cylPt2.x <= CYL_HALF_LEN) : (cylPt2.x >= -CYL_HALF_LEN);
#else
    bool cylPt2Valid = (cylPt2.x <= CYL_HALF_LEN) && (cylPt2.x >= -CYL_HALF_LEN);
#endif // RENDER_CAPS

#ifdef RENDER_CAPS
    lambdas.x = cylPt1Valid ? lambdas.x : (((cylPt1Right ? CYL_HALF_LEN : -CYL_HALF_LEN) - camPos.x) / ray.x);
    lambdas.x = (cylPt1Valid || cylPt2Valid) ? lambdas.x : maxLambda;

#ifdef CLIP
    if (lambdas.x >= maxLambda) { discard; }
#else // CLIP
    if (lambdas.x >= maxLambda) { radicand = -1.0; }
#endif // CLIP

#else // RENDER_CAPS
    lambdas.x = (cylPt1Valid) ? lambdas.x : lambdas.y;    

#ifdef CLIP
    if ((!cylPt1Valid && !cylPt2Valid)) { discard; }
#else // CLIP
    if ((!cylPt1Valid && !cylPt2Valid)) { radicand = -1.0; }
#endif // CLIP
#endif // RENDER_CAPS

    if( lambdas.x < 0.0 ) discard;
    vec3 intersection = camPos.xyz + ray * lambdas.x;
#ifdef RENDER_CAPS
    vec3 normal = (cylPt1Valid ? vec3(0.0, normalize(intersection.yz)) : (cylPt1Right ? vec3(1.0, 0.0, 0.0) : vec3(-1.0, 0.0, 0.0)));
#else // RENDER_CAPS
    vec3 normal = vec3(0.0, normalize(intersection.yz));
#endif // RENDER_CAPS


    // chose color for lighting
    vec3 color = gl_Color.rgb;

    // set fragment color (kroneml)
    if( cylPt1.x > 0.0 )
    {
        color = gl_SecondaryColor.rgb;
    }
    else
    {
        color = gl_Color.rgb;
    }

    // phong lighting with directional light
    gl_FragColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color), 1.0);


    // calculate depth
#ifdef DEPTH
    tmp = intersection;
    intersection.x = dot(rotMatT0, tmp.xyz);
    intersection.y = dot(rotMatT1, tmp.xyz);
    intersection.z = dot(rotMatT2, tmp.xyz);

    intersection += objPos.xyz;

    vec4 Ding = vec4(intersection, 1.0);
    float depth = dot(MVPtransp[2], Ding);
    float depthW = dot(MVPtransp[3], Ding);
#ifndef CLIP
    if (radicand < 0.0) { 
        gl_FragColor = gl_SecondaryColor;
        depth = 1.0;
        depthW = 1.0;
    }
#endif // CLIP
    gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
#endif // DEPTH

#ifdef RETICLE
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    if (min(abs(coord.x - centerFragment.x), abs(coord.y - centerFragment.y)) < 0.002) {
        gl_FragColor.rgb += vec3(0.3, 0.3, 0.5);
    }
#endif // RETICLE
//    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
//    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
}
-->
      </snippet>
    </shader>
  </namespace>

  <!-- shaders for the cartoon protein renderer -->
  <namespace name="cartoon">
    <namespace name="cartoon">
      <shader name="vertex">
        <snippet type="string">
          <!--
/*
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120

varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;

void main(void)
{
    gl_FrontColor=gl_Color;
    gl_BackColor=gl_Color;
    
    // do not ftransform(), geometry shader needs the original vertices
    gl_Position= gl_Vertex;
}
-->
        </snippet>
      </shader>
      <shader name="geometry">
        <snippet type="string">
          <!--
/* Geometry Shader: Cartoon Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable

varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;


void lighting( vec3 norm)
{
    // transformation of the normal into eye space
    normal = normalize(gl_NormalMatrix * norm);
    // normalize the direction of the light
    lightDir = normalize(vec3(gl_LightSource[0].position));
    // normalize the halfVector to pass it to the fragment shader
    halfVector = normalize(gl_LightSource[0].halfVector.xyz);
    // compute the diffuse, ambient and globalAmbient terms
    diffuse = gl_FrontColor * gl_LightSource[0].diffuse;
    ambient = gl_FrontColor * gl_LightSource[0].ambient;
    ambient += gl_LightModel.ambient * gl_FrontColor;
}

void main(void)
{
    // get all vertex positions
    vec3 v0 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v1 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v2 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v3 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 v4 = vec3(gl_PositionIn[4].xyz) / gl_PositionIn[4].w;
    vec3 v5 = vec3(gl_PositionIn[5].xyz) / gl_PositionIn[5].w;
    // compute all needed directions
    vec3 dir20 = v2 - v0;
    vec3 dir12 = v1 - v2;
    vec3 dir32 = v3 - v2;
    vec3 dir43 = v4 - v3;
    vec3 dir53 = v5 - v3;
    
    // number of segments
    const int n = 6;
    // scale factor for the width of the tube
    float scale = gl_FrontColorIn[1].x;
    float stretch1 = gl_FrontColorIn[1].y;
    float stretch2 = gl_FrontColorIn[1].z;

    vec3 dir1 = normalize( cross( dir12, dir32));
    vec3 dir2 = normalize( cross( dir43, dir53));
    
    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    // coil/turn
    if( gl_FrontColorIn[2].x < 1.0 )
    {
        // angle for the rotation
        float alpha;
        // matrices for rotation
        mat3 e = mat3( 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
        mat3 m1 = mat3( 0.0,-ortho1.z, ortho1.y, ortho1.z, 0.0,-ortho1.x,-ortho1.y, ortho1.x, 0.0);
        mat3 m2 = mat3( 0.0,-ortho2.z, ortho2.y, ortho2.z, 0.0,-ortho2.x,-ortho2.y, ortho2.x, 0.0);
        mat3 m1quat = m1 * m1;
        mat3 m2quat = m2 * m2;
        
        vec3 res1;
        vec3 res2;
        
        dir1 = dir1 * scale;
        dir2 = dir2 * scale;
        
        for( int i = 0; i < n; i++ )
        {
            alpha = (360.0/float(n))*float(i);
            res1 = ( e + sin( radians( alpha)) * m1 + ( 1.0 - cos( radians( alpha))) * m1quat ) * dir1;
            res2 = ( e + sin( radians( alpha)) * m2 + ( 1.0 - cos( radians( alpha))) * m2quat ) * dir2;
            
            // copy color 
            gl_FrontColor = gl_FrontColorIn[0];
            // copy position 
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + res1).xyz, 1.0);
            // compute lighting
            lighting( normalize( res1));
            // done with the vertex 
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + res2).xyz, 1.0);
            lighting( normalize( res2));
            EmitVertex();
        }
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1).xyz, 1.0);
        lighting( normalize( dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2).xyz, 1.0);
        lighting( normalize( dir2));
        EmitVertex();
        
        EndPrimitive();
/*
        ////////////////
        // draw start //
        ////////////////
        for( int i = 0; i < n; i++ )
        {
            alpha = (360.0/float(n))*float(i);
            res1 = ( e + sin( radians( alpha)) * m2 + ( 1.0 - cos( radians( alpha))) * m2quat ) * dir2;
            alpha = (360.0/float(n))*float(i+1);
            res2 = ( e + sin( radians( alpha)) * m2 + ( 1.0 - cos( radians( alpha))) * m2quat ) * dir2;
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + res1).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + res2).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( v3, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            EndPrimitive();
        }
*/
/*
        //////////////
        // draw end //
        //////////////
        for( int i = 0; i < n; i++ )
        {
            alpha = (360.0/float(n))*float(i);
            res1 = ( e + sin( radians( alpha)) * m1 + ( 1.0 - cos( radians( alpha))) * m1quat ) * dir1;
            alpha = (360.0/float(n))*float(i+1);
            res2 = ( e + sin( radians( alpha)) * m1 + ( 1.0 - cos( radians( alpha))) * m1quat ) * dir1;
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + res1).xyz, 1.0);
            lighting( normalize(-dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + res2).xyz, 1.0);
            lighting( normalize(-dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( v2, 1.0);
            lighting( normalize(-dir20));
            EmitVertex();
            
            EndPrimitive();
        }
*/
    }
    // sheet ribbon
    else if( gl_FrontColorIn[2].x > 0.5 && gl_FrontColorIn[2].x < 1.5 )
    {
        dir1 = normalize( cross( dir1, ortho1))*stretch1;
        dir2 = normalize( cross( dir2, ortho2))*stretch2;
        vec3 norm1 = normalize( cross( dir1, ortho1));
        vec3 norm2 = normalize( cross( dir2, ortho2));
        
        /////////////////////
        // draw top ribbon //
        /////////////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
        lighting( normalize( norm1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
        lighting( normalize( norm1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
        lighting( normalize( norm2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
        lighting( normalize( norm2));
        EmitVertex();
        
        EndPrimitive();
        
        ////////////////////////
        // draw bottom ribbon //
        ////////////////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
        lighting( normalize(-norm1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
        lighting( normalize(-norm1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
        lighting( normalize(-norm2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
        lighting( normalize(-norm2));
        EmitVertex();
        
        EndPrimitive();
        
        /////////////////////
        // draw first side //
        /////////////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
        lighting( normalize( dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
        lighting( normalize( dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir2));
        EmitVertex();
        
        EndPrimitive();
        
        //////////////////////
        // draw second side //
        //////////////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
        lighting( normalize(-dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
        lighting( normalize(-dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
        lighting( normalize(-dir2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
        lighting( normalize(-dir2));
        EmitVertex();
        
        EndPrimitive();
        
        if( gl_FrontColorIn[2].y > 0.0 )
        {
            ////////////////
            // draw start //
            ////////////////
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            EndPrimitive();
        }
        
        if( gl_FrontColorIn[2].z > 0.0 )
        {
            //////////////
            // draw end //
            //////////////
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
            lighting( normalize(-dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
            lighting( normalize(-dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
            lighting( normalize(-dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
            lighting( normalize(-dir20));
            EmitVertex();
            
            EndPrimitive();
        }
    }
    // helix ribbon
    else if( gl_FrontColorIn[2].x > 1.5 && gl_FrontColorIn[2].x < 2.5 )
    {
        dir1 = normalize( cross( dir1, ortho1))*stretch1;
        dir2 = normalize( cross( dir2, ortho2))*stretch2;
        vec3 norm1 = normalize( cross( dir1, ortho1));
        vec3 norm2 = normalize( cross( dir2, ortho2));
        
        /////////////////////
        // draw top ribbon //
        /////////////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
        lighting( normalize(-dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
        lighting( normalize(-dir2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 + norm1*scale).xyz, 1.0);
        lighting( normalize( norm1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 + norm2*scale).xyz, 1.0);
        lighting( normalize( norm2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 + norm1*scale).xyz, 1.0);
        lighting( normalize( norm1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 + norm2*scale).xyz, 1.0);
        lighting( normalize( norm2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir2));
        EmitVertex();
        
        EndPrimitive();
        
        ////////////////////////
        // draw bottom ribbon //
        ////////////////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
        lighting( normalize(-dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
        lighting( normalize(-dir2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 - norm1*scale).xyz, 1.0);
        lighting( normalize(-norm1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 - norm2*scale).xyz, 1.0);
        lighting( normalize(-norm2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 - norm1*scale).xyz, 1.0);
        lighting( normalize(-norm1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 - norm2*scale).xyz, 1.0);
        lighting( normalize(-norm2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir2));
        EmitVertex();
        
        EndPrimitive();
        
        /////////////////////
        // draw first side //
        /////////////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir2));
        EmitVertex();
        
        EndPrimitive();
        
        //////////////////////
        // draw second side //
        //////////////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
        lighting( normalize(-dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
        lighting( normalize(-dir1));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
        lighting( normalize(-dir2));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
        lighting( normalize(-dir2));
        EmitVertex();
        
        EndPrimitive();
        
        if( gl_FrontColorIn[2].y > 0.0 )
        {
            ////////////////
            // draw start //
            ////////////////
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 + norm2*scale).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 + norm2*scale).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 - norm2*scale).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 - norm2*scale).xyz, 1.0);
            lighting( normalize( dir32));
            EmitVertex();
            
            EndPrimitive();
        }

        if( gl_FrontColorIn[2].z > 0.0 )
        {
            //////////////
            // draw end //
            //////////////
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 + norm1*scale).xyz, 1.0);
            lighting( normalize( -dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 + norm1*scale).xyz, 1.0);
            lighting( normalize( -dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
            lighting( normalize( -dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
            lighting( normalize( -dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
            lighting( normalize( -dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
            lighting( normalize( -dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 - norm1*scale).xyz, 1.0);
            lighting( normalize( -dir20));
            EmitVertex();
            
            gl_FrontColor = gl_FrontColorIn[0];
            gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 - norm1*scale).xyz, 1.0);
            lighting( normalize( -dir20));
            EmitVertex();
            
            EndPrimitive();
        }
    }
}
-->
        </snippet>
      </shader>
      <shader name="fragment">
        <snippet type="string">
          <!--
/*
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120

varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;


void main(void)
{    
    //gl_FragColor = gl_Color;

    vec3 n,halfV;
    float NdotL,NdotHV;
    
    // store the ambient term
    vec4 color = ambient;
    
    // store the normalized interpolated normal
    n = normalize(normal);
    
    // compute the dot product between normal and ldir
    NdotL = max(dot(n,lightDir),0.0);
    if (NdotL > 0.0) {
        color += diffuse * NdotL;
        halfV = normalize(halfVector);
        NdotHV = max(dot(n,halfV),0.0);
        color += gl_FrontMaterial.specular * gl_LightSource[0].specular * 
                pow(NdotHV, gl_FrontMaterial.shininess);
    }

    gl_FragColor = color;
    
    /*
    vec3 fogCol = vec3( 1.0, 1.0, 1.0);
    const float LOG2 = 1.442695;
    float fogDensity = 0.35;
    float z = gl_FragCoord.z / gl_FragCoord.w;
    float fogFactor = exp2( - fogDensity * fogDensity * z * z * LOG2 );
    fogFactor = clamp(fogFactor, 0.0, 1.0);
    gl_FragColor.rgb = mix( fogCol, gl_FragColor.rgb, fogFactor );
    */
}
-->
        </snippet>
      </shader>
    </namespace>
    <shader name="tubeGeometry">
      <snippet type="string">
        <!-- 
/* Geometry Shader: Tube Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable

varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;


void lighting( vec3 norm)
{
    // transformation of the normal into eye space
    normal = normalize(gl_NormalMatrix * norm);
    // normalize the direction of the light
    lightDir = normalize(vec3(gl_LightSource[0].position));
    // normalize the halfVector to pass it to the fragment shader
    halfVector = normalize(gl_LightSource[0].halfVector.xyz);
    // compute the diffuse, ambient and globalAmbient terms
    diffuse = gl_FrontColor * gl_LightSource[0].diffuse;
    ambient = gl_FrontColor * gl_LightSource[0].ambient;
    ambient += gl_LightModel.ambient * gl_FrontColor;
}

void main(void)
{
    // get all vertex positions
    vec3 v0 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v1 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v2 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v3 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 v4 = vec3(gl_PositionIn[4].xyz) / gl_PositionIn[4].w;
    vec3 v5 = vec3(gl_PositionIn[5].xyz) / gl_PositionIn[5].w;
    // compute all needed directions
    vec3 dir20 = v2 - v0;
    vec3 dir12 = v1 - v2;
    vec3 dir32 = v3 - v2;
    vec3 dir43 = v4 - v3;
    vec3 dir53 = v5 - v3;
    
    // number of segments
    const int n = 12;
    // scale factor for the width of the tube
    float scale = gl_FrontColorIn[1].x;
    float stretch1 = gl_FrontColorIn[1].y;
    float stretch2 = gl_FrontColorIn[1].z;

    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));

    // angle for the rotation
    float alpha;
    // matrices for rotation
    mat3 e = mat3( 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
    mat3 m1 = mat3( 0.0,-ortho1.z, ortho1.y, ortho1.z, 0.0,-ortho1.x,-ortho1.y, ortho1.x, 0.0);
    mat3 m2 = mat3( 0.0,-ortho2.z, ortho2.y, ortho2.z, 0.0,-ortho2.x,-ortho2.y, ortho2.x, 0.0);
    mat3 m1quat = m1 * m1;
    mat3 m2quat = m2 * m2;
    
    vec3 res1;
    vec3 res2;
    
    dir1 = dir1 * scale;
    dir2 = dir2 * scale;
    
    for( int i = 0; i < n; i++ )
    {
        alpha = (360.0/float(n))*float(i);
        res1 = ( e + sin( radians( alpha)) * m1 + ( 1.0 - cos( radians( alpha))) * m1quat ) * dir1;
        res2 = ( e + sin( radians( alpha)) * m2 + ( 1.0 - cos( radians( alpha))) * m2quat ) * dir2;
        
        // copy color 
        gl_FrontColor = gl_FrontColorIn[0];
        // copy position 
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + res1).xyz, 1.0);
        // compute lighting
        lighting( normalize( res1));
        // done with the vertex 
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + res2).xyz, 1.0);
        lighting( normalize( res2));
        EmitVertex();
    }
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
}
-->
      </snippet>
    </shader>
    <shader name="arrowGeometry">
      <snippet type="string">
        <!--
/* Geometry Shader: Arrow Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable

varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;


void lighting( vec3 norm)
{
    // transformation of the normal into eye space
    normal = normalize(gl_NormalMatrix * norm);
    // normalize the direction of the light
    lightDir = normalize(vec3(gl_LightSource[0].position));
    // normalize the halfVector to pass it to the fragment shader
    halfVector = normalize(gl_LightSource[0].halfVector.xyz);
    // compute the diffuse, ambient and globalAmbient terms
    diffuse = gl_FrontColor * gl_LightSource[0].diffuse;
    ambient = gl_FrontColor * gl_LightSource[0].ambient;
    ambient += gl_LightModel.ambient * gl_FrontColor;
}

void main(void)
{
    // get all vertex positions
    vec3 v0 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v1 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v2 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v3 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 v4 = vec3(gl_PositionIn[4].xyz) / gl_PositionIn[4].w;
    vec3 v5 = vec3(gl_PositionIn[5].xyz) / gl_PositionIn[5].w;
    // compute all needed directions
    vec3 dir20 = v2 - v0;
    vec3 dir12 = v1 - v2;
    vec3 dir32 = v3 - v2;
    vec3 dir43 = v4 - v3;
    vec3 dir53 = v5 - v3;
    
    // scale factor for the width of the tube
    float scale = gl_FrontColorIn[1].x;
    float stretch1 = gl_FrontColorIn[1].y;
    float stretch2 = gl_FrontColorIn[1].z;

    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));

    dir1 = normalize( cross( dir1, ortho1))*stretch1;
    dir2 = normalize( cross( dir2, ortho2))*stretch2;
    
    vec3 norm1 = normalize( cross( dir1, ortho1));
    vec3 norm2 = normalize( cross( dir2, ortho2));
    
    /////////////////////
    // draw top ribbon //
    /////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
    lighting( normalize( norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
    lighting( normalize( norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
    lighting( normalize( norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
    lighting( normalize( norm2));
    EmitVertex();
    
    EndPrimitive();
    
    ////////////////////////
    // draw bottom ribbon //
    ////////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
    lighting( normalize(-norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
    lighting( normalize(-norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
    lighting( normalize(-norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
    lighting( normalize(-norm2));
    EmitVertex();
    
    EndPrimitive();
    
    /////////////////////
    // draw first side //
    /////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
    
    //////////////////////
    // draw second side //
    //////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    EndPrimitive();
    
    if( gl_FrontColorIn[2].y > 0.0 )
    {
        ////////////////
        // draw start //
        ////////////////
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        EndPrimitive();
    }
    
    if( gl_FrontColorIn[2].z > 0.0 )
    {
        //////////////
        // draw end //
        //////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
        lighting( normalize(-dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
        lighting( normalize(-dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
        lighting( normalize(-dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
        lighting( normalize(-dir20));
        EmitVertex();
        
        EndPrimitive();
    }

}
-->
      </snippet>
    </shader>
    <shader name="helixGeometry">
      <snippet type="string">
        <!--
/* Geometry Shader: Helix Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable

varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;


void lighting( vec3 norm)
{
    // transformation of the normal into eye space
    normal = normalize(gl_NormalMatrix * norm);
    // normalize the direction of the light
    lightDir = normalize(vec3(gl_LightSource[0].position));
    // normalize the halfVector to pass it to the fragment shader
    halfVector = normalize(gl_LightSource[0].halfVector.xyz);
    // compute the diffuse, ambient and globalAmbient terms
    diffuse = gl_FrontColor * gl_LightSource[0].diffuse;
    ambient = gl_FrontColor * gl_LightSource[0].ambient;
    ambient += gl_LightModel.ambient * gl_FrontColor;
}

void main(void)
{
    // get all vertex positions
    vec3 v0 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v1 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v2 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v3 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 v4 = vec3(gl_PositionIn[4].xyz) / gl_PositionIn[4].w;
    vec3 v5 = vec3(gl_PositionIn[5].xyz) / gl_PositionIn[5].w;
    // compute all needed directions
    vec3 dir20 = v2 - v0;
    vec3 dir12 = v1 - v2;
    vec3 dir32 = v3 - v2;
    vec3 dir43 = v4 - v3;
    vec3 dir53 = v5 - v3;
    
    // scale factor for the width of the tube
    float scale = gl_FrontColorIn[1].x;
    float stretch1 = gl_FrontColorIn[1].y;
    float stretch2 = gl_FrontColorIn[1].z;

    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));
    
    dir1 = normalize( cross( dir1, ortho1))*stretch1;
    dir2 = normalize( cross( dir2, ortho2))*stretch2;
    vec3 norm1 = normalize( cross( dir1, ortho1));
    vec3 norm2 = normalize( cross( dir2, ortho2));
    
    /////////////////////
    // draw top ribbon //
    /////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 + norm1*scale).xyz, 1.0);
    lighting( normalize( norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 + norm2*scale).xyz, 1.0);
    lighting( normalize( norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 + norm1*scale).xyz, 1.0);
    lighting( normalize( norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 + norm2*scale).xyz, 1.0);
    lighting( normalize( norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
    
    ////////////////////////
    // draw bottom ribbon //
    ////////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 - norm1*scale).xyz, 1.0);
    lighting( normalize(-norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 - norm2*scale).xyz, 1.0);
    lighting( normalize(-norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 - norm1*scale).xyz, 1.0);
    lighting( normalize(-norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 - norm2*scale).xyz, 1.0);
    lighting( normalize(-norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
    
    /////////////////////
    // draw first side //
    /////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
    
    //////////////////////
    // draw second side //
    //////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    EndPrimitive();
    
    if( gl_FrontColorIn[2].y > 0.0 )
    {
        ////////////////
        // draw start //
        ////////////////
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        EndPrimitive();
    }

    if( gl_FrontColorIn[2].z > 0.0 )
    {
        //////////////
        // draw end //
        //////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 + norm1*scale).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 + norm1*scale).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 - norm1*scale).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 - norm1*scale).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        EndPrimitive();
    }
}
-->
      </snippet>
    </shader>

    <namespace name="simple">
      <shader name="vertex">
        <snippet type="string">
          <!--
/*
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120


void main(void)
{
    gl_FrontColor=gl_Color;
    gl_BackColor=gl_Color;
    
    // do not ftransform(), geometry shader needs the original vertices
    gl_Position= gl_Vertex;
}
-->
        </snippet>
      </shader>
      <shader name="fragment">
        <snippet type="string">
          <!--
/*
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120


void main(void)
{    
    gl_FragColor = gl_Color;
}
-->
        </snippet>
      </shader>
      <shader name="tubeGeometry">
        <snippet type="string">
          <!--
/* Geometry Shader: Cartoon Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable


void lighting( vec3 norm)
{
    vec3 normal, lightDir;
    vec4 diffuse, ambient, globalAmbient;
    float NdotL;
    
    normal = normalize(gl_NormalMatrix * norm);
    lightDir = normalize(vec3(gl_LightSource[0].position));
    NdotL = max(dot(normal, lightDir), 0.0);
    diffuse = gl_FrontColor * gl_LightSource[0].diffuse;
    
    /* Compute the ambient and globalAmbient terms */
    ambient = gl_FrontColor * gl_LightSource[0].ambient;
    globalAmbient = gl_LightModel.ambient * gl_FrontColor;
    
    gl_FrontColor =  NdotL * diffuse + globalAmbient + ambient;
    gl_BackColor =  NdotL * diffuse + globalAmbient + ambient;
}

void main(void)
{
    // get all vertex positions
    vec3 v0 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v1 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v2 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v3 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 v4 = vec3(gl_PositionIn[4].xyz) / gl_PositionIn[4].w;
    vec3 v5 = vec3(gl_PositionIn[5].xyz) / gl_PositionIn[5].w;
    // compute all needed directions
    vec3 dir20 = v2 - v0;
    vec3 dir12 = v1 - v2;
    vec3 dir32 = v3 - v2;
    vec3 dir43 = v4 - v3;
    vec3 dir53 = v5 - v3;
    
    // number of segments
    const int n = 12;
    // scale factor for the width of the tube
    float scale = gl_FrontColorIn[1].x;
    float stretch1 = gl_FrontColorIn[1].y;
    float stretch2 = gl_FrontColorIn[1].z;

    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));
    
    // angle for the rotation
    float alpha;
    // matrices for rotation
    mat3 e = mat3( 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
    mat3 m1 = mat3( 0.0,-ortho1.z, ortho1.y, ortho1.z, 0.0,-ortho1.x,-ortho1.y, ortho1.x, 0.0);
    mat3 m2 = mat3( 0.0,-ortho2.z, ortho2.y, ortho2.z, 0.0,-ortho2.x,-ortho2.y, ortho2.x, 0.0);
    mat3 m1quat = m1 * m1;
    mat3 m2quat = m2 * m2;
    
    vec3 res1;
    vec3 res2;
    
    dir1 = dir1 * scale;
    dir2 = dir2 * scale;
    
    for( int i = 0; i < n; i++ )
    {
        alpha = (360.0/float(n))*float(i);
        res1 = ( e + sin( radians( alpha)) * m1 + ( 1.0 - cos( radians( alpha))) * m1quat ) * dir1;
        res2 = ( e + sin( radians( alpha)) * m2 + ( 1.0 - cos( radians( alpha))) * m2quat ) * dir2;
        
        // copy color 
        gl_FrontColor = gl_FrontColorIn[0];
        // copy position
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + res1).xyz, 1.0);
        // compute lighting
        lighting( normalize( res1));
        // done with the vertex 
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + res2).xyz, 1.0);
        lighting( normalize( res2));
        EmitVertex();
    }
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
}
-->
        </snippet>
      </shader>
      <shader name="arrowGeometry">
        <snippet type="string">
          <!--
/* Geometry Shader: Cartoon Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable


void lighting( vec3 norm)
{
    vec3 normal, lightDir;
    vec4 diffuse, ambient, globalAmbient;
    float NdotL;
    
    normal = normalize(gl_NormalMatrix * norm);
    lightDir = normalize(vec3(gl_LightSource[0].position));
    NdotL = max(dot(normal, lightDir), 0.0);
    diffuse = gl_FrontColor * gl_LightSource[0].diffuse;
    
    /* Compute the ambient and globalAmbient terms */
    ambient = gl_FrontColor * gl_LightSource[0].ambient;
    globalAmbient = gl_LightModel.ambient * gl_FrontColor;
    
    gl_FrontColor =  NdotL * diffuse + globalAmbient + ambient;
    gl_BackColor =  NdotL * diffuse + globalAmbient + ambient;
}

void main(void)
{
    // get all vertex positions
    vec3 v0 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v1 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v2 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v3 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 v4 = vec3(gl_PositionIn[4].xyz) / gl_PositionIn[4].w;
    vec3 v5 = vec3(gl_PositionIn[5].xyz) / gl_PositionIn[5].w;
    // compute all needed directions
    vec3 dir20 = v2 - v0;
    vec3 dir12 = v1 - v2;
    vec3 dir32 = v3 - v2;
    vec3 dir43 = v4 - v3;
    vec3 dir53 = v5 - v3;
    
    // scale factor for the width of the tube
    float scale = gl_FrontColorIn[1].x;
    float stretch1 = gl_FrontColorIn[1].y;
    float stretch2 = gl_FrontColorIn[1].z;

    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));

    dir1 = normalize( cross( dir1, ortho1))*stretch1;
    dir2 = normalize( cross( dir2, ortho2))*stretch2;
    vec3 norm1 = normalize( cross( dir1, ortho1));
    vec3 norm2 = normalize( cross( dir2, ortho2));
    
    /////////////////////
    // draw top ribbon //
    /////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
    lighting( normalize( norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
    lighting( normalize( norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
    lighting( normalize( norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
    lighting( normalize( norm2));
    EmitVertex();
    
    EndPrimitive();
    
    ////////////////////////
    // draw bottom ribbon //
    ////////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
    lighting( normalize(-norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
    lighting( normalize(-norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
    lighting( normalize(-norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
    lighting( normalize(-norm2));
    EmitVertex();
    
    EndPrimitive();
    
    /////////////////////
    // draw first side //
    /////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
    
    //////////////////////
    // draw second side //
    //////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    EndPrimitive();
    
    if( gl_FrontColorIn[2].y > 0.0 )
    {
        ////////////////
        // draw start //
        ////////////////
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        EndPrimitive();
    }
    
    if( gl_FrontColorIn[2].z > 0.0 )
    {
        //////////////
        // draw end //
        //////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
        lighting( normalize(-dir20));
        EmitVertex();
        
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
        lighting( normalize(-dir20));
        EmitVertex();
        
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
        lighting( normalize(-dir20));
        EmitVertex();
        
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
        lighting( normalize(-dir20));
        EmitVertex();
        
        EndPrimitive();
    }
}
-->
        </snippet>
      </shader>
      <shader name="helixGeometry">
        <snippet type="string">
          <!--
/* Geometry Shader: Cartoon Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable


void lighting( vec3 norm)
{
    vec3 normal, lightDir;
    vec4 diffuse, ambient, globalAmbient;
    float NdotL;
    
    normal = normalize(gl_NormalMatrix * norm);
    lightDir = normalize(vec3(gl_LightSource[0].position));
    NdotL = max(dot(normal, lightDir), 0.0);
    diffuse = gl_FrontColor * gl_LightSource[0].diffuse;
    
    /* Compute the ambient and globalAmbient terms */
    ambient = gl_FrontColor * gl_LightSource[0].ambient;
    globalAmbient = gl_LightModel.ambient * gl_FrontColor;
    
    gl_FrontColor =  NdotL * diffuse + globalAmbient + ambient;
    gl_BackColor =  NdotL * diffuse + globalAmbient + ambient;
}

void main(void)
{
    // get all vertex positions
    vec3 v0 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v1 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v2 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v3 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 v4 = vec3(gl_PositionIn[4].xyz) / gl_PositionIn[4].w;
    vec3 v5 = vec3(gl_PositionIn[5].xyz) / gl_PositionIn[5].w;
    // compute all needed directions
    vec3 dir20 = v2 - v0;
    vec3 dir12 = v1 - v2;
    vec3 dir32 = v3 - v2;
    vec3 dir43 = v4 - v3;
    vec3 dir53 = v5 - v3;
    
    // scale factor for the width of the tube
    float scale = gl_FrontColorIn[1].x;
    float stretch1 = gl_FrontColorIn[1].y;
    float stretch2 = gl_FrontColorIn[1].z;

    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));
    
    dir1 = normalize( cross( dir1, ortho1))*stretch1;
    dir2 = normalize( cross( dir2, ortho2))*stretch2;
    vec3 norm1 = normalize( cross( dir1, ortho1));
    vec3 norm2 = normalize( cross( dir2, ortho2));
        
    /////////////////////
    // draw top ribbon //
    /////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 + norm1*scale).xyz, 1.0);
    lighting( normalize( norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 + norm2*scale).xyz, 1.0);
    lighting( normalize( norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 + norm1*scale).xyz, 1.0);
    lighting( normalize( norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 + norm2*scale).xyz, 1.0);
    lighting( normalize( norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
    
    ////////////////////////
    // draw bottom ribbon //
    ////////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 - norm1*scale).xyz, 1.0);
    lighting( normalize(-norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 - norm2*scale).xyz, 1.0);
    lighting( normalize(-norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 - norm1*scale).xyz, 1.0);
    lighting( normalize(-norm1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 - norm2*scale).xyz, 1.0);
    lighting( normalize(-norm2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
    
    /////////////////////
    // draw first side //
    /////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
    lighting( normalize( dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
    lighting( normalize( dir2));
    EmitVertex();
    
    EndPrimitive();
    
    //////////////////////
    // draw second side //
    //////////////////////
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[0];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir1));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    gl_FrontColor = gl_FrontColorIn[3];
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
    lighting( normalize(-dir2));
    EmitVertex();
    
    EndPrimitive();
    
    if( gl_FrontColorIn[2].y > 0.0 )
    {
        ////////////////
        // draw start //
        ////////////////
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 + norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale*0.5).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2*0.7 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[3];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2*0.7 - norm2*scale).xyz, 1.0);
        lighting( normalize( dir32));
        EmitVertex();
        
        EndPrimitive();
    }

    if( gl_FrontColorIn[2].z > 0.0 )
    {
        //////////////
        // draw end //
        //////////////
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 + norm1*scale).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 + norm1*scale).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale*0.5).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1*0.7 - norm1*scale).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        gl_FrontColor = gl_FrontColorIn[0];
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1*0.7 - norm1*scale).xyz, 1.0);
        lighting( normalize( -dir20));
        EmitVertex();
        
        EndPrimitive();
    }
}
-->
        </snippet>
      </shader>
    </namespace>

    <namespace name="spline">
      <shader name="vertex">
        <snippet type="string">
          <!--
/*
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120

void main(void)
{
    gl_FrontColor = gl_Color;
    gl_BackColor = gl_Color;
    gl_FrontSecondaryColor = gl_SecondaryColor;
    gl_BackSecondaryColor = gl_SecondaryColor;
    
    // do not ftransform(), geometry shader needs the original vertices
    gl_Position = gl_Vertex;
}
-->
        </snippet>
      </shader>
      <shader name="fragment">
        <snippet type="string">
          <!--
/*
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120

varying vec3 normal;
varying vec3 color;

void main(void) {
#if 0
    vec3 norm, lightDir;
    vec4 diffuse, ambient, globalAmbient;
    float NdotL;
    
    norm = normalize(gl_NormalMatrix * normal);
    lightDir = normalize(vec3(gl_LightSource[0].position));
    NdotL = max(dot(norm, lightDir), 0.0);
    diffuse = vec4( color, 1.0) * gl_LightSource[0].diffuse;
    
    /* Compute the ambient and globalAmbient terms */
    ambient = vec4( color, 1.0) * gl_LightSource[0].ambient;
    globalAmbient = gl_LightModel.ambient * vec4( color, 1.0);
    gl_FragColor = NdotL * diffuse + globalAmbient + ambient;
#else    
    // normalize the direction of the light
    vec3 lightDir = normalize(vec3(gl_LightSource[0].position));

    // normalize the halfVector to pass it to the fragment shader
    vec3 halfVector = normalize(gl_LightSource[0].halfVector.xyz);
    
    vec4 diffuse, ambient;
    // compute the diffuse, ambient and globalAmbient terms
    diffuse = vec4( color, 1.0) * gl_LightSource[0].diffuse;
    ambient = vec4( color, 1.0) * gl_LightSource[0].ambient;
    ambient += gl_LightModel.ambient * vec4( color, 1.0);
    
    vec3 n;
    float NdotL,NdotHV;
    
    // store the ambient term
    vec4 colorOut = ambient;
    
    // transformation of the normal into eye space
    n = normalize(gl_NormalMatrix * normal);

    // compute the dot product between normal and lightDir
    NdotL = dot(n,lightDir);
    if (NdotL > 0.0) {
        // front side
        colorOut += diffuse * NdotL;
        NdotHV = max(dot(n,halfVector),4.88e-04);
        colorOut += gl_FrontMaterial.specular * gl_LightSource[0].specular * pow(NdotHV, gl_FrontMaterial.shininess);
    }

    gl_FragColor = colorOut;
#endif
    //gl_FragColor = gl_Color;
}
-->
        </snippet>
      </shader>
      <shader name="tubeGeometry">
        <snippet type="string">
          <!--
/* Geometry Shader: Arrow Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable

varying out vec3 normal;
varying out vec3 color;

void compute( vec3 v2, vec3 v3, vec3 dir20, vec3 dir12, vec3 dir32, vec3 dir43, vec3 dir53, float scale, int n)
{
    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));

    // angle for the rotation
    float alpha;
    // matrices for rotation
    mat3 e = mat3( 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
    mat3 m1 = mat3( 0.0,-ortho1.z, ortho1.y, ortho1.z, 0.0,-ortho1.x,-ortho1.y, ortho1.x, 0.0);
    mat3 m2 = mat3( 0.0,-ortho2.z, ortho2.y, ortho2.z, 0.0,-ortho2.x,-ortho2.y, ortho2.x, 0.0);
    mat3 m1quat = m1 * m1;
    mat3 m2quat = m2 * m2;
    
    vec3 res1;
    vec3 res2;
    
    dir1 = dir1 * scale;
    dir2 = dir2 * scale;
    
    for( int i = 0; i < n; i++ )
    {
        alpha = (360.0/float(n))*float(i);
        res1 = ( e + sin( radians( alpha)) * m1 + ( 1.0 - cos( radians( alpha))) * m1quat ) * dir1;
        res2 = ( e + sin( radians( alpha)) * m2 + ( 1.0 - cos( radians( alpha))) * m2quat ) * dir2;
        
        // copy color 
        color = vec3( gl_FrontSecondaryColorIn[0]);
        // copy position 
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + res1).xyz, 1.0);
        // compute lighting
        normal = normalize( res1);
        // done with the vertex 
        EmitVertex();
        
        color = vec3( gl_FrontSecondaryColorIn[0]);
        gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + res2).xyz, 1.0);
        normal = normalize( res2);
        EmitVertex();
    }
    color = vec3( gl_FrontSecondaryColorIn[0]);
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1).xyz, 1.0);
    normal = normalize( dir1);
    EmitVertex();
    
    color = vec3( gl_FrontSecondaryColorIn[0]);
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2).xyz, 1.0);
    normal = normalize( dir2);
    EmitVertex();
    
    EndPrimitive();
}

void main(void)
{
    // number of segments for the tube
    int numSegTube = 6;
    // number of segments for each curve section
    const int numSeg = 6;
    const float N = float( numSeg);
    // dimension of 'results' and 'directions' MUST be numSeg+1 
    vec3 results[numSeg + 1];
    vec3 directions[numSeg + 1];
    // vertices and directions
    /*
    vec3 v0 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v1 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v2 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v3 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 v4 = vec3(gl_PositionIn[4].xyz) / gl_PositionIn[4].w;
    vec3 v5 = vec3(gl_PositionIn[5].xyz) / gl_PositionIn[5].w;
    vec3 n1 = vec3(gl_FrontColorIn[1].xyz) / gl_FrontColorIn[1].w;
    vec3 n2 = vec3(gl_FrontColorIn[2].xyz) / gl_FrontColorIn[2].w;
    vec3 n3 = vec3(gl_FrontColorIn[3].xyz) / gl_FrontColorIn[3].w;
    vec3 n4 = vec3(gl_FrontColorIn[4].xyz) / gl_FrontColorIn[4].w;
    */
    vec3 v1 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v2 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v3 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v4 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 n1 = vec3(gl_FrontColorIn[0].xyz) / gl_FrontColorIn[0].w;
    vec3 n2 = vec3(gl_FrontColorIn[1].xyz) / gl_FrontColorIn[1].w;
    vec3 n3 = vec3(gl_FrontColorIn[2].xyz) / gl_FrontColorIn[2].w;
    vec3 n4 = vec3(gl_FrontColorIn[3].xyz) / gl_FrontColorIn[3].w;
        
    // assign matrix S
  mat4 S;
    S[0] = vec4( 6.0/(N*N*N), 6.0/(N*N*N), 1.0/(N*N*N), 0.0 );
    S[1] = vec4(         0.0,   2.0/(N*N),   1.0/(N*N), 0.0 );
    S[2] = vec4(                 0.0,         0.0,       1.0/N, 0.0 );
    S[3] = vec4(                 0.0,         0.0,         0.0, 1.0 );
    // assign the basis matrix
  mat4 B;
    B[0] = vec4(-1.0/6.0, 3.0/6.0,-3.0/6.0, 1.0/6.0 );
    B[1] = vec4( 3.0/6.0,-6.0/6.0, 0.0/6.0, 4.0/6.0 );
    B[2] = vec4(-3.0/6.0, 3.0/6.0, 3.0/6.0, 1.0/6.0 );
    B[3] = vec4( 1.0/6.0, 0.0/6.0, 0.0/6.0, 0.0/6.0 );
    
    // assign the geometry matrix
    mat4 G;
    G[0] = vec4( v1.x, v2.x, v3.x, v4.x );
    G[1] = vec4( v1.y, v2.y, v3.y, v4.y );
    G[2] = vec4( v1.z, v2.z, v3.z, v4.z );
    G[3] = vec4( 1.0, 1.0, 1.0, 1.0 );
    // compute the matrix M
    mat4 M = S * ( B * G );
    // start computation of first spline segment 
    results[0] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    for( int k = 0; k < numSeg; k++ )
    {
        M[0].w = M[0].w + M[0].z;
        M[1].w = M[1].w + M[1].z;
        M[2].w = M[2].w + M[2].z;
        M[3].w = M[3].w + M[3].z;
        M[0].z = M[0].z + M[0].y;
        M[1].z = M[1].z + M[1].y;
        M[2].z = M[2].z + M[2].y;
        M[3].z = M[3].z + M[3].y;
        M[0].y = M[0].y + M[0].x;
        M[1].y = M[1].y + M[1].x;
        M[2].y = M[2].y + M[2].x;
        M[3].y = M[3].y + M[3].x;
        
        results[k+1] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    }
    
    G[0] = vec4( n1.x+v1.x, n2.x+v2.x, n3.x+v3.x, n4.x+v4.x );
    G[1] = vec4( n1.y+v1.y, n2.y+v2.y, n3.y+v3.y, n4.y+v4.y );
    G[2] = vec4( n1.z+v1.z, n2.z+v2.z, n3.z+v3.z, n4.z+v4.z );
    // compute the matrix M
    M = S * ( B * G );
    // start computation of second spline segments
    directions[0] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    for( int k = 0; k < numSeg; k++ )
    {
        M[0].w = M[0].w + M[0].z;
        M[1].w = M[1].w + M[1].z;
        M[2].w = M[2].w + M[2].z;
        M[3].w = M[3].w + M[3].z;
        M[0].z = M[0].z + M[0].y;
        M[1].z = M[1].z + M[1].y;
        M[2].z = M[2].z + M[2].y;
        M[3].z = M[3].z + M[3].y;
        M[0].y = M[0].y + M[0].x;
        M[1].y = M[1].y + M[1].x;
        M[2].y = M[2].y + M[2].x;
        M[3].y = M[3].y + M[3].x;
        directions[k+1] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    }
    
    // draw
    vec3 dir20;
    vec3 dir12;
    vec3 dir32;
    vec3 dir43;
    vec3 dir53;
    
    // compute all needed directions
    dir20 = v3 - v1;
    dir12 = directions[0] - results[0];
    dir32 = results[1] - results[0];
    dir43 = directions[1] - results[1];
    dir53 = results[2] - results[1];
    compute( results[0], results[1], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, numSegTube );
    
    for( int i = 0; i < numSeg-2; i++ )
    {
        // compute all needed directions
        dir20 = results[i+1] - results[i+0];
        dir12 = directions[i+1] - results[i+1];
        dir32 = results[i+2] - results[i+1];
        dir43 = directions[i+2] - results[i+2];
        dir53 = results[i+3] - results[i+2];
        compute( results[i+1], results[i+2], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, numSegTube );
    }
    
    // compute all needed directions
    dir20 = results[numSeg-1] - results[numSeg-2];
    dir12 = directions[numSeg-1] - results[numSeg-1];
    dir32 = results[numSeg] - results[numSeg-1];
    dir43 = directions[numSeg] - results[numSeg];
    dir53 = v4 - v2;
    compute( results[numSeg-1], results[numSeg], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, numSegTube );
}
-->
        </snippet>
      </shader>
      <shader name="arrowGeometry">
        <snippet type="string">
          <!--
/* Geometry Shader: Arrow Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable

varying out vec3 normal;
varying out vec3 color;

void compute( vec3 v2, vec3 v3, vec3 dir20, vec3 dir12, vec3 dir32, vec3 dir43, vec3 dir53, float scale, float stretch1, float stretch2)
{
    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));

    dir1 = normalize( cross( dir1, ortho1))*stretch1;
    dir2 = normalize( cross( dir2, ortho2))*stretch2;
    
    vec3 norm1 = normalize( cross( dir1, ortho1));
    vec3 norm2 = normalize( cross( dir2, ortho2));
    
    /////////////////////
    // draw top ribbon //
    /////////////////////
    color = vec3( gl_FrontSecondaryColorIn[0]);
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
    normal = norm1;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
    normal = norm2;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
    EmitVertex();
    
    EndPrimitive();
    
    ////////////////////////
    // draw bottom ribbon //
    ////////////////////////
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
    normal = -norm1;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
    normal = -norm2;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
    EmitVertex();
    
    EndPrimitive();
    
    /////////////////////
    // draw first side //
    /////////////////////
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
    normal = dir1;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
    normal = dir2;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
    EmitVertex();
    
    EndPrimitive();
    
    //////////////////////
    // draw second side //
    //////////////////////
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
    normal = -dir1;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
    normal = -dir2;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
    EmitVertex();
    
    EndPrimitive();
}

void main(void)
{
    // number of segments for each curve section
    const int numSeg = 6;
    const float N = float( numSeg);
    // dimension of 'results' and 'directions' MUST be numSeg+1 
    vec3 results[numSeg + 1];
    vec3 directions[numSeg + 1];
    // vertices and directions
    // vertices and directions
    vec3 v1 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v2 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v3 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v4 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 n1 = vec3(gl_FrontColorIn[0].xyz) / gl_FrontColorIn[0].w;
    vec3 n2 = vec3(gl_FrontColorIn[1].xyz) / gl_FrontColorIn[1].w;
    vec3 n3 = vec3(gl_FrontColorIn[2].xyz) / gl_FrontColorIn[2].w;
    vec3 n4 = vec3(gl_FrontColorIn[3].xyz) / gl_FrontColorIn[3].w;
        
    // assign matrix S
  mat4 S;
    S[0] = vec4( 6.0/(N*N*N), 6.0/(N*N*N), 1.0/(N*N*N), 0.0 );
    S[1] = vec4(         0.0,   2.0/(N*N),   1.0/(N*N), 0.0 );
    S[2] = vec4(                 0.0,         0.0,       1.0/N, 0.0 );
    S[3] = vec4(                 0.0,         0.0,         0.0, 1.0 );
    // assign the basis matrix
  mat4 B;
    B[0] = vec4(-1.0/6.0, 3.0/6.0,-3.0/6.0, 1.0/6.0 );
    B[1] = vec4( 3.0/6.0,-6.0/6.0, 0.0/6.0, 4.0/6.0 );
    B[2] = vec4(-3.0/6.0, 3.0/6.0, 3.0/6.0, 1.0/6.0 );
    B[3] = vec4( 1.0/6.0, 0.0/6.0, 0.0/6.0, 0.0/6.0 );
    
    // assign the geometry matrix
    mat4 G;
    G[0] = vec4( v1.x, v2.x, v3.x, v4.x );
    G[1] = vec4( v1.y, v2.y, v3.y, v4.y );
    G[2] = vec4( v1.z, v2.z, v3.z, v4.z );
    G[3] = vec4( 1.0, 1.0, 1.0, 1.0 );
    // compute the matrix M
    mat4 M = S * ( B * G );
    // start computation of first spline segment 
    results[0] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    for( int k = 0; k < numSeg; k++ )
    {
        M[0].w = M[0].w + M[0].z;
        M[1].w = M[1].w + M[1].z;
        M[2].w = M[2].w + M[2].z;
        M[3].w = M[3].w + M[3].z;
        M[0].z = M[0].z + M[0].y;
        M[1].z = M[1].z + M[1].y;
        M[2].z = M[2].z + M[2].y;
        M[3].z = M[3].z + M[3].y;
        M[0].y = M[0].y + M[0].x;
        M[1].y = M[1].y + M[1].x;
        M[2].y = M[2].y + M[2].x;
        M[3].y = M[3].y + M[3].x;
        
        results[k+1] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    }
    
    mat4 G1;
    G1[0] = vec4( n1.x+v1.x, n2.x+v2.x, n3.x+v3.x, n4.x+v4.x );
    G1[1] = vec4( n1.y+v1.y, n2.y+v2.y, n3.y+v3.y, n4.y+v4.y );
    G1[2] = vec4( n1.z+v1.z, n2.z+v2.z, n3.z+v3.z, n4.z+v4.z );
    G1[3] = vec4( 1.0, 1.0, 1.0, 1.0 );

    // compute the matrix M
    mat4 M1 = S * ( B * G1 );
    // start computation of second spline segments
    directions[0] = vec3( M1[0][3]/M1[3][3], M1[1][3]/M1[3][3], M1[2][3]/M1[3][3]);
    for( int k = 0; k < numSeg; k++ )
    {
        M1[0].w = M1[0].w + M1[0].z;
        M1[1].w = M1[1].w + M1[1].z;
        M1[2].w = M1[2].w + M1[2].z;
        M1[3].w = M1[3].w + M1[3].z;
        M1[0].z = M1[0].z + M1[0].y;
        M1[1].z = M1[1].z + M1[1].y;
        M1[2].z = M1[2].z + M1[2].y;
        M1[3].z = M1[3].z + M1[3].y;
        M1[0].y = M1[0].y + M1[0].x;
        M1[1].y = M1[1].y + M1[1].x;
        M1[2].y = M1[2].y + M1[2].x;
        M1[3].y = M1[3].y + M1[3].x;
        
        directions[k+1] = vec3( M1[0][3]/M1[3][3], M1[1][3]/M1[3][3], M1[2][3]/M1[3][3]);
    }
    
    // draw
    vec3 dir20;
    vec3 dir12;
    vec3 dir32;
    vec3 dir43;
    vec3 dir53;
    
    float factor = ( gl_FrontSecondaryColorIn[1].y / N ) * gl_FrontSecondaryColorIn[1].z;
    float f2;
    float f1 = gl_FrontSecondaryColorIn[1].y + factor;
    
    f2 = f1;
    f1 = f1 - factor;    
    // compute all needed directions
    dir20 = v3 - v1;
    dir12 = directions[0] - results[0];
    dir32 = results[1] - results[0];
    dir43 = directions[1] - results[1];
    dir53 = results[2] - results[1];
    compute( results[0], results[1], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, f2, f1 );
    
    for( int i = 0; i < numSeg-2; i++ )
    {
        f2 = f1;
        f1 = f1 - factor;
        // compute all needed directions
        dir20 = results[i+1] - results[i+0];
        dir12 = directions[i+1] - results[i+1];
        dir32 = results[i+2] - results[i+1];
        dir43 = directions[i+2] - results[i+2];
        dir53 = results[i+3] - results[i+2];
        compute( results[i+1], results[i+2], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, f2, f1 );
    }
    
    f2 = f1;
    f1 = f1 - factor;
    // compute all needed directions
    dir20 = results[numSeg-1] - results[numSeg-2];
    dir12 = directions[numSeg-1] - results[numSeg-1];
    dir32 = results[numSeg] - results[numSeg-1];
    dir43 = directions[numSeg] - results[numSeg];
    dir53 = v4 - v2;
    compute( results[numSeg-1], results[numSeg], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, f2, f1 );
}
-->
        </snippet>
      </shader>
      <shader name="helixGeometry">
        <snippet type="string">
          <!--
/* Geometry Shader: Arrow Renderer
 * Copyright (C) 2007 by Universitaet Stuttgart (VIS) / Michael Krone. Alle Rechte vorbehalten.
 */

//#version 120
#extension GL_EXT_geometry_shader4 : enable
#extension GL_EXT_gpu_shader4 : enable

varying out vec3 normal;
varying out vec3 color;


void compute( vec3 v2, vec3 v3, vec3 dir20, vec3 dir12, vec3 dir32, vec3 dir43, vec3 dir53, float scale, float stretch1)
{
    vec3 ortho1 = normalize( dir20 + dir32);
    vec3 ortho2 = normalize( dir32 + dir53);
    
    vec3 dir1 = normalize( cross( dir12, ortho1));
    vec3 dir2 = normalize( cross( dir43, ortho2));
    
    dir1 = normalize( cross( dir1, ortho1))*stretch1;
    dir2 = normalize( cross( dir2, ortho2))*stretch1;
    
    vec3 norm1 = normalize( cross( dir1, ortho1));
    vec3 norm2 = normalize( cross( dir2, ortho2));
    
    /////////////////////
    // draw top ribbon //
    /////////////////////
    color = vec3( gl_FrontSecondaryColorIn[0]);
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
    normal = norm1;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
    normal = norm2;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
    EmitVertex();
    
    EndPrimitive();
    
    ////////////////////////
    // draw bottom ribbon //
    ////////////////////////
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
    normal =  -norm1;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
    normal = -norm2;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
    EmitVertex();
    
    EndPrimitive();
    
    /////////////////////
    // draw first side //
    /////////////////////
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 + norm1*scale).xyz, 1.0);
    normal = dir1;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 + dir1 - norm1*scale).xyz, 1.0);
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 + norm2*scale).xyz, 1.0);
    normal = dir2;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 + dir2 - norm2*scale).xyz, 1.0);
    EmitVertex();
    
    EndPrimitive();
    
    //////////////////////
    // draw second side //
    //////////////////////
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 + norm1*scale).xyz, 1.0);
    normal = -dir1;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v2 - dir1 - norm1*scale).xyz, 1.0);
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 + norm2*scale).xyz, 1.0);
    normal = -dir2;
    EmitVertex();
    
    gl_Position = gl_ModelViewProjectionMatrix*vec4( (v3 - dir2 - norm2*scale).xyz, 1.0);
    EmitVertex();
    
    EndPrimitive();
}

void main(void)
{
    // number of segments for each curve section
    const int numSeg = 6;
    const float N = float( numSeg);
    // dimension of 'results' and 'directions' MUST be numSeg+1 
    vec3 results[numSeg + 1];
    vec3 directions[numSeg + 1];
    // vertices and directions
    vec3 v1 = vec3(gl_PositionIn[0].xyz) / gl_PositionIn[0].w;
    vec3 v2 = vec3(gl_PositionIn[1].xyz) / gl_PositionIn[1].w;
    vec3 v3 = vec3(gl_PositionIn[2].xyz) / gl_PositionIn[2].w;
    vec3 v4 = vec3(gl_PositionIn[3].xyz) / gl_PositionIn[3].w;
    vec3 n1 = vec3(gl_FrontColorIn[0].xyz) / gl_FrontColorIn[0].w;
    vec3 n2 = vec3(gl_FrontColorIn[1].xyz) / gl_FrontColorIn[1].w;
    vec3 n3 = vec3(gl_FrontColorIn[2].xyz) / gl_FrontColorIn[2].w;
    vec3 n4 = vec3(gl_FrontColorIn[3].xyz) / gl_FrontColorIn[3].w;
        
    // assign matrix S
  mat4 S;
    S[0] = vec4( 6.0/(N*N*N), 6.0/(N*N*N), 1.0/(N*N*N), 0.0 );
    S[1] = vec4(         0.0,   2.0/(N*N),   1.0/(N*N), 0.0 );
    S[2] = vec4(                 0.0,         0.0,       1.0/N, 0.0 );
    S[3] = vec4(                 0.0,         0.0,         0.0, 1.0 );
    // assign the basis matrix
  mat4 B;
    B[0] = vec4(-1.0/6.0, 3.0/6.0,-3.0/6.0, 1.0/6.0 );
    B[1] = vec4( 3.0/6.0,-6.0/6.0, 0.0/6.0, 4.0/6.0 );
    B[2] = vec4(-3.0/6.0, 3.0/6.0, 3.0/6.0, 1.0/6.0 );
    B[3] = vec4( 1.0/6.0, 0.0/6.0, 0.0/6.0, 0.0/6.0 );
    
    // assign the geometry matrix
    mat4 G;
    G[0] = vec4( v1.x, v2.x, v3.x, v4.x );
    G[1] = vec4( v1.y, v2.y, v3.y, v4.y );
    G[2] = vec4( v1.z, v2.z, v3.z, v4.z );
    G[3] = vec4( 1.0, 1.0, 1.0, 1.0 );
    // compute the matrix M
    mat4 M = S * ( B * G );
    // start computation of first spline segment 
    results[0] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    for( int k = 0; k < numSeg; k++ )
    {
        M[0].w = M[0].w + M[0].z;
        M[1].w = M[1].w + M[1].z;
        M[2].w = M[2].w + M[2].z;
        M[3].w = M[3].w + M[3].z;
        M[0].z = M[0].z + M[0].y;
        M[1].z = M[1].z + M[1].y;
        M[2].z = M[2].z + M[2].y;
        M[3].z = M[3].z + M[3].y;
        M[0].y = M[0].y + M[0].x;
        M[1].y = M[1].y + M[1].x;
        M[2].y = M[2].y + M[2].x;
        M[3].y = M[3].y + M[3].x;
        
        results[k+1] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    }
    
    G[0] = vec4( n1.x+v1.x, n2.x+v2.x, n3.x+v3.x, n4.x+v4.x );
    G[1] = vec4( n1.y+v1.y, n2.y+v2.y, n3.y+v3.y, n4.y+v4.y );
    G[2] = vec4( n1.z+v1.z, n2.z+v2.z, n3.z+v3.z, n4.z+v4.z );
    // compute the matrix M
    M = S * ( B * G );
    // start computation of second spline segments
    directions[0] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    for( int k = 0; k < numSeg; k++ )
    {
        M[0].w = M[0].w + M[0].z;
        M[1].w = M[1].w + M[1].z;
        M[2].w = M[2].w + M[2].z;
        M[3].w = M[3].w + M[3].z;
        M[0].z = M[0].z + M[0].y;
        M[1].z = M[1].z + M[1].y;
        M[2].z = M[2].z + M[2].y;
        M[3].z = M[3].z + M[3].y;
        M[0].y = M[0].y + M[0].x;
        M[1].y = M[1].y + M[1].x;
        M[2].y = M[2].y + M[2].x;
        M[3].y = M[3].y + M[3].x;
        directions[k+1] = vec3( M[0][3]/M[3][3], M[1][3]/M[3][3], M[2][3]/M[3][3]);
    }
    
    // draw
    vec3 dir20;
    vec3 dir12;
    vec3 dir32;
    vec3 dir43;
    vec3 dir53;
    
    // compute all needed directions
    dir20 = v3 - v1;
    dir12 = directions[0] - results[0];
    dir32 = results[1] - results[0];
    dir43 = directions[1] - results[1];
    dir53 = results[2] - results[1];
    compute( results[0], results[1], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, gl_FrontSecondaryColorIn[1].y );
    
    for( int i = 0; i < numSeg-2; i++ )
    {
        // compute all needed directions
        dir20 = results[i+1] - results[i+0];
        dir12 = directions[i+1] - results[i+1];
        dir32 = results[i+2] - results[i+1];
        dir43 = directions[i+2] - results[i+2];
        dir53 = results[i+3] - results[i+2];
        compute( results[i+1], results[i+2], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, gl_FrontSecondaryColorIn[1].y );
    }
    
    // compute all needed directions
    dir20 = results[numSeg-1] - results[numSeg-2];
    dir12 = directions[numSeg-1] - results[numSeg-1];
    dir32 = results[numSeg] - results[numSeg-1];
    dir43 = directions[numSeg] - results[numSeg];
    dir53 = v4 - v2;
    compute( results[numSeg-1], results[numSeg], dir20, dir12, dir32, dir43, dir53, gl_FrontSecondaryColorIn[1].x, gl_FrontSecondaryColorIn[1].y );
}
-->
        </snippet>
      </shader>
    </namespace>

    <namespace name="perpixellight">
      <shader name="vertex">
        <snippet type="string">
          <!--
varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;

void main()
{    
    // transformation of the normal into eye space
    normal = normalize(gl_NormalMatrix * gl_Normal);
    
    // normalize the direction of the light
    lightDir = normalize(vec3(gl_LightSource[0].position));

    // normalize the halfVector to pass it to the fragment shader
    halfVector = normalize(gl_LightSource[0].halfVector.xyz);
                
    // compute the diffuse, ambient and globalAmbient terms
    //diffuse = gl_FrontMaterial.diffuse * gl_LightSource[0].diffuse;
    //ambient = gl_FrontMaterial.ambient * gl_LightSource[0].ambient;
    //ambient += gl_LightModel.ambient * gl_FrontMaterial.ambient;
    diffuse = gl_Color * gl_LightSource[0].diffuse;
    ambient = gl_Color * gl_LightSource[0].ambient;
    ambient += gl_LightModel.ambient * gl_Color;

    gl_Position = ftransform();
}
-->
        </snippet>
      </shader>
    
      <shader name="fragment">
        <snippet type="string">
          <!--
varying vec4 diffuse,ambient;
varying vec3 normal,lightDir,halfVector;


void main()
{
    vec3 n,halfV;
    float NdotL,NdotHV;
    
    // store the ambient term
    vec4 color = ambient;
    
    // store the normalized interpolated normal
    n = normalize(normal);

    // compute the dot product between normal and lightDir
    NdotL = max(dot(n,lightDir),0.0);
    if (NdotL > 0.0)
    {
        color += diffuse * NdotL;
        halfV = normalize(halfVector);
        NdotHV = max(dot(n,halfV),0.0);
        color += gl_FrontMaterial.specular * gl_LightSource[0].specular * pow(NdotHV, gl_FrontMaterial.shininess);
    }

    gl_FragColor = color;
}
-->
        </snippet>
      </shader>
    </namespace>
  </namespace>
</btf>
