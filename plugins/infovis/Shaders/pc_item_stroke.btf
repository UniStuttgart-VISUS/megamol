<?xml version="1.0" encoding="utf-8"?>
<btf namespace="pc_item_stroke" type="MegaMolGLSLShader" version="1.0">

  <include file="pc" />

  <snippet name="intersectLineLine" type="string">
    <![CDATA[
// @see http://stackoverflow.com/a/565282/791895

#define FLOAT_EPS (1.0e-10)

float cross2(vec2 v, vec2 w)
{
  return v.x * w.y - v.y * w.x;
}

bool intersectLineLine(vec2 p, vec2 r, vec2 q, vec2 s)
{
  float rXs = cross2(r, s);
  
  if (abs(rXs) > FLOAT_EPS)
  {
    vec2 qp = q - p;
    float t = cross2(qp, s) / rXs;
    float u = cross2(qp, r) / rXs;
    
    return (0.0 <= t) && (t <= 1.0) && (0.0 <= u) && (u <= 1.0);
  }
  
  return false;
}
    ]]>
  </snippet>
  
  <shader name="comp">
    <snippet type="version">430</snippet>
    <snippet name="::pc::extensions" />
    <snippet name="::pc::useLineStrip" />
    <snippet name="::pc::buffers" />
    <snippet name="::pc::uniforms" />
    <snippet name="::pc::common" />
    <snippet name="::pc_item_stroke::uniforms" />
    <snippet name="::pc_item_stroke::intersectLineLine" />
    <snippet name="::bitflags::main" />
    <snippet type="string">
      <![CDATA[
layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

void main()
{
  uint itemID = gl_GlobalInvocationID.y * (gl_NumWorkGroups.x * gl_WorkGroupSize.x) + gl_GlobalInvocationID.x;
  
  if (itemID < itemCount
    && bitflag_isVisible(flags[itemID])
    )
  {
    bool selected = false;
    
    for (uint dimension = 1; dimension < dimensionCount; ++dimension)
    {
      vec4 p = pc_item_vertex(itemID, pc_item_dataID(itemID, pc_dimension(dimension - 1)), pc_dimension(dimension - 1), (dimension - 1));
      vec4 q = pc_item_vertex(itemID, pc_item_dataID(itemID, pc_dimension(dimension)), pc_dimension(dimension), (dimension));
      
      if (intersectLineLine(mousePressed, mouseReleased - mousePressed, p.xy, q.xy - p.xy)) {
        selected = true;
        break;
      }
    }
    
    bitflag_set(flags[itemID], FLAG_SELECTED, selected);
  }
}
      ]]>
    </snippet>
  </shader>
  
  <namespace name="indicator">

    <snippet name="interface" type="string">
      <![CDATA[
	    ]]>
    </snippet>

    <shader name="vert">
      <snippet type="version">430</snippet>
      <snippet name="::pc::extensions" />
      <snippet name="::pc::useLineStrip" />
      <snippet name="::pc::buffers" />
      <snippet name="::pc::uniforms" />
      <snippet name="::pc::common" />
      <snippet name="::pc_item_stroke::uniforms" />
      <snippet type="string">
        <![CDATA[
uniform int width;
uniform int height;
uniform float thickness;

void main()
{
#if 0
float left = abscissae[0] * scaling.x;
float bottom = 0.0f;
float right = abscissae[dimensionCount - 1] * scaling.x;
float top = scaling.y;

//vec2 extent = vec2(right - left, bottom - top);
vec2 extent = vec2(1920,1080);
#endif
#if 1
vec2 from = mouseReleased;
vec2 to = mousePressed;
#else
vec2 from = vec2(left,bottom);
vec2 to = mouseReleased*vec2(right,top);
#endif

  vec2 dir = (projection * modelView * vec4(to,0,0) - projection * modelView * vec4(from,0,0)).xy;
  vec2 offset = normalize(vec2(-dir.y * height, dir.x * width));
  offset = vec2(offset.x / width, offset.y / height); 
  offset = thickness * offset;
  
  int side = gl_VertexID / 2 - gl_VertexID/3;
  vec4 vertex = vec4((1 - (gl_VertexID % 2)) * from + (gl_VertexID % 2) * to, pc_item_defaultDepth, 1.0);

  gl_Position = (projection * modelView * vertex) + vec4(1 * offset.xy, 0, 0) + side * vec4(2* -offset, 0, 0);
}
      ]]>
      </snippet>
    </shader>

    <shader name="frag">
      <snippet type="version">430</snippet>
      <snippet name="::pc::extensions" />
      <snippet name="::pc::useLineStrip" />
      <snippet name="::pc::buffers" />
      <snippet name="::pc::uniforms" />
      <snippet name="::pc::common" />
      <snippet name="::pc_item_stroke::uniforms" />
      <snippet type="string">
        <![CDATA[
uniform vec4 indicatorColor = vec4(0.0, 0.0, 1.0, 1.0);

out vec4 fragColor;

void main()
{
  fragColor = indicatorColor;
}
      ]]>
      </snippet>
    </shader>

  </namespace>

</btf>
