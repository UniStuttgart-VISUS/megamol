<?xml version="1.0" encoding="utf-8"?>
<btf type="MegaMolGLSLShader" version="1.0" namespace="quartz">
  <include file="common"/>

  <namespace name="common">

    <snippet name="directLight" type="string">
      <![CDATA[
// normal: Normal in object space
// col:    Color
vec4 DirectLight(vec3 normal, vec4 col) {
  float nDotVP;
  float nDotHV;
  float pf;
  vec4 tempColor = vec4(0.f);

  // OLD normal = (gl_ModelViewMatrixInverseTranspose * vec4(normal, 1.0)).xyz;
  normal = (ModelViewMatrixInverseTranspose * vec4(normal, 1.0)).xyz;
  normal = normalize(normal);

  for(int i = 0; i < numLights; ++i) {
    // OLD nDotVP = max(0.0, dot(normal, normalize(gl_LightSource[0].position.xyz)));
    nDotVP = max(0.0, dot(normal, normalize(vec3(light[i].px, light[i].py, light[i].pz))));
    //nDotHV = max(0.0, dot(normal, gl_LightSource[0].halfVector.xyz));

    //if (nDotVP == 0.0) {
    //  pf = 0.0;
    //} else {
    //  pf = pow(nDotHV, gl_FrontMaterial.shininess);
    //}

    // OLD vec4 ambient = gl_LightSource[0].ambient;
    // OLD vec4 diffuse = gl_LightSource[0].diffuse * nDotVP;
    // OLD //vec4 specular = gl_LightSource[0].specular * pf;
    vec4 ambient = light[i].lightIntensity * ambientCol;
    vec4 diffuse = light[i].lightIntensity * diffuseCol * nDotVP;
    //vec4 specular = specularCol * pf;

    tempColor += vec4(col.rgb * ambient.rgb + col.rgb * diffuse.rgb /*+ specular.rgb*/, 1.0);
  }

  return tempColor;
}
]]>
    </snippet>
    <snippet name="simpleFragment" type="string">
      <![CDATA[
uniform vec4 color;
void main() {
  // OLD gl_FragColor = vec4(gl_Color.xyz, 1.0); // whoho fancy
  gl_FragColor = vec4(color.xyz, 1.0); // whoho fancy
}
]]>
    </snippet>

  </namespace>

  <namespace name="geo">

    <shader name="vert">
      <snippet type="version">430</snippet>
      <snippet type="string">
        <!--#extension GL_EXT_gpu_shader4:enable
-->
      </snippet>
      <snippet type="string">
        <![CDATA[
varying vec4 x;
varying vec4 y;
varying vec4 z;
varying vec4 quat;

void main() {
  quat = gl_MultiTexCoord0;
  vec4 origin = gl_ModelViewProjectionMatrix * vec4(gl_Vertex.xyz, 1.0);
  vec3 vec = vec3(1.0, 0.0, 0.0);
  vec = ((2.0 * ((dot(quat.xyz, vec) * quat.xyz) + (quat.w * cross(quat.xyz, vec)))) + (((quat.w * quat.w) - dot(quat.xyz, quat.xyz)) * vec));
  vec4 xaxis = gl_ModelViewProjectionMatrix * vec4(gl_Vertex.xyz + vec, 1.0);
  vec = vec3(0.0, 1.0, 0.0);
  vec = ((2.0 * ((dot(quat.xyz, vec) * quat.xyz) + (quat.w * cross(quat.xyz, vec)))) + (((quat.w * quat.w) - dot(quat.xyz, quat.xyz)) * vec));
  vec4 yaxis = gl_ModelViewProjectionMatrix * vec4(gl_Vertex.xyz + vec, 1.0);
  vec = vec3(0.0, 0.0, 1.0);
  vec = ((2.0 * ((dot(quat.xyz, vec) * quat.xyz) + (quat.w * cross(quat.xyz, vec)))) + (((quat.w * quat.w) - dot(quat.xyz, quat.xyz)) * vec));
  vec4 zaxis = gl_ModelViewProjectionMatrix * vec4(gl_Vertex.xyz + vec, 1.0);
  gl_Position = origin;
  x = (xaxis - origin) * gl_Vertex.w;
  y = (yaxis - origin) * gl_Vertex.w;
  z = (zaxis - origin) * gl_Vertex.w;
  gl_FrontColor = gl_Color;
}
]]>
      </snippet>
    </shader>

    <shader name="geom">
      <snippet type="version">430</snippet>
      <snippet type="string">
        <!--#extension GL_EXT_gpu_shader4:enable
#extension GL_EXT_geometry_shader4:enable
-->
      </snippet>
      <snippet type="string">
        <![CDATA[
varying in vec4 x[];
varying in vec4 y[];
varying in vec4 z[];
varying in vec4 quat[];
]]>
      </snippet>
      <snippet name="common::directLight"/>
      <snippet type="string">
        <![CDATA[
void main() {
  vec4 o = gl_PositionIn[0];
  vec4 p;
  vec3 faceNormal;
  vec4 faceColor;
]]>
      </snippet>
      <snippet type="string" name="geometry">
        <![CDATA[
  faceNormal = vec3(0.0, 1.0, 0.0);
  faceNormal = ((2.0 * ((dot(quat[0].xyz, faceNormal) * quat[0].xyz) + (quat[0].w * cross(quat[0].xyz, faceNormal)))) + (((quat[0].w * quat[0].w) - dot(quat[0].xyz, quat[0].xyz)) * faceNormal));
  faceColor = DirectLight(faceNormal, vec4(1.0, 0.0, 0.0, 1.0));
  p = o + x[0] * -1.0 + y[0] * 0.0 + z[0] * 1.0;
  gl_Position = p / p.w;
  gl_FrontColor = faceColor;
  EmitVertex();
  p = o + x[0] * 1.0 + y[0] * 0.0 + z[0] * 1.0;
  gl_Position = p / p.w;
  gl_FrontColor = faceColor;
  EmitVertex();
  p = o + x[0] * 0.0 + y[0] * 1.0 + z[0] * -1.0;
  gl_Position = p / p.w;
  gl_FrontColor = faceColor;
  EmitVertex();
  EndPrimitive();

  faceNormal = vec3(0.0, -1.0, 0.0);
  faceNormal = ((2.0 * ((dot(quat[0].xyz, faceNormal) * quat[0].xyz) + (quat[0].w * cross(quat[0].xyz, faceNormal)))) + (((quat[0].w * quat[0].w) - dot(quat[0].xyz, quat[0].xyz)) * faceNormal));
  faceColor = DirectLight(faceNormal, vec4(1.0, 1.0, 0.0, 1.0));
  p = o + x[0] * 1.0 + y[0] * 0.0 + z[0] * 1.0;
  gl_Position = p / p.w;
  gl_FrontColor = faceColor;
  EmitVertex();
  p = o + x[0] * -1.0 + y[0] * 0.0 + z[0] * 1.0;
  gl_Position = p / p.w;
  gl_FrontColor = faceColor;
  EmitVertex();
  p = o + x[0] * 0.0 + y[0] * -1.0 + z[0] * -1.0;
  gl_Position = p / p.w;
  gl_FrontColor = faceColor;
  EmitVertex();
  EndPrimitive();

  faceNormal = vec3(-1.0, 0.0, 0.0);
  faceNormal = ((2.0 * ((dot(quat[0].xyz, faceNormal) * quat[0].xyz) + (quat[0].w * cross(quat[0].xyz, faceNormal)))) + (((quat[0].w * quat[0].w) - dot(quat[0].xyz, quat[0].xyz)) * faceNormal));
  faceColor = DirectLight(faceNormal, vec4(0.0, 1.0, 0.0, 1.0));
  p = o + x[0] * -1.0 + y[0] * 0.0 + z[0] * 1.0;
  gl_Position = p / p.w;
  gl_FrontColor = faceColor;
  EmitVertex();
  p = o + x[0] * 0.0 + y[0] * 1.0 + z[0] * -1.0;
  gl_Position = p / p.w;
  gl_FrontColor = faceColor;
  EmitVertex();
  p = o + x[0] * 0.0 + y[0] * -1.0 + z[0] * -1.0;
  gl_Position = p / p.w;
  gl_FrontColor = faceColor;
  EmitVertex();
  EndPrimitive();

  faceNormal = vec3(1.0, 0.0, 0.0);
  faceNormal = ((2.0 * ((dot(quat[0].xyz, faceNormal) * quat[0].xyz) + (quat[0].w * cross(quat[0].xyz, faceNormal)))) + (((quat[0].w * quat[0].w) - dot(quat[0].xyz, quat[0].xyz)) * faceNormal));
  faceColor = DirectLight(faceNormal, vec4(0.0, 0.0, 1.0, 1.0));
  p = o + x[0] * 0.0 + y[0] * 1.0 + z[0] * -1.0;
  gl_Position = p / p.w;
  gl_FrontColor = faceColor;
  EmitVertex();
  p = o + x[0] * 1.0 + y[0] * 0.0 + z[0] * 1.0;
  gl_Position = p / p.w;
  gl_FrontColor = faceColor;
  EmitVertex();
  p = o + x[0] * 0.0 + y[0] * -1.0 + z[0] * -1.0;
  gl_Position = p / p.w;
  gl_FrontColor = faceColor;
  EmitVertex();
  EndPrimitive();
]]>
    </snippet>
    <snippet type="string">
      <![CDATA[
}
]]>
      </snippet>
    </shader>

    <shader name="frag">
      <snippet type="version">430</snippet>
      <snippet type="string">
        <!--#extension GL_EXT_gpu_shader4:enable
-->
      </snippet>
      <snippet name="common::simpleFragment" />
    </shader>

  </namespace>

  <namespace name="simple">

    <shader name="vert">
      <snippet type="version">430</snippet>
      <snippet name="common::directLight"/>
      <snippet type="string">
        <![CDATA[
void main() {
  vec4 quat = gl_MultiTexCoord1;
  vec3 normal = gl_Normal;
  normal = ((2.0 * ((dot(quat.xyz, normal) * quat.xyz) + (quat.w * cross(quat.xyz, normal)))) + (((quat.w * quat.w) - dot(quat.xyz, quat.xyz)) * normal));
  gl_FrontColor = DirectLight(normal.xyz, gl_Color);
  vec3 vec = gl_Vertex.xyz * gl_MultiTexCoord0.w;
  vec = ((2.0 * ((dot(quat.xyz, vec) * quat.xyz) + (quat.w * cross(quat.xyz, vec)))) + (((quat.w * quat.w) - dot(quat.xyz, quat.xyz)) * vec));
  vec += gl_MultiTexCoord0.xyz;
  vec4 pos = gl_ModelViewProjectionMatrix * vec4(vec, 1.0);
  gl_Position = pos / pos.w;
}
]]>
      </snippet>
    </shader>

    <shader name="instvert">
      <snippet type="version">430</snippet>
      <snippet type="string">
        <![CDATA[#extension GL_EXT_gpu_shader4:enable
]]>
      </snippet>
      <snippet name="common::directLight"/>
      <snippet type="string">
        <![CDATA[
uniform sampler2D partTex;
uniform int partTexWidth;
uniform vec4 bboxMin;
uniform vec4 bboxSize;

void main() {
  int id = 2 * gl_InstanceID;
  ivec2 texC = ivec2(mod(id, partTexWidth), floor(id / partTexWidth));
  vec4 posR = texelFetch2D(partTex, texC, 0);
  posR *= bboxSize;
  posR += bboxMin;
  vec4 quat = texelFetch2D(partTex, texC + ivec2(1, 0), 0);
  quat *= bboxSize;
  quat += bboxMin;

  vec3 normal = gl_Normal;
  normal = ((2.0 * ((dot(quat.xyz, normal) * quat.xyz) + (quat.w * cross(quat.xyz, normal)))) + (((quat.w * quat.w) - dot(quat.xyz, quat.xyz)) * normal));

  gl_FrontColor = DirectLight(normal.xyz, gl_Color);

  vec3 vec = gl_Vertex.xyz * posR.w;
  vec = ((2.0 * ((dot(quat.xyz, vec) * quat.xyz) + (quat.w * cross(quat.xyz, vec)))) + (((quat.w * quat.w) - dot(quat.xyz, quat.xyz)) * vec));
  vec += posR.xyz;
  vec4 pos = gl_ModelViewProjectionMatrix * vec4(vec, 1.0);

  gl_Position = pos / pos.w;
}
]]>
      </snippet>
    </shader>

    <shader name="frag">
      <snippet type="version">430</snippet>
      <snippet name="common::simpleFragment" />
    </shader>

    <shader name="errVert">
      <snippet type="version">430</snippet>
      <snippet type="string">
    <![CDATA[
uniform vec4 clipplane; // a,b,c,d
uniform mat4 ModelViewProjectionMatrix;
layout(location = 0) in vec4 vertex;

void main() {
  // OLD vec4 pos = vec4(gl_Vertex.xyz, 1.0);
  vec4 pos = vec4(vertex.xyz, 1.0);
  gl_FrontColor = vec4(1.0, 0.0, 0.0, 1.0);
  if (clipplane != vec4(0.0)) {
    float d = dot(pos.xyz, clipplane.xyz);
    if (d > -clipplane.w) {
      gl_FrontColor = vec4(0.0, 0.0, 1.0, 1.0);
      pos.w = 0.0;
    }
  }
  pos = ModelViewProjectionMatrix * pos;
  gl_Position = pos / pos.w;
  gl_PointSize = 4.0;
}
]]>
      </snippet>
    </shader>

  </namespace>

  <namespace name="ray">

    <shader name="vert">
      <snippet type="version">430</snippet>
      <snippet type="string" name="replaceMeParams">
        <![CDATA[
#define OUTERRAD 1.0
]]>
      </snippet>
      <snippet type="string">
        <![CDATA[

uniform vec4 viewAttr;
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;

varying vec4 quat;
varying vec4 camPos;
varying vec4 objPos;
varying vec4 lightPos;
varying float rad;

void main() {
    quat = gl_MultiTexCoord0 * vec4(-1.0, -1.0, -1.0, 1.0); // inverted/conjugated quaternion
    vec4 inPos = gl_Vertex;
    rad = inPos.w;
    float squarRad = rad * rad * OUTERRAD * OUTERRAD;
    inPos.w = 1.0;

    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)

    // calculate cam position
    camPos = gl_ModelViewMatrixInverse[3]; // (C) by Christoph
    camPos.xyz -= objPos.xyz; // cam pos to glyph space
    // rotate camera AFTER silhouette approximation

    // calculate light position in glyph space
    lightPos = gl_ModelViewMatrixInverse * gl_LightSource[0].position;
    // Don't rotate! Otherwise we would need to rotate the half-way-vector too

    // Sphere-Touch-Plane-Approach™
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    vec2 d, p, q, h, dd;

    // get camera orthonormal coordinate system
    vec4 tmp;

    vec2 mins, maxs;
    vec3 testPos;
    vec4 projPos;

    // projected camera vector
    vec3 c2 = vec3(dot(camPos.xyz, camRight), dot(camPos.xyz, camUp), dot(camPos.xyz, camIn));

    // rotate camera AFTER silhouette approximation
    camPos.xyz = ((2.0 * ((dot(quat.xyz, camPos.xyz) * quat.xyz) + (quat.w * cross(quat.xyz, camPos.xyz)))) + (((quat.w * quat.w) - dot(quat.xyz, quat.xyz)) * camPos.xyz));

    vec3 cpj1 = camIn * c2.z + camRight * c2.x;
    vec3 cpm1 = camIn * c2.x - camRight * c2.z;

    vec3 cpj2 = camIn * c2.z + camUp * c2.y;
    vec3 cpm2 = camIn * c2.y - camUp * c2.z;
    
    d.x = length(cpj1);
    d.y = length(cpj2);

    dd = vec2(1.0) / d;

    p = squarRad * dd;
    q = d - p;
    h = sqrt(p * q);

    p *= dd;
    h *= dd;

    cpj1 *= p.x;
    cpm1 *= h.x;
    cpj2 *= p.y;
    cpm2 *= h.y;

    testPos = objPos.xyz + cpj1 + cpm1;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = projPos.xy;
    maxs = projPos.xy;

    testPos -= 2.0 * cpm1;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos = objPos.xyz + cpj2 + cpm2;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos -= 2.0 * cpm2;
    projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    maxs = (maxs - mins) * 0.5 * winHalf;
    gl_PointSize = max(maxs.x, maxs.y) + 0.5;
    gl_FrontColor = gl_Color;
}
]]>
      </snippet>
    </shader>

    <shader name="frag">
      <snippet type="version">430</snippet>
      <snippet type="string">
        <![CDATA[
uniform vec4 viewAttr;

varying vec4 quat;
varying vec4 camPos;
varying vec4 objPos;
varying vec4 lightPos;
varying float rad;
]]>
      </snippet>
      <snippet name="common::directLight"/>
      <snippet type="string">
        <![CDATA[
// @param faceNormal The face normal vector in glyph space
// @param faceDist Face distance from origin in glyph space
// @param ray The ray vector in glyph space
// @uses camPos The camera position in glyph space
vec2 planeCast(vec3 faceNormal, float faceDist, vec3 ray) {
  float hitdir = dot(ray, faceNormal);
  float lambda = (faceDist - dot(camPos.xyz, faceNormal)) / hitdir;
  return vec2(lambda, hitdir);
}
]]>
      </snippet>
      <snippet type="string">
        <![CDATA[
void main() {
    vec4 coord;
    vec3 ray;

    vec3 faceNormal = vec3(0.0, 1.0, 0.0);

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);

    // transform fragment coordinates from view coordinates to object coordinates.
    coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;
    coord -= objPos; // ... and to glyph space

    coord.xyz = ((2.0 * ((dot(quat.xyz, coord.xyz) * quat.xyz) + (quat.w * cross(quat.xyz, coord.xyz)))) + (((quat.w * quat.w) - dot(quat.xyz, quat.xyz)) * coord.xyz));

    // calc the viewing ray
    ray = normalize(coord.xyz - camPos.xyz);

    float lambda = 1000000.0;
    vec3 normal;
]]>
  </snippet>
  <snippet type="string" name="mastercaster">
    <![CDATA[
    // lambda = planeCast(faceNormal, 1.0, ray);
]]>
  </snippet>
  <snippet type="string">
    <![CDATA[
    vec4 iquat = quat * vec4(-1.0, -1.0, -1.0, 1.0);

    // transform normal into object space to work with the correct half-way-vector (ugly)
    normal.xyz = ((2.0 * ((dot(iquat.xyz, normal.xyz) * iquat.xyz) + (iquat.w * cross(iquat.xyz, normal.xyz)))) + (((iquat.w * iquat.w) - dot(iquat.xyz, iquat.xyz)) * normal.xyz));
    gl_FragColor = DirectLight(normal, gl_Color);

    // fragment position
    // ... glyph-space
    coord = camPos;
    coord.xyz += ray * lambda;

    // ... object-space
    coord.xyz = ((2.0 * ((dot(iquat.xyz, coord.xyz) * iquat.xyz) + (iquat.w * cross(iquat.xyz, coord.xyz)))) + (((iquat.w * iquat.w) - dot(iquat.xyz, iquat.xyz)) * coord.xyz));
    coord += objPos;

    // ... image-space
    coord.w = 1.0;
    vec2 depth;
    depth.x = dot(gl_ModelViewProjectionMatrixTranspose[2], coord);
    depth.y = dot(gl_ModelViewProjectionMatrixTranspose[3], coord);
    gl_FragDepth = ((depth.x / depth.y) + 1.0) * 0.5;
}
]]>
      </snippet>
    </shader>

    <shader name="vertclipped">
      <snippet type="version">430</snippet>
      <snippet type="string" name="replaceMeParams">
        <![CDATA[
#define OUTERRAD 1.0
]]>
      </snippet>
      <snippet type="string">
        <![CDATA[
layout(location = 0) in vec4 vertex;
layout(location = 1) in vec4 texCoord;

uniform vec4 viewAttr;
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
uniform vec4 camPosInit;
uniform vec3 posoffset;
uniform vec3 bboxmin;
uniform vec3 bboxmax;
uniform mat4 ModelViewProjectionMatrix;

uniform vec4 clipplane;
uniform vec3 clipcol;

uniform vec4 color;

varying vec4 quat;
varying vec4 camPos;
varying vec4 objPos;
varying float rad;

varying vec4 clipping;

void main() {
    // OLD quat = gl_MultiTexCoord0 * vec4(-1.0, -1.0, -1.0, 1.0); // inverted/conjugated quaternion
    quat = texCoord * vec4(-1.0, -1.0, -1.0, 1.0); // inverted/conjugated quaternion
    // OLD vec4 inPos = gl_Vertex;
    vec4 inPos = vertex;
    rad = inPos.w;
    float squarRad = rad * rad * OUTERRAD * OUTERRAD;
    inPos.w = 1.0;
    inPos.xyz += posoffset;

    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)

    // calculate cam position
    // OLD camPos = gl_ModelViewMatrixInverse[3]; // (C) by Christoph
    camPos = camPosInit;
    camPos.xyz -= objPos.xyz; // cam pos to glyph space
    // rotate camera AFTER silhouette approximation

    // calculate light position in glyph space
    // OLD lightPos = gl_ModelViewMatrixInverse * gl_LightSource[0].position;
    // Don't rotate! Otherwise we would need to rotate the half-way-vector too

    // Sphere-Touch-Plane-Approach™
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    vec2 d, p, q, h, dd;

    // get camera orthonormal coordinate system
    vec4 tmp;

    vec2 mins, maxs;
    vec3 testPos;
    vec4 projPos;

    // projected camera vector
    vec3 c2 = vec3(dot(camPos.xyz, camRight), dot(camPos.xyz, camUp), dot(camPos.xyz, camIn));

    // rotate camera AFTER silhouette approximation
    camPos.xyz = ((2.0 * ((dot(quat.xyz, camPos.xyz) * quat.xyz) + (quat.w * cross(quat.xyz, camPos.xyz)))) + (((quat.w * quat.w) - dot(quat.xyz, quat.xyz)) * camPos.xyz));

    vec3 cpj1 = camIn * c2.z + camRight * c2.x;
    vec3 cpm1 = camIn * c2.x - camRight * c2.z;

    vec3 cpj2 = camIn * c2.z + camUp * c2.y;
    vec3 cpm2 = camIn * c2.y - camUp * c2.z;
    
    d.x = length(cpj1);
    d.y = length(cpj2);

    dd = vec2(1.0) / d;

    p = squarRad * dd;
    q = d - p;
    h = sqrt(p * q);

    p *= dd;
    h *= dd;

    cpj1 *= p.x;
    cpm1 *= h.x;
    cpj2 *= p.y;
    cpm2 *= h.y;

    testPos = objPos.xyz + cpj1 + cpm1;
    // OLD projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos = ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = projPos.xy;
    maxs = projPos.xy;

    testPos -= 2.0 * cpm1;
    projPos = ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos = objPos.xyz + cpj2 + cpm2;
    projPos = ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos -= 2.0 * cpm2;
    projPos = ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    maxs = (maxs - mins) * 0.5 * winHalf;
    gl_PointSize = max(maxs.x, maxs.y) + 0.5;
    // OLD gl_FrontColor = gl_Color;
    gl_FrontColor = color;
    clipping = vec4(0.0);

    if (clipplane != vec4(0.0)) {
        float d = dot(inPos.xyz, clipplane.xyz);
        float dd = d + clipplane.w;
        dd /= length(clipplane.xyz);
        if (dd > rad * OUTERRAD) {
            gl_Position = vec4(0.0);
            gl_PointSize = 0.0;
        } else if (dd > rad * -OUTERRAD) {
            clipping = clipplane;
            clipping.xyz = ((2.0 * ((dot(quat.xyz, clipping.xyz) * quat.xyz) + (quat.w * cross(quat.xyz, clipping.xyz)))) + (((quat.w * quat.w) - dot(quat.xyz, quat.xyz)) * clipping.xyz));
            clipping.w = -(d + clipping.w);
            
        }
    }
}
]]>
      </snippet>
    </shader>

    <shader name="fragclipped">
      <snippet type="version">430</snippet>
      <snippet type="string">
        <![CDATA[
struct LightParams {
  float px, py, pz, pw;
  float cr, cg, cb, ca;
  float lightIntensity;
};

layout( std430, binding = 2 ) readonly buffer lightBuffer {
  LightParams light[]; 
};

uniform vec4 viewAttr;
uniform vec3 bboxmin;
uniform vec3 bboxmax;
uniform vec3 clipcol;

uniform vec4 color;
uniform vec4 ambientCol;
uniform vec4 diffuseCol;
uniform vec4 specularCol;
//uniform float lightIntensity;
uniform int numLights;

varying vec4 quat;
uniform vec4 camPosInit;
varying vec4 camPos;
varying vec4 objPos;
//uniform vec4 lightPos;
varying float rad;

uniform mat4 ModelViewMatrixInverseTranspose;
uniform mat4 ModelViewProjectionMatrixInverse;
uniform mat4 ModelViewProjectionMatrixTranspose;

varying vec4 clipping;
]]>
      </snippet>
      <snippet name="common::directLight"/>
      <snippet type="string">
        <![CDATA[
// @param faceNormal The face normal vector in glyph space
// @param faceDist Face distance from origin in glyph space
// @param ray The ray vector in glyph space
// @uses camPos The camera position in glyph space
vec2 planeCast(vec3 faceNormal, float faceDist, vec3 ray) {
  float hitdir = dot(ray, faceNormal);
  float lambda = (faceDist - dot(camPos.xyz, faceNormal)) / hitdir;
  return vec2(lambda, hitdir);
}
]]>
      </snippet>
      <snippet type="string">
        <![CDATA[
void main() {
    vec4 coord;
    vec3 ray;

    vec3 faceNormal = vec3(0.0, 1.0, 0.0);

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);

    // transform fragment coordinates from view coordinates to object coordinates.
    // OLD coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord = ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;

    vec3 fragCoordWS = coord.xyz; // fragment coordinates in world-space
    // OLD vec3 camPosWS = gl_ModelViewMatrixInverse[3].xyz; // (C) by Christoph
    vec3 camPosWS = camPosInit.xyz;

    coord -= objPos; // ... and to glyph space
    coord.xyz = ((2.0 * ((dot(quat.xyz, coord.xyz) * quat.xyz) + (quat.w * cross(quat.xyz, coord.xyz)))) + (((quat.w * quat.w) - dot(quat.xyz, quat.xyz)) * coord.xyz));

    // calc the viewing ray
    ray = normalize(coord.xyz - camPos.xyz);

    // OLD vec4 col = gl_Color;
    vec4 col = color;

    float lambda = 1000000.0;
    vec3 normal;
]]>
      </snippet>
      <snippet type="string" name="mastercaster">
        <![CDATA[
    // lambda = planeCast(faceNormal, 1.0, ray);
]]>
      </snippet>
      <snippet type="string">
        <![CDATA[
    // clipping plane action
    if (clipping != vec4(0.0)) {
      ll = planeCast(clipping.xyz, clipping.w, ray);
      if (ll.y < 0.0) {
        // hit from front
        if (lams.x < ll.x) {
          lams.x = ll.x;
          normal = clipping.xyz;
          col = vec4(clipcol, 1.0);
// DEBUG: positions for debugging in clipplane-space
//col.xyz = camPos.xyz + ray * lams.x; // glyph space coordinates
//vec4 iquat = quat * vec4(-1.0, -1.0, -1.0, 1.0);
//col.xyz = ((2.0 * ((dot(iquat.xyz, col.xyz) * iquat.xyz) + (iquat.w * cross(iquat.xyz, col.xyz)))) + (((iquat.w * iquat.w) - dot(iquat.xyz, iquat.xyz)) * col.xyz));
//col.xyz += objPos.xyz;  // world space
//col.xyz /= 255.0;
        }
      }
      if (ll.y > 0.0) {
        // hit from behind
        if (lams.y > ll.x) {
          lams.y = ll.x;
        }
      }
      if (lams.y < lams.x) discard;
      lambda = lams.x;
    }
]]>
      </snippet>
      <snippet type="string">
        <![CDATA[
  // bboxclipping
  bool wsNormalSet = false;
  if (bboxmin != bboxmax) {
    vec3 rayWS = normalize(fragCoordWS - camPosWS);
    vec3 posFWS = camPosWS + (rayWS * lams.x);
    vec3 posBWS = camPosWS + (rayWS * lams.y);

    vec2 blams = vec2(0.0, 1000000.0);
    vec3 bn;
    float bl;
    if (rayWS.x != 0.0) {
      bl = (bboxmax.x - camPosWS.x) / rayWS.x;
      if (camPosWS.x > bboxmax.x) { // maxX hit from outside
        if (bl > blams.x) {
          blams.x = bl;
          bn = vec3(1.0, 0.0, 0.0);
        }
      } else if (bl > 0.0) {
        blams.y = min(blams.y, bl);
      }
      bl = (bboxmin.x - camPosWS.x) / rayWS.x;
      if (camPosWS.x < bboxmin.x) { // minX hit from outside
        if (bl > blams.x) {
          blams.x = bl;
          bn = vec3(-1.0, 0.0, 0.0);
        }
      } else if (bl > 0.0) {
        blams.y = min(blams.y, bl);
      }
    }
    if (rayWS.y != 0.0) {
      bl = (bboxmax.y - camPosWS.y) / rayWS.y;
      if (camPosWS.y > bboxmax.y) { // maxY hit from outside
        if (bl > blams.x) {
          blams.x = bl;
          bn = vec3(0.0, 1.0, 0.0);
        }
      } else if (bl > 0.0) {
        blams.y = min(blams.y, bl);
      }
      bl = (bboxmin.y - camPosWS.y) / rayWS.y;
      if (camPosWS.y < bboxmin.y) { // minY hit from outside
        if (bl > blams.x) {
          blams.x = bl;
          bn = vec3(0.0, -1.0, 0.0);
        }
      } else if (bl > 0.0) {
        blams.y = min(blams.y, bl);
      }
    }
    if (rayWS.z != 0.0) {
      bl = (bboxmax.z - camPosWS.z) / rayWS.z;
      if (camPosWS.z > bboxmax.z) { // maxZ hit from outside
        if (bl > blams.x) {
          blams.x = bl;
          bn = vec3(0.0, 0.0, 1.0);
        }
      } else if (bl > 0.0) {
        blams.y = min(blams.y, bl);
      }
      bl = (bboxmin.z - camPosWS.z) / rayWS.z;
      if (camPosWS.z < bboxmin.z) { // minZ hit from outside
        if (bl > blams.x) {
          blams.x = bl;
          bn = vec3(0.0, 0.0, -1.0);
        }
      } else if (bl > 0.0) {
        blams.y = min(blams.y, bl);
      }
    }
    if (blams.y < blams.x) discard;

    vec3 faceposWS = camPosWS + (rayWS * blams.x);
    const float EPSILON = 0.001;
    if (any(greaterThan(faceposWS, bboxmax + vec3(EPSILON))) || any(lessThan(faceposWS, bboxmin - vec3(EPSILON)))) discard;
    if (blams.y < lambda) discard;
    if (blams.x > lambda) {
      // OLD col = gl_Color; // avoid error close to the clipping plane
      col = color; // avoid error close to the clipping plane
      normal = bn;
      wsNormalSet = true;
      lambda = blams.x;
      if (lambda > lams.y) discard;
    }
  }
]]>
      </snippet>
      <snippet type="string">
        <![CDATA[
    vec4 iquat = quat * vec4(-1.0, -1.0, -1.0, 1.0);

    // transform normal into object space to work with the correct half-way-vector (ugly)
    if (!wsNormalSet) {
      normal.xyz = ((2.0 * ((dot(iquat.xyz, normal.xyz) * iquat.xyz) + (iquat.w * cross(iquat.xyz, normal.xyz)))) + (((iquat.w * iquat.w) - dot(iquat.xyz, iquat.xyz)) * normal.xyz));
    }

    gl_FragColor += DirectLight(normal, col);

    // fragment position
    // ... glyph-space
    coord = camPos;
    coord.xyz += ray * lambda;

    // ... object-space
    coord.xyz = ((2.0 * ((dot(iquat.xyz, coord.xyz) * iquat.xyz) + (iquat.w * cross(iquat.xyz, coord.xyz)))) + (((iquat.w * iquat.w) - dot(iquat.xyz, iquat.xyz)) * coord.xyz));
    coord += objPos;

    // ... image-space
    coord.w = 1.0;
    vec2 depth;
    // OLD depth.x = dot(gl_ModelViewProjectionMatrixTranspose[2], coord);
    depth.x = dot(ModelViewProjectionMatrixTranspose[2], coord);
    // OLD depth.y = dot(gl_ModelViewProjectionMatrixTranspose[3], coord);
    depth.y = dot(ModelViewProjectionMatrixTranspose[3], coord);
    gl_FragDepth = ((depth.x / depth.y) + 1.0) * 0.5;
}
]]>
      </snippet>
    </shader>

    <namespace name="plane">

      <shader name="vertErr">
        <snippet type="version">430</snippet>
        <snippet type="string">
    <![CDATA[
uniform vec3 camX;
uniform vec3 camY;
uniform vec3 camZ;

void main() {
  vec4 pos = gl_Vertex;
  pos = vec4(dot(camX, pos.xyz), dot(camY, pos.xyz), 0.0, 1.0);
  pos = gl_ModelViewProjectionMatrix * pos;
  gl_FrontColor = vec4(1.0, 0.0, 0.0, 0.0);
  gl_Position = pos;
  gl_PointSize = 4.0;
}
]]>
        </snippet>
      </shader>

      <shader name="fragErr">
        <snippet type="version">430</snippet>
        <snippet name="common::simpleFragment" />
      </shader>

      <shader name="vert">
        <snippet type="version">430</snippet>
        <snippet type="string">
          <![CDATA[
#define OUTERRAD 1.0
]]>
        </snippet>
        <snippet type="string">
          <![CDATA[
uniform vec4 viewAttr;
uniform vec3 camX;
uniform vec3 camY;
uniform vec3 camZ;
uniform vec3 bboxmin;
uniform vec3 bboxmax;
uniform vec3 posoffset;

varying vec3 objPos;
varying vec4 quat;
varying float rad;

void main() {
  vec4 inquat = gl_MultiTexCoord0 * vec4(-1.0, -1.0, -1.0, 1.0); // inverted/conjugated quaternion

  quat = inquat;
  objPos = gl_Vertex.xyz + posoffset;
  rad = gl_Vertex.w;

  vec4 pos = vec4(dot(camX, objPos), dot(camY, objPos), 0.0, 1.0);
  vec4 ppos = gl_ModelViewProjectionMatrix * pos;
  gl_Position = ppos / ppos.w;

  pos.x += OUTERRAD * gl_Vertex.w;
  vec4 ppos2 = gl_ModelViewProjectionMatrix * pos;
  gl_PointSize = 2.0 * abs(ppos2.x - ppos.x) / viewAttr.z;

  gl_FrontColor = gl_Color;
}
]]>
        </snippet>
      </shader>

      <shader name="frag">
        <snippet type="version">430</snippet>
        <snippet type="string">
          <![CDATA[
uniform vec4 viewAttr;
uniform vec3 camX;
uniform vec3 camY;
uniform vec3 camZ;
uniform float planeZ;
uniform vec3 posoffset;
uniform vec3 bboxmin;
uniform vec3 bboxmax;

varying vec3 objPos;
varying vec4 quat;
varying float rad;

void main() {
  // transform fragment coordinates from window coordinates to view coordinates.
  vec4 col = gl_Color;
  vec4 coord = gl_FragCoord * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
      + vec4(-1.0, -1.0, -1.0, 1.0);
  coord = gl_ModelViewProjectionMatrixInverse * coord;
  coord /= coord.w;
  coord.xyz = (camX * coord.x) + (camY * coord.y) - (camZ * planeZ);

  if (bboxmin != bboxmax) {
    if (any(lessThan(coord.xyz, bboxmin))
        || any(greaterThan(coord.xyz, bboxmax))) {
      //col = vec4(1.0, 0.0, 0.0, 1.0);
      discard;
    }
  }

  coord.xyz -= objPos;
  coord.xyz = ((2.0 * ((dot(quat.xyz, coord.xyz) * quat.xyz) + (quat.w * cross(quat.xyz, coord.xyz)))) + (((quat.w * quat.w) - dot(quat.xyz, quat.xyz)) * coord.xyz));
  coord.xyz /= rad;
]]>
        </snippet>
        <snippet type="string" name="polyederclipping" />
        <snippet type="string">
          <![CDATA[
  gl_FragColor = col;
}
]]>
        </snippet>
      </shader>

      <namespace name="tex">

        <shader name="vert">
          <snippet type="version">430</snippet>
          <snippet type="string">
            <![CDATA[#extension GL_EXT_gpu_shader4:enable
]]>
          </snippet>
          <snippet type="string">
            <![CDATA[
#define OUTERRAD outerRad
]]>
          </snippet>
          <snippet type="string">
            <![CDATA[
uniform vec4 viewAttr;
uniform vec3 camX;
uniform vec3 camY;
uniform vec3 camZ;
uniform vec3 bboxmin;
uniform vec3 bboxmax;
uniform vec3 posoffset;
uniform float outerRad;
uniform sampler2D typeData;
uniform ivec2 typeInfo; // type-row, num-faces

varying vec3 objPos;
varying vec4 quat;
varying float rad;

void main() {
  vec4 inquat = gl_MultiTexCoord0 * vec4(-1.0, -1.0, -1.0, 1.0); // inverted/conjugated quaternion

  quat = inquat;
  objPos = gl_Vertex.xyz + posoffset;
  rad = gl_Vertex.w;

  vec4 pos = vec4(dot(camX, objPos), dot(camY, objPos), 0.0, 1.0);
  vec4 ppos = gl_ModelViewProjectionMatrix * pos;
  gl_Position = ppos / ppos.w;

  pos.x += OUTERRAD * gl_Vertex.w;
  vec4 ppos2 = gl_ModelViewProjectionMatrix * pos;
  gl_PointSize = 2.0 * abs(ppos2.x - ppos.x) / viewAttr.z;

  gl_FrontColor = gl_Color;
}
]]>
          </snippet>
        </shader>

        <shader name="frag">
          <snippet type="version">430</snippet>
          <snippet type="string">
            <![CDATA[#extension GL_EXT_gpu_shader4:enable
]]>
          </snippet>
          <snippet type="string">
            <![CDATA[
uniform vec4 viewAttr;
uniform vec3 camX;
uniform vec3 camY;
uniform vec3 camZ;
uniform float planeZ;
uniform vec3 posoffset;
uniform vec3 bboxmin;
uniform vec3 bboxmax;
uniform sampler2D typeData;
uniform ivec2 typeInfo; // type-row, num-faces

varying vec3 objPos;
varying vec4 quat;
varying float rad;

void main() {
  // transform fragment coordinates from window coordinates to view coordinates.
  vec4 col = gl_Color;
  vec4 coord = gl_FragCoord * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
      + vec4(-1.0, -1.0, -1.0, 1.0);
  coord = gl_ModelViewProjectionMatrixInverse * coord;
  coord /= coord.w;
  coord.xyz = (camX * coord.x) + (camY * coord.y) - (camZ * planeZ);

  if (bboxmin != bboxmax) {
    if (any(lessThan(coord.xyz, bboxmin))
        || any(greaterThan(coord.xyz, bboxmax))) {
      //col = vec4(1.0, 0.0, 0.0, 1.0);
      discard;
    }
  }

  coord.xyz -= objPos;
  coord.xyz = ((2.0 * ((dot(quat.xyz, coord.xyz) * quat.xyz) + (quat.w * cross(quat.xyz, coord.xyz)))) + (((quat.w * quat.w) - dot(quat.xyz, quat.xyz)) * coord.xyz));
  coord.xyz /= rad;
]]>
          </snippet>
          <snippet type="string">
            <![CDATA[

  float d = 0.0;
  for (int i = 0; i < typeInfo.y; i++) {
    vec4 f = texelFetch2D(typeData, ivec2(i, typeInfo.x), 0);
    d = max(d, dot(f.xyz, coord.xyz) / f.w);
  }
  if (d > 1.0) discard;

]]>
          </snippet>
          <snippet type="string">
            <![CDATA[
  gl_FragColor = col;
}
]]>
          </snippet>
        </shader>

        <shader name="fragfaced">
          <snippet type="version">430</snippet>
          <snippet type="string">
            <![CDATA[#extension GL_EXT_gpu_shader4:enable
]]>
          </snippet>
          <snippet type="string">
            <![CDATA[
uniform vec4 viewAttr;
uniform vec3 camX;
uniform vec3 camY;
uniform vec3 camZ;
uniform float planeZ;
uniform vec3 posoffset;
uniform vec3 bboxmin;
uniform vec3 bboxmax;
uniform sampler2D typeData;
uniform ivec2 typeInfo; // type-row, num-faces

varying vec3 objPos;
varying vec4 quat;
varying float rad;

void main() {
  // transform fragment coordinates from window coordinates to view coordinates.
  vec4 col = gl_Color;
  vec4 coord = gl_FragCoord * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
      + vec4(-1.0, -1.0, -1.0, 1.0);
  coord = gl_ModelViewProjectionMatrixInverse * coord;
  coord /= coord.w;
  coord.xyz = (camX * coord.x) + (camY * coord.y) - (camZ * planeZ);

  if (bboxmin != bboxmax) {
    if (any(lessThan(coord.xyz, bboxmin))
        || any(greaterThan(coord.xyz, bboxmax))) {
      //col = vec4(1.0, 0.0, 0.0, 1.0);
      discard;
    }
  }

  coord.xyz -= objPos;
  coord.xyz = ((2.0 * ((dot(quat.xyz, coord.xyz) * quat.xyz) + (quat.w * cross(quat.xyz, coord.xyz)))) + (((quat.w * quat.w) - dot(quat.xyz, quat.xyz)) * coord.xyz));
  coord.xyz /= rad;

  float d = 0.0;
  float df;
  vec3 dfn = vec3(1.0, 0.0, 0.0);
  for (int i = 0; i < typeInfo.y; i++) {
    vec4 f = texelFetch2D(typeData, ivec2(i, typeInfo.x), 0);
    df = dot(f.xyz, coord.xyz);
    df /= f.w;
    //d = max(d, dot(f.xyz, coord.xyz) / f.w);
    if (d < df) {
      d = df;
      dfn = f.xyz;
    }
  }
  if (d > 1.0) {
    discard;
  } else {
    vec4 iquat = quat * vec4(-1.0, -1.0, -1.0, 1.0);
    dfn = ((2.0 * ((dot(iquat.xyz, dfn) * iquat.xyz) + (iquat.w * cross(iquat.xyz, dfn)))) + (((iquat.w * iquat.w) - dot(iquat.xyz, iquat.xyz)) * dfn));
    vec2 pd = vec2(dot(dfn, camX), dot(dfn, camY));
    pd = normalize(pd);
    float c = 1.0;

    c = (pd.x + 1.0) * 0.5 * 0.48;
    c += (pd.y > 0.0) ? 0.52 : 0.02;

    gl_FragColor = vec4(vec3(c), 1.0);
  }
}
]]>
          </snippet>
        </shader>

      </namespace>

    </namespace>

    <namespace name="tex">

      <shader name="vertclipped">
        <snippet type="version">430</snippet>
        <snippet type="string">
          <![CDATA[#extension GL_EXT_gpu_shader4:enable
]]>
        </snippet>
        <snippet type="string" name="replaceMeParams">
          <![CDATA[
#define OUTERRAD outerRad
]]>
        </snippet>
        <snippet type="string">
          <![CDATA[
layout(location = 0) in vec4 vertex;
layout(location = 1) in vec4 texCoord;

uniform vec4 viewAttr;
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
uniform vec4 camPosInit;
uniform vec3 posoffset;
uniform vec3 bboxmin;
uniform vec3 bboxmax;
uniform vec4 clipplane;
uniform vec3 clipcol;
uniform vec4 color;
uniform sampler2D typeData;
uniform ivec2 typeInfo; // type-row, num-faces
uniform float outerRad;

uniform mat4 ModelViewProjectionMatrix;

varying vec4 quat;
varying vec4 camPos;
varying vec4 objPos;
varying float rad;

varying vec4 clipping;

void main() {
    // OLD quat = gl_MultiTexCoord0 * vec4(-1.0, -1.0, -1.0, 1.0); // inverted/conjugated quaternion
    quat = texCoord * vec4(-1.0, -1.0, -1.0, 1.0); // inverted/conjugated quaternion
    // OLD vec4 inPos = gl_Vertex;
    vec4 inPos = vertex;
    rad = inPos.w;
    float squarRad = rad * rad * OUTERRAD * OUTERRAD;
    inPos.w = 1.0;
    inPos.xyz += posoffset;

    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)

    // calculate cam position
    // OLD camPos = gl_ModelViewMatrixInverse[3]; // (C) by Christoph
    camPos = camPosInit;
    camPos.xyz -= objPos.xyz; // cam pos to glyph space
    // rotate camera AFTER silhouette approximation

    // calculate light position in glyph space
    // OLD lightPos = gl_ModelViewMatrixInverse * gl_LightSource[0].position;
    // Don't rotate! Otherwise we would need to rotate the half-way-vector too

    // Sphere-Touch-Plane-Approach™
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    vec2 d, p, q, h, dd;

    // get camera orthonormal coordinate system
    vec4 tmp;

    vec2 mins, maxs;
    vec3 testPos;
    vec4 projPos;

    // projected camera vector
    vec3 c2 = vec3(dot(camPos.xyz, camRight), dot(camPos.xyz, camUp), dot(camPos.xyz, camIn));

    // rotate camera AFTER silhouette approximation
    camPos.xyz = ((2.0 * ((dot(quat.xyz, camPos.xyz) * quat.xyz) + (quat.w * cross(quat.xyz, camPos.xyz)))) + (((quat.w * quat.w) - dot(quat.xyz, quat.xyz)) * camPos.xyz));

    vec3 cpj1 = camIn * c2.z + camRight * c2.x;
    vec3 cpm1 = camIn * c2.x - camRight * c2.z;

    vec3 cpj2 = camIn * c2.z + camUp * c2.y;
    vec3 cpm2 = camIn * c2.y - camUp * c2.z;
    
    d.x = length(cpj1);
    d.y = length(cpj2);

    dd = vec2(1.0) / d;

    p = squarRad * dd;
    q = d - p;
    h = sqrt(p * q);

    p *= dd;
    h *= dd;

    cpj1 *= p.x;
    cpm1 *= h.x;
    cpj2 *= p.y;
    cpm2 *= h.y;

    testPos = objPos.xyz + cpj1 + cpm1;
    // OLD projPos = gl_ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos = ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = projPos.xy;
    maxs = projPos.xy;

    testPos -= 2.0 * cpm1;
    projPos = ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos = objPos.xyz + cpj2 + cpm2;
    projPos = ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos -= 2.0 * cpm2;
    projPos = ModelViewProjectionMatrix * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    maxs = (maxs - mins) * 0.5 * winHalf;
    gl_PointSize = max(maxs.x, maxs.y) + 0.5;
    gl_FrontColor = color;
    clipping = vec4(0.0);

    if (clipplane != vec4(0.0)) {
        float d = dot(inPos.xyz, clipplane.xyz);
        float dd = d + clipplane.w;
        dd /= length(clipplane.xyz);
        if (dd > rad * OUTERRAD) {
            gl_Position = vec4(0.0);
            gl_PointSize = 0.0;
        } else if (dd > rad * -OUTERRAD) {
            clipping = clipplane;
            clipping.xyz = ((2.0 * ((dot(quat.xyz, clipping.xyz) * quat.xyz) + (quat.w * cross(quat.xyz, clipping.xyz)))) + (((quat.w * quat.w) - dot(quat.xyz, quat.xyz)) * clipping.xyz));
            clipping.w = -(d + clipping.w);
            
        }
    }
}
]]>
        </snippet>
      </shader>

      <shader name="fragclipped">
        <snippet type="version">430</snippet>
        <snippet type="string">
          <![CDATA[#extension GL_EXT_gpu_shader4:enable
]]>
        </snippet>
        <snippet type="string">
          <![CDATA[
struct LightParams {
  float px, py, pz, pw;
  float cr, cg, cb, ca;
  float lightIntensity;
};

layout( std430, binding = 2 ) readonly buffer lightBuffer {
  LightParams light[]; 
};

uniform vec4 viewAttr;
uniform vec3 bboxmin;
uniform vec3 bboxmax;
uniform vec3 clipcol;
uniform sampler2D typeData;
uniform ivec2 typeInfo; // type-row, num-faces

uniform vec4 color;
uniform vec4 ambientCol;
uniform vec4 diffuseCol;
uniform vec4 specularCol;
//uniform float lightIntensity;
uniform int numLights;

varying vec4 quat;
uniform vec4 camPosInit;
varying vec4 camPos;
varying vec4 objPos;
//uniform vec4 lightPos;
varying float rad;

uniform mat4 ModelViewMatrixInverseTranspose;
uniform mat4 ModelViewProjectionMatrixInverse;
uniform mat4 ModelViewProjectionMatrixTranspose;

varying vec4 clipping;
]]>
        </snippet>
        <snippet name="common::directLight"/>
        <snippet type="string">
          <![CDATA[
// @param faceNormal The face normal vector in glyph space
// @param faceDist Face distance from origin in glyph space
// @param ray The ray vector in glyph space
// @uses camPos The camera position in glyph space
vec2 planeCast(vec3 faceNormal, float faceDist, vec3 ray) {
  float hitdir = dot(ray, faceNormal);
  float lambda = (faceDist - dot(camPos.xyz, faceNormal)) / hitdir;
  return vec2(lambda, hitdir);
}
]]>
        </snippet>
        <snippet type="string">
          <![CDATA[
void main() {
    vec4 coord;
    vec3 ray;

    vec3 faceNormal = vec3(0.0, 1.0, 0.0);

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);

    // transform fragment coordinates from view coordinates to object coordinates.
    // OLD coord = gl_ModelViewProjectionMatrixInverse * coord;
    coord = ModelViewProjectionMatrixInverse * coord;
    coord /= coord.w;

    vec3 fragCoordWS = coord.xyz; // fragment coordinates in world-space
    // OLD vec3 camPosWS = gl_ModelViewMatrixInverse[3].xyz; // (C) by Christoph
    vec3 camPosWS = camPosInit.xyz;

    coord -= objPos; // ... and to glyph space
    coord.xyz = ((2.0 * ((dot(quat.xyz, coord.xyz) * quat.xyz) + (quat.w * cross(quat.xyz, coord.xyz)))) + (((quat.w * quat.w) - dot(quat.xyz, quat.xyz)) * coord.xyz));

    // calc the viewing ray
    ray = normalize(coord.xyz - camPos.xyz);

    // OLD vec4 col = gl_Color;
    vec4 col = color;

    float lambda = 1000000.0;
    vec3 normal;
]]>
        </snippet>
        <snippet type="string">
          <![CDATA[
  vec2 ll;
  vec2 lams = vec2(-1000000.0, 1000000.0);
  for (int i = 0; i < typeInfo.y; i++) {
    vec4 face = texelFetch2D(typeData, ivec2(i, typeInfo.x), 0);

    ll = planeCast(face.xyz, face.w * rad, ray);

    if (ll.y < 0.0) {
      // hit from front
      if (lams.x < ll.x) {
        lams.x = ll.x;
        normal = face.xyz;
      }
    }
    if (ll.y > 0.0) {
      // hit from behind
      if (lams.y > ll.x) {
        lams.y = ll.x;
      }
    }
  }

  if (lams.y < lams.x) discard;
  lambda = lams.x;
]]>
        </snippet>
        <snippet type="string">
          <![CDATA[
    // clipping plane action
    if (clipping != vec4(0.0)) {
      ll = planeCast(clipping.xyz, clipping.w, ray);
      if (ll.y < 0.0) {
        // hit from front
        if (lams.x < ll.x) {
          lams.x = ll.x;
          normal = clipping.xyz;
          col = vec4(clipcol, 1.0);
// DEBUG: positions for debugging in clipplane-space
//col.xyz = camPos.xyz + ray * lams.x; // glyph space coordinates
//vec4 iquat = quat * vec4(-1.0, -1.0, -1.0, 1.0);
//col.xyz = ((2.0 * ((dot(iquat.xyz, col.xyz) * iquat.xyz) + (iquat.w * cross(iquat.xyz, col.xyz)))) + (((iquat.w * iquat.w) - dot(iquat.xyz, iquat.xyz)) * col.xyz));
//col.xyz += objPos.xyz;  // world space
//col.xyz /= 255.0;
        }
      }
      if (ll.y > 0.0) {
        // hit from behind
        if (lams.y > ll.x) {
          lams.y = ll.x;
        }
      }
      if (lams.y < lams.x) discard;
      lambda = lams.x;
    }
]]>
        </snippet>
        <snippet type="string">
          <![CDATA[
  // bboxclipping
  if (bboxmin != bboxmax) {
    vec3 rayWS = normalize(fragCoordWS - camPosWS);
    vec3 posFWS = camPosWS + (rayWS * lams.x);
    vec3 posBWS = camPosWS + (rayWS * lams.y);

    vec2 blams = vec2(0.0, 1000000.0);
    vec3 bn;
    float bl;
    if (rayWS.x != 0.0) {
      bl = (bboxmax.x - camPosWS.x) / rayWS.x;
      if (camPosWS.x > bboxmax.x) { // maxX hit from outside
        if (bl > blams.x) {
          blams.x = bl;
          bn = vec3(1.0, 0.0, 0.0);
        }
      } else if (bl > 0.0) {
        blams.y = min(blams.y, bl);
      }
      bl = (bboxmin.x - camPosWS.x) / rayWS.x;
      if (camPosWS.x < bboxmin.x) { // minX hit from outside
        if (bl > blams.x) {
          blams.x = bl;
          bn = vec3(-1.0, 0.0, 0.0);
        }
      } else if (bl > 0.0) {
        blams.y = min(blams.y, bl);
      }
    }
    if (rayWS.y != 0.0) {
      bl = (bboxmax.y - camPosWS.y) / rayWS.y;
      if (camPosWS.y > bboxmax.y) { // maxY hit from outside
        if (bl > blams.x) {
          blams.x = bl;
          bn = vec3(0.0, 1.0, 0.0);
        }
      } else if (bl > 0.0) {
        blams.y = min(blams.y, bl);
      }
      bl = (bboxmin.y - camPosWS.y) / rayWS.y;
      if (camPosWS.y < bboxmin.y) { // minY hit from outside
        if (bl > blams.x) {
          blams.x = bl;
          bn = vec3(0.0, -1.0, 0.0);
        }
      } else if (bl > 0.0) {
        blams.y = min(blams.y, bl);
      }
    }
    if (rayWS.z != 0.0) {
      bl = (bboxmax.z - camPosWS.z) / rayWS.z;
      if (camPosWS.z > bboxmax.z) { // maxZ hit from outside
        if (bl > blams.x) {
          blams.x = bl;
          bn = vec3(0.0, 0.0, 1.0);
        }
      } else if (bl > 0.0) {
        blams.y = min(blams.y, bl);
      }
      bl = (bboxmin.z - camPosWS.z) / rayWS.z;
      if (camPosWS.z < bboxmin.z) { // minZ hit from outside
        if (bl > blams.x) {
          blams.x = bl;
          bn = vec3(0.0, 0.0, -1.0);
        }
      } else if (bl > 0.0) {
        blams.y = min(blams.y, bl);
      }
    }
    if (blams.y < blams.x) discard;

    vec3 faceposWS = camPosWS + (rayWS * blams.x);
    const float EPSILON = 0.001;
    if (any(greaterThan(faceposWS, bboxmax + vec3(EPSILON))) || any(lessThan(faceposWS, bboxmin - vec3(EPSILON)))) discard;
    if (blams.y < lambda) discard;
    if (blams.x > lambda) {
      col = color; // avoid error close to the clipping plane
      normal = bn;
      normal.xyz = ((2.0 * ((dot(quat.xyz, normal.xyz) * quat.xyz) + (quat.w * cross(quat.xyz, normal.xyz)))) + (((quat.w * quat.w) - dot(quat.xyz, quat.xyz)) * normal.xyz));
      lambda = blams.x;
      if (lambda > lams.y) discard;
    }
  }
]]>
        </snippet>
        <snippet type="string">
          <![CDATA[
    vec4 iquat = quat * vec4(-1.0, -1.0, -1.0, 1.0);

    // transform normal into object space to work with the correct half-way-vector (ugly)
    normal.xyz = ((2.0 * ((dot(iquat.xyz, normal.xyz) * iquat.xyz) + (iquat.w * cross(iquat.xyz, normal.xyz)))) + (((iquat.w * iquat.w) - dot(iquat.xyz, iquat.xyz)) * normal.xyz));
    gl_FragColor = DirectLight(normal, col);

    // fragment position
    // ... glyph-space
    coord = camPos;
    coord.xyz += ray * lambda;

    // ... object-space
    coord.xyz = ((2.0 * ((dot(iquat.xyz, coord.xyz) * iquat.xyz) + (iquat.w * cross(iquat.xyz, coord.xyz)))) + (((iquat.w * iquat.w) - dot(iquat.xyz, iquat.xyz)) * coord.xyz));
    coord += objPos;

    // ... image-space
    coord.w = 1.0;
    vec2 depth;
    // OLD depth.x = dot(gl_ModelViewProjectionMatrixTranspose[2], coord);
    depth.x = dot(ModelViewProjectionMatrixTranspose[2], coord);
    // OLD depth.y = dot(gl_ModelViewProjectionMatrixTranspose[3], coord);
    depth.y = dot(ModelViewProjectionMatrixTranspose[3], coord);
    gl_FragDepth = ((depth.x / depth.y) + 1.0) * 0.5;
}
]]>
        </snippet>
      </shader>

    </namespace>

  </namespace>

</btf>